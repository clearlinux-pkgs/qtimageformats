Antti Kokko (1):
      Add changes file for Qt 5.15.2

Christian Ehrlicher (1):
      TGA Plugin: don't print warning in QTgaHandler::canRead(QIODevice*)

Eirik Aavitsland (11):
      Avoid oob access when reading certain corrupt tiled tiffs
      Avoid oob access when reading certain corrupt tiled tiffs
      Update bundled libwebp to version 1.2.0
      Update bundled libtiff to version 4.2.0
      Avoid scanline overflow when reading corrupt tiffs
      Update bundled libtiff to version 4.3.0
      Patch bundled libtiff to compile on Integrity
      Update bundled libwebp to version 1.2.1
      Add some basic checking against corrupt input
      Reject tiled tiffs with corrupt tile size early
      webp: support sequential input device if full file is available

Jani Heikkinen (2):
      Bump version
      Bump version

Moody Liu (2):
      jp2: use correct buffer_size for jas_stream_memopen
      jp2: use new APIs for jasper 3

Robert Loehning (1):
      Check earlier to avoid sanitzer warnings

Tarja Sundqvist (9):
      Update commercial license headers
      Revert "Update commercial license headers"
      Bump version
      Bump version
      Bump version
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.4' into tqtc/lts-5.15-opensource
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.5' into tqtc/lts-5.15-opensource
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.6' into tqtc/lts-5.15-opensource
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.7' into tqtc/lts-5.15-opensource

diff --git a/src/3rdparty/libtiff.pri b/src/3rdparty/libtiff.pri
index c57c668..f9b8f42 100644
--- a/src/3rdparty/libtiff.pri
+++ b/src/3rdparty/libtiff.pri
@@ -32,11 +32,9 @@ SOURCES += \
     $$PWD/libtiff/libtiff/tif_version.c \
     $$PWD/libtiff/libtiff/tif_warning.c \
     $$PWD/libtiff/libtiff/tif_write.c \
-    $$PWD/libtiff/libtiff/tif_zip.c \
-    $$PWD/libtiff/port/snprintf.c
+    $$PWD/libtiff/libtiff/tif_zip.c
 
 win32:        SOURCES += $$PWD/libtiff/libtiff/tif_win32.c
 else:         SOURCES += $$PWD/libtiff/libtiff/tif_unix.c
-android:      SOURCES += $$PWD/libtiff/port/lfind.c
 
 include($$PWD/zlib_dependency.pri)
diff --git a/src/3rdparty/libtiff/ChangeLog b/src/3rdparty/libtiff/ChangeLog
index 01e2182..9bda39c 100644
--- a/src/3rdparty/libtiff/ChangeLog
+++ b/src/3rdparty/libtiff/ChangeLog
@@ -1,3 +1,2341 @@
+2021-04-16  Even Rouault  <even.rouault@spatialys.com>
+
+	libtiff v4.3.0 released
+
+2021-04-15  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'libjpeg12_cmake' into 'master'
+	libtiff/tif_config.h.cmake.in: surround LIBJPEG_12_PATH by double quotes
+
+	See merge request libtiff/libtiff!237
+
+2021-04-15  Even Rouault  <even.rouault@spatialys.com>
+
+	libtiff/tif_config.h.cmake.in: surround LIBJPEG_12_PATH by double quotes
+
+2021-04-14  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'lerc_api_change' into 'master'
+	tif_lerc.c: cope with API breakage in liblerc master
+
+	See merge request libtiff/libtiff!236
+
+2021-04-14  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_lerc.c: cope with API breakage in liblerc master.
+
+2021-04-08  Even Rouault  <even.rouault@spatialys.com>
+
+	libtiff: remove remaining #ifdef WIN32 and use PRI formatting.
+
+2021-03-10  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'kmilos-master-patch-73187' into 'master'
+	tiffcp: Remove LZW help text, preset not supported
+
+	See merge request libtiff/libtiff!229
+
+2021-03-10  Miloš Komarčević  <miloskomarcevic@aim.com>
+
+	tiffcp: Remove LZW help text, preset not supported.
+
+2021-03-10  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'feature/lerc' into 'master'
+	Add LERC Compression Plugin (closes: #213)
+
+	Closes #213
+
+	See merge request libtiff/libtiff!228
+
+2021-03-10  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'cmake-fixes' into 'master'
+	CMake fixes
+
+	Closes #246 et #245
+
+	See merge request libtiff/libtiff!232
+
+2021-03-09  Roger Leigh  <rleigh@codelibre.net>
+
+	cmake: Correct FindCMath.
+
+	cmake: Correct ZSTD_USABLE typo.
+
+2021-03-07  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'cmake-find-lib-prefixes' into 'master'
+	cmake: Correct find lib prefixes for Deflate and JBIG
+
+	See merge request libtiff/libtiff!231
+
+2021-03-07  Roger Leigh  <rleigh@codelibre.net>
+
+	cmake: FindJBIG uses lib prefix on Windows.
+
+	cmake: FindDeflate uses lib prefix on Windows.
+
+2021-03-07  Even Rouault  <even.rouault@spatialys.com>
+
+	TWebPDecode(): avoid potential overflow on multiplication (CID 1472928)
+
+	TIFFReadDirEntryArrayWithLimit(): avoid false positive from Coverity Scan regarding out-of-bounds access (CID 1472927)
+
+	tif_dirwrite.c: avoid setting a variable that is not read afterwards.
+
+2021-03-07  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'coverity-fixes' into 'master'
+	Coverity fixes (high impact)
+
+	See merge request libtiff/libtiff!227
+
+2021-03-07  Roger Leigh  <rleigh@codelibre.net>
+
+	Fix high-impact Coverity issues (resource leaks).
+	The issues are in the tests and tiffcrop, not the core library. Real issues, but not high risk.
+
+	Use to test if Coverity integration is performing properly on merge.
+
+2021-03-07  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'fix_tif_fax3_encoder_regression' into 'master'
+	tif_fax3.c: fix master regression in encoder
+
+	See merge request libtiff/libtiff!230
+
+2021-03-07  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_fax3.c: fix master regression in encoder.
+	Fix issue introduced in 39a74eede0455ec8ee334dcddf71f5354d508d8b
+
+	Spotted by gdal's tiff_write_76 test
+
+2021-03-07  Antonio Valentino  <antonio.valentino@tiscali.it>
+
+	Add LERC support in CMake.
+
+2021-03-07  Antonio Valentino  <Antonio.Valentino@esa.int>
+
+	Add LERC support in configure.ac and Makefile.am.
+
+2021-03-07  Antonio Valentino  <antonio.valentino@tiscali.it>
+
+	Add LERC support to tiffcp.
+
+2021-03-07  Antonio Valentino  <Antonio.Valentino@esa.int>
+
+	Add LERC plugin.
+	The lerc plugin code has been copyed form GDAL.
+
+2021-03-06  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'display_tool_purpose' into 'master'
+	TIFF tools: insert a line of text summarizing each tool's purpose
+
+	See merge request libtiff/libtiff!214
+
+2021-03-06  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'cmake-update' into 'master'
+	CMake updates
+
+	See merge request libtiff/libtiff!224
+
+2021-03-06  Even Rouault  <even.rouault@spatialys.com>
+
+	tiff.h: typo fix in comment.
+
+2021-02-15  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'remove-travis' into 'master'
+	ci: Remove unused Travis-CI support
+
+	See merge request libtiff/libtiff!226
+
+2021-02-14  Roger Leigh  <rleigh@codelibre.net>
+
+	ci: Remove unused Travis-CI support.
+
+2021-02-14  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'ci-coverity' into 'master'
+	Enable Coverity static analysis with CI pipeline
+
+	See merge request libtiff/libtiff!225
+
+2021-02-14  Roger Leigh  <rleigh@codelibre.net>
+
+	ci: Add Coverity static analysis job.
+
+	ci: Use custom libtiff CI image.
+
+2021-02-13  Roger Leigh  <rleigh@codelibre.net>
+
+	cmake: Add release target.
+
+	cmake: Remove empty contrib files.
+
+	cmake: Tidy toplevel.
+
+	cmake: Move pkg-config support to PkgConfig.cmake.
+
+	cmake: Move library feature options to CXXLibraryFeatures.cmake.
+
+	cmake: Move C++ support to CXXLibrary.cmake.
+
+	cmake: Add FindCMath to handle libm linking portably.
+
+	cmake: Tidy unused includes.
+
+	cmake: Rename release date to build date.
+
+	cmake: Compute timestamp portably.
+
+	cmake: Remove remaining uses of report_values()
+
+	cmake: Move JPEG12 checks to JPEGCodec.cmake.
+
+	cmake: Move OpenGL checks to OpenGLChecks.cmake.
+
+	cmake: Move OpenGL checks to OpenGLChecks.cmake.
+
+	cmake: Move WebP codec support to WebPCodec.cmake.
+
+	cmake: Use imported targets for WebP.
+
+	cmake: Add FindWebP.
+
+	cmake: Move ZSTD codec support to ZSTDCodec.cmake.
+
+	cmake: Use imported targets for ZSTD.
+
+	cmake: Add FindZSTD.
+
+	cmake: Move LZMA codec support to LZMACodec.cmake.
+
+	cmake: Use imported targets for LibLZMA.
+
+	cmake: Move JBIG codec support to JBIGCodec.cmake.
+
+	cmake: Use imported targets for JBIG.
+
+	cmake: Add FindJBIG.
+
+	cmake: Move PixarLog codec support to PixarLogCodec.cmake.
+
+	cmake: Report system name in configuration report.
+
+	cmake: Move JPEG codec support to JPEGCodec.cmake.
+
+	cmake: Use imported targets for JPEG.
+
+	cmake: Move Deflate codec support to DeflateCodec.cmake.
+
+	cmake: Use imported targets for ZLIB and Deflate.
+
+	cmake: Add FindDeflate.
+
+	cmake: Move symbol checks to SymbolChecks.cmake.
+
+	cmake: Move include checks to IncludeChecks.cmake.
+
+	cmake: Move all autotools logic to separate files.
+
+	cmake: Move internal codec options to InternalCodecs.cmake.
+
+	cmake: Move LFS check to LargeFileSupport.cmake.
+
+	cmake: Move Win32 IO feature to WindowsIOFeature.cmake.
+
+	cmake: Move processor capability checks to ProcessorChecks.cmake.
+
+	cmake: Move type size checks to TypeSizeChecks.cmake.
+
+	cmake: Move linker checks to LinkerChecks.cmake.
+
+	cmake: Move warning options to CompilerChecks.
+
+	cmake: Move version introspection to AutotoolsVersion.cmake.
+
+	cmake: Move compiler checks to CompilerChecks.cmake.
+
+	cmake: Split into helper scripts.
+
+2021-02-08  Roger Leigh  <rleigh@codelibre.net>
+
+	cmake: Use target_sources.
+
+	libport: Adjust header and library to only define and link if required.
+	* Make libport an OBJECT library when in use, otherwise a dummy
+	  INTERFACE library
+	* libport.h will work if getopt is present or not present.  If
+	  present, will fall back to <unistd.h>, else will define
+	  symbols
+	* Add generated libport_config.h to define HAVE_GETOPT and HAVE_UNISTD_H
+	* dummy.c no longer needed with CMake
+	* libtiff/libtiffxx no longer link with libport
+
+	cmake: Remove unnecessary extra_dist usage.
+	Only makes sense in the context of Automake.  Was carried over
+	for reference while porting, but is not needed.
+
+	cmake: Update minimum version and policy version to 3.9.
+
+2021-02-08  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'remove-nmake' into 'master'
+	Remove NMake build support
+
+	See merge request libtiff/libtiff!223
+
+2021-02-08  Roger Leigh  <rleigh@codelibre.net>
+
+	Remove NMake build support.
+	The functionality provided by the NMake build is now completely
+	superseded by the CMake build.
+
+2021-02-08  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'warning-fixes' into 'master'
+	Warning fixes
+
+	See merge request libtiff/libtiff!222
+
+2021-02-07  Miguel Medalha  <medalist@sapo.pt>
+
+	Update tiffsplit.c.
+
+	Reinsert summary line lost after conflicting merge.
+
+	Merge branch 'master' into 'display_tool_purpose'
+	# Conflicts:
+	#   tools/tiffsplit.c
+
+2021-02-06  Roger Leigh  <rleigh@codelibre.net>
+
+	ci: Enable fatal warnings with -Werror for AppVeyor/GCC.
+
+	ci: Enable fatal warnings with -Werror for GitLab CI.
+
+	tif_zstd.c: Remove unused variable warning.
+
+	custom_dir_EXIF_231: Remove case statement fallthrough.
+
+	custom_dir_EXIF_231: Correct use of strncpy.
+
+	Correct include order.
+
+	Eliminate implict fallthrough usage.
+	Use simple loops in place of manual loop unrolling.  Rely on
+	the compiler optimiser to unroll loops when appropriate.
+
+	Suppress potential unused variable warning.
+
+	Suppress warnings or avoid case statement fallthrough.
+
+2021-02-05  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'c99-ssize_t-fixes' into 'master'
+	C99 ssize_t fixes
+
+	Closes #239
+
+	See merge request libtiff/libtiff!219
+
+2021-02-05  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'tiffsplit-too-many-args' into 'master'
+	tiffsplit.c: exit with EXIT_FAILURE if there are extra args on the command line
+
+	See merge request libtiff/libtiff!209
+
+2021-02-05  Roger Leigh  <rleigh@codelibre.net>
+
+	Add additional TIFF_SSIZE_FORMAT uses.
+
+2021-02-04  Roger Leigh  <rleigh@codelibre.net>
+
+	NMake fixes for size type formatting.
+
+	Add TIFF_SIZE_FORMAT for portable use of %z.
+	MinGW64 does support %z, but it issues a compiler warning.
+
+	Align Autoconf tif_config.h and CMake tif_config.cmake.in.
+
+	Use TIFF_SSIZE_FORMAT for formatting tmsize_t.
+
+2021-02-04  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'remove-lcc' into 'master'
+	Remove Makefile.lcc
+
+	See merge request libtiff/libtiff!221
+
+2021-02-04  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'remove-scons' into 'master'
+	Remove SCons build
+
+	See merge request libtiff/libtiff!220
+
+2021-02-03  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'c99-snprintf' into 'master'
+	Use C99 snprintf
+
+	See merge request libtiff/libtiff!217
+
+2021-02-03  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'tiff2ps-const' into 'master'
+	tiff2ps.c: string literals must be const char *, not char *
+
+	See merge request libtiff/libtiff!202
+
+2021-02-03  Roger Leigh  <rleigh@codelibre.net>
+
+	Remove SCons build.
+	Unmaintained for 16 years.
+
+2021-02-03  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'codec_summary' into 'master'
+	Modify 'CMakeLists.txt' to produce a meaningful summary of external codecs
+
+	See merge request libtiff/libtiff!192
+
+2021-02-03  Roger Leigh  <rleigh@codelibre.net>
+
+	Remove Makefile.lcc.
+	Unmaintained for 22 years.
+
+2021-02-02  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'ci-32-bit' into 'master'
+	ci: Build 32- and 64-bit MSVC variants
+
+	See merge request libtiff/libtiff!218
+
+2021-02-01  Roger Leigh  <rleigh@codelibre.net>
+
+	ci: Build 32- and 64-bit MSVC variants.
+
+	Use C99 snprintf.
+
+2021-02-01  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'c99-strtol' into 'master'
+	Use C99 strtol, strtoul, strtoll and strtoull
+
+	See merge request libtiff/libtiff!216
+
+2021-01-31  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'c99-inline' into 'master'
+	Use C99 inline
+
+	See merge request libtiff/libtiff!215
+
+2021-01-31  Roger Leigh  <rleigh@codelibre.net>
+
+	Use C99 strtol, strtoul, strtoll and strtoull.
+
+	tif_fax3: Use C99 inline.
+
+	Remove inline feature tests and defines.
+	Available as a standard feature with C99.
+
+2021-01-30  Miguel Medalha  <medalist@sapo.pt>
+
+	Update raw2tiff.c (remove duplicate description of tool)
+
+2021-01-30  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'c99-format-strings' into 'master'
+	C99 format strings
+
+	See merge request libtiff/libtiff!211
+
+2021-01-29  Miguel Medalha  <medalist@sapo.pt>
+
+	Update tiffdither.c (2 tabs caused slight misalignment of lines in usage info output)
+
+2021-01-28  Miguel Medalha  <medalist@sapo.pt>
+
+	Update ppm2tiff.c (slight misalignment of lines in usage info output)
+
+	Update tiffset.c (small misalignment of lines in usage info output)
+
+2021-01-28  Medalha  <medalist@sapo.pt>
+
+	Display tool purpose.
+
+2021-01-28  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2ps.c: string literals must be const char *, not char *
+
+2021-01-28  Roger Leigh  <rleigh@codelibre.net>
+
+	libtiff: Use PRI format flags and remove unnecessary casts.
+
+2021-01-27  Roger Leigh  <rleigh@codelibre.net>
+
+	ascii_tag: Use PRI format flags and remove unnecessary casts.
+
+	check_tag: Use PRI format flags and remove unnecessary casts.
+
+	custom_dir_EXIF_231: Use PRI format flags and remove unnecessary casts.
+
+	short_tag: Use PRI format flags and remove unnecessary casts.
+
+	strip_rw: Use PRI format flags and remove unnecessary casts.
+
+	fax2tiff: Use PRI format flags and remove unnecessary casts.
+
+	ppm2tiff: Correct format strings.
+
+	raw2tiff: Use PRI format flags and remove unnecessary casts.
+
+	rgb2ycbcr: Use PRI format flags and remove unnecessary casts.
+
+	tiff2pdf: Use PRI format flags and remove unnecessary casts.
+
+	tiff2ps: Use PRI format flags and remove unnecessary casts.
+
+	tiff2rgba: Use PRI format flags and remove unnecessary casts.
+
+	tiffcmp: Use PRI format flags and remove unnecessary casts.
+
+	tiffcp: Use PRI format flags and remove unnecessary casts.
+
+	tiffcrop: Use PRI format flags and remove unnecessary casts.
+
+	tiffinfo: Use PRI format flags and remove unnecessary casts.
+
+	tiffdump: Use PRI format flags and remove unnecessary casts.
+
+2021-01-27  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'c99-require-stdtypes' into 'master'
+	Use standard C99 integer types
+
+	See merge request libtiff/libtiff!205
+
+2021-01-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'reserve_COMPRESSION_JXL' into 'master'
+	tiff.h: reserve COMPRESSION_JXL=50002 for JPEGXL
+
+	See merge request libtiff/libtiff!210
+
+2021-01-22  Even Rouault  <even.rouault@spatialys.com>
+
+	tiff.h: reserve COMPRESSION_JXL=50002 for JPEGXL.
+
+2021-01-22  Kurt Schwehr  <schwehr@google.com>
+
+	tiffsplit.c: exit with EXIT_FAILURE if there are extra args on the command line
+	e.g. tiffsplit in.tif a_prefix_ junk
+
+2021-01-22  Roger Leigh  <rleigh@codelibre.net>
+
+	Add and enable TIFF_DISABLE_DEPRECATED for internal use.
+
+	Add typedef deprecations for GCC/Clang and MSVC.
+
+	Use standard C99 integer types.
+
+2021-01-20  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'ubuntu-zstd-wepb' into 'master'
+	gitlab-ci : use libzstd-dev and libwebp-dev ubuntu packages
+
+	See merge request libtiff/libtiff!208
+
+2021-01-20  Thomas Bernard  <miniupnp@free.fr>
+
+	gitlab-ci : use libzstd-dev and libwebp-dev ubuntu packages.
+	should replace !206
+
+2021-01-20  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-232' into 'master'
+	tiff2ps: exit the loop in case of error
+
+	Closes #232
+
+	See merge request libtiff/libtiff!201
+
+2021-01-20  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'tiffsplit-exit-status' into 'master'
+	tiffsplit: Exit with EXIT_FAILURE if unable to open the input file.
+
+	See merge request libtiff/libtiff!207
+
+2021-01-20  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'config-cleanup' into 'master'
+	Remove HAVE_INTTYPES_H, HAVE_LFIND & lfind, HAVE_SEARCH_H & include <search.h>
+
+	See merge request libtiff/libtiff!203
+
+2021-01-19  Kurt Schwehr  <schwehr@google.com>
+
+	tiffsplit: Exit with EXIT_FAILURE if unable to open the input file.
+
+2021-01-18  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'tiffcmp' into 'master'
+	tiffcmp: fix comparaison with pixels that are fractional number of bytes
+
+	Closes #53
+
+	See merge request libtiff/libtiff!141
+
+2021-01-15  Kurt Schwehr  <schwehr@google.com>
+
+	CMakeLists.txt: Remove search for lfind.
+
+	Remove HAVE_INTTYPES_H, HAVE_LFIND & lfind, HAVE_SEARCH_H & include <search.h>
+	- HAVE_INTTYPES_H is replaced with TIFF_HAVE_INTTYPES_H
+	- tif_dirinfo.c has a static td_lfind
+
+2021-01-15  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffcmp: fix comparaison with pixels that are fractional number of bytes
+	For exemple : 4bits per sample + 3 samples per pixel => 1.5 bytes per pixel
+
+	tiff2ps: exit the loop in case of error.
+	fixes #232
+
+2021-01-15  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'rm-strcasecmp' into 'master'
+	Remove port/strcasecmp.c as strcasecmp is not currently used in libtiff.
+
+	Closes #235
+
+	See merge request libtiff/libtiff!199
+
+2021-01-15  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'std-int-types' into 'master'
+	Use standard C99 integer types
+
+	See merge request libtiff/libtiff!185
+
+2021-01-13  Kurt Schwehr  <schwehr@google.com>
+
+	Remove port/strcasecmp.c as strcasecmp is not currently used in libtiff.
+	Fixes #235
+
+2021-01-10  Miguel Medalha  <medalist@sapo.pt>
+
+	Update CMakeLists.txt. Delete unnecessary line from libdeflate codec support section
+
+2021-01-10  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'include_libport' into 'master'
+	tiff tools and libtiff/mkg3states: include 'libport.h', remove local definition of 'getopt()'
+
+	See merge request libtiff/libtiff!198
+
+2021-01-09  Miguel Medalha  <medalist@sapo.pt>
+
+	Update CMakeLists.txt. Cleanup of indentation space. Removal of leading '/' from webp include dir.
+
+2021-01-09  miguel  <medalist@sapo.pt>
+
+	cmake: Use target_include_directories correctly.
+
+2021-01-09  Roger Leigh  <rleigh@codelibre.net>
+
+	cmake: Use target_include_directories correctly.
+
+	cmake: Drop unnecessary TOOL_INCLUDES.
+
+2021-01-07  Roger Leigh  <rleigh@codelibre.net>
+
+	cmake: Use target_include_directories correctly.
+
+2021-01-07  miguel  <medalist@sapo.pt>
+
+	tiff tools and libtiff/mkg3states: include 'libport.h', remove local definition of 'getopt()'
+
+2021-01-07  Miguel Medalha  <medalist@sapo.pt>
+
+	Update CMakeLists.txt.
+
+2021-01-07  miguel  <medalist@sapo.pt>
+
+	tiff tools: include 'libport.h', remove local definition of 'getopt()'
+
+2021-01-06  Roger Leigh  <rleigh@codelibre.net>
+
+	Remove conditional use of <string.h>
+
+	cmake: Drop dlfcn.h check.
+
+	cmake: Remove duplicate line.
+
+	Use stdint.h types when available.
+
+2021-01-05  Olivier Paquet  <olivier.paquet@gmail.com>
+
+	Merge branch 'iptcutil' into 'master'
+	contrib/iptcutil.c: set '#ifdef _WIN32' (was '#ifdef WIN32', which failed at build time)
+
+	See merge request libtiff/libtiff!197
+
+2021-01-05  miguel  <medalist@sapo.pt>
+
+	tiff tools: include 'libport.h', remove local definition of 'getopt()'
+
+	contrib/iptcutil.c - set '#ifdef _WIN32' (was '#ifdef WIN32', which failed at build time)
+
+2021-01-04  Even Rouault  <even.rouault@spatialys.com>
+
+	tools/CMakeLists.txt: add comment about rgb2ycbcr and thumbnail not to be installed
+
+2021-01-04  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'revert-5331ed49' into 'master'
+	Revert "Merge branch 'install_targets' into 'master'"
+
+	See merge request libtiff/libtiff!196
+
+2021-01-04  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'drop-wince' into 'master'
+	Remove non-functional WinCE support
+
+	See merge request libtiff/libtiff!188
+
+2021-01-04  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'drop-vms' into 'master'
+	Remove non-functional VMS support
+
+	See merge request libtiff/libtiff!187
+
+2021-01-03  Even Rouault  <even.rouault@spatialys.com>
+
+	Revert "Merge branch 'install_targets' into 'master'"
+	This reverts merge request !193
+
+2021-01-03  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'tiffcp_b_parameter' into 'master'
+	tiffcp: Remove unnecessary reference to compression from usage info for -b parameter
+
+	See merge request libtiff/libtiff!189
+
+2021-01-03  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'cmake-faxtable' into 'master'
+	cmake: Add faxtable target
+
+	See merge request libtiff/libtiff!186
+
+2021-01-03  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'install_targets' into 'master'
+	Update 'CMakeLists.txt' from 'tools'.
+
+	See merge request libtiff/libtiff!193
+
+2021-01-03  Miguel Medalha  <medalist@sapo.pt>
+
+	Update 'CMakeLists.txt' from 'tools'.
+
+	Update CMakeLists.txt.
+
+2021-01-03  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'usage_info' into 'master'
+	thumbnail: Rename constant variable 'stuff' to 'usage_info'
+
+	See merge request libtiff/libtiff!190
+
+2021-01-03  Miguel Medalha  <medalist@sapo.pt>
+
+	Modified 'CMakeLists.txt' to produce a meaningful summary of external codecs support.
+
+	Removed unnecessary reference to compression from usage info for -b parameter
+
+	Constant variable 'stuff' renamed to 'usage_info' for consistency with the other tools
+
+2021-01-02  Roger Leigh  <rleigh@codelibre.net>
+
+	Remove non-functional VMS support.
+
+	Remove non-functional WinCE support.
+
+2021-01-02  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'codespell' into 'master'
+	Fix spelling mistakes.
+
+	See merge request libtiff/libtiff!183
+
+2021-01-02  Kurt Schwehr  <schwehr@google.com>
+
+	ChangeLog: Remove extraneous character from prior commit - 00fe7828.
+
+2021-01-02  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'codespell-custom_dir_EXIF_231' into 'master'
+	custom_dir_EXIF_231.c: dos2unix and codespell
+
+	See merge request libtiff/libtiff!184
+
+2021-01-01  Roger Leigh  <rleigh@codelibre.net>
+
+	mkg3states: Sync generator with current generated file content.
+
+	cmake: Add faxtable and mkg3states targets.
+
+2020-12-31  Kurt Schwehr  <schwehr@google.com>
+
+	custom_dir_EXIF_231.c: dos2unix and codespell.
+	additonal, Varable, greather, alwasy
+
+2020-12-31  Kurt Schwehr  <schwehr@google.com>
+
+	Fix spelling mistakes.
+	Found with:
+
+	codespell --version
+	1.17.1
+
+2020-12-29  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'remove-some-vms-ifdef' into 'master'
+	Remove "ifdef VMS" that are no longer necessary.
+
+	See merge request libtiff/libtiff!181
+
+2020-12-29  Kurt Schwehr  <schwehr@google.com>
+
+	Remove "ifdef VMS" that are no longer necessary.
+	Both sides of the if are now the same.
+
+2020-12-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	_TIFFBuiltinCODECS should be const.
+
+2020-12-28  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-202' into 'master'
+	tiff2pdf.c: check that tiff_datasize fits in a signed tsize_t
+
+	Closes #202
+
+	See merge request libtiff/libtiff!166
+
+2020-12-28  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'w_report-when-libdeflate-is-found' into 'master'
+	CMakeLists.txt: Report when libdeflate is found
+
+	See merge request libtiff/libtiff!175
+
+2020-12-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Declare gpsFields as static const.
+
+2020-12-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Merge branch 'tools-reduce-initialized-data' into 'master'
+	Reduce initialized data by making more data const and simplifying usage() implementation.
+
+	See merge request libtiff/libtiff!180
+
+2020-12-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Reduce initialized data by making more data const and simplifying usage() implementation.
+
+2020-12-27  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Merge branch 'master' into 'master'
+	tiff tools: display of compression methods is now conditional instead of hard-coded
+
+	See merge request libtiff/libtiff!176
+
+2020-12-27  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Merge branch 'build' into 'master'
+	Fix wrong URL for fetching config.guess and config.sub
+
+	See merge request libtiff/libtiff!177
+
+2020-12-26  Chocobo1  <Chocobo1@users.noreply.github.com>
+
+	Fix wrong URL for fetching config.guess and config.sub.
+
+2020-12-25  miguel  <medalist@sapo.pt>
+
+	tiff tools: made display of compression methods and their parameters conditional on their actual availability
+
+2020-12-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	autogen.sh now updates config.guess and config.sub from master gnulib version.
+
+2020-12-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Add a https://libtiff.gitlab.io/libtiff/ link.
+
+	Remove stray character in URL area.
+
+	Changes for 4.2.0 release.
+
+	Changes for 4.2.0 release.
+
+2020-12-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	* libtiff 4.2.0 released.
+
+	* configure.ac: Pass tar-ustar option to AM_INIT_AUTOMAKE rather
+	than tar-pax since ustar POSIX 1003.1-1988 format is more portable
+	than PAX POSIX 1003.1-2001 format.
+
+2020-12-12  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'w_adjust-deflate_names' into 'master'
+	Set 'deflate' to DEFLATE_NAMES, instead of 'libdeflate'
+
+	See merge request libtiff/libtiff!174
+
+2020-12-12  Lemures Lemniscati  <lemures.lemniscati@gmail.com>
+
+	Set 'deflate' to DEFLATE_NAMES, instead of 'libdeflate'
+	'lib' will be automatically added as a prefix while doing find_library()
+
+2020-12-12  Even Rouault  <even.rouault@spatialys.com>
+
+	DoubleToRational(): avoid casting NaN to uint32 (fixes #227)
+
+2020-12-12  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'fix_221' into 'master'
+	tiffio.h: do not define __attribute__ but defines TIFF_ATTRIBUTE instead (fixes #221)
+
+	Closes #221
+
+	See merge request libtiff/libtiff!173
+
+2020-12-12  Even Rouault  <even.rouault@spatialys.com>
+
+	tiffio.h: do not define __attribute__ but defines TIFF_ATTRIBUTE instead (fixes #221)
+
+2020-12-08  Even Rouault  <even.rouault@spatialys.com>
+
+	TIFFReadDirEntryArrayWithLimit(): properly read from offline tag value when we clamp the number of strips to 1.
+	Fixes regression of commit 7057734d986001b7fd6d2afde9667da7754ff2cc on reading
+	a file with StripByteCounts with 1 element (broken) and StripOffsets with
+	896 elements, and where StripOffsets[0] is correct
+
+	$ tiffdump foo.tif
+	Magic: 0x4949 <little-endian> Version: 0x2a <ClassicTIFF>
+	Directory 0: offset 25725448 (0x1888a08) next 0 (0)
+	SubFileType (254) LONG (4) 1<0>
+	ImageWidth (256) LONG (4) 1<640>
+	ImageLength (257) LONG (4) 1<20098>
+	BitsPerSample (258) SHORT (3) 1<16>
+	Photometric (262) SHORT (3) 1<1>
+	SamplesPerPixel (277) SHORT (3) 1<1>
+	ResolutionUnit (296) SHORT (3) 1<2>
+	StripByteCounts (279) LONG (4) 1<1806>
+	StripOffsets (273) LONG (4) 896<8 648 1288 1928 2568 3208 3848 4488 5128 5768 6408 7048 7688 8328 8968 9608 10248 10888 11528 12168 12808 13448 14088 14728 ...>
+
+2020-12-02  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_jpeg.c: avoid potential harmless unsigned integer overflow on data->fileoffset in JPEGFixupTagsSubsamplingSkip() by validating earlier. Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28200
+
+2020-11-27  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'Jamaika1-master-patch-47839' into 'master'
+	Change ULARGE_INTEGER to LARGE_INTEGER
+
+	See merge request libtiff/libtiff!170
+
+2020-11-27  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'Jamaika1-master-patch-46397' into 'master'
+	Added stdint.h
+
+	See merge request libtiff/libtiff!171
+
+2020-11-27  Jamaika  <lukaszcz18@wp.pl>
+
+	Added stdint.h.
+
+	``` tif_win32.c: In function '_tiffSizeProc': tif_win32.c:159:23: warning: passing argument 2 of 'GetFileSizeEx' from incompatible pointer type [-Wincompatible-pointer-types]   159 |  if (GetFileSizeEx(fd,&m))       |                       ^~       |                       |       |                       ULARGE_INTEGER * In file included from c:\msys1021\x86_64-w64-mingw32\include\winbase.h:18,                  from c:\msys1021\x86_64-w64-mingw32\include\windows.h:70,                  from tif_win32.c:32: c:\msys1021\x86_64-w64-mingw32\include\fileapi.h:78:73: note: expected 'PLARGE_INTEGER' {aka 'LARGE_INTEGER *'} but argument is of type 'ULARGE_INTEGER *'    78 |   WINBASEAPI WINBOOL WINAPI GetFileSizeEx (HANDLE hFile, PLARGE_INTEGER lpFileSize);       |                                                          ~~~~~~~~~~~~~~~^~~~~~~~~~ ```
+
+2020-11-21  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-113' into 'master'
+	tiffcrop: fix buffer overrun in extractContigSamples24bits()
+
+	Closes #113
+
+	See merge request libtiff/libtiff!169
+
+2020-11-21  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-156' into 'master'
+	tiff2pdf: Check output size before writing
+
+	Closes #156
+
+	See merge request libtiff/libtiff!168
+
+2020-11-21  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-201' into 'master'
+	tiff2pdf: enforce memory limit for tiled pictures too
+
+	Closes #201
+
+	See merge request libtiff/libtiff!167
+
+2020-11-20  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-207' into 'master'
+	enforce (configurable) memory limit in tiff2rgba
+
+	Closes #209 et #207
+
+	See merge request libtiff/libtiff!165
+
+2020-11-20  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_lzw.c: avoid false positive -Wnull-dereference of mingw32 gcc 7.3.
+
+2020-11-17  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffcrop: fix buffer overrun in extractContigSamples24bits()
+	fixes #113
+
+	tiff2pdf: Check output size before writing.
+	fixes #156
+
+	tiff2pdf: enforce memory limit for tiled pictures too.
+	fixes #201
+
+2020-11-15  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2rgba.1: -M option.
+
+	enforce (configurable) memory limit in tiff2rgba.
+	fixes #207
+	fixes #209
+
+2020-11-14  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-220' into 'master'
+	tiff2pdf.c: properly calculate datasize when saving to JPEG YCbCr
+
+	Closes #220
+
+	See merge request libtiff/libtiff!159
+
+2020-11-14  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2pdf.c: properly calculate datasize when saving to JPEG YCbCr.
+	fixes #220
+
+2020-11-14  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-204' into 'master'
+	avoid buffer overflow while writing jpeg end of file marker
+
+	Closes #204
+
+	See merge request libtiff/libtiff!161
+
+2020-11-14  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-193' into 'master'
+	fix buffer overflow in tiff2ps.c
+
+	Closes #193
+
+	See merge request libtiff/libtiff!162
+
+2020-11-14  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'skal65535-master-patch-91082' into 'master'
+	More overflow fixes for large widths
+
+	See merge request libtiff/libtiff!164
+
+2020-11-14  skal  <pascal.massimino@gmail.com>
+
+	More overflow fixes for large width.
+	Also: use INT_MAX instead of hard-coded constants.
+
+2020-11-12  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'skal65535-master-patch-56655' into 'master'
+	Fix potential overflow in gtStripContig()
+
+	See merge request libtiff/libtiff!163
+
+2020-11-12  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-211' into 'master'
+	check for tile width overflow
+
+	Closes #211
+
+	See merge request libtiff/libtiff!160
+
+2020-11-12  skal  <pascal.massimino@gmail.com>
+
+	Fix potential overflow in gtStripContig()
+	(w + w) might not fit in int32 if too large.
+
+2020-11-09  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2ps.c: fix buffer overread.
+	fixes #193
+
+	fix undefined behaviour (int shifted too much to the left)
+
+	avoid buffer overflow while writing jpeg end of file marker.
+	fixes #204
+
+	gtTileContig(): check Tile width for overflow.
+	fixes #211
+
+	fix warning messages (v32 is unsigned)
+
+2020-10-26  Even Rouault  <even.rouault@spatialys.com>
+
+	TIFFStartStrip(): avoid potential crash in WebP codec when using scanline access on corrupted files. Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26650
+
+2020-10-20  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_webp.c: validate tile/strip dimension to avoid unsigned integer overflow in RGBA.size computation
+
+2020-10-19  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_zip.c: fix typo in comment.
+
+2020-10-16  Even Rouault  <even.rouault@spatialys.com>
+
+	tiff.h: remove irrelevant warning about webp related pseudo-tags not being registered: they are purely internal libtiff concepts
+
+2020-10-16  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'libdeflate' into 'master'
+	Add support for building against libdeflate for faster Zip/Deflate compression/decompression
+
+	See merge request libtiff/libtiff!158
+
+2020-10-16  Even Rouault  <even.rouault@spatialys.com>
+
+	test: add testdeflatelaststripextradata.sh.
+
+2020-10-16  Even Rouault  <even.rouault@spatialys.com>
+
+	Add support for optional building against libdeflate for faster Zip/Deflate compression/decompression.
+	So we can have 2 kind of builds with the Zip/Deflate codec:
+	- zlib only
+	- zlib + libdeflate
+
+	Speed improvements in the 35%-50% range can be expected when libdeflate is used.
+	Compression level up to 12 is now supported (capped to 9 when zlib is used).
+	Still requires zlib for situations where libdeflate cannot be used (that
+	is for scanline access, since libdeflate has no streaming mode)
+
+	Pseudo-tag TIFFTAG_DEFLATE_SUBCODEC=DEFLATE_SUBCODEC_ZLIB/DEFLATE_SUBCODEC_LIBDEFLATE
+	is added to control which subcodec (zlib or libdeflate) should be used (it defaults
+	of course to libdeflate, when it is available).
+	This is mostly aimed at being used on the writing side, to be able to reproduce
+	output of previous libtiff versions at a binary level, in situations where this would
+	be really needed. Or as a safety belt in case there would be unforeseen issues
+	with using libdeflate.
+	It can be used to know when libdeflate is available at runtime (DEFLATE_SUBCODEC_LIBDEFLATE
+	will be the default value in that situation).
+
+	Of course, deflate codestreams produced by libdeflate can be read by zlib, and vice-versa.
+
+2020-10-14  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_webp.c: fix compiler warnings with MSVC.
+
+2020-10-12  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'various_fixes' into 'master'
+	Fix compiler warnings about unused variables when assert() expands to nothing
+
+	See merge request libtiff/libtiff!157
+
+2020-10-12  Even Rouault  <even.rouault@spatialys.com>
+
+	.gitignore: add entries for new files in test/
+
+	Fix compiler warnings about unused variables when assert() expands to nothing
+
+2020-10-09  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch '215-cygwin-appveyor-fail' into 'master'
+	Update Appveyor CI build to build with VS2019 image
+
+	Closes #215
+
+	See merge request libtiff/libtiff!154
+
+2020-10-09  Roger Leigh  <rleigh@codelibre.net>
+
+	wip.
+
+	wip.
+
+	wip.
+
+	wip.
+
+	wip.
+
+	wip.
+
+2020-10-09  Roger Leigh  <rleigh@codelibre.net>
+
+	Merge branch 'TIFF-217_m_lib_path' into 'master'
+	cmake: Do not use absolute libm path
+
+	Closes #217
+
+	See merge request libtiff/libtiff!156
+
+2020-10-09  Roger Leigh  <rleigh@codelibre.net>
+
+	cmake: Do not use absolute libm path.
+
+2020-10-08  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_fax3.h: restore systematic calls to CLEANUP_RUNS()
+	now that SETVALUE() no longer cause overflows.
+	Those were removed per b351db8be1b4d3f712bdb9424a79d3174cc03202 and
+	3440ac216463fcad170bbb391491e69730a59ffa.
+
+	As SETVALUE() now returns an error, this allow the decoder to exit.
+
+	Otherwise, the assert(x == lastx) in _TIFFFax3fillruns() can trigger.
+
+	Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26201
+
+2020-10-06  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'check_TIFFFlushData1' into 'master'
+	FAX/JPEG/LZMA/PixarLog/ZIP/ZSTD codecs: make sure to check TIFFFlushData1() return value
+
+	See merge request libtiff/libtiff!155
+
+2020-10-04  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'shared-memory' into 'master'
+	Set the --shared-memory linker flag for Emscripten builds
+
+	See merge request libtiff/libtiff!153
+
+2020-10-03  Even Rouault  <even.rouault@spatialys.com>
+
+	tiff2rgba.c: fix -Wold-style-declaration warning.
+
+	FAX/JPEG/LZMA/PixarLog/ZIP/ZSTD codecs: make sure to check TIFFFlushData1() return value
+
+2020-09-26  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_fax3.h: extra buffer overflow checks. Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25934
+
+2020-09-25  Roger Leigh  <rleigh@codelibre.net>
+
+	wip.
+
+	wip.
+
+	wip.
+
+	wip.
+
+	wip.
+
+	wip.
+
+	Update AppVeyor image.
+
+	test-appveyor.
+
+2020-09-24  Attila Oláh  <atl@google.com>
+
+	Also pass --shared-memory to raw_decode.
+	This is needed when building for Emscripten with *both* WEBP and JPEG
+	support.
+
+	Set the --shared-memory linker flag for Emscripten builds.
+	This is only needed when building with WEBP support, which uses atomics,
+	therefore the linker needs the --shared-memory flag. The flag cannot be
+	added globally because not all executables link against libwebp.
+
+2020-09-22  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_fax3.h: return error when a buffer overflow occurs. Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25552 and https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25849
+
+2020-09-11  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'fix-float-compare' into 'master'
+	Fix comparison for max negative float value.
+
+	See merge request libtiff/libtiff!152
+
+2020-09-11  Dirk Lemstra  <dirk@lemstra.org>
+
+	Fix comparison for max negative float value.
+
+2020-09-07  Even Rouault  <even.rouault@spatialys.com>
+
+	Fax3PreDecode(): reset curruns and refruns state variables.
+	to avoid out-of-bounds write triggered by GDAL when repeatedly
+	reading a corrupt strip.
+
+	Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25493
+
+2020-06-06  Thomas Bernard  <miniupnp@free.fr>
+
+	Merge branch 'issue-17' into 'master'
+	normalize tools behaviour regarding -h
+
+	Closes #17
+
+	See merge request libtiff/libtiff!115
+
+2020-05-31  Even Rouault  <even.rouault@spatialys.com>
+
+	TWebPSetupEncode(): fix logic problem (and instead of or) in test that checks input is 8bit unsigned data
+
+2020-05-12  Even Rouault  <even.rouault@spatialys.com>
+
+	TIFFGetConfiguredCODECs(): fix to avoid wrong structure to be returned for registered (ie non built-in) codecs
+
+2020-05-09  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'zstd-webp-update' into 'master'
+	gitlab-ci: use latest zstd and webp versions
+
+	See merge request libtiff/libtiff!148
+
+2020-05-09  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'deprecated' into 'master'
+	ojpeg: s/Depreciated/Deprecated/
+
+	See merge request libtiff/libtiff!149
+
+2020-05-09  Aaron Boxer  <boxerab@gmail.com>
+
+	ojpeg: s/Depreciated/Deprecated/
+
+2020-04-27  Even Rouault  <even.rouault@spatialys.com>
+
+	Fix typos.
+
+	tif_jpeg.c: avoid potential division in previous fix (master only)
+
+2020-04-26  Thomas Bernard  <miniupnp@free.fr>
+
+	gitlab-ci: use latest zstd and webp versions.
+
+2020-04-26  Even Rouault  <even.rouault@spatialys.com>
+
+	tiff.h: fixes to use ASCII only characters (master only)
+
+2020-04-26  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffsplit: use EXIT_SUCCESS / EXIT_FAILURE.
+
+	tiffset: print usage on stdout when -h is used.
+	also use EXIT_FAILURE / EXIT_SUCCESS
+	see #17
+
+	tiffmedian: shopw usage on stdout when -h is used.
+	also use EXIT_SUCCESS/EXIT_FAILURE
+	see #17
+
+	tiffinfo: print usage on stdout when -h is used.
+	also use EXIT_FAILURE / EXIT_SUCCESS
+	see #17
+
+	raw2tiff: print usage to stdout when -h is used.
+	see #17
+
+	tiff2pdf: print usage on stdout when -h is used.
+	see #17
+
+	tiffgt: output usage on stdout with -h.
+	also use EXIT_SUCCESS / EXIT_FAILURE
+
+	tiffdump: use EXIT_FAILURE / EXIT_SUCCESS.
+	see #17
+
+	tiffdither: print usage on stdout when -h is used.
+	see #17
+
+2020-04-26  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffcrop: -h / -v prints usage/version to stdout.
+	also uses the standard C EXIT_SUCCESS / EXIT_FAILURE
+	macros
+
+	see #17
+
+2020-04-26  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffcp: output usage to stdout when using -h.
+	also use EXIT_FAILURE / EXIT_SUCCESS
+	see #17
+
+	tiffcmp: match exit status for posix cmp and diff tools.
+
+	tiff2rgba: output usage to stdout when using -h.
+	also uses std C EXIT_FAILURE / EXIT_SUCCESS
+	see #17
+
+	tiff2ps: sue EXIT_FAILURE / EXIT_SUCCESS.
+	see #17
+
+	tiff2bw: output usage on stdout when using -h.
+	also uses EXIT_SUCCESS / EXIT_FAILURE
+	see #17
+
+	thumbnail: use EXIT_FAILURE / EXIT_SUCCESS.
+	the -h option was already used so it cannot be used for help/usage
+	see #17
+
+	rgb2ycbcr: use EXIT_FAILURE / EXIT_SUCCESS.
+	the -h option was already used so it cannot be used for help/usage
+	see #17
+
+	ppm2tiff: output usage to stdout when using -h option.
+	also uses std C EXIT_SUCCESS / EXIT_FAILURE
+	see #17
+
+	pal2rgb: output usage to stdout when -h is used.
+	see #17
+
+	fax2tiff.c: print usage on stdout when using -h option.
+	see #17
+
+	fax2ps: output usage to stdout when using -h option.
+	also use EXIT_SUCCESS, EXIT_FAILURE from C standard
+
+2020-04-25  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'jpeg_multiscan_dos_logic' into 'master'
+	tif_jpeg.c: revise logic to detect potential excessive memory usage when...
+
+	See merge request libtiff/libtiff!147
+
+2020-04-24  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-176' into 'master'
+	tiff2pdf: get rid of uninitialized memory content
+
+	Closes #176
+
+	See merge request libtiff/libtiff!143
+
+2020-04-24  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_jpeg.c: revise logic to detect potential excessive memory usage when decoding multiscan JPEG compressed images
+
+2020-04-19  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2pdf: test the return code of TIFFReadRawStrip() and TIFFReadRawTile()
+
+	tiff2pdf.c: fix some whitespace problems in source.
+
+	tiff2pdf: get rid of uninitialized memory content.
+	fixes #176
+
+2020-04-19  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-18' into 'master'
+	tiffset: pass size for TIFFTAG_INKNAMES
+
+	Closes #18
+
+	See merge request libtiff/libtiff!146
+
+2020-04-18  Olivier Paquet  <olivier.paquet@gmail.com>
+
+	Merge branch 'issue-80' into 'master'
+	tiffinfo: fix dump of Tiled images
+
+	Closes #80
+
+	See merge request libtiff/libtiff!144
+
+2020-04-15  Even Rouault  <even.rouault@spatialys.com>
+
+	Fix wrong file size checks for memory-mapped BigTIFF files that could lead to image rejection
+
+2020-04-05  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffset: pass size for TIFFTAG_INKNAMES.
+	Uses TIFFFieldPassCount() to know which arguments need to be
+	passed to TiffSetField()
+
+	fixes #18
+	see http://bugzilla.maptools.org/show_bug.cgi?id=2202
+
+2020-04-04  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffinfo: showdata for tiled images.
+
+	tiffinfo: fix dump of Tiled images.
+	fixes #80
+
+2020-04-03  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-117' into 'master'
+	tiffcrop: enforce memory allocation limit
+
+	Closes #117
+
+	See merge request libtiff/libtiff!140
+
+2020-04-03  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffcrop: enforce memory allocation limit.
+	uses -k option to change limit (default to 256MiB)
+	fixes #117 / http://bugzilla.maptools.org/show_bug.cgi?id=2757
+
+2020-04-02  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-45' into 'master'
+	tiffcp: disable strip chopping when trying to convert to JBIG compression
+
+	Closes #45
+
+	See merge request libtiff/libtiff!138
+
+2020-04-02  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-124' into 'master'
+	TIFFGetFields(3tiff): TIFFTAG_*BYTECOUNTS TIFFTAG_*OFFSETS are uint64
+
+	Closes #124
+
+	See merge request libtiff/libtiff!137
+
+2020-04-02  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'aix_itrunc' into 'master'
+	Rename itrunc to fix name clash with a different itrunc in math.h on AIX. Fixes issue #189
+
+	Closes #189
+
+	See merge request libtiff/libtiff!139
+
+2020-04-01  Rob Boehne  <robb@datalogics.com>
+
+	Rename itrunc to fix name clash with a different itrunc in math.h on AIX. Fixes issue #189
+
+2020-04-01  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffcp: disable strip chopping when trying to convert to JBIG compression
+	fixes #45
+
+2020-03-29  Thomas Bernard  <miniupnp@free.fr>
+
+	TIFFGetFields(3tiff): TIFFTAG_*BYTECOUNTS TIFFTAG_*OFFSETS are uint64.
+	fixes #124 / http://bugzilla.maptools.org/show_bug.cgi?id=2774
+
+2020-03-29  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-48' into 'master'
+	tiff2pdf: fix "raw" copy of Deflate streams
+
+	Closes #48
+
+	See merge request libtiff/libtiff!136
+
+2020-03-27  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2pdf: fix "raw" copy of Deflate streams.
+	The Predictor parameter was not copied from the source tiff to the PDF.
+	fixes #48 / http://bugzilla.maptools.org/show_bug.cgi?id=2442
+
+2020-03-26  Thomas Bernard  <miniupnp@free.fr>
+
+	tif_fax3: quit Fax3Decode2D() when a buffer overflow occurs.
+	fixes #186
+
+2020-03-24  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-143-144' into 'master'
+	tiffdump: avoid unaligned memory access
+
+	Closes #144 et #143
+
+	See merge request libtiff/libtiff!133
+
+2020-03-24  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-133' into 'master'
+	tiff2pdf: avoid divide by 0
+
+	Closes #133
+
+	See merge request libtiff/libtiff!126
+
+2020-03-24  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2pdf: normalizePoint() macro to normalize the white point.
+
+2020-03-23  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffdump: avoid unaligned memory access.
+	fixes #143
+	fixes #144
+
+2020-03-23  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'out-of-memory' into 'master'
+	tiffcp/tiff2pdf/tiff2ps: enforce maximum malloc size
+
+	Closes #153, #84, #116 et #115
+
+	See merge request libtiff/libtiff!130
+
+2020-03-23  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-157' into 'master'
+	tiffset: check memory allocation
+
+	Closes #157
+
+	See merge request libtiff/libtiff!132
+
+2020-03-23  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-185' into 'master'
+	tif_fax3: more buffer overflow checks in Fax3Decode2D()
+
+	Closes #185
+
+	See merge request libtiff/libtiff!131
+
+2020-03-23  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffset: check memory allocation.
+	fixes #157 / http://bugzilla.maptools.org/show_bug.cgi?id=2850
+
+	tif_fax3: more buffer overflow checks in Fax3Decode2D()
+	fixes #185
+
+2020-03-21  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2ps: enforce memory allocation limit.
+	fixes #153 / http://bugzilla.maptools.org/show_bug.cgi?id=2845
+
+	tiff2pdf: enforce maximum data size.
+	fixes #116 / http://bugzilla.maptools.org/show_bug.cgi?id=2756
+	fixes #84 / http://bugzilla.maptools.org/show_bug.cgi?id=2683
+
+	update man page for tiffcp regarding the -m option.
+
+	tiffcp.c:  _TIFFmalloc() => limitMalloc()
+
+2020-03-21  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffcp: enforce maximum malloc size.
+	default is 256MB. use -m option to change
+
+	fixes #115 / http://bugzilla.maptools.org/show_bug.cgi?id=2755
+
+2020-03-21  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-184' into 'master'
+	CmakeLists.txt: define WORDS_BIGENDIAN when the CPU is big endian
+
+	Closes #184
+
+	See merge request libtiff/libtiff!127
+
+2020-03-21  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-44' into 'master'
+	tiff2pdf: "" causes the relevant argument not to be written
+
+	Closes #44
+
+	See merge request libtiff/libtiff!128
+
+2020-03-21  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-56' into 'master'
+	fix man for TIFFReadEncodedStrip(), TIFFStripSize, TIFFVStripSize, TIFFRawStripSize
+
+	Closes #56
+
+	See merge request libtiff/libtiff!129
+
+2020-03-20  Thomas Bernard  <miniupnp@free.fr>
+
+	fix man for TIFFReadEncodedStrip(), TIFFStripSize, TIFFVStripSize, TIFFRawStripSize
+	fixes #56
+	http://bugzilla.maptools.org/show_bug.cgi?id=2507
+
+	tiff2pdf: "" causes the relevant argument not to be written.
+	fixes #44
+
+	CmakeLists.txt: define WORDS_BIGENDIAN when the CPU is big endian.
+	fixes #184
+
+2020-03-17  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2pdf: avoid divide by 0.
+	fixes #133 http://bugzilla.maptools.org/show_bug.cgi?id=2796
+
+2020-03-17  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-22' into 'master'
+	do not _tiffMapProc 0 size files
+
+	Closes #22
+
+	See merge request libtiff/libtiff!125
+
+2020-03-13  Thomas Bernard  <miniupnp@free.fr>
+
+	tif_win32.c: do not _tiffMapProc() 0 sized files.
+	see #22
+
+	tif_unix.c: do not _tiffMapProc 0 size files.
+	fixes #22
+	http://bugzilla.maptools.org/show_bug.cgi?id=2249
+
+2020-03-12  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_fax3.c: fix warning C4018: '<': signed/unsigned mismatch introduced in past commits
+
+2020-03-11  Even Rouault  <even.rouault@spatialys.com>
+
+	tiff.h: mention TIFFTAG_RPCCOEFFICIENT, TIFFTAG_TIFF_RSID, TIFFTAG_GEO_METADATA
+
+2020-03-11  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-60' into 'master'
+	added support for more private tags
+
+	Closes #60
+
+	See merge request libtiff/libtiff!124
+
+2020-03-11  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-160' into 'master'
+	Fax3SetupState(): check consistency of rowbytes and rowpixels
+
+	Closes #160
+
+	See merge request libtiff/libtiff!123
+
+2020-03-11  Thomas Bernard  <miniupnp@free.fr>
+
+	added support for more private tags.
+	see https://gitlab.com/libtiff/libtiff/-/issues/60
+	bugzilla.maptools.org/show_bug.cgi?id=2525
+
+	closes #60
+
+	original author : art1@andreas-romeyke.de
+
+2020-03-11  Thomas Bernard  <miniupnp@free.fr>
+
+	Fax3SetupState(): check consistency of rowbytes and rowpixels.
+	also add some parameter documentation to Fax3Decode1D()
+
+	fixes #160
+	http://bugzilla.maptools.org/show_bug.cgi?id=2854
+
+2020-03-10  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-11-const-pointers' into 'master'
+	Make pointers returned via TIFFGetField const
+
+	Closes #11
+
+	See merge request libtiff/libtiff!118
+
+2020-03-10  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_ojpeg.c: relax again too strict sanity checks to allow reading of valid images such as https://gitlab.com/libtiff/libtiff/-/issues/181#note_302535232. Fixes #181
+
+2020-03-09  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-52' into 'master'
+	contrib/win_dib/tiff2dib: fix Uninitialized variable: lpBits
+
+	Closes #52
+
+	See merge request libtiff/libtiff!121
+
+2020-03-09  Thomas Bernard  <miniupnp@free.fr>
+
+	contrib/win_dib/tiff2dib: fix Uninitialized variable: lpBits.
+	fixes #52
+	http://bugzilla.maptools.org/show_bug.cgi?id=2469
+
+2020-03-08  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-58' into 'master'
+	Make TIFFTAG_CFAPATTERN variable count
+
+	Closes #58
+
+	See merge request libtiff/libtiff!120
+
+2020-03-08  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-158-no-predictor-in-webp' into 'master'
+	TIFFTAG_PREDICTOR is not supported for WebP
+
+	Closes #158
+
+	See merge request libtiff/libtiff!119
+
+2020-03-08  Sam Hasinoff  <hasinoff@google.com>
+
+	Make TIFFTAG_CFAPATTERN variable count.
+	The TIFFTAG_CFAPATTERN tag (33422) from TIFF/EP, recently introduced in libtiff
+	3363eda09d082e3e1dfffa6281f53085cac51ad3 / http://bugzilla.maptools.org/show_bug.cgi?id=2457
+	is described as having a fixed count of 4.
+	But the TIFF/EP spec says this should support a variable count (= CFARepeatRows * CFARepeatCols):
+
+	TIFF/EP, ISO 12234-2:2001
+	http://www.barrypearson.co.uk/top2009/downloads/TAG2000-22_DIS12234-2.pdf
+	page 18 and 26
+
+2020-03-08  Thomas Bernard  <miniupnp@free.fr>
+
+	TIFFTAG_PREDICTOR is not supported for WebP.
+	fixes #158
+	https://gitlab.com/libtiff/libtiff/-/issues/158
+
+	this bug was introduced by 9eacd59fecc4ef593ac17689bc530ab451c8ec14
+	merge request !32
+
+2020-03-07  Adam Goode  <adam@spicenitz.org>
+
+	Make the default whitepoint and ycbcrcoeffs arrays const.
+	Now that we are returning const pointers in TIFFGetFieldDefaulted,
+	we can now make these static default arrays const.
+
+	see #11
+
+2020-03-07  Adam Goode  <adam@spicenitz.org>
+
+	Make pointers returned via TIFFGetField const.
+	According to http://bugzilla.maptools.org/show_bug.cgi?id=2125#c6
+	callers are not allowed to modify pointer or array values returned from
+	TIFFGetField or the like. So, make this explicit in the documentation
+	by specifying these things as const. Note that this is not an ABI
+	change, since C does not encode const in libraries. Also, this is
+	not really an API change, since the varargs call strips away all
+	the types anyway. So it really is more of a documentation change.
+
+	fixes #11
+
+2020-03-07  Even Rouault  <even.rouault@spatialys.com>
+
+	CMake: Skip custom_dir_EXIF_231 test on shared builds to avoid issues on Windows
+
+2020-03-07  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'EXIF231_GPS_upgrade' into 'master'
+	EXIF 2.32 and GPS TIFF-tags and functionality upgraded.
+
+	See merge request libtiff/libtiff!91
+
+2020-03-07  Su_Laus  <sulau@freenet.de>
+
+	EXIF 2.32 and GPS tags and functionality upgraded.
+	- Existing EXIF field definition of tags is upgraded to EXIF version 2.3.2
+	- EXIF-GPS structure, tags and access functions are added as special CustomDirectory (like it was done for EXIF).
+	- Test program custom_dir_EXIF_231.c added to test writing/reading of EXID IFD and GPS IFD tags
+	  and to highlight some quirks of IFD-handling and peculiarities of reading/writing the different data types.
+	- Reading error for FileSource and SceneType tags corrected.
+
+	- EXIF_GPS_upgrade rebased onto c8c5309b765ef4ff097d2aaffbdb8f403db8967d (Merge branch 'Rational2DoublePrecision_correction' into 'master')
+	and adapted:
+	- tif_dirinfo.c:         All rational tags set to TIFF_SETGET_FLOAT but only the GPSTAG_ tags set to TIFF_SETGET_DOUBLE.
+	- custom_dir_EXIF_231.c: Editorials amended and gcc warnings fixed.
+	- CMakeLists.txt: add_test(NAME "custom_dir_EXIF_231"  COMMAND "custom_dir_EXIF_231")  added.
+
+2020-03-07  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-55' into 'master'
+	ppm2tiff: support any bps value from 1 to 16
+
+	Closes #55
+
+	See merge request libtiff/libtiff!106
+
+2020-03-07  Thomas Bernard  <miniupnp@free.fr>
+
+	ppm2tiff: Add test for 16bpc PPM.
+
+	ppm2tiff: remove unused argument warning.
+
+2020-03-07  Ludolf Holzheid  <ludolf.holzheid@gmx.de>
+
+	ppm2tiff: support any bps value from 1 to 16.
+	fix #55
+	http://bugzilla.maptools.org/show_bug.cgi?id=2505
+
+	Patch originally submitted by Ludolf Holzheid <ludolf.holzheid@gmx.de>
+
+2020-03-06  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'fax-test' into 'master'
+	add test for fax4 decoding
+
+	See merge request libtiff/libtiff!114
+
+2020-03-05  Thomas Bernard  <miniupnp@free.fr>
+
+	add test for fax4 decoding.
+	This will check for regression on #46
+	https://gitlab.com/libtiff/libtiff/issues/46
+	http://bugzilla.maptools.org/show_bug.cgi?id=2434
+
+2020-03-05  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'freebsd-tests' into 'master'
+	make tests pass under FreeBSD.
+
+	See merge request libtiff/libtiff!113
+
+2020-03-05  Thomas Bernard  <miniupnp@free.fr>
+
+	make tests pass under FreeBSD.
+	the -I option for the GNU diff and the FreeBSD diff
+	behaves differently regarding escaping the ( ) and |
+
+	By using two -I option, we avoid using such charracters.
+
+2020-03-05  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-31' into 'master'
+	HTML
+
+	Closes #31
+
+	See merge request libtiff/libtiff!111
+
+2020-03-05  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-179' into 'master'
+	tif_fax3.h: check for buffer overflow in EXPAND2D before "calling" CLEANUP_RUNS()
+
+	Closes #179
+
+	See merge request libtiff/libtiff!112
+
+2020-03-05  Thomas Bernard  <miniupnp@free.fr>
+
+	v4.1.0.html: fix for validation.
+	long <!----------------> comments were replaced
+	because they confused some parsers
+
+	add DOCTYPE on v*.html.
+
+	fix HTML files so they are valid according to https://validator.w3.org.
+
+2020-03-05  Thomas Bernard  <miniupnp@free.fr>
+
+	tif_fax3.h: check for buffer overflow in EXPAND2D before "calling" CLEANUP_RUNS()
+	fixes #179
+
+	this fixes the regression introduced in 02bb0175 / 72c4acef
+	( merge request !110 )
+
+	It may be a better fix to do the overflow check in SETVALUE() but the
+	macro do { } while(0) construct makes it difficult to quit the loop
+	properly.
+
+2020-03-01  Thomas Bernard  <miniupnp@free.fr>
+
+	index.html: fix unclosed <tt> tag.
+
+2020-03-01  Thomas Bernard  <miniupnp@free.fr>
+
+	html: do not force colors (which are default anyway)
+	If needed, style should be set using CSS.
+
+	fixes #31
+	https://gitlab.com/libtiff/libtiff/issues/31
+	http://bugzilla.maptools.org/show_bug.cgi?id=2326
+
+2020-03-01  Even Rouault  <even.rouault@spatialys.com>
+
+	TIFFReadCustomDirectory(): fix potential heap buffer overflow when reading a custom directory, after a regular directory where a codec was active. Fixes https://gitlab.com/libtiff/libtiff/issues/178
+
+2020-03-01  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-46' into 'master'
+	fix decoding of fax4 images
+
+	Closes #46
+
+	See merge request libtiff/libtiff!110
+
+2020-02-29  Thomas Bernard  <miniupnp@free.fr>
+
+	tif_fax3: better fix for CVE-2011-0192.
+	There are some legitimate case which were forbidden by the previous fix
+
+	tif_fax3.h: allow 0 length run in DECODE2D.
+	fixes #46
+	https://gitlab.com/libtiff/libtiff/issues/46
+	http://bugzilla.maptools.org/show_bug.cgi?id=2434
+
+2020-02-29  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'mingwlibm' into 'master'
+	Don't use libm with libtiff due to conflict with libmsvcrt
+
+	See merge request libtiff/libtiff!73
+
+2020-02-29  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'Rational2DoublePrecision_correction' into 'master'
+	tif_dirwrite.c: bugfix DoubleToSrational() for plain signed integers
+
+	See merge request libtiff/libtiff!109
+
+2020-02-29  Su_Laus  <sulau@freenet.de>
+
+	tif_dirwrite.c: bugfix DoubleToSrational(), which returns plain signed integer values always as unsigned rationals. Add a test into rational_precision2double.c for "-1.0" and some editorials in tif_dirwrite.c. (code is related to 6df997c786928757caea0dd68d26ea5f098f49df changes).
+
+2020-02-29  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'issue-174' into 'master'
+	tif_fax3.c: check buffer overflow in Fax4Decode()
+
+	Closes #174
+
+	See merge request libtiff/libtiff!108
+
+2020-02-29  Thomas Bernard  <miniupnp@free.fr>
+
+	Fax4Decode(): log error message in case of buffer overrun.
+
+	tif_fax3.c: check buffer overflow in Fax4Decode()
+	fixes #174
+
+2020-02-28  Even Rouault  <even.rouault@spatialys.com>
+
+	typo fixes in code comments.
+
+	ToRationalEuclideanGCD: remove useless test that confuses Coverity Scan about a potential later modulo by zero
+
+2020-02-27  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_dirwrite.c: fix other warnings related to 6df997c786928757caea0dd68d26ea5f098f49df changes
+
+	rational_precision2double.c: fix many warnings, and do not build it on CMake on shared lib builds
+
+	tif_dirwrite.c: fix various warnings found when building GDAL with internal libtiff after 6df997c786928757caea0dd68d26ea5f098f49df changes
+
+	tif_dirwrite.c: qualify ToRationalEuclideanGCD() with static.
+
+2020-02-27  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'Rational2DoublePrecision' into 'master'
+	Rational with Double Precision Upgrade
+
+	See merge request libtiff/libtiff!100
+
+2020-02-27  Su_Laus  <sulau@freenet.de>
+
+	Rational with Double Precision Upgrade.
+	Unfortunately, custom rational tags (TIFF_RATIONAL with field_bit=FIELD_CUSTOM) are defined as TIFF_SETGET_DOUBLE
+	but for the reading interface and LibTiff internally they are stored ALWAYS as floating point SINGLE precision.
+	Double precision custom rational tags are not supported by LibTiff.
+
+	For the GPS tags in WGS84 a higher accuracy / precision is needed.
+	Therefore, this upgrade is made, keeping the old interface for the already defined tags and allowing a double precision definition,
+	as well as calculating rationals with higher accuracy / precision.
+	This higher accuracy can be used for newly defined tags like that in EXIF/GPS.
+
+	Refer also to the very old Bugzilla issue 2542 (#69)
+
+	A test file rational_precision2double.c is added, which shows prevention of the old interface to the already defined custom rational tags
+	with the standard library as well as with the upgraded library.
+
+	Also TIFFTAG_XRESOLUTION, TIFFTAG_YRESOLUTION, TIFFTAG_XPOSITION, TIFFTAG_YPOSITION amended from TIFF_SETGET_DOUBLE to TIFF_SETGET_FLOAT and testcase inserted in rational_precision2double.c
+
+2020-02-26  Chris Degawa  <ccom@randomderp.com>
+
+	mingw-w64 cmake: Don't find libm.
+	mingw-w64 will provide libm symbols by default without -lm and mingw-64's
+	libm is just a stub.
+
+	This is just to make sure that on systems with msys2 and also cygwin, cmake
+	doesn't find a libm that actually contains math functions.
+
+2020-02-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'division-by-zero' into 'master'
+	tools/tiffcp.c: fix potential division by zero
+
+	See merge request libtiff/libtiff!83
+
+2020-02-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'fix-unused-warning' into 'master'
+	warnings: mark conditionally used parameters
+
+	See merge request libtiff/libtiff!49
+
+2020-02-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'master' into 'master'
+	fix issue #78 warnings regarding RichTIFFIPTC data type
+
+	Closes #78
+
+	See merge request libtiff/libtiff!99
+
+2020-02-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'win64-handle-casts-warn-fix' into 'master'
+	Avoid warnings about casts between HANDLE and int in Win64 builds
+
+	Closes #2
+
+	See merge request libtiff/libtiff!93
+
+2020-02-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'bug2839' into 'master'
+	raw2tiff: avoid divide by 0
+
+	Closes #151
+
+	See merge request libtiff/libtiff!103
+
+2020-02-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'bug2669' into 'master'
+	tiff2pdf: palette bound check in t2p_sample_realize_palette()
+
+	Closes #82
+
+	See merge request libtiff/libtiff!104
+
+2020-02-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'int-shift' into 'master'
+	tiffcrop: fix asan runtime error caused by integer promotion
+
+	See merge request libtiff/libtiff!105
+
+2020-02-26  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'bug-2538' into 'master'
+	libtiff.html: fix function casing
+
+	Closes #68
+
+	See merge request libtiff/libtiff!107
+
+2020-02-16  Thomas Bernard  <miniupnp@free.fr>
+
+	raw2tiff: avoid divide by 0.
+	fixes #151 / http://bugzilla.maptools.org/show_bug.cgi?id=2839
+
+	first memcmp() lines before computing correlation
+	and always avoid divide by 0 anyway
+
+2020-02-09  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'bug2855' into 'master'
+	tiff2ps: fix heap buffer read overflow in PSDataColorContig()
+
+	Closes #161
+
+	See merge request libtiff/libtiff!102
+
+2020-02-08  Thomas Bernard  <miniupnp@free.fr>
+
+	libtiff.html: fix function casing.
+
+	libtiff.html: fix function casing.
+	fixes #68 / http://bugzilla.maptools.org/show_bug.cgi?id=2538
+
+2020-02-08  Thomas Bernard  <miniupnp@free.fr>
+
+	tiffcrop: fix asan runtime error caused by integer promotion.
+	tiffcrop.c:4027:20: runtime error: left shift of 190 by 24 places cannot be represented in type 'int'
+
+	C treats (byte << 24) as an int expression.
+	casting explicitly to unsigned type uint32 avoids the problem.
+
+	the same issue has been fixed elsewhere with a24213691616e7cd35aa3e2805493de80c7e4fcf
+
+	I detected the bug with the test file of #86
+
+2020-02-08  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2pdf: palette bound check in t2p_sample_realize_palette()
+	fixes #82
+
+2020-02-08  Thomas Bernard  <miniupnp@free.fr>
+
+	tiff2ps: fix heap buffer read overflow in PSDataColorContig()
+	fixes #161 / http://bugzilla.maptools.org/show_bug.cgi?id=2855
+
+	in 05029fb7f1ecf771abaf90b5705b6cab9eb522a7 I missed that 1 extra byte is read
+	in this loop.
+
+2020-02-05  Even Rouault  <even.rouault@spatialys.com>
+
+	tif_dirread.c: suppress CLang static Analyzer 9.0 false positive.
+
+2020-02-01  Even Rouault  <even.rouault@spatialys.com>
+
+	TIFFSetupStrips: enforce 2GB limitation of Strip/Tile Offsets/ByteCounts arrays
+	TIFFWriteDirectoryTagData() has an assertion that checks that the
+	arrays are not larger than 2GB. So error out earlier if in that situation.
+
+2020-01-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Simplify nmake configuration for building port directory.  Now there is only one boolean setting to enable building strtoll() and strtoull() port functions.  The boolean setting enables the necessary port files to be built, but the remainder of the logic is via pre-processor code in the common tif_config.h, which was prepared before entering the port directory to do a build.
+
+2020-01-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Make sure that tif_config.h is produced prior to entering the port directory and add an include path so that the port files can include tif_config.h.  Do not actually include tif_config.h at this time since CMake and Autotools builds are not prepared for that.  This issue could be handled by updating the CMake and Autotools builds or by adding a define which directs libport.h to include tif_config.h.
+
+2020-01-26  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Fix nmake build mistakes in my last commit:
+	tif_config.vc.h:
+
+	  Always define HAVE_STRTOL/HAVE_STRTOUL.
+	  Define HAVE_STRTOLL/HAVE_STRTOULL if _MSC_VER >= 1900.
+
+	nmake.opt:
+
+	  Provide defaults suitable for MSVC prior to 14.0.
+
+	libport.h:
+
+	  The sense of the pre-processor logic was inverted from what it
+	  should be.  The intention is to only provide the prototype if the
+	  function is missing.
+
+2020-01-25  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
+
+	Add nmake build support for manually configuring the 'port' files to be built based on MSVC features. Include tif_config.h in tools/tiffset.c.
+
+2020-01-23  Even Rouault  <even.rouault@spatialys.com>
+
+	Adjust previous fix to avoid undue warning in some situations triggered by GDAL
+
+2020-01-12  Even Rouault  <even.rouault@spatialys.com>
+
+	_TIFFPartialReadStripArray: bring back support for non-conformant SLONG8 data type
+	Such as in https://github.com/OSGeo/gdal/issues/2165
+
+2020-01-07  Even Rouault  <even.rouault@spatialys.com>
+
+	test: add test for single-strip OJPEG file without RowsPerStrip tag (like in CR2 files)
+
+	OJPEGReadHeaderInfo: if rowsperstrip not defined, then assume one-single-strip. Complementary fix to 0356ea76bac908c61160d735f078437ace953bd3
+
+2019-12-16  Angel Sánchez  <angelsanchez@inedit.com>
+
+	fix issue #78 warnings regarding RichTIFFIPTC data type.
+
+2019-12-14  Even Rouault  <even.rouault@spatialys.com>
+
+	contrib/oss-fuzz/build.sh: fix broken if construct.
+
+2019-11-28  Even Rouault  <even.rouault@spatialys.com>
+
+	contrib/oss-fuzz/build.sh: other attempt at fixing build failure.
+
+2019-11-20  Even Rouault  <even.rouault@spatialys.com>
+
+	contrib/oss-fuzz/build.sh: install liblzma-dev for x86_64 builds.
+
+2019-11-17  Even Rouault  <even.rouault@spatialys.com>
+
+	contrib/oss-fuzz/build.sh: install liblzma-dev:i386 on i386 builds.
+
+2019-11-15  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'cmake-parse' into 'master'
+	CMake: simplify parsing variables from configure
+
+	See merge request libtiff/libtiff!98
+
+2019-11-15  Rolf Eike Beer  <eb@emlix.com>
+
+	CMake: simplify parsing variables from configure.
+
+2019-11-14  Even Rouault  <even.rouault@spatialys.com>
+
+	contrib/oss-fuzz/build.sh: fix ossfuzz build by statically linking to lzma
+
+2019-11-12  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'fix_ojpeg_172' into 'master'
+	OJPEG: fix broken sanity check added in 4.1.0 (#fixes 172)
+
+	See merge request libtiff/libtiff!97
+
+2019-11-11  Even Rouault  <even.rouault@spatialys.com>
+
+	OJPEG: fix broken sanity check added in 4.1.0, and add two OJPEG test files
+
+	test/: add missing generated .sh files.
+
+2019-11-04  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'fix-missing-checks-TIFFGetField-tiffcrop' into 'master'
+	adds missing checks on TIFFGetField in tiffcrop tool
+
+	Closes #170
+
+	See merge request libtiff/libtiff!96
+
+2019-11-04  Bug Checkers  <coolbugcheckers@gmail.com>
+
+	adds missing checks on TIFFGetField in tiffcrop tool (fixes #170)
+
+2019-11-04  Even Rouault  <even.rouault@spatialys.com>
+
+	Merge branch 'adds-missing-TIFFClose-rgb2ycbcr' into 'master'
+	adds a missing TIFFClose in rgb2ycbcr tool
+
+	See merge request libtiff/libtiff!95
+
+2019-11-04  Mansour Ahmadi  <mansourweb@gmail.com>
+
+	adds a missing TIFFClose in rgb2ycbcr tool.
+
 2019-11-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
 
 	libtiff 4.1.0 released.
@@ -81,7 +2419,7 @@
 
 2019-08-25  Even Rouault  <even.rouault@spatialys.com>
 
-	JPEG: avoid use of unintialized memory on corrupted files.
+	JPEG: avoid use of uninitialized memory on corrupted files.
 	Follow-up of cf3ce6fab894414a336546f62adc57f02590a22c
 	Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16602
 	Credit to OSS Fuzz
@@ -145,7 +2483,7 @@
 	signed), which was especially easily triggered on 32-bit builds (with recent
 	enough compilers that assume that signed multiplication cannot overflow, since
 	this is undefined behaviour by the C standard). The original issue which lead to
-	this fix was trigged from tif_fax3.c
+	this fix was triggered from tif_fax3.c
 
 	There were also unsafe (implementation defied), and broken in practice on 64bit
 	builds, ways of checking that a uint64 fits of a (signed) tmsize_t by doing
@@ -218,7 +2556,7 @@
 		- Discussion in https://gitlab.com/libtiff/libtiff/merge_requests/39
 		- http://bugzilla.maptools.org/show_bug.cgi?id=2540
 
-	Comments and indention adapted.
+	Comments and indentation adapted.
 
 	Preparation to rebase onto master
 
@@ -238,7 +2576,7 @@
 	[00:02:58] -- CMAKE_HOST_SYSTEM_PROCESSOR set to AMD64
 	[00:02:58] -- HOST_FILLORDER set to FILLORDER_MSB2LSB
 
-	Ther reason is that we match the "amd64.*" lowercase string whereas
+	The reason is that we match the "amd64.*" lowercase string whereas
 	CMAKE_HOST_SYSTEM_PROCESSOR is set to AMD64 uppercase.
 
 2019-07-09  Even Rouault  <even.rouault@spatialys.com>
@@ -248,13 +2586,13 @@
 2019-07-09  Even Rouault  <even.rouault@spatialys.com>
 
 	Merge branch 'fix_chromium_925269' into 'master'
-	OJPEG: avoid use of unintialized memory on corrupted files
+	OJPEG: avoid use of uninitialized memory on corrupted files
 
 	See merge request libtiff/libtiff!86
 
 2019-07-05  Even Rouault  <even.rouault@spatialys.com>
 
-	OJPEG: avoid use of unintialized memory on corrupted files.
+	OJPEG: avoid use of uninitialized memory on corrupted files.
 	Fixes https://bugs.chromium.org/p/chromium/issues/detail?id=925269
 	Patch from Lei Zhang with little adaptations.
 
@@ -407,12 +2745,12 @@
 	arrays are only loaded when first accessed. This can speed-up the opening
 	of files stored on the network when just metadata retrieval is needed.
 	This mode has been used for years by the GDAL library when compiled with
-	its embeded libtiff copy.
+	its embedded libtiff copy.
 
 	To avoid potential out-of-tree code (typically codecs) that would use
 	the td_stripbytecount and td_stripoffset array inconditionnaly assuming they
 	have been loaded, those have been suffixed with _p (for protected). The
-	use of the new functions mentionned below is then recommended.
+	use of the new functions mentioned below is then recommended.
 
 	Another addition of this commit is the capability of loading only the
 	values of the offset/bytecount of the strile of interest instead of the
@@ -428,7 +2766,7 @@
 	if a strile is present or not without decompressing the data, or updating
 	an existing sparse file.
 	They will also be used to enable a future enhancement where client code can entirely
-	skip bytecount loading in some situtations
+	skip bytecount loading in some situations
 
 	A new test/defer_strile_loading.c test has been added to test the above
 	capabilities.
@@ -699,8 +3037,8 @@
 	Also the values were not properly calculated. It should be
 	255-x, 15-x, 3-x for bps 8, 4, 2.
 
-	But anyway it is easyer to invert all bits as 255-x = ~x, etc.
-	(substracting from a binary number composed of all 1 is like inverting
+	But anyway it is easier to invert all bits as 255-x = ~x, etc.
+	(subtracting from a binary number composed of all 1 is like inverting
 	the bits)
 
 2019-02-11  Thomas Bernard  <miniupnp@free.fr>
@@ -1228,7 +3566,7 @@
 
 	Merge branch 'zstd'
 
-	Add warning about COMPRESSION_ZSTD not being officialy registered.
+	Add warning about COMPRESSION_ZSTD not being officially registered.
 
 2018-02-14  Even Rouault  <even.rouault@mines-paris.org>
 
@@ -1458,7 +3796,7 @@
 	result, we end up writing past the end of the buffer.
 
 	There are also some related issues that this also fixes. For example,
-	TIFFGetField can return uninitalized pointer values, and the logic to
+	TIFFGetField can return uninitialized pointer values, and the logic to
 	detect a N=3 vs N=1 transfer function seemed rather strange.
 
 	It is also strange that we declare the transfer functions to be of type
@@ -1873,7 +4211,7 @@
 	scans and not interleavedin a single one, needs to allocate memory (or
 	backing store) for the whole strip/tile.
 	See http://www.libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf
-	This limitation may be overriden by setting the 
+	This limitation may be overridden by setting the
 	LIBTIFF_ALLOW_LARGE_LIBJPEG_MEM_ALLOC environment variable, or recompiling
 	libtiff with a custom value of TIFF_LIBJPEG_LARGEST_MEM_ALLOC macro.
 
@@ -2156,7 +4494,7 @@
 
 	* libtiff/tif_jpeg.c: only run JPEGFixupTagsSubsampling() if the
 	YCbCrSubsampling tag is not explicitly present. This helps a bit to reduce
-	the I/O amount when te tag is present (especially on cloud hosted files).
+	the I/O amount when the tag is present (especially on cloud hosted files).
 
 2017-01-14 Even Rouault <even.rouault at spatialys.com>
 
@@ -2397,7 +4735,7 @@
 2016-12-03 Even Rouault <even.rouault at spatialys.com>
 
 	* libtiff/tif_dirread.c: modify ChopUpSingleUncompressedStrip() to
-	instanciate compute ntrips as TIFFhowmany_32(td->td_imagelength, rowsperstrip),
+	instantiate compute ntrips as TIFFhowmany_32(td->td_imagelength, rowsperstrip),
 	instead of a logic based on the total size of data. Which is faulty is
 	the total size of data is not sufficient to fill the whole image, and thus
 	results in reading outside of the StripByCounts/StripOffsets arrays when
@@ -2421,7 +4759,7 @@
 
 2016-12-02 Even Rouault <even.rouault at spatialys.com>
 
-	* tools/tiffcp.c: avoid uint32 underflow in cpDecodedStrips that 
+	* tools/tiffcp.c: avoid uint32 underflow in cpDecodedStrips that
 	can cause various issues, such as buffer overflows in the library.
 	Reported by Agostino Sarubbo.
 	Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2598
@@ -2863,7 +5201,7 @@
 	* libtiff/tif_write.c: TIFFWriteEncodedStrip() and TIFFWriteEncodedTile()
 	should return -1 in case of failure of tif_encodestrip() as documented
 	* libtiff/tif_dumpmode.c: DumpModeEncode() should return 0 in case of
-	failure so that the above mentionned functions detect the error.
+	failure so that the above mentioned functions detect the error.
 
 2015-12-06  Even Rouault <even.rouault at spatialys.com>
 
@@ -2886,7 +5224,7 @@
 2015-11-22  Even Rouault <even.rouault at spatialys.com>
 
 	* libtiff/*.c: fix typos in comments (patch by Kurt Schwehr)
- 
+
 2015-11-22  Even Rouault <even.rouault at spatialys.com>
 
 	* libtiff/*.c: fix MSVC warnings related to cast shortening and
@@ -3454,7 +5792,7 @@
 2014-12-27  Even Rouault  <even.rouault@spatialys.com>
 
 	* libtiff/tif_dir.c: in TIFFDefaultDirectory(), reset any already existing
-	extented tags installed by user code through the extender mechaninm before
+	extended tags installed by user code through the extender mechanism before
 	calling the extender callback (GDAL #5054)
 
 2014-12-26  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
@@ -3557,14 +5895,14 @@
 	cpStripToTile() (called from writeBufferToContigTiles).
 	Note that the resulting TIFF file would be scrambled even
 	if tiffcp wouldn't crash, since the output file would contain
-	RGB data intepreted as subsampled YCbCr values.
+	RGB data interpreted as subsampled YCbCr values.
 	This patch fixes the problem by forcing RGB space on the output
 	TIF if the input is JPEG-encoded and output is *not* JPEG-encoded.
 	Author: Tomasz Buchert <tomasz.buchert@inria.fr>
 
 2014-12-21  Even Rouault  <even.rouault@spatialys.com>
 
-	Fix various crasher bugs on fuzzed images.
+	Fix various crash bugs on fuzzed images.
 	* libtiff/tif_dir.c: TIFFSetField(): refuse to set negative values for
 	TIFFTAG_XRESOLUTION and TIFFTAG_YRESOLUTION that cause asserts when writing
 	the directory
@@ -3901,7 +6239,7 @@
 
 	*  libtiff 4.0.2 released.
 
-	* tools/tif2pdf.c, tools/tifdump.c: avoid unitialized variable
+	* tools/tif2pdf.c, tools/tifdump.c: avoid uninitialized variable
 	warnings with clang.
 
 2012-06-15  Tom Lane  <tgl@sss.pgh.pa.us>
@@ -5548,7 +7886,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 	Added support for a TIFF_PTRDIFF_T type to use when doing pointer arithmetic.
 	Added support for a TIFF_SSIZE_T in order to return memory sizes but still
 	allow returning -1 for errors.
-	* libtiff/tiffconf.vc.h: Add porting type defintions for WIN32.
+	* libtiff/tiffconf.vc.h: Add porting type definitions for WIN32.
 
 2007-06-25  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>
 
@@ -5683,7 +8021,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 	* libtiff/tif_config.wince.h: Added configuration header for WinCE.
 	* libtiff/tiffconf.wince.h: Ported old configuration header for WinCE.
 	* libtiff/tif_wince.c: Added WinCE-specific implementation of some
-	functons from tif_win32.c.
+	functions from tif_win32.c.
 	* libtiff/tif_win32.c: Disabled some functions already reimplemented in tif_wince.c.
 	* libtiff/tiffiop.h, port/lfind.c: Added conditional include of some
 	standard header files for Windows CE build.
@@ -5927,7 +8265,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 
 	* libtiff/tif_jpeg.c: strip size related bugfix in encode raw
 
-	* libtiff/tif_strip.c: temporarilly added two new versions of
+	* libtiff/tif_strip.c: temporarily added two new versions of
 	TIFFScanlineSize
 	  - TIFFNewScanlineSize: proposed new version, after all related
 	    issues and side-effects are sorted out
@@ -5987,7 +8325,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 
 2006-03-16  Andrey Kiselev  <dron@ak4719.spb.edu>
 
-	* libtiff/tiffiop.h: Added decalration for
+	* libtiff/tiffiop.h: Added declaration for
 	_TIFFSetDefaultCompressionState().
 
 	* libtiff/{tif_jpeg.c, tif_fax3.c, tif_zip.c, tif_pixarlog.c,
@@ -6317,7 +8655,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 
 	http://bugzilla.remotesensing.org/show_bug.cgi?id=1003
 
-	* libtiff/tif_dirinfo.c: Correctly yse bsearch() and lfind()
+	* libtiff/tif_dirinfo.c: Correctly use bsearch() and lfind()
 	functions as per bug
 
 	http://bugzilla.remotesensing.org/show_bug.cgi?id=1008
@@ -6362,7 +8700,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 
 	http://bugzilla.remotesensing.org/show_bug.cgi?id=977
 
-	* tools/tiffsplit.c: Copy fax related fields over splitted parts
+	* tools/tiffsplit.c: Copy fax related fields over split parts
 	as per bug
 
 	http://bugzilla.remotesensing.org/show_bug.cgi?id=983
@@ -6544,12 +8882,12 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 2005-06-07  Andrey Kiselev  <dron@ak4719.spb.edu>
 
 	* contrib/addtiffo/tif_ovrcache.c: Properly extract tile/strip size;
-	use pixel sized shift in contigous case.
+	use pixel sized shift in contiguous case.
 
 2005-06-06  Andrey Kiselev  <dron@ak4719.spb.edu>
 
 	* contrib/addtiffo/{tif_overview.c, tif_ovrcache.c, tif_ovrcache.h}:
-	Make overviews working for contiguos images.
+	Make overviews working for contiguous images.
 
 2005-06-03  Andrey Kiselev  <dron@ak4719.spb.edu>
 
@@ -6979,7 +9317,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 
 	http://bugzilla.remotesensing.org/show_bug.cgi?id=697
 
-	* libtiff/tif_config.in.vc: Removed unneded definitions for
+	* libtiff/tif_config.in.vc: Removed unneeded definitions for
 	read/open/close/lseek functions to fix the
 
 	http://bugzilla.remotesensing.org/show_bug.cgi?id=680
@@ -7838,7 +10176,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 	* man/tiff2pdf.1: Few improvements in page layout.
 
 	* Makefile.in, /man/Makefile.in, /html/man/tiff2pdf.1.html:
-	 Added support fpr tiff2pdf manual page.
+	 Added support for tiff2pdf manual page.
 
 2003-11-26 Ross Finlayson  <libtiff@apexinternetsoftware.com>
 
@@ -7847,7 +10185,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 2003-11-26  Andrey Kiselev  <dron@ak4719.spb.edu>
 
 	* Makefile.in, /tools/{Makefile.in, makefile.vc}:
-	 Added support fpr tiff2pdf utility.
+	 Added support for tiff2pdf utility.
 
 2003-11-25  Ross Finlayson  <libtiff@apexinternetsoftware.com>
 
@@ -7890,7 +10228,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 2003-11-17  Andrey Kiselev  <dron@ak4719.spb.edu>
 
 	* contrib/pds/{tif_pdsdirread.c, tif_pdsdirwrite.c}: Use
-	TIFFDataWidth() function insted of tiffDataWidth array.
+	TIFFDataWidth() function instead of tiffDataWidth array.
 
 2003-11-16  Andrey Kiselev  <dron@ak4719.spb.edu>
 
@@ -8677,7 +11015,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 	TIFFDataType sizes instead of working with tiffDataWidth array
 	directly. Should prevent out-of-borders bugs in case of unknown or
 	broken data types.  EstimateStripByteCounts routine modified, so it
-	won't work when tags with uknown sizes founded.
+	won't work when tags with unknown sizes founded.
 	Closes http://bugzilla.remotesensing.org/show_bug.cgi?id=109
 
 2002-03-13  Andrey Kiselev  <dron@ak4719.spb.edu>
@@ -8879,7 +11217,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 
 	* libtiff/tif_getimage.c: relax handling of contig case where
 	there are extra samples that are supposed to be ignored.  This
-	should now work for 8bit greyscale or palletted images.
+	should now work for 8bit greyscale or paletted images.
 
 	http://bugzilla.remotesensing.org/show_bug.cgi?id=75
 
@@ -9109,7 +11447,7 @@ btiff/tif_win32.c: Replace custom Win32 memory api with generic
 2001-02-16  Frank Warmerdam  <warmerdam@pobox.com>
 
 	* libtiff/libtiff.def: Brent Roman submitted new version adding
-	serveral missing entry points.
+	several missing entry points.
 
 	* libtiff/tif_dirinfo.c: don't declare tiffFieldInfo static on VMS.
 	Some sort of weird VMS thing.
@@ -9519,7 +11857,7 @@ Tue Nov 30 14:41:43 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>    *** 3.5
 
 Tue Nov 30 14:15:32 EST 1999   Mike Welles <mike@onshore.com>
 
-        * Added zip creation to relase makefile target
+        * Added zip creation to release makefile target
 
 	* Added html for TIFFWriteTile.3t man page.
 
diff --git a/src/3rdparty/libtiff/README b/src/3rdparty/libtiff/README
deleted file mode 100644
index 5f30f4e..0000000
--- a/src/3rdparty/libtiff/README
+++ /dev/null
@@ -1,61 +0,0 @@
-$Header: /cvs/maptools/cvsroot/libtiff/README,v 1.7 2012-02-18 21:53:27 bfriesen Exp $
-
-
-TIFF Software Distribution
---------------------------
-This file is just a placeholder; all the documentation is now in
-HTML in the html directory.  To view the documentation point your
-favorite WWW viewer at html/index.html; 
-
-e.g.
-
-    firefox html/index.html
-
-If you don't have an HTML viewer then you can read the HTML source
-or fetch a PostScript version of this documentation from the directory
-
-    ftp://ftp.remotesensing.org/pub/libtiff/
-
-If you can't hack either of these options then basically what you
-want to do is:
-
-    % ./configure
-    % make
-    % su
-    # make install
-
-More information, email contacts, and mailing list information can be 
-found online at http://www.remotesensing.org/libtiff/.
-
-
-Use and Copyright
------------------
-Silicon Graphics has seen fit to allow us to give this work away.  It
-is free.  There is no support or guarantee of any sort as to its
-operations, correctness, or whatever.  If you do anything useful with
-all or parts of it you need to honor the copyright notices.   I would
-also be interested in knowing about it and, hopefully, be acknowledged.
-
-The legal way of saying that is:
-
-Copyright (c) 1988-1997 Sam Leffler
-Copyright (c) 1991-1997 Silicon Graphics, Inc.
-
-Permission to use, copy, modify, distribute, and sell this software and 
-its documentation for any purpose is hereby granted without fee, provided
-that (i) the above copyright notices and this permission notice appear in
-all copies of the software and related documentation, and (ii) the names of
-Sam Leffler and Silicon Graphics may not be used in any advertising or
-publicity relating to the software without the specific, prior written
-permission of Sam Leffler and Silicon Graphics.
-
-THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
-EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
-WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
-
-IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
-ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
-OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
-LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
-OF THIS SOFTWARE.
diff --git a/src/3rdparty/libtiff/README.vms b/src/3rdparty/libtiff/README.vms
deleted file mode 100644
index 44d9663..0000000
--- a/src/3rdparty/libtiff/README.vms
+++ /dev/null
@@ -1,12 +0,0 @@
-Dear OpenVMS user
-to make this library, execute
-$@CONFIGURE
-$@BUILD
-
-Build process should be error and warning free. When process will be finished,
-LIBTIFF$STRATUP.COM file containing all required definitions, will be  created.
-Please call it from system startup procedure or individual user procedure LOGIN.COM
-To link software with libtiff, use TIFF:LIBTIFF.OPT
-
-best regards,
-Alexey Chupahin,   elvis_75@mail.ru
diff --git a/src/3rdparty/libtiff/RELEASE-DATE b/src/3rdparty/libtiff/RELEASE-DATE
index ad4fa62..e74bf2b 100644
--- a/src/3rdparty/libtiff/RELEASE-DATE
+++ b/src/3rdparty/libtiff/RELEASE-DATE
@@ -1 +1 @@
-20191103
+20210416
diff --git a/src/3rdparty/libtiff/VERSION b/src/3rdparty/libtiff/VERSION
index ee74734..8089590 100644
--- a/src/3rdparty/libtiff/VERSION
+++ b/src/3rdparty/libtiff/VERSION
@@ -1 +1 @@
-4.1.0
+4.3.0
diff --git a/src/3rdparty/libtiff/libtiff/SConstruct b/src/3rdparty/libtiff/libtiff/SConstruct
deleted file mode 100644
index af3daac..0000000
--- a/src/3rdparty/libtiff/libtiff/SConstruct
+++ /dev/null
@@ -1,71 +0,0 @@
-# Tag Image File Format (TIFF) Software
-#
-# Copyright (C) 2005, Andrey Kiselev <dron@ak4719.spb.edu>
-#
-# Permission to use, copy, modify, distribute, and sell this software and 
-# its documentation for any purpose is hereby granted without fee, provided
-# that (i) the above copyright notices and this permission notice appear in
-# all copies of the software and related documentation, and (ii) the names of
-# Sam Leffler and Silicon Graphics may not be used in any advertising or
-# publicity relating to the software without the specific, prior written
-# permission of Sam Leffler and Silicon Graphics.
-# 
-# THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
-# EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
-# WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
-# 
-# IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
-# ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
-# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-# WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
-# LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
-# OF THIS SOFTWARE.
-
-# This file contains rules to build software with the SCons tool
-# (see the http://www.scons.org/ for details on SCons).
-
-# Import globally defined options
-Import([ 'env', 'idir_lib' ])
-
-SRCS = [ \
-	'tif_aux.c', \
-	'tif_close.c', \
-	'tif_codec.c', \
-	'tif_color.c', \
-	'tif_compress.c', \
-	'tif_dir.c', \
-	'tif_dirinfo.c', \
-	'tif_dirread.c', \
-	'tif_dirwrite.c', \
-	'tif_dumpmode.c', \
-	'tif_error.c', \
-	'tif_extension.c', \
-	'tif_fax3.c', \
-	'tif_fax3sm.c', \
-	'tif_flush.c', \
-	'tif_getimage.c', \
-	'tif_jbig.c', \
-	'tif_jpeg.c', \
-	'tif_luv.c', \
-	'tif_lzw.c', \
-	'tif_next.c', \
-	'tif_ojpeg.c', \
-	'tif_open.c', \
-	'tif_packbits.c', \
-	'tif_pixarlog.c', \
-	'tif_predict.c', \
-	'tif_print.c', \
-	'tif_read.c', \
-	'tif_strip.c', \
-	'tif_swab.c', \
-	'tif_thunder.c', \
-	'tif_tile.c', \
-	'tif_unix.c', \
-	'tif_version.c', \
-	'tif_warning.c', \
-	'tif_write.c', \
-	'tif_zip.c' ]
-
-StaticLibrary('tiff', SRCS)
-SharedLibrary('tiff', SRCS)
-
diff --git a/src/3rdparty/libtiff/libtiff/libtiff.def b/src/3rdparty/libtiff/libtiff/libtiff.def
index e34fac5..b2d03fe 100644
--- a/src/3rdparty/libtiff/libtiff/libtiff.def
+++ b/src/3rdparty/libtiff/libtiff/libtiff.def
@@ -12,6 +12,7 @@ EXPORTS	TIFFAccessTagMethods
 	TIFFCreateCustomDirectory
 	TIFFCreateDirectory
 	TIFFCreateEXIFDirectory
+	TIFFCreateGPSDirectory
 	TIFFCurrentDirOffset
 	TIFFCurrentDirectory
 	TIFFCurrentRow
@@ -86,6 +87,7 @@ EXPORTS	TIFFAccessTagMethods
 	TIFFReadCustomDirectory
 	TIFFReadDirectory
 	TIFFReadEXIFDirectory
+	TIFFReadGPSDirectory
 	TIFFReadEncodedStrip
 	TIFFReadEncodedTile
 	TIFFReadFromUserBuffer
@@ -171,5 +173,7 @@ EXPORTS	TIFFAccessTagMethods
 	_TIFFmemcpy
 	_TIFFmemset
 	_TIFFrealloc
-        _TIFFMultiply32
-        _TIFFMultiply64
+	_TIFFMultiply32
+	_TIFFMultiply64
+	_TIFFGetExifFields
+	_TIFFGetGpsFields
diff --git a/src/3rdparty/libtiff/libtiff/mkg3states.c b/src/3rdparty/libtiff/libtiff/mkg3states.c
index 2cb9174..4465325 100644
--- a/src/3rdparty/libtiff/libtiff/mkg3states.c
+++ b/src/3rdparty/libtiff/libtiff/mkg3states.c
@@ -28,6 +28,7 @@
  *      Copyright (C) 1990, 1995  Frank D. Cringle.
  */
 #include "tif_config.h"
+#include "libport.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -39,10 +40,6 @@
 
 #include "tif_fax3.h"
 
-#ifndef HAVE_GETOPT
-extern int getopt(int argc, char * const argv[], const char *optstring);
-#endif
-
 #define	streq(a,b)	(strcmp(a,b) == 0)
 
 /* NB: can't use names in tif_fax3.h 'cuz they are declared const */
@@ -51,8 +48,8 @@ TIFFFaxTabEnt WhiteTable[4096];
 TIFFFaxTabEnt BlackTable[8192];
 
 struct proto {
-    uint16 code;		/* right justified, lsb-first, zero filled */
-    uint16 val;		/* (pixel count)<<4 + code width  */
+    uint16_t code;		/* right justified, lsb-first, zero filled */
+    uint16_t val;		/* (pixel count)<<4 + code width  */
 };
 
 static struct proto Pass[] = {
@@ -433,11 +430,19 @@ main(int argc, char* argv[])
 
     fprintf(fd, "/* WARNING, this file was automatically generated by the\n");
     fprintf(fd, "    mkg3states program */\n");
+    fprintf(fd, "#include <stdint.h>\n");
     fprintf(fd, "#include \"tiff.h\"\n");
     fprintf(fd, "#include \"tif_fax3.h\"\n");
     WriteTable(fd, MainTable, 128, "TIFFFaxMainTable");
     WriteTable(fd, WhiteTable, 4096, "TIFFFaxWhiteTable");
     WriteTable(fd, BlackTable, 8192, "TIFFFaxBlackTable");
+    fprintf(fd, "/*\n"
+                " * Local Variables:\n"
+                " * mode: c\n"
+                " * c-basic-offset: 8\n"
+                " * fill-column: 78\n"
+                " * End:\n"
+                " */\n");
     fclose(fd);
     return (0);
 }
diff --git a/src/3rdparty/libtiff/libtiff/tif_aux.c b/src/3rdparty/libtiff/libtiff/tif_aux.c
index 8188db5..140f26c 100644
--- a/src/3rdparty/libtiff/libtiff/tif_aux.c
+++ b/src/3rdparty/libtiff/libtiff/tif_aux.c
@@ -32,10 +32,10 @@
 #include <math.h>
 #include <float.h>
 
-uint32
-_TIFFMultiply32(TIFF* tif, uint32 first, uint32 second, const char* where)
+uint32_t
+_TIFFMultiply32(TIFF* tif, uint32_t first, uint32_t second, const char* where)
 {
-	if (second && first > TIFF_UINT32_MAX / second) {
+	if (second && first > UINT32_MAX / second) {
 		TIFFErrorExt(tif->tif_clientdata, where, "Integer overflow in %s", where);
 		return 0;
 	}
@@ -43,10 +43,10 @@ _TIFFMultiply32(TIFF* tif, uint32 first, uint32 second, const char* where)
 	return first * second;
 }
 
-uint64
-_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)
+uint64_t
+_TIFFMultiply64(TIFF* tif, uint64_t first, uint64_t second, const char* where)
 {
-	if (second && first > TIFF_UINT64_MAX / second) {
+	if (second && first > UINT64_MAX / second) {
 		TIFFErrorExt(tif->tif_clientdata, where, "Integer overflow in %s", where);
 		return 0;
 	}
@@ -79,9 +79,9 @@ _TIFFMultiplySSize(TIFF* tif, tmsize_t first, tmsize_t second, const char* where
     return first * second;
 }
 
-tmsize_t _TIFFCastUInt64ToSSize(TIFF* tif, uint64 val, const char* module)
+tmsize_t _TIFFCastUInt64ToSSize(TIFF* tif, uint64_t val, const char* module)
 {
-    if( val > (uint64)TIFF_TMSIZE_T_MAX )
+    if( val > (uint64_t)TIFF_TMSIZE_T_MAX )
     {
         if( tif != NULL && module != NULL )
         {
@@ -109,8 +109,8 @@ _TIFFCheckRealloc(TIFF* tif, void* buffer,
 	if (cp == NULL) {
 		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
 			     "Failed to allocate memory for %s "
-			     "(%ld elements of %ld bytes each)",
-			     what,(long) nmemb, (long) elem_size);
+			     "(%"TIFF_SSIZE_FORMAT" elements of %"TIFF_SSIZE_FORMAT" bytes each)",
+			     what, nmemb, elem_size);
 	}
 
 	return cp;
@@ -125,7 +125,7 @@ _TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what
 static int
 TIFFDefaultTransferFunction(TIFFDirectory* td)
 {
-	uint16 **tf = td->td_transferfunction;
+	uint16_t **tf = td->td_transferfunction;
 	tmsize_t i, n, nbytes;
 
 	tf[0] = tf[1] = tf[2] = 0;
@@ -133,22 +133,22 @@ TIFFDefaultTransferFunction(TIFFDirectory* td)
 		return 0;
 
 	n = ((tmsize_t)1)<<td->td_bitspersample;
-	nbytes = n * sizeof (uint16);
-        tf[0] = (uint16 *)_TIFFmalloc(nbytes);
+	nbytes = n * sizeof (uint16_t);
+        tf[0] = (uint16_t *)_TIFFmalloc(nbytes);
 	if (tf[0] == NULL)
 		return 0;
 	tf[0][0] = 0;
 	for (i = 1; i < n; i++) {
 		double t = (double)i/((double) n-1.);
-		tf[0][i] = (uint16)floor(65535.*pow(t, 2.2) + .5);
+		tf[0][i] = (uint16_t)floor(65535. * pow(t, 2.2) + .5);
 	}
 
 	if (td->td_samplesperpixel - td->td_extrasamples > 1) {
-                tf[1] = (uint16 *)_TIFFmalloc(nbytes);
+                tf[1] = (uint16_t *)_TIFFmalloc(nbytes);
 		if(tf[1] == NULL)
 			goto bad;
 		_TIFFmemcpy(tf[1], tf[0], nbytes);
-                tf[2] = (uint16 *)_TIFFmalloc(nbytes);
+                tf[2] = (uint16_t *)_TIFFmalloc(nbytes);
 		if (tf[2] == NULL)
 			goto bad;
 		_TIFFmemcpy(tf[2], tf[0], nbytes);
@@ -205,7 +205,7 @@ TIFFDefaultRefBlackWhite(TIFFDirectory* td)
  *	place in the library -- in TIFFDefaultDirectory.
  */
 int
-TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)
+TIFFVGetFieldDefaulted(TIFF* tif, uint32_t tag, va_list ap)
 {
 	TIFFDirectory *td = &tif->tif_dir;
 
@@ -213,37 +213,37 @@ TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)
 		return (1);
 	switch (tag) {
 	case TIFFTAG_SUBFILETYPE:
-		*va_arg(ap, uint32 *) = td->td_subfiletype;
+		*va_arg(ap, uint32_t *) = td->td_subfiletype;
 		return (1);
 	case TIFFTAG_BITSPERSAMPLE:
-		*va_arg(ap, uint16 *) = td->td_bitspersample;
+		*va_arg(ap, uint16_t *) = td->td_bitspersample;
 		return (1);
 	case TIFFTAG_THRESHHOLDING:
-		*va_arg(ap, uint16 *) = td->td_threshholding;
+		*va_arg(ap, uint16_t *) = td->td_threshholding;
 		return (1);
 	case TIFFTAG_FILLORDER:
-		*va_arg(ap, uint16 *) = td->td_fillorder;
+		*va_arg(ap, uint16_t *) = td->td_fillorder;
 		return (1);
 	case TIFFTAG_ORIENTATION:
-		*va_arg(ap, uint16 *) = td->td_orientation;
+		*va_arg(ap, uint16_t *) = td->td_orientation;
 		return (1);
 	case TIFFTAG_SAMPLESPERPIXEL:
-		*va_arg(ap, uint16 *) = td->td_samplesperpixel;
+		*va_arg(ap, uint16_t *) = td->td_samplesperpixel;
 		return (1);
 	case TIFFTAG_ROWSPERSTRIP:
-		*va_arg(ap, uint32 *) = td->td_rowsperstrip;
+		*va_arg(ap, uint32_t *) = td->td_rowsperstrip;
 		return (1);
 	case TIFFTAG_MINSAMPLEVALUE:
-		*va_arg(ap, uint16 *) = td->td_minsamplevalue;
+		*va_arg(ap, uint16_t *) = td->td_minsamplevalue;
 		return (1);
 	case TIFFTAG_MAXSAMPLEVALUE:
-		*va_arg(ap, uint16 *) = td->td_maxsamplevalue;
+		*va_arg(ap, uint16_t *) = td->td_maxsamplevalue;
 		return (1);
 	case TIFFTAG_PLANARCONFIG:
-		*va_arg(ap, uint16 *) = td->td_planarconfig;
+		*va_arg(ap, uint16_t *) = td->td_planarconfig;
 		return (1);
 	case TIFFTAG_RESOLUTIONUNIT:
-		*va_arg(ap, uint16 *) = td->td_resolutionunit;
+		*va_arg(ap, uint16_t *) = td->td_resolutionunit;
 		return (1);
 	case TIFFTAG_PREDICTOR:
     {
@@ -252,67 +252,67 @@ TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)
         {
             TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                          "Cannot get \"Predictor\" tag as plugin is not configured");
-            *va_arg(ap, uint16*) = 0;
+            *va_arg(ap, uint16_t*) = 0;
             return 0;
         }
-        *va_arg(ap, uint16*) = (uint16) sp->predictor;
+        *va_arg(ap, uint16_t*) = (uint16_t) sp->predictor;
         return 1;
     }
 	case TIFFTAG_DOTRANGE:
-		*va_arg(ap, uint16 *) = 0;
-		*va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1;
+		*va_arg(ap, uint16_t *) = 0;
+		*va_arg(ap, uint16_t *) = (1 << td->td_bitspersample) - 1;
 		return (1);
 	case TIFFTAG_INKSET:
-		*va_arg(ap, uint16 *) = INKSET_CMYK;
+		*va_arg(ap, uint16_t *) = INKSET_CMYK;
 		return 1;
 	case TIFFTAG_NUMBEROFINKS:
-		*va_arg(ap, uint16 *) = 4;
+		*va_arg(ap, uint16_t *) = 4;
 		return (1);
 	case TIFFTAG_EXTRASAMPLES:
-		*va_arg(ap, uint16 *) = td->td_extrasamples;
-		*va_arg(ap, uint16 **) = td->td_sampleinfo;
+		*va_arg(ap, uint16_t *) = td->td_extrasamples;
+		*va_arg(ap, const uint16_t **) = td->td_sampleinfo;
 		return (1);
 	case TIFFTAG_MATTEING:
-		*va_arg(ap, uint16 *) =
+		*va_arg(ap, uint16_t *) =
 		    (td->td_extrasamples == 1 &&
 		     td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
 		return (1);
 	case TIFFTAG_TILEDEPTH:
-		*va_arg(ap, uint32 *) = td->td_tiledepth;
+		*va_arg(ap, uint32_t *) = td->td_tiledepth;
 		return (1);
 	case TIFFTAG_DATATYPE:
-		*va_arg(ap, uint16 *) = td->td_sampleformat-1;
+		*va_arg(ap, uint16_t *) = td->td_sampleformat - 1;
 		return (1);
 	case TIFFTAG_SAMPLEFORMAT:
-		*va_arg(ap, uint16 *) = td->td_sampleformat;
+		*va_arg(ap, uint16_t *) = td->td_sampleformat;
                 return(1);
 	case TIFFTAG_IMAGEDEPTH:
-		*va_arg(ap, uint32 *) = td->td_imagedepth;
+		*va_arg(ap, uint32_t *) = td->td_imagedepth;
 		return (1);
 	case TIFFTAG_YCBCRCOEFFICIENTS:
 		{
 			/* defaults are from CCIR Recommendation 601-1 */
-			static float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };
-			*va_arg(ap, float **) = ycbcrcoeffs;
+			static const float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };
+			*va_arg(ap, const float **) = ycbcrcoeffs;
 			return 1;
 		}
 	case TIFFTAG_YCBCRSUBSAMPLING:
-		*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0];
-		*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1];
+		*va_arg(ap, uint16_t *) = td->td_ycbcrsubsampling[0];
+		*va_arg(ap, uint16_t *) = td->td_ycbcrsubsampling[1];
 		return (1);
 	case TIFFTAG_YCBCRPOSITIONING:
-		*va_arg(ap, uint16 *) = td->td_ycbcrpositioning;
+		*va_arg(ap, uint16_t *) = td->td_ycbcrpositioning;
 		return (1);
 	case TIFFTAG_WHITEPOINT:
 		{
-			static float whitepoint[2];
-
 			/* TIFF 6.0 specification tells that it is no default
 			   value for the WhitePoint, but AdobePhotoshop TIFF
 			   Technical Note tells that it should be CIE D50. */
-			whitepoint[0] =	D50_X0 / (D50_X0 + D50_Y0 + D50_Z0);
-			whitepoint[1] =	D50_Y0 / (D50_X0 + D50_Y0 + D50_Z0);
-			*va_arg(ap, float **) = whitepoint;
+			static const float whitepoint[] = {
+						D50_X0 / (D50_X0 + D50_Y0 + D50_Z0),
+						D50_Y0 / (D50_X0 + D50_Y0 + D50_Z0)
+			};
+			*va_arg(ap, const float **) = whitepoint;
 			return 1;
 		}
 	case TIFFTAG_TRANSFERFUNCTION:
@@ -321,16 +321,16 @@ TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)
 			TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "No space for \"TransferFunction\" tag");
 			return (0);
 		}
-		*va_arg(ap, uint16 **) = td->td_transferfunction[0];
+		*va_arg(ap, const uint16_t **) = td->td_transferfunction[0];
 		if (td->td_samplesperpixel - td->td_extrasamples > 1) {
-			*va_arg(ap, uint16 **) = td->td_transferfunction[1];
-			*va_arg(ap, uint16 **) = td->td_transferfunction[2];
+			*va_arg(ap, const uint16_t **) = td->td_transferfunction[1];
+			*va_arg(ap, const uint16_t **) = td->td_transferfunction[2];
 		}
 		return (1);
 	case TIFFTAG_REFERENCEBLACKWHITE:
 		if (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td))
 			return (0);
-		*va_arg(ap, float **) = td->td_refblackwhite;
+		*va_arg(ap, const float **) = td->td_refblackwhite;
 		return (1);
 	}
 	return 0;
@@ -341,7 +341,7 @@ TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)
  * value if the tag is not present in the directory.
  */
 int
-TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)
+TIFFGetFieldDefaulted(TIFF* tif, uint32_t tag, ...)
 {
 	int ok;
 	va_list ap;
@@ -353,16 +353,16 @@ TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)
 }
 
 struct _Int64Parts {
-	int32 low, high;
+	int32_t low, high;
 };
 
 typedef union {
 	struct _Int64Parts part;
-	int64 value;
+	int64_t value;
 } _Int64;
 
 float
-_TIFFUInt64ToFloat(uint64 ui64)
+_TIFFUInt64ToFloat(uint64_t ui64)
 {
 	_Int64 i;
 
@@ -378,7 +378,7 @@ _TIFFUInt64ToFloat(uint64 ui64)
 }
 
 double
-_TIFFUInt64ToDouble(uint64 ui64)
+_TIFFUInt64ToDouble(uint64_t ui64)
 {
 	_Int64 i;
 
@@ -406,7 +406,7 @@ int _TIFFSeekOK(TIFF* tif, toff_t off)
 {
     /* Huge offsets, especially -1 / UINT64_MAX, can cause issues */
     /* See http://bugzilla.maptools.org/show_bug.cgi?id=2726 */
-    return off <= (~(uint64)0)/2 && TIFFSeekFile(tif,off,SEEK_SET)==off;
+    return off <= (~(uint64_t)0) / 2 && TIFFSeekFile(tif, off, SEEK_SET) == off;
 }
 
 /* vim: set ts=8 sts=8 sw=8 noet: */
diff --git a/src/3rdparty/libtiff/libtiff/tif_close.c b/src/3rdparty/libtiff/libtiff/tif_close.c
index e4228df..674518a 100644
--- a/src/3rdparty/libtiff/libtiff/tif_close.c
+++ b/src/3rdparty/libtiff/libtiff/tif_close.c
@@ -76,7 +76,7 @@ TIFFCleanup(TIFF* tif)
          * Clean up custom fields.
          */
 	if (tif->tif_fields && tif->tif_nfields > 0) {
-		uint32 i;
+		uint32_t i;
 
 		for (i = 0; i < tif->tif_nfields; i++) {
 			TIFFField *fld = tif->tif_fields[i];
@@ -91,7 +91,7 @@ TIFFCleanup(TIFF* tif)
 	}
 
         if (tif->tif_nfieldscompat > 0) {
-                uint32 i;
+                uint32_t i;
 
                 for (i = 0; i < tif->tif_nfieldscompat; i++) {
                         if (tif->tif_fieldscompat[i].allocated_size)
diff --git a/src/3rdparty/libtiff/libtiff/tif_codec.c b/src/3rdparty/libtiff/libtiff/tif_codec.c
index b6c04f0..931eb09 100644
--- a/src/3rdparty/libtiff/libtiff/tif_codec.c
+++ b/src/3rdparty/libtiff/libtiff/tif_codec.c
@@ -67,6 +67,9 @@ static int NotConfigured(TIFF*, int);
 #ifndef LOGLUV_SUPPORT
 #define TIFFInitSGILog NotConfigured
 #endif
+#ifndef LERC_SUPPORT
+#define TIFFInitLERC NotConfigured
+#endif
 #ifndef LZMA_SUPPORT
 #define TIFFInitLZMA NotConfigured
 #endif
@@ -80,11 +83,7 @@ static int NotConfigured(TIFF*, int);
 /*
  * Compression schemes statically built into the library.
  */
-#ifdef VMS
 const TIFFCodec _TIFFBuiltinCODECS[] = {
-#else
-TIFFCodec _TIFFBuiltinCODECS[] = {
-#endif
     { "None",		COMPRESSION_NONE,	TIFFInitDumpMode },
     { "LZW",		COMPRESSION_LZW,	TIFFInitLZW },
     { "PackBits",	COMPRESSION_PACKBITS,	TIFFInitPackBits },
@@ -105,6 +104,7 @@ TIFFCodec _TIFFBuiltinCODECS[] = {
     { "LZMA",		COMPRESSION_LZMA,	TIFFInitLZMA },
     { "ZSTD",		COMPRESSION_ZSTD,	TIFFInitZSTD },
     { "WEBP",		COMPRESSION_WEBP,	TIFFInitWebP },
+    { "LERC",		COMPRESSION_LERC,	TIFFInitLERC },
     { NULL,             0,                      NULL }
 };
 
@@ -114,7 +114,7 @@ _notConfigured(TIFF* tif)
 	const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);
         char compression_code[20];
         
-        sprintf(compression_code, "%d",tif->tif_dir.td_compression );
+        sprintf(compression_code, "%"PRIu16, tif->tif_dir.td_compression );
 	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                      "%s compression support is not configured", 
                      c ? c->name : compression_code );
@@ -146,7 +146,7 @@ NotConfigured(TIFF* tif, int scheme)
  */
 
 int
-TIFFIsCODECConfigured(uint16 scheme)
+TIFFIsCODECConfigured(uint16_t scheme)
 {
 	const TIFFCodec* codec = TIFFFindCODEC(scheme);
 
diff --git a/src/3rdparty/libtiff/libtiff/tif_color.c b/src/3rdparty/libtiff/libtiff/tif_color.c
index 8fae40e..2b962af 100644
--- a/src/3rdparty/libtiff/libtiff/tif_color.c
+++ b/src/3rdparty/libtiff/libtiff/tif_color.c
@@ -41,8 +41,8 @@
  * Convert color value from the CIE L*a*b* 1976 space to CIE XYZ.
  */
 void
-TIFFCIELabToXYZ(TIFFCIELabToRGB *cielab, uint32 l, int32 a, int32 b,
-		float *X, float *Y, float *Z)
+TIFFCIELabToXYZ(TIFFCIELabToRGB *cielab, uint32_t l, int32_t a, int32_t b,
+                float *X, float *Y, float *Z)
 {
 	float L = (float)l * 100.0F / 255.0F;
 	float cby, tmp;
@@ -68,13 +68,13 @@ TIFFCIELabToXYZ(TIFFCIELabToRGB *cielab, uint32 l, int32 a, int32 b,
 		*Z = cielab->Z0 * tmp * tmp * tmp;
 }
 
-#define RINT(R) ((uint32)((R)>0?((R)+0.5):((R)-0.5)))
+#define RINT(R) ((uint32_t)((R)>0?((R)+0.5):((R)-0.5)))
 /*
  * Convert color value from the XYZ space to RGB.
  */
 void
 TIFFXYZToRGB(TIFFCIELabToRGB *cielab, float X, float Y, float Z,
-	     uint32 *r, uint32 *g, uint32 *b)
+             uint32_t *r, uint32_t *g, uint32_t *b)
 {
 	int i;
 	float Yr, Yg, Yb;
@@ -171,17 +171,17 @@ TIFFCIELabToRGBInit(TIFFCIELabToRGB* cielab,
  * see below for more information on how it works.
  */
 #define	SHIFT			16
-#define	FIX(x)			((int32)((x) * (1L<<SHIFT) + 0.5))
-#define	ONE_HALF		((int32)(1<<(SHIFT-1)))
-#define	Code2V(c, RB, RW, CR)	((((c)-(int32)(RB))*(float)(CR))/(float)(((RW)-(RB)!=0) ? ((RW)-(RB)) : 1))
+#define	FIX(x)			((int32_t)((x) * (1L<<SHIFT) + 0.5))
+#define	ONE_HALF		((int32_t)(1<<(SHIFT-1)))
+#define	Code2V(c, RB, RW, CR)	((((c)-(int32_t)(RB))*(float)(CR))/(float)(((RW)-(RB)!=0) ? ((RW)-(RB)) : 1))
 #define	CLAMP(f,min,max)	((f)<(min)?(min):(f)>(max)?(max):(f))
 #define HICLAMP(f,max)		((f)>(max)?(max):(f))
 
 void
-TIFFYCbCrtoRGB(TIFFYCbCrToRGB *ycbcr, uint32 Y, int32 Cb, int32 Cr,
-	       uint32 *r, uint32 *g, uint32 *b)
+TIFFYCbCrtoRGB(TIFFYCbCrToRGB *ycbcr, uint32_t Y, int32_t Cb, int32_t Cr,
+               uint32_t *r, uint32_t *g, uint32_t *b)
 {
-	int32 i;
+	int32_t i;
 
 	/* XXX: Only 8-bit YCbCr input supported for now */
 	Y = HICLAMP(Y, 255);
@@ -241,7 +241,7 @@ TIFFYCbCrToRGBInit(TIFFYCbCrToRGB* ycbcr, float *luma, float *refBlackWhite)
 #define LumaBlue    luma[2]
 
     clamptab = (TIFFRGBValue*)(
-	(uint8*) ycbcr+TIFFroundup_32(sizeof (TIFFYCbCrToRGB), sizeof (long)));  
+            (uint8_t*) ycbcr + TIFFroundup_32(sizeof (TIFFYCbCrToRGB), sizeof (long)));
     _TIFFmemset(clamptab, 0, 256);		/* v < 0 => 0 */
     ycbcr->clamptab = (clamptab += 256);
     for (i = 0; i < 256; i++)
@@ -249,14 +249,14 @@ TIFFYCbCrToRGBInit(TIFFYCbCrToRGB* ycbcr, float *luma, float *refBlackWhite)
     _TIFFmemset(clamptab+256, 255, 2*256);	/* v > 255 => 255 */
     ycbcr->Cr_r_tab = (int*) (clamptab + 3*256);
     ycbcr->Cb_b_tab = ycbcr->Cr_r_tab + 256;
-    ycbcr->Cr_g_tab = (int32*) (ycbcr->Cb_b_tab + 256);
+    ycbcr->Cr_g_tab = (int32_t*) (ycbcr->Cb_b_tab + 256);
     ycbcr->Cb_g_tab = ycbcr->Cr_g_tab + 256;
     ycbcr->Y_tab = ycbcr->Cb_g_tab + 256;
 
-    { float f1 = 2-2*LumaRed;		int32 D1 = FIX(CLAMP(f1,0.0F,2.0F));
-      float f2 = LumaRed*f1/LumaGreen;	int32 D2 = -FIX(CLAMP(f2,0.0F,2.0F));
-      float f3 = 2-2*LumaBlue;		int32 D3 = FIX(CLAMP(f3,0.0F,2.0F));
-      float f4 = LumaBlue*f3/LumaGreen;	int32 D4 = -FIX(CLAMP(f4,0.0F,2.0F));
+    { float f1 = 2-2*LumaRed;		int32_t D1 = FIX(CLAMP(f1, 0.0F, 2.0F));
+      float f2 = LumaRed*f1/LumaGreen;	int32_t D2 = -FIX(CLAMP(f2, 0.0F, 2.0F));
+      float f3 = 2-2*LumaBlue;		int32_t D3 = FIX(CLAMP(f3, 0.0F, 2.0F));
+      float f4 = LumaBlue*f3/LumaGreen;	int32_t D4 = -FIX(CLAMP(f4, 0.0F, 2.0F));
       int x;
 
 #undef LumaBlue
@@ -271,19 +271,19 @@ TIFFYCbCrToRGBInit(TIFFYCbCrToRGB* ycbcr, float *luma, float *refBlackWhite)
        * constructing tables indexed by the raw pixel data.
        */
       for (i = 0, x = -128; i < 256; i++, x++) {
-	    int32 Cr = (int32)CLAMPw(Code2V(x, refBlackWhite[4] - 128.0F,
+	    int32_t Cr = (int32_t)CLAMPw(Code2V(x, refBlackWhite[4] - 128.0F,
 			    refBlackWhite[5] - 128.0F, 127),
                             -128.0F * 32, 128.0F * 32);
-	    int32 Cb = (int32)CLAMPw(Code2V(x, refBlackWhite[2] - 128.0F,
+	    int32_t Cb = (int32_t)CLAMPw(Code2V(x, refBlackWhite[2] - 128.0F,
 			    refBlackWhite[3] - 128.0F, 127),
                             -128.0F * 32, 128.0F * 32);
 
-	    ycbcr->Cr_r_tab[i] = (int32)((D1*Cr + ONE_HALF)>>SHIFT);
-	    ycbcr->Cb_b_tab[i] = (int32)((D3*Cb + ONE_HALF)>>SHIFT);
+	    ycbcr->Cr_r_tab[i] = (int32_t)((D1 * Cr + ONE_HALF) >> SHIFT);
+	    ycbcr->Cb_b_tab[i] = (int32_t)((D3 * Cb + ONE_HALF) >> SHIFT);
 	    ycbcr->Cr_g_tab[i] = D2*Cr;
 	    ycbcr->Cb_g_tab[i] = D4*Cb + ONE_HALF;
 	    ycbcr->Y_tab[i] =
-		    (int32)CLAMPw(Code2V(x + 128, refBlackWhite[0], refBlackWhite[1], 255),
+		    (int32_t)CLAMPw(Code2V(x + 128, refBlackWhite[0], refBlackWhite[1], 255),
                                   -128.0F * 32, 128.0F * 32);
       }
     }
diff --git a/src/3rdparty/libtiff/libtiff/tif_compress.c b/src/3rdparty/libtiff/libtiff/tif_compress.c
index 8130ef0..8fcedf4 100644
--- a/src/3rdparty/libtiff/libtiff/tif_compress.c
+++ b/src/3rdparty/libtiff/libtiff/tif_compress.c
@@ -40,28 +40,28 @@ TIFFNoEncode(TIFF* tif, const char* method)
 			     c->name, method);
 	} else {
 		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			"Compression scheme %u %s encoding is not implemented",
+			"Compression scheme %"PRIu16" %s encoding is not implemented",
 			     tif->tif_dir.td_compression, method);
 	}
 	return (-1);
 }
 
 int
-_TIFFNoRowEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
+_TIFFNoRowEncode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s)
 {
 	(void) pp; (void) cc; (void) s;
 	return (TIFFNoEncode(tif, "scanline"));
 }
 
 int
-_TIFFNoStripEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
+_TIFFNoStripEncode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s)
 {
 	(void) pp; (void) cc; (void) s;
 	return (TIFFNoEncode(tif, "strip"));
 }
 
 int
-_TIFFNoTileEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
+_TIFFNoTileEncode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s)
 {
 	(void) pp; (void) cc; (void) s;
 	return (TIFFNoEncode(tif, "tile"));
@@ -78,7 +78,7 @@ TIFFNoDecode(TIFF* tif, const char* method)
 			     c->name, method);
 	else
 		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Compression scheme %u %s decoding is not implemented",
+			     "Compression scheme %"PRIu16" %s decoding is not implemented",
 			     tif->tif_dir.td_compression, method);
 	return (0);
 }
@@ -91,28 +91,28 @@ _TIFFNoFixupTags(TIFF* tif)
 }
 
 int
-_TIFFNoRowDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
+_TIFFNoRowDecode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s)
 {
 	(void) pp; (void) cc; (void) s;
 	return (TIFFNoDecode(tif, "scanline"));
 }
 
 int
-_TIFFNoStripDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
+_TIFFNoStripDecode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s)
 {
 	(void) pp; (void) cc; (void) s;
 	return (TIFFNoDecode(tif, "strip"));
 }
 
 int
-_TIFFNoTileDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
+_TIFFNoTileDecode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s)
 {
 	(void) pp; (void) cc; (void) s;
 	return (TIFFNoDecode(tif, "tile"));
 }
 
 int
-_TIFFNoSeek(TIFF* tif, uint32 off)
+_TIFFNoSeek(TIFF* tif, uint32_t off)
 {
 	(void) off;
 	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
@@ -121,7 +121,7 @@ _TIFFNoSeek(TIFF* tif, uint32 off)
 }
 
 int
-_TIFFNoPreCode(TIFF* tif, uint16 s)
+_TIFFNoPreCode(TIFF* tif, uint16_t s)
 {
 	(void) tif; (void) s;
 	return (1);
@@ -158,7 +158,7 @@ _TIFFSetDefaultCompressionState(TIFF* tif)
 int
 TIFFSetCompressionScheme(TIFF* tif, int scheme)
 {
-	const TIFFCodec *c = TIFFFindCODEC((uint16) scheme);
+	const TIFFCodec *c = TIFFFindCODEC((uint16_t) scheme);
 
 	_TIFFSetDefaultCompressionState(tif);
 	/*
@@ -182,7 +182,7 @@ typedef struct _codec {
 static codec_t* registeredCODECS = NULL;
 
 const TIFFCodec*
-TIFFFindCODEC(uint16 scheme)
+TIFFFindCODEC(uint16_t scheme)
 {
 	const TIFFCodec* c;
 	codec_t* cd;
@@ -197,15 +197,15 @@ TIFFFindCODEC(uint16 scheme)
 }
 
 TIFFCodec*
-TIFFRegisterCODEC(uint16 scheme, const char* name, TIFFInitMethod init)
+TIFFRegisterCODEC(uint16_t scheme, const char* name, TIFFInitMethod init)
 {
 	codec_t* cd = (codec_t*)
 	    _TIFFmalloc((tmsize_t)(sizeof (codec_t) + sizeof (TIFFCodec) + strlen(name)+1));
 
 	if (cd != NULL) {
-		cd->info = (TIFFCodec*) ((uint8*) cd + sizeof (codec_t));
+		cd->info = (TIFFCodec*) ((uint8_t*) cd + sizeof (codec_t));
 		cd->info->name = (char*)
-		    ((uint8*) cd->info + sizeof (TIFFCodec));
+		    ((uint8_t*) cd->info + sizeof (TIFFCodec));
 		strcpy(cd->info->name, name);
 		cd->info->scheme = scheme;
 		cd->info->init = init;
@@ -264,7 +264,7 @@ TIFFGetConfiguredCODECs()
 			return NULL;
 		}
 		codecs = new_codecs;
-		_TIFFmemcpy(codecs + i - 1, cd, sizeof(TIFFCodec));
+		_TIFFmemcpy(codecs + i - 1, cd->info, sizeof(TIFFCodec));
 		i++;
 	}
 	for (c = _TIFFBuiltinCODECS; c->name; c++) {
diff --git a/src/3rdparty/libtiff/libtiff/tif_config.h b/src/3rdparty/libtiff/libtiff/tif_config.h
index 73c602f..3384aeb 100644
--- a/src/3rdparty/libtiff/libtiff/tif_config.h
+++ b/src/3rdparty/libtiff/libtiff/tif_config.h
@@ -2,20 +2,18 @@
   Configuration defines for Qt.
 */
 
-#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
-#define _CRT_SECURE_NO_WARNINGS
-#endif
+#include "tiffconf.h"
 
-#include <qglobal.h>
 #if defined(Q_OS_WINCE)
-# include <qfunctions_wince.h>
+#include <qfunctions_wince.h>
 #endif
 
-/* Define if building universal (internal helper macro) */
-/* #undef AC_APPLE_UNIVERSAL_BUILD */
+#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
+#define _CRT_SECURE_NO_WARNINGS
+#endif
 
 /* Support CCITT Group 3 & 4 algorithms */
-/* #undef CCITT_SUPPORT */
+#define CCITT_SUPPORT 1
 
 /* Pick up YCbCr subsampling info from the JPEG data stream to support files
    lacking the tag (default enabled). */
@@ -25,12 +23,7 @@
 /* #undef CHUNKY_STRIP_READ_SUPPORT */
 
 /* Support C++ stream API (requires C++ compiler) */
-/* #undef CXX_SUPPORT */
-
-/* Treat extra sample as alpha (default enabled). The RGBA interface will
-   treat a fourth sample with no EXTRASAMPLE_ value as being ASSOCALPHA. Many
-   packages produce RGBA files but don't mark the alpha properly. */
-/* #undef DEFAULT_EXTRASAMPLE_AS_ALPHA */
+/* #undef CXX_SUPPORT 1 */
 
 /* enable deferred strip/tile offset/size loading */
 /* #undef DEFER_STRILE_LOAD */
@@ -42,17 +35,11 @@
    */
 #define HAVE_DECL_OPTARG 0
 
-/* Define to 1 if you have the <dlfcn.h> header file. */
-/* #undef HAVE_DLFCN_H */
-
 /* Define to 1 if you have the <fcntl.h> header file. */
 #if !defined(Q_OS_WINCE)
 #define HAVE_FCNTL_H 1
 #endif
 
-/* Define to 1 if you have the `floor' function. */
-/* #undef HAVE_FLOOR */
-
 /* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
 /* #undef HAVE_FSEEKO */
 
@@ -71,58 +58,12 @@
 /* Define to 1 if you have the <GL/gl.h> header file. */
 /* #undef HAVE_GL_GL_H */
 
-/* Define as 0 or 1 according to the floating point format suported by the
-   machine */
-/* #undef HAVE_IEEEFP */
-
-/* Define to 1 if the system has the type `int16'. */
-#ifdef Q_OS_AIX
-#define HAVE_INT16 1
-#endif
-
-/* Define to 1 if the system has the type `int32'. */
-#ifdef Q_OS_AIX
-#define HAVE_INT32 1
-#endif
-
-/* Define to 1 if the system has the type `int8'. */
-#ifdef Q_OS_AIX
-#define HAVE_INT8 1
-#endif
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-/* #undef HAVE_INTTYPES_H */
-
 /* Define to 1 if you have the <io.h> header file. */
 /* #undef HAVE_IO_H */
 
-/* Define to 1 if you have the `isascii' function. */
-/* #undef HAVE_ISASCII */
-
 /* Define to 1 if you have the `jbg_newlen' function. */
 /* #undef HAVE_JBG_NEWLEN */
 
-/* Define to 1 if you have the `lfind' function. */
-/* #undef HAVE_LFIND */
-
-/* Define to 1 if you have the `c' library (-lc). */
-/* #undef HAVE_LIBC */
-
-/* Define to 1 if you have the <limits.h> header file. */
-/* #undef HAVE_LIMITS_H */
-
-/* Define to 1 if you have the <malloc.h> header file. */
-/* #undef HAVE_MALLOC_H */
-
-/* Define to 1 if you have the `memmove' function. */
-/* #undef HAVE_MEMMOVE */
-
-/* Define to 1 if you have the <memory.h> header file. */
-/* #undef HAVE_MEMORY_H */
-
-/* Define to 1 if you have the `memset' function. */
-/* #undef HAVE_MEMSET */
-
 /* Define to 1 if you have the `mmap' function. */
 /* #undef HAVE_MMAP */
 
@@ -132,67 +73,15 @@
 /* Define to 1 if you have the <OpenGL/gl.h> header file. */
 /* #undef HAVE_OPENGL_GL_H */
 
-/* Define to 1 if you have the `pow' function. */
-/* #undef HAVE_POW */
-
-/* Define if you have POSIX threads libraries and header files. */
-/* #undef HAVE_PTHREAD */
-
-/* Define to 1 if you have the <search.h> header file. */
-#if !defined(Q_OS_WINCE) && !defined(Q_OS_VXWORKS) && !defined(Q_OS_ANDROID) && !defined(Q_OS_INTEGRITY)
-#define HAVE_SEARCH_H 1
-#endif
-
 /* Define to 1 if you have the `setmode' function. */
 /* #undef HAVE_SETMODE */
 
 /* Define to 1 if you have the `snprintf' function. */
-#if defined(snprintf) || (!defined(_MSC_VER) || _MSC_VER >= 1900)
-#define HAVE_SNPRINTF 1
-#endif
-
-/* Define to 1 if you have the `sqrt' function. */
-/* #undef HAVE_SQRT */
-
-/* Define to 1 if you have the <stdint.h> header file. */
-/* #undef HAVE_STDINT_H */
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-/* #undef HAVE_STDLIB_H */
-
-/* Define to 1 if you have the `strcasecmp' function. */
-/* #undef HAVE_STRCASECMP */
-
-/* Define to 1 if you have the `strchr' function. */
-/* #undef HAVE_STRCHR */
+/* #undef HAVE_SNPRINTF */
 
 /* Define to 1 if you have the <strings.h> header file. */
 /* #undef HAVE_STRINGS_H */
 
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the `strrchr' function. */
-/* #undef HAVE_STRRCHR */
-
-/* Define to 1 if you have the `strstr' function. */
-/* #undef HAVE_STRSTR */
-
-/* Define to 1 if you have the `strtol' function. */
-/* #undef HAVE_STRTOL */
-
-/* Define to 1 if you have the `strtoul' function. */
-/* #undef HAVE_STRTOUL */
-
-/* Define to 1 if you have the `strtoull' function. */
-/* #undef HAVE_STRTOULL */
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-/* #undef HAVE_SYS_STAT_H */
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-/* #undef HAVE_SYS_TIME_H */
-
 /* Define to 1 if you have the <sys/types.h> header file. */
 #define HAVE_SYS_TYPES_H 1
 
@@ -201,52 +90,18 @@
 #define HAVE_UNISTD_H 1
 #endif
 
-/* Use nonstandard varargs form for the GLU tesselator callback */
-/* #undef HAVE_VARARGS_GLU_TESSCB */
-
-/* Define to 1 if you have the <windows.h> header file. */
-/* #undef HAVE_WINDOWS_H */
-
-/* Native cpu byte order: 1 if big-endian (Motorola) or 0 if little-endian
-   (Intel) */
-/* #undef HOST_BIGENDIAN */
-
-/* Set the native cpu bit order (FILLORDER_LSB2MSB or FILLORDER_MSB2LSB) */
-/* #undef HOST_FILLORDER FILLORDER_LSB2MSB */
-
-/* Support ISO JBIG compression (requires JBIG-KIT library) */
-/* #undef JBIG_SUPPORT */
-
 /* 8/12 bit libjpeg dual mode enabled */
 /* #undef JPEG_DUAL_MODE_8_12 */
 
-/* Support JPEG compression (requires IJG JPEG library) */
-/* #undef JPEG_SUPPORT */
+/* Support LERC compression */
+/* #undef LERC_SUPPORT */
 
 /* 12bit libjpeg primary include file with path */
 /* #undef LIBJPEG_12_PATH */
 
-/* Support LogLuv high dynamic range encoding */
-/* #undef LOGLUV_SUPPORT */
-
-/* Define to the sub-directory where libtool stores uninstalled libraries. */
-/* #undef LT_OBJDIR */
-
 /* Support LZMA2 compression */
 /* #undef LZMA_SUPPORT */
 
-/* Support LZW algorithm */
-/* #undef LZW_SUPPORT */
-
-/* Support Microsoft Document Imaging format */
-/* #undef MDI_SUPPORT */
-
-/* Support NeXT 2-bit RLE algorithm */
-/* #undef NEXT_SUPPORT */
-
-/* Support Old JPEG compresson (read-only) */
-/* #undef OJPEG_SUPPORT */
-
 /* Name of package */
 /* #undef PACKAGE */
 
@@ -266,154 +121,48 @@
 /* #undef PACKAGE_URL */
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "4.0.9"
-
-/* Support Macintosh PackBits algorithm */
-/* #undef PACKBITS_SUPPORT */
-
-/* Support Pixar log-format algorithm (requires Zlib) */
-/* #undef PIXARLOG_SUPPORT */
-
-/* Define to necessary symbol if this constant uses a non-standard name on
-   your system. */
-/* #undef PTHREAD_CREATE_JOINABLE */
-
-/* The size of `signed int', as computed by sizeof. */
-/* #undef SIZEOF_SIGNED_INT */
-
-/* The size of `signed long', as computed by sizeof. */
-/* #undef SIZEOF_SIGNED_LONG */
-
-/* The size of `signed long long', as computed by sizeof. */
-/* #undef SIZEOF_SIGNED_LONG_LONG */
-
-/* The size of `signed short', as computed by sizeof. */
-/* #undef SIZEOF_SIGNED_SHORT */
+/* #undef PACKAGE_VERSION */
 
 /* The size of `size_t', as computed by sizeof. */
-/* #undef SIZEOF_SIZE_T */
-
-/* The size of `unsigned char *', as computed by sizeof. */
-/* #undef SIZEOF_UNSIGNED_CHAR_P */
-
-/* The size of `unsigned int', as computed by sizeof. */
-/* #undef SIZEOF_UNSIGNED_INT */
-
-/* The size of `unsigned long', as computed by sizeof. */
-/* #undef SIZEOF_UNSIGNED_LONG */
-
-/* The size of `unsigned long long', as computed by sizeof. */
-/* #undef SIZEOF_UNSIGNED_LONG_LONG */
-
-/* The size of `unsigned short', as computed by sizeof. */
-/* #undef SIZEOF_UNSIGNED_SHORT */
-
-/* Define to 1 if you have the ANSI C header files. */
-/* #undef STDC_HEADERS */
-
-/* Support strip chopping (whether or not to convert single-strip uncompressed
-   images to mutiple strips of specified size to reduce memory usage) */
-/* #undef STRIPCHOP_DEFAULT TIFF_STRIPCHOP */
+#if SIZE_MAX == 0xffffffff
+#define SIZEOF_SIZE_T 4
+#elif SIZE_MAX == 0xffffffffffffffff
+#define SIZEOF_SIZE_T 8
+#endif
 
 /* Default size of the strip in bytes (when strip chopping enabled) */
 /* #undef STRIP_SIZE_DEFAULT */
 
-/* Enable SubIFD tag (330) support */
-/* #undef SUBIFD_SUPPORT */
-
-/* Support ThunderScan 4-bit RLE algorithm */
-/* #undef THUNDER_SUPPORT */
-
-/* Signed 16-bit type */
-/* #undef TIFF_INT16_T qint16 */
-
-/* Signed 32-bit type formatter */
-#define TIFF_INT32_FORMAT "%d"
-
-/* Signed 32-bit type */
-/* #undef TIFF_INT32_T qint32 */
-
-/* Signed 64-bit type formatter */
-#define TIFF_INT64_FORMAT "%lld"
-
-/* Signed 64-bit type */
-/* #undef TIFF_INT64_T qint64 */
-
-/* Signed 8-bit type */
-/* #undef TIFF_INT8_T qint8 */
-
-/* Pointer difference type formatter */
-#define TIFF_PTRDIFF_FORMAT "%ld"
-
-/* Pointer difference type */
-#define TIFF_PTRDIFF_T ptrdiff_t
-
-/* Size type formatter */
-/* #undef TIFF_SIZE_FORMAT */
-
-/* Unsigned size type */
-/* #undef TIFF_SIZE_T */
-
-/* Signed size type formatter */
-#if QT_POINTER_SIZE == 4
-#define TIFF_SSIZE_FORMAT "%ld"
-#else
-#define TIFF_SSIZE_FORMAT "%lld"
-#endif
-
-/* Signed size type */
-/* #undef TIFF_SSIZE_T qint64 */
-
-/* Unsigned 16-bit type */
-/* #undef TIFF_UINT16_T quint16 */
-
-/* Unsigned 32-bit type formatter */
-#define TIFF_UINT32_FORMAT "%u"
-
-/* Unsigned 32-bit type */
-/* #undef TIFF_UINT32_T quint32 */
-
-/* Unsigned 64-bit type formatter */
-#define TIFF_UINT64_FORMAT "%llu"
-
-/* Unsigned 64-bit type */
-/* #undef TIFF_UINT64_T quint64 */
-
-/* Unsigned 8-bit type */
-/* #undef TIFF_UINT8_T quint8 */
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-/* #undef TIME_WITH_SYS_TIME */
-
-/* Define to 1 if your <sys/time.h> declares `struct tm'. */
-/* #undef TM_IN_SYS_TIME */
-
 /* define to use win32 IO system */
-#ifdef Q_OS_WIN
-#define USE_WIN32_FILEIO 1
-#endif
+/* #undef USE_WIN32_FILEIO */
 
 /* Version number of package */
-/* #undef VERSION */
+#define VERSION "4.3.0"
+
+/* Support webp compression */
+/* #undef WEBP_SUPPORT */
 
 /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
    significant byte first (like Motorola and SPARC, unlike Intel). */
-#if (Q_BYTE_ORDER == Q_BIG_ENDIAN)
-#define WORDS_BIGENDIAN 1
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#  if (Q_BYTE_ORDER == Q_BIG_ENDIAN)
+#   define WORDS_BIGENDIAN 1
+#  endif
+# endif
 #endif
 
-/* Define to 1 if the X Window System is missing or not being used. */
-/* #undef X_DISPLAY_MISSING */
-
-/* Support Deflate compression */
-/* #undef ZIP_SUPPORT */
+/* Support zstd compression */
+/* #undef ZSTD_SUPPORT */
 
 /* Enable large inode numbers on Mac OS X 10.5.  */
-#if defined(Q_OS_MAC)
 #ifndef _DARWIN_USE_64_BIT_INODE
 # define _DARWIN_USE_64_BIT_INODE 1
 #endif
-#endif
 
 /* Number of bits in a file offset, on hosts where this is settable. */
 /* #undef _FILE_OFFSET_BITS */
@@ -424,25 +173,19 @@
 /* Define for large files, on AIX-style hosts. */
 /* #undef _LARGE_FILES */
 
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#if defined(Q_CC_MSVC)
-#ifndef __cplusplus
-# ifndef inline
-#  define inline __inline
-# endif
-#endif
-#endif
-
-/* Define to `long int' if <sys/types.h> does not define. */
-/* #undef off_t */
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef size_t */
-
-#ifdef Q_OS_WIN
-#define TIF_PLATFORM_CONSOLE
+#if !defined(__MINGW32__)
+#  define TIFF_SIZE_FORMAT "zu"
+#endif
+#if SIZEOF_SIZE_T == 8
+#  define TIFF_SSIZE_FORMAT "lld"
+#  if defined(__MINGW32__)
+#    define TIFF_SIZE_FORMAT "llu"
+#  endif
+#elif SIZEOF_SIZE_T == 4
+#  define TIFF_SSIZE_FORMAT "d"
+#  if defined(__MINGW32__)
+#    define TIFF_SIZE_FORMAT "u"
+#  endif
+#else
+#  error "Unsupported size_t size; please submit a bug report"
 #endif
diff --git a/src/3rdparty/libtiff/libtiff/tif_config.h-vms b/src/3rdparty/libtiff/libtiff/tif_config.h-vms
deleted file mode 100644
index d653bd8..0000000
--- a/src/3rdparty/libtiff/libtiff/tif_config.h-vms
+++ /dev/null
@@ -1,46 +0,0 @@
-/* Define to 1 if you have the <assert.h> header file. */
-#define HAVE_ASSERT_H 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define as 0 or 1 according to the floating point format suported by the
-   machine */
-#define HAVE_IEEEFP 1
-
-#define HAVE_UNISTD_H 1
-
-#define HAVE_STRING_H 1
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <io.h> header file. */
-//#define HAVE_IO_H 1
-
-/* Define to 1 if you have the <search.h> header file. */
-//#define HAVE_SEARCH_H 1
-
-/* The size of a `int', as computed by sizeof. */
-#define SIZEOF_INT 4
-
-/* The size of a `long', as computed by sizeof. */
-#define SIZEOF_LONG 4
-
-/* Set the native cpu bit order */
-#define HOST_FILLORDER FILLORDER_LSB2MSB
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-/* #undef WORDS_BIGENDIAN */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-/*
-#ifndef __cplusplus
-# ifndef inline
-#  define inline __inline
-# endif
-#endif
-*/
-
-// #define lfind _lfind
diff --git a/src/3rdparty/libtiff/libtiff/tif_config.h.cmake.in b/src/3rdparty/libtiff/libtiff/tif_config.h.cmake.in
new file mode 100644
index 0000000..20e4463
--- /dev/null
+++ b/src/3rdparty/libtiff/libtiff/tif_config.h.cmake.in
@@ -0,0 +1,155 @@
+/* libtiff/tif_config.h.cmake.in.  Not generated, but originated from autoheader.  */
+/* This file must be kept up-to-date with needed substitutions from libtiff/tif_config.h.in. */
+
+#include "tiffconf.h"
+
+/* Support CCITT Group 3 & 4 algorithms */
+#cmakedefine CCITT_SUPPORT 1
+
+/* Pick up YCbCr subsampling info from the JPEG data stream to support files
+   lacking the tag (default enabled). */
+#cmakedefine CHECK_JPEG_YCBCR_SUBSAMPLING 1
+
+/* enable partial strip reading for large strips (experimental) */
+#cmakedefine CHUNKY_STRIP_READ_SUPPORT 1
+
+/* Support C++ stream API (requires C++ compiler) */
+#cmakedefine CXX_SUPPORT 1
+
+/* enable deferred strip/tile offset/size loading (experimental) */
+#cmakedefine DEFER_STRILE_LOAD 1
+
+/* Define to 1 if you have the <assert.h> header file. */
+#cmakedefine HAVE_ASSERT_H 1
+
+/* Define to 1 if you have the declaration of `optarg', and to 0 if you don't. */
+#cmakedefine HAVE_DECL_OPTARG 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#cmakedefine HAVE_FCNTL_H 1
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#cmakedefine HAVE_FSEEKO 1
+
+/* Define to 1 if you have the `getopt' function. */
+#cmakedefine HAVE_GETOPT 1
+
+/* Define to 1 if you have the <GLUT/glut.h> header file. */
+#cmakedefine HAVE_GLUT_GLUT_H 1
+
+/* Define to 1 if you have the <GL/glut.h> header file. */
+#cmakedefine HAVE_GL_GLUT_H 1
+
+/* Define to 1 if you have the <GL/glu.h> header file. */
+#cmakedefine HAVE_GL_GLU_H 1
+
+/* Define to 1 if you have the <GL/gl.h> header file. */
+#cmakedefine HAVE_GL_GL_H 1
+
+/* Define to 1 if you have the <io.h> header file. */
+#cmakedefine HAVE_IO_H 1
+
+/* Define to 1 if you have the `jbg_newlen' function. */
+#cmakedefine HAVE_JBG_NEWLEN 1
+
+/* Define to 1 if you have the `mmap' function. */
+#cmakedefine HAVE_MMAP 1
+
+/* Define to 1 if you have the <OpenGL/glu.h> header file. */
+#cmakedefine HAVE_OPENGL_GLU_H 1
+
+/* Define to 1 if you have the <OpenGL/gl.h> header file. */
+#cmakedefine HAVE_OPENGL_GL_H 1
+
+/* Define to 1 if you have the `setmode' function. */
+#cmakedefine HAVE_SETMODE 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H 1
+
+/* 8/12 bit libjpeg dual mode enabled */
+#cmakedefine JPEG_DUAL_MODE_8_12 1 1
+
+/* Support LERC compression */
+#cmakedefine LERC_SUPPORT 1
+
+/* 12bit libjpeg primary include file with path */
+#define LIBJPEG_12_PATH "@LIBJPEG_12_PATH@"
+
+/* Support LZMA2 compression */
+#cmakedefine LZMA_SUPPORT 1
+
+/* Name of package */
+#define PACKAGE "@PACKAGE_NAME@"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "@PACKAGE_BUGREPORT@"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "@PACKAGE_NAME@"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "@PACKAGE_STRING@"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "@PACKAGE_TARNAME@"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "@PACKAGE_URL@"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "@PACKAGE_VERSION@"
+
+/* Size of size_t */
+#define SIZEOF_SIZE_T @SIZEOF_SIZE_T@
+
+/* Default size of the strip in bytes (when strip chopping enabled) */
+#define STRIP_SIZE_DEFAULT @STRIP_SIZE_DEFAULT@
+
+/* define to use win32 IO system */
+#cmakedefine USE_WIN32_FILEIO 1
+
+/* Version number of package */
+#define VERSION "@PACKAGE_VERSION@"
+
+/* Support WEBP compression */
+#cmakedefine WEBP_SUPPORT 1
+
+/* Support ZSTD compression */
+#cmakedefine ZSTD_SUPPORT 1
+
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#endif
+
+#if !defined(__MINGW32__)
+#  define TIFF_SIZE_FORMAT "zu"
+#endif
+#if SIZEOF_SIZE_T == 8
+#  define TIFF_SSIZE_FORMAT PRId64
+#  if defined(__MINGW32__)
+#    define TIFF_SIZE_FORMAT PRIu64
+#  endif
+#elif SIZEOF_SIZE_T == 4
+#  define TIFF_SSIZE_FORMAT PRId32
+#  if defined(__MINGW32__)
+#    define TIFF_SIZE_FORMAT PRIu32
+#  endif
+#else
+#  error "Unsupported size_t size; please submit a bug report"
+#endif
diff --git a/src/3rdparty/libtiff/libtiff/tif_config.h.in b/src/3rdparty/libtiff/libtiff/tif_config.h.in
index 523da3e..66eef23 100644
--- a/src/3rdparty/libtiff/libtiff/tif_config.h.in
+++ b/src/3rdparty/libtiff/libtiff/tif_config.h.in
@@ -1,7 +1,6 @@
-/* libtiff/tif_config.h.in.  Generated from configure.ac by autoheader.  */
+/* libtiff/tif_config.h.in.  Not generated, but originated from autoheader.  */
 
-/* Define if building universal (internal helper macro) */
-#undef AC_APPLE_UNIVERSAL_BUILD
+#include "tiffconf.h"
 
 /* Support CCITT Group 3 & 4 algorithms */
 #undef CCITT_SUPPORT
@@ -16,11 +15,6 @@
 /* Support C++ stream API (requires C++ compiler) */
 #undef CXX_SUPPORT
 
-/* Treat extra sample as alpha (default enabled). The RGBA interface will
-   treat a fourth sample with no EXTRASAMPLE_ value as being ASSOCALPHA. Many
-   packages produce RGBA files but don't mark the alpha properly. */
-#undef DEFAULT_EXTRASAMPLE_AS_ALPHA
-
 /* enable deferred strip/tile offset/size loading */
 #undef DEFER_STRILE_LOAD
 
@@ -31,9 +25,6 @@
    */
 #undef HAVE_DECL_OPTARG
 
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#undef HAVE_DLFCN_H
-
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
@@ -55,25 +46,12 @@
 /* Define to 1 if you have the <GL/gl.h> header file. */
 #undef HAVE_GL_GL_H
 
-/* Define as 0 or 1 according to the floating point format suported by the
-   machine */
-#undef HAVE_IEEEFP
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
 /* Define to 1 if you have the <io.h> header file. */
 #undef HAVE_IO_H
 
 /* Define to 1 if you have the `jbg_newlen' function. */
 #undef HAVE_JBG_NEWLEN
 
-/* Define to 1 if you have the `lfind' function. */
-#undef HAVE_LFIND
-
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
 /* Define to 1 if you have the `mmap' function. */
 #undef HAVE_MMAP
 
@@ -83,100 +61,33 @@
 /* Define to 1 if you have the <OpenGL/gl.h> header file. */
 #undef HAVE_OPENGL_GL_H
 
-/* Define if you have POSIX threads libraries and header files. */
-#undef HAVE_PTHREAD
-
-/* Define to 1 if you have the <search.h> header file. */
-#undef HAVE_SEARCH_H
-
 /* Define to 1 if you have the `setmode' function. */
 #undef HAVE_SETMODE
 
 /* Define to 1 if you have the `snprintf' function. */
 #undef HAVE_SNPRINTF
 
-/* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the `strcasecmp' function. */
-#undef HAVE_STRCASECMP
-
 /* Define to 1 if you have the <strings.h> header file. */
 #undef HAVE_STRINGS_H
 
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the `strtol' function. */
-#undef HAVE_STRTOL
-
-/* Define to 1 if you have the `strtoll' function. */
-#undef HAVE_STRTOLL
-
-/* Define to 1 if you have the `strtoul' function. */
-#undef HAVE_STRTOUL
-
-/* Define to 1 if you have the `strtoull' function. */
-#undef HAVE_STRTOULL
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
 /* Define to 1 if you have the <sys/types.h> header file. */
 #undef HAVE_SYS_TYPES_H
 
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
-/* Use nonstandard varargs form for the GLU tesselator callback */
-#undef HAVE_VARARGS_GLU_TESSCB
-
-/* Define to 1 if you have the <windows.h> header file. */
-#undef HAVE_WINDOWS_H
-
-/* Native cpu byte order: 1 if big-endian (Motorola) or 0 if little-endian
-   (Intel) */
-#undef HOST_BIGENDIAN
-
-/* Set the native cpu bit order (FILLORDER_LSB2MSB or FILLORDER_MSB2LSB) */
-#undef HOST_FILLORDER
-
-/* Support ISO JBIG compression (requires JBIG-KIT library) */
-#undef JBIG_SUPPORT
-
 /* 8/12 bit libjpeg dual mode enabled */
 #undef JPEG_DUAL_MODE_8_12
 
-/* Support JPEG compression (requires IJG JPEG library) */
-#undef JPEG_SUPPORT
+/* Support LERC compression */
+#undef LERC_SUPPORT
 
 /* 12bit libjpeg primary include file with path */
 #undef LIBJPEG_12_PATH
 
-/* Support LogLuv high dynamic range encoding */
-#undef LOGLUV_SUPPORT
-
-/* Define to the sub-directory where libtool stores uninstalled libraries. */
-#undef LT_OBJDIR
-
 /* Support LZMA2 compression */
 #undef LZMA_SUPPORT
 
-/* Support LZW algorithm */
-#undef LZW_SUPPORT
-
-/* Support Microsoft Document Imaging format */
-#undef MDI_SUPPORT
-
-/* Support NeXT 2-bit RLE algorithm */
-#undef NEXT_SUPPORT
-
-/* Support Old JPEG compresson (read-only) */
-#undef OJPEG_SUPPORT
-
 /* Name of package */
 #undef PACKAGE
 
@@ -198,116 +109,12 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
-/* Support Macintosh PackBits algorithm */
-#undef PACKBITS_SUPPORT
-
-/* Support Pixar log-format algorithm (requires Zlib) */
-#undef PIXARLOG_SUPPORT
-
-/* Define to necessary symbol if this constant uses a non-standard name on
-   your system. */
-#undef PTHREAD_CREATE_JOINABLE
-
-/* The size of `signed int', as computed by sizeof. */
-#undef SIZEOF_SIGNED_INT
-
-/* The size of `signed long', as computed by sizeof. */
-#undef SIZEOF_SIGNED_LONG
-
-/* The size of `signed long long', as computed by sizeof. */
-#undef SIZEOF_SIGNED_LONG_LONG
-
 /* The size of `size_t', as computed by sizeof. */
 #undef SIZEOF_SIZE_T
 
-/* The size of `unsigned char *', as computed by sizeof. */
-#undef SIZEOF_UNSIGNED_CHAR_P
-
-/* The size of `unsigned int', as computed by sizeof. */
-#undef SIZEOF_UNSIGNED_INT
-
-/* The size of `unsigned long', as computed by sizeof. */
-#undef SIZEOF_UNSIGNED_LONG
-
-/* The size of `unsigned long long', as computed by sizeof. */
-#undef SIZEOF_UNSIGNED_LONG_LONG
-
-/* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
-
-/* Support strip chopping (whether or not to convert single-strip uncompressed
-   images to mutiple strips of specified size to reduce memory usage) */
-#undef STRIPCHOP_DEFAULT
-
 /* Default size of the strip in bytes (when strip chopping enabled) */
 #undef STRIP_SIZE_DEFAULT
 
-/* Enable SubIFD tag (330) support */
-#undef SUBIFD_SUPPORT
-
-/* Support ThunderScan 4-bit RLE algorithm */
-#undef THUNDER_SUPPORT
-
-/* Signed 16-bit type */
-#undef TIFF_INT16_T
-
-/* Signed 32-bit type formatter */
-#undef TIFF_INT32_FORMAT
-
-/* Signed 32-bit type */
-#undef TIFF_INT32_T
-
-/* Signed 64-bit type formatter */
-#undef TIFF_INT64_FORMAT
-
-/* Signed 64-bit type */
-#undef TIFF_INT64_T
-
-/* Signed 8-bit type */
-#undef TIFF_INT8_T
-
-/* Pointer difference type formatter */
-#undef TIFF_PTRDIFF_FORMAT
-
-/* Pointer difference type */
-#undef TIFF_PTRDIFF_T
-
-/* Size type formatter */
-#undef TIFF_SIZE_FORMAT
-
-/* Unsigned size type */
-#undef TIFF_SIZE_T
-
-/* Signed size type formatter */
-#undef TIFF_SSIZE_FORMAT
-
-/* Signed size type */
-#undef TIFF_SSIZE_T
-
-/* Unsigned 16-bit type */
-#undef TIFF_UINT16_T
-
-/* Unsigned 32-bit type formatter */
-#undef TIFF_UINT32_FORMAT
-
-/* Unsigned 32-bit type */
-#undef TIFF_UINT32_T
-
-/* Unsigned 64-bit type formatter */
-#undef TIFF_UINT64_FORMAT
-
-/* Unsigned 64-bit type */
-#undef TIFF_UINT64_T
-
-/* Unsigned 8-bit type */
-#undef TIFF_UINT8_T
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#undef TIME_WITH_SYS_TIME
-
-/* Define to 1 if your <sys/time.h> declares `struct tm'. */
-#undef TM_IN_SYS_TIME
-
 /* define to use win32 IO system */
 #undef USE_WIN32_FILEIO
 
@@ -329,12 +136,6 @@
 # endif
 #endif
 
-/* Define to 1 if the X Window System is missing or not being used. */
-#undef X_DISPLAY_MISSING
-
-/* Support Deflate compression */
-#undef ZIP_SUPPORT
-
 /* Support zstd compression */
 #undef ZSTD_SUPPORT
 
@@ -352,17 +153,19 @@
 /* Define for large files, on AIX-style hosts. */
 #undef _LARGE_FILES
 
-/* Define to empty if `const' does not conform to ANSI C. */
-#undef const
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-#undef inline
+#if !defined(__MINGW32__)
+#  define TIFF_SIZE_FORMAT "zu"
+#endif
+#if SIZEOF_SIZE_T == 8
+#  define TIFF_SSIZE_FORMAT PRId64
+#  if defined(__MINGW32__)
+#    define TIFF_SIZE_FORMAT PRIu64
+#  endif
+#elif SIZEOF_SIZE_T == 4
+#  define TIFF_SSIZE_FORMAT PRId32
+#  if defined(__MINGW32__)
+#    define TIFF_SIZE_FORMAT PRIu32
+#  endif
+#else
+#  error "Unsupported size_t size; please submit a bug report"
 #endif
-
-/* Define to `long int' if <sys/types.h> does not define. */
-#undef off_t
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-#undef size_t
diff --git a/src/3rdparty/libtiff/libtiff/tif_config.vc.h b/src/3rdparty/libtiff/libtiff/tif_config.vc.h
deleted file mode 100644
index 5cebfa0..0000000
--- a/src/3rdparty/libtiff/libtiff/tif_config.vc.h
+++ /dev/null
@@ -1,137 +0,0 @@
-#ifndef _TIF_CONFIG_H_
-#define _TIF_CONFIG_H_
-
-/* Define to 1 if you have the <assert.h> header file. */
-#define HAVE_ASSERT_H 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define as 0 or 1 according to the floating point format suported by the
-   machine */
-#define HAVE_IEEEFP 1
-
-/* Define to 1 if you have the `jbg_newlen' function. */
-#define HAVE_JBG_NEWLEN 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <io.h> header file. */
-#define HAVE_IO_H 1
-
-/* Define to 1 if you have the <search.h> header file. */
-#define HAVE_SEARCH_H 1
-
-/* Define to 1 if you have the `setmode' function. */
-#define HAVE_SETMODE 1
-
-/* Define to 1 if you have the declaration of `optarg', and to 0 if you don't. */
-#define HAVE_DECL_OPTARG 0
-
-/* The size of a `int', as computed by sizeof. */
-#define SIZEOF_INT 4
-
-/* The size of a `long', as computed by sizeof. */
-#define SIZEOF_LONG 4
-
-/* Signed 64-bit type formatter */
-#define TIFF_INT64_FORMAT "%I64d"
-
-/* Signed 64-bit type */
-#define TIFF_INT64_T signed __int64
-
-/* Unsigned 64-bit type formatter */
-#define TIFF_UINT64_FORMAT "%I64u"
-
-/* Unsigned 64-bit type */
-#define TIFF_UINT64_T unsigned __int64
-
-#if _WIN64
-/*
-  Windows 64-bit build
-*/
-
-/* Pointer difference type */
-#  define TIFF_PTRDIFF_T TIFF_INT64_T
-
-/* The size of `size_t', as computed by sizeof. */
-#  define SIZEOF_SIZE_T 8
-
-/* Size type formatter */
-#  define TIFF_SIZE_FORMAT TIFF_INT64_FORMAT
-
-/* Unsigned size type */
-#  define TIFF_SIZE_T TIFF_UINT64_T
-
-/* Signed size type formatter */
-#  define TIFF_SSIZE_FORMAT TIFF_INT64_FORMAT
-
-/* Signed size type */
-#  define TIFF_SSIZE_T TIFF_INT64_T
-
-#else
-/*
-  Windows 32-bit build
-*/
-
-/* Pointer difference type */
-#  define TIFF_PTRDIFF_T signed int
-
-/* The size of `size_t', as computed by sizeof. */
-#  define SIZEOF_SIZE_T 4
-
-/* Size type formatter */
-#  define TIFF_SIZE_FORMAT "%u"
-
-/* Size type formatter */
-#  define TIFF_SIZE_FORMAT "%u"
-
-/* Unsigned size type */
-#  define TIFF_SIZE_T unsigned int
-
-/* Signed size type formatter */
-#  define TIFF_SSIZE_FORMAT "%d"
-
-/* Signed size type */
-#  define TIFF_SSIZE_T signed int
-
-#endif
-
-/* Set the native cpu bit order */
-#define HOST_FILLORDER FILLORDER_LSB2MSB
-
-/* Visual Studio 2015 / VC 14 / MSVC 19.00 finally has snprintf() */
-#if defined(_MSC_VER) && _MSC_VER < 1900
-#define snprintf _snprintf
-#else
-#define HAVE_SNPRINTF 1
-#endif
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-/* #undef WORDS_BIGENDIAN */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-# ifndef inline
-#  define inline __inline
-# endif
-#endif
-
-#define lfind _lfind
-
-#pragma warning(disable : 4996) /* function deprecation warnings */
-
-#endif /* _TIF_CONFIG_H_ */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/src/3rdparty/libtiff/libtiff/tif_config.wince.h b/src/3rdparty/libtiff/libtiff/tif_config.wince.h
deleted file mode 100644
index e85e2e6..0000000
--- a/src/3rdparty/libtiff/libtiff/tif_config.wince.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * TIFF library configuration header for Windows CE platform.
- */
-#ifndef _WIN32_WCE
-# error This version of tif_config.h header is dedicated for Windows CE platform!
-#endif
-
-/* Define to 1 if you have the <assert.h> header file. */
-#define HAVE_ASSERT_H 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define  HAVE_FCNTL_H 1
-
-/* Define as 0 or 1 according to the floating point format suported by the
-   machine */
-#define HAVE_IEEEFP 1
-
-/* Define to 1 if you have the `jbg_newlen' function. */
-#define HAVE_JBG_NEWLEN 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have the <io.h> header file. */
-#define HAVE_IO_H 1
-
-/* Define to 1 if you have the <search.h> header file. */
-#define HAVE_SEARCH_H 1
-
-/* Define to 1 if you have the `setmode' function. */
-#define HAVE_SETMODE 1
-
-/* Define to 1 if you have the `bsearch' function. */
-#define HAVE_BSEARCH 1
-#define bsearch wceex_bsearch
-
-/* Define to 1 if you have the `lfind' function. */
-#define HAVE_LFIND 1
-#define lfind wceex_lfind
-
-/* The size of a `int', as computed by sizeof. */
-#define SIZEOF_INT 4
-
-/* Set the native cpu bit order */
-#define HOST_FILLORDER FILLORDER_LSB2MSB
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-/* #undef WORDS_BIGENDIAN */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-# ifndef inline
-#  define inline __inline
-# endif
-#endif
-
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/src/3rdparty/libtiff/libtiff/tif_dir.c b/src/3rdparty/libtiff/libtiff/tif_dir.c
index 1e0a76c..a6c254f 100644
--- a/src/3rdparty/libtiff/libtiff/tif_dir.c
+++ b/src/3rdparty/libtiff/libtiff/tif_dir.c
@@ -29,6 +29,7 @@
  * (and also some miscellaneous stuff)
  */
 #include "tiffiop.h"
+#include <float.h>	/*--: for Rational2Double */
 
 /*
  * These are used in the backwards compatibility code...
@@ -53,21 +54,21 @@ setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)
 			_TIFFmemcpy(*vpp, vp, bytes);
 	}
 }
-void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)
+void _TIFFsetByteArray(void** vpp, void* vp, uint32_t n)
     { setByteArray(vpp, vp, n, 1); }
 void _TIFFsetString(char** cpp, char* cp)
     { setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); }
-static void _TIFFsetNString(char** cpp, char* cp, uint32 n)
+static void _TIFFsetNString(char** cpp, char* cp, uint32_t n)
     { setByteArray((void**) cpp, (void*) cp, n, 1); }
-void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)
-    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }
-void _TIFFsetLongArray(uint32** lpp, uint32* lp, uint32 n)
-    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); }
-static void _TIFFsetLong8Array(uint64** lpp, uint64* lp, uint32 n)
-    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint64)); }
-void _TIFFsetFloatArray(float** fpp, float* fp, uint32 n)
+void _TIFFsetShortArray(uint16_t** wpp, uint16_t* wp, uint32_t n)
+    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16_t)); }
+void _TIFFsetLongArray(uint32_t** lpp, uint32_t* lp, uint32_t n)
+    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32_t)); }
+static void _TIFFsetLong8Array(uint64_t** lpp, uint64_t* lp, uint32_t n)
+    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint64_t)); }
+void _TIFFsetFloatArray(float** fpp, float* fp, uint32_t n)
     { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }
-void _TIFFsetDoubleArray(double** dpp, double* dp, uint32 n)
+void _TIFFsetDoubleArray(double** dpp, double* dp, uint32_t n)
     { setByteArray((void**) dpp, (void*) dp, n, sizeof (double)); }
 
 static void
@@ -87,20 +88,20 @@ setDoubleArrayOneValue(double** vpp, double value, size_t nmemb)
  * Install extra samples information.
  */
 static int
-setExtraSamples(TIFF* tif, va_list ap, uint32* v)
+setExtraSamples(TIFF* tif, va_list ap, uint32_t* v)
 {
 /* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */
 #define EXTRASAMPLE_COREL_UNASSALPHA 999 
 
-	uint16* va;
-	uint32 i;
+	uint16_t* va;
+	uint32_t i;
         TIFFDirectory* td = &tif->tif_dir;
         static const char module[] = "setExtraSamples";
 
-	*v = (uint16) va_arg(ap, uint16_vap);
-	if ((uint16) *v > td->td_samplesperpixel)
+	*v = (uint16_t) va_arg(ap, uint16_vap);
+	if ((uint16_t) *v > td->td_samplesperpixel)
 		return 0;
-	va = va_arg(ap, uint16*);
+	va = va_arg(ap, uint16_t*);
 	if (*v > 0 && va == NULL)		/* typically missing param */
 		return 0;
 	for (i = 0; i < *v; i++) {
@@ -123,13 +124,13 @@ setExtraSamples(TIFF* tif, va_list ap, uint32* v)
         {
                 TIFFWarningExt(tif->tif_clientdata,module,
                     "ExtraSamples tag value is changing, "
-                    "but TransferFunction was read with a different value. Cancelling it");
+                    "but TransferFunction was read with a different value. Canceling it");
                 TIFFClrFieldBit(tif,FIELD_TRANSFERFUNCTION);
                 _TIFFfree(td->td_transferfunction[0]);
                 td->td_transferfunction[0] = NULL;
         }
 
-	td->td_extrasamples = (uint16) *v;
+	td->td_extrasamples = (uint16_t) *v;
 	_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);
 	return 1;
 
@@ -140,11 +141,11 @@ setExtraSamples(TIFF* tif, va_list ap, uint32* v)
  * Confirm we have "samplesperpixel" ink names separated by \0.  Returns 
  * zero if the ink names are not as expected.
  */
-static uint32
-checkInkNamesString(TIFF* tif, uint32 slen, const char* s)
+static uint32_t
+checkInkNamesString(TIFF* tif, uint32_t slen, const char* s)
 {
 	TIFFDirectory* td = &tif->tif_dir;
-	uint16 i = td->td_samplesperpixel;
+	uint16_t i = td->td_samplesperpixel;
 
 	if (slen > 0) {
 		const char* ep = s+slen;
@@ -155,29 +156,29 @@ checkInkNamesString(TIFF* tif, uint32 slen, const char* s)
 				goto bad;
 			cp++;				/* skip \0 */
 		}
-		return ((uint32)(cp-s));
+		return ((uint32_t)(cp - s));
 	}
 bad:
 	TIFFErrorExt(tif->tif_clientdata, "TIFFSetField",
-	    "%s: Invalid InkNames value; expecting %d names, found %d",
+	    "%s: Invalid InkNames value; expecting %"PRIu16" names, found %"PRIu16,
 	    tif->tif_name,
 	    td->td_samplesperpixel,
-	    td->td_samplesperpixel-i);
+	    (uint16_t)(td->td_samplesperpixel-i));
 	return (0);
 }
 
 static int
-_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
+_TIFFVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	static const char module[] = "_TIFFVSetField";
 
 	TIFFDirectory* td = &tif->tif_dir;
 	int status = 1;
-	uint32 v32, i, v;
+	uint32_t v32, i, v;
     double dblval;
 	char* s;
 	const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);
-	uint32 standard_tag = tag;
+	uint32_t standard_tag = tag;
 	if( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */
 	    return 0;
 	/*
@@ -192,20 +193,20 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 
 	switch (standard_tag) {
 	case TIFFTAG_SUBFILETYPE:
-		td->td_subfiletype = (uint32) va_arg(ap, uint32);
+		td->td_subfiletype = (uint32_t) va_arg(ap, uint32_t);
 		break;
 	case TIFFTAG_IMAGEWIDTH:
-		td->td_imagewidth = (uint32) va_arg(ap, uint32);
+		td->td_imagewidth = (uint32_t) va_arg(ap, uint32_t);
 		break;
 	case TIFFTAG_IMAGELENGTH:
-		td->td_imagelength = (uint32) va_arg(ap, uint32);
+		td->td_imagelength = (uint32_t) va_arg(ap, uint32_t);
 		break;
 	case TIFFTAG_BITSPERSAMPLE:
-		td->td_bitspersample = (uint16) va_arg(ap, uint16_vap);
+		td->td_bitspersample = (uint16_t) va_arg(ap, uint16_vap);
 		/*
 		 * If the data require post-decoding processing to byte-swap
 		 * samples, set it up here.  Note that since tags are required
-		 * to be ordered, compression code can override this behaviour
+		 * to be ordered, compression code can override this behavior
 		 * in the setup method if it wants to roll the post decoding
 		 * work in with its normal work.
 		 */
@@ -225,14 +226,14 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		}
 		break;
 	case TIFFTAG_COMPRESSION:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		/*
 		 * If we're changing the compression scheme, the notify the
 		 * previous module so that it can cleanup any state it's
 		 * setup.
 		 */
 		if (TIFFFieldSet(tif, FIELD_COMPRESSION)) {
-			if ((uint32)td->td_compression == v)
+			if ((uint32_t)td->td_compression == v)
 				break;
 			(*tif->tif_cleanup)(tif);
 			tif->tif_flags &= ~TIFF_CODERSETUP;
@@ -241,31 +242,31 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		 * Setup new compression routine state.
 		 */
 		if( (status = TIFFSetCompressionScheme(tif, v)) != 0 )
-		    td->td_compression = (uint16) v;
+		    td->td_compression = (uint16_t) v;
 		else
 		    status = 0;
 		break;
 	case TIFFTAG_PHOTOMETRIC:
-		td->td_photometric = (uint16) va_arg(ap, uint16_vap);
+		td->td_photometric = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_THRESHHOLDING:
-		td->td_threshholding = (uint16) va_arg(ap, uint16_vap);
+		td->td_threshholding = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_FILLORDER:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		if (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)
 			goto badvalue;
-		td->td_fillorder = (uint16) v;
+		td->td_fillorder = (uint16_t) v;
 		break;
 	case TIFFTAG_ORIENTATION:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		if (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)
 			goto badvalue;
 		else
-			td->td_orientation = (uint16) v;
+			td->td_orientation = (uint16_t) v;
 		break;
 	case TIFFTAG_SAMPLESPERPIXEL:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		if (v == 0)
 			goto badvalue;
         if( v != td->td_samplesperpixel )
@@ -275,7 +276,7 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
             {
                 TIFFWarningExt(tif->tif_clientdata,module,
                     "SamplesPerPixel tag value is changing, "
-                    "but SMinSampleValue tag was read with a different value. Cancelling it");
+                    "but SMinSampleValue tag was read with a different value. Canceling it");
                 TIFFClrFieldBit(tif,FIELD_SMINSAMPLEVALUE);
                 _TIFFfree(td->td_sminsamplevalue);
                 td->td_sminsamplevalue = NULL;
@@ -284,7 +285,7 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
             {
                 TIFFWarningExt(tif->tif_clientdata,module,
                     "SamplesPerPixel tag value is changing, "
-                    "but SMaxSampleValue tag was read with a different value. Cancelling it");
+                    "but SMaxSampleValue tag was read with a different value. Canceling it");
                 TIFFClrFieldBit(tif,FIELD_SMAXSAMPLEVALUE);
                 _TIFFfree(td->td_smaxsamplevalue);
                 td->td_smaxsamplevalue = NULL;
@@ -296,16 +297,16 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
             {
                     TIFFWarningExt(tif->tif_clientdata,module,
                         "SamplesPerPixel tag value is changing, "
-                        "but TransferFunction was read with a different value. Cancelling it");
+                        "but TransferFunction was read with a different value. Canceling it");
                     TIFFClrFieldBit(tif,FIELD_TRANSFERFUNCTION);
                     _TIFFfree(td->td_transferfunction[0]);
                     td->td_transferfunction[0] = NULL;
             }
         }
-		td->td_samplesperpixel = (uint16) v;
+		td->td_samplesperpixel = (uint16_t) v;
 		break;
 	case TIFFTAG_ROWSPERSTRIP:
-		v32 = (uint32) va_arg(ap, uint32);
+		v32 = (uint32_t) va_arg(ap, uint32_t);
 		if (v32 == 0)
 			goto badvalue32;
 		td->td_rowsperstrip = v32;
@@ -315,10 +316,10 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		}
 		break;
 	case TIFFTAG_MINSAMPLEVALUE:
-		td->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);
+		td->td_minsamplevalue = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_MAXSAMPLEVALUE:
-		td->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);
+		td->td_maxsamplevalue = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_SMINSAMPLEVALUE:
 		if (tif->tif_flags & TIFF_PERSAMPLE)
@@ -345,10 +346,10 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		td->td_yresolution = _TIFFClampDoubleToFloat( dblval );
 		break;
 	case TIFFTAG_PLANARCONFIG:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		if (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)
 			goto badvalue;
-		td->td_planarconfig = (uint16) v;
+		td->td_planarconfig = (uint16_t) v;
 		break;
 	case TIFFTAG_XPOSITION:
 		td->td_xposition = _TIFFClampDoubleToFloat( va_arg(ap, double) );
@@ -357,66 +358,66 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		td->td_yposition = _TIFFClampDoubleToFloat( va_arg(ap, double) );
 		break;
 	case TIFFTAG_RESOLUTIONUNIT:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		if (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)
 			goto badvalue;
-		td->td_resolutionunit = (uint16) v;
+		td->td_resolutionunit = (uint16_t) v;
 		break;
 	case TIFFTAG_PAGENUMBER:
-		td->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);
-		td->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);
+		td->td_pagenumber[0] = (uint16_t) va_arg(ap, uint16_vap);
+		td->td_pagenumber[1] = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_HALFTONEHINTS:
-		td->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);
-		td->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);
+		td->td_halftonehints[0] = (uint16_t) va_arg(ap, uint16_vap);
+		td->td_halftonehints[1] = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_COLORMAP:
-		v32 = (uint32)(1L<<td->td_bitspersample);
-		_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);
-		_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);
-		_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);
+		v32 = (uint32_t)(1L << td->td_bitspersample);
+		_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16_t*), v32);
+		_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16_t*), v32);
+		_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16_t*), v32);
 		break;
 	case TIFFTAG_EXTRASAMPLES:
 		if (!setExtraSamples(tif, ap, &v))
 			goto badvalue;
 		break;
 	case TIFFTAG_MATTEING:
-		td->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);
+		td->td_extrasamples =  (((uint16_t) va_arg(ap, uint16_vap)) != 0);
 		if (td->td_extrasamples) {
-			uint16 sv = EXTRASAMPLE_ASSOCALPHA;
+			uint16_t sv = EXTRASAMPLE_ASSOCALPHA;
 			_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);
 		}
 		break;
 	case TIFFTAG_TILEWIDTH:
-		v32 = (uint32) va_arg(ap, uint32);
+		v32 = (uint32_t) va_arg(ap, uint32_t);
 		if (v32 % 16) {
 			if (tif->tif_mode != O_RDONLY)
 				goto badvalue32;
 			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-				"Nonstandard tile width %d, convert file", v32);
+				"Nonstandard tile width %"PRIu32", convert file", v32);
 		}
 		td->td_tilewidth = v32;
 		tif->tif_flags |= TIFF_ISTILED;
 		break;
 	case TIFFTAG_TILELENGTH:
-		v32 = (uint32) va_arg(ap, uint32);
+		v32 = (uint32_t) va_arg(ap, uint32_t);
 		if (v32 % 16) {
 			if (tif->tif_mode != O_RDONLY)
 				goto badvalue32;
 			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-			    "Nonstandard tile length %d, convert file", v32);
+			    "Nonstandard tile length %"PRIu32", convert file", v32);
 		}
 		td->td_tilelength = v32;
 		tif->tif_flags |= TIFF_ISTILED;
 		break;
 	case TIFFTAG_TILEDEPTH:
-		v32 = (uint32) va_arg(ap, uint32);
+		v32 = (uint32_t) va_arg(ap, uint32_t);
 		if (v32 == 0)
 			goto badvalue32;
 		td->td_tiledepth = v32;
 		break;
 	case TIFFTAG_DATATYPE:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		switch (v) {
 		case DATATYPE_VOID:	v = SAMPLEFORMAT_VOID;	break;
 		case DATATYPE_INT:	v = SAMPLEFORMAT_INT;	break;
@@ -424,13 +425,13 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		case DATATYPE_IEEEFP:	v = SAMPLEFORMAT_IEEEFP;break;
 		default:		goto badvalue;
 		}
-		td->td_sampleformat = (uint16) v;
+		td->td_sampleformat = (uint16_t) v;
 		break;
 	case TIFFTAG_SAMPLEFORMAT:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		if (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)
 			goto badvalue;
-		td->td_sampleformat = (uint16) v;
+		td->td_sampleformat = (uint16_t) v;
 
 		/*  Try to fix up the SWAB function for complex data. */
 		if( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT
@@ -444,13 +445,13 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		    tif->tif_postdecode = _TIFFSwab32BitData;
 		break;
 	case TIFFTAG_IMAGEDEPTH:
-		td->td_imagedepth = (uint32) va_arg(ap, uint32);
+		td->td_imagedepth = (uint32_t) va_arg(ap, uint32_t);
 		break;
 	case TIFFTAG_SUBIFD:
 		if ((tif->tif_flags & TIFF_INSUBIFD) == 0) {
-			td->td_nsubifd = (uint16) va_arg(ap, uint16_vap);
-			_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),
-			    (uint32) td->td_nsubifd);
+			td->td_nsubifd = (uint16_t) va_arg(ap, uint16_vap);
+			_TIFFsetLong8Array(&td->td_subifd, (uint64_t*) va_arg(ap, uint64_t*),
+			    (uint32_t) td->td_nsubifd);
 		} else {
 			TIFFErrorExt(tif->tif_clientdata, module,
 				     "%s: Sorry, cannot nest SubIFDs",
@@ -459,24 +460,24 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		}
 		break;
 	case TIFFTAG_YCBCRPOSITIONING:
-		td->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);
+		td->td_ycbcrpositioning = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_YCBCRSUBSAMPLING:
-		td->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);
-		td->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);
+		td->td_ycbcrsubsampling[0] = (uint16_t) va_arg(ap, uint16_vap);
+		td->td_ycbcrsubsampling[1] = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_TRANSFERFUNCTION:
 		v = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;
 		for (i = 0; i < v; i++)
 			_TIFFsetShortArray(&td->td_transferfunction[i],
-			    va_arg(ap, uint16*), 1U<<td->td_bitspersample);
+                               va_arg(ap, uint16_t*), 1U << td->td_bitspersample);
 		break;
 	case TIFFTAG_REFERENCEBLACKWHITE:
 		/* XXX should check for null range */
 		_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);
 		break;
 	case TIFFTAG_INKNAMES:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		s = va_arg(ap, char*);
 		v = checkInkNamesString(tif, v, s);
 		status = v > 0;
@@ -486,7 +487,7 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		}
 		break;
 	case TIFFTAG_PERSAMPLE:
-		v = (uint16) va_arg(ap, uint16_vap);
+		v = (uint16_t) va_arg(ap, uint16_vap);
 		if( v == PERSAMPLE_MULTI )
 			tif->tif_flags |= TIFF_PERSAMPLE;
 		else
@@ -559,6 +560,10 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		 * Set custom value ... save a copy of the custom tag value.
 		 */
 		tv_size = _TIFFDataSize(fip->field_type);
+		/*--: Rational2Double: For Rationals evaluate "set_field_type" to determine internal storage size. */
+		if (fip->field_type == TIFF_RATIONAL || fip->field_type == TIFF_SRATIONAL) {
+			tv_size = _TIFFSetGetFieldSize(fip->set_field_type);
+		}
 		if (tv_size == 0) {
 			status = 0;
 			TIFFErrorExt(tif->tif_clientdata, module,
@@ -570,18 +575,18 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 
 		if (fip->field_type == TIFF_ASCII)
 		{
-			uint32 ma;
+			uint32_t ma;
 			char* mb;
 			if (fip->field_passcount)
 			{
 				assert(fip->field_writecount==TIFF_VARIABLE2);
-				ma=(uint32)va_arg(ap,uint32);
+				ma=(uint32_t)va_arg(ap, uint32_t);
 				mb=(char*)va_arg(ap,char*);
 			}
 			else
 			{
 				mb=(char*)va_arg(ap,char*);
-				ma=(uint32)(strlen(mb)+1);
+				ma=(uint32_t)(strlen(mb) + 1);
 			}
 			tv->count=ma;
 			setByteArray(&tv->value,mb,ma,1);
@@ -590,7 +595,7 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		{
 			if (fip->field_passcount) {
 				if (fip->field_writecount == TIFF_VARIABLE2)
-					tv->count = (uint32) va_arg(ap, uint32);
+					tv->count = (uint32_t) va_arg(ap, uint32_t);
 				else
 					tv->count = (int) va_arg(ap, int);
 			} else if (fip->field_writecount == TIFF_VARIABLE
@@ -627,9 +632,9 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 				   handled this way ... likely best if we move it into
 				   the directory structure with an explicit field in 
 				   libtiff 4.1 and assign it a FIELD_ value */
-				uint16 v2[2];
-				v2[0] = (uint16)va_arg(ap, int);
-				v2[1] = (uint16)va_arg(ap, int);
+				uint16_t v2[2];
+				v2[0] = (uint16_t)va_arg(ap, int);
+				v2[1] = (uint16_t)va_arg(ap, int);
 				_TIFFmemcpy(tv->value, &v2, 4);
 			}
 
@@ -638,6 +643,7 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 				  || fip->field_writecount == TIFF_VARIABLE2
 				  || fip->field_writecount == TIFF_SPP
 				  || tv->count > 1) {
+			  /*--: Rational2Double: For Rationals tv_size is set above to 4 or 8 according to fip->set_field_type! */
 				_TIFFmemcpy(tv->value, va_arg(ap, void *),
 				    tv->count * tv_size);
 			} else {
@@ -648,56 +654,72 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 				case TIFF_BYTE:
 				case TIFF_UNDEFINED:
 					{
-						uint8 v2 = (uint8)va_arg(ap, int);
+						uint8_t v2 = (uint8_t)va_arg(ap, int);
 						_TIFFmemcpy(val, &v2, tv_size);
 					}
 					break;
 				case TIFF_SBYTE:
 					{
-						int8 v2 = (int8)va_arg(ap, int);
+						int8_t v2 = (int8_t)va_arg(ap, int);
 						_TIFFmemcpy(val, &v2, tv_size);
 					}
 					break;
 				case TIFF_SHORT:
 					{
-						uint16 v2 = (uint16)va_arg(ap, int);
+						uint16_t v2 = (uint16_t)va_arg(ap, int);
 						_TIFFmemcpy(val, &v2, tv_size);
 					}
 					break;
 				case TIFF_SSHORT:
 					{
-						int16 v2 = (int16)va_arg(ap, int);
+						int16_t v2 = (int16_t)va_arg(ap, int);
 						_TIFFmemcpy(val, &v2, tv_size);
 					}
 					break;
 				case TIFF_LONG:
 				case TIFF_IFD:
 					{
-						uint32 v2 = va_arg(ap, uint32);
+						uint32_t v2 = va_arg(ap, uint32_t);
 						_TIFFmemcpy(val, &v2, tv_size);
 					}
 					break;
 				case TIFF_SLONG:
 					{
-						int32 v2 = va_arg(ap, int32);
+						int32_t v2 = va_arg(ap, int32_t);
 						_TIFFmemcpy(val, &v2, tv_size);
 					}
 					break;
 				case TIFF_LONG8:
 				case TIFF_IFD8:
 					{
-						uint64 v2 = va_arg(ap, uint64);
+						uint64_t v2 = va_arg(ap, uint64_t);
 						_TIFFmemcpy(val, &v2, tv_size);
 					}
 					break;
 				case TIFF_SLONG8:
 					{
-						int64 v2 = va_arg(ap, int64);
+						int64_t v2 = va_arg(ap, int64_t);
 						_TIFFmemcpy(val, &v2, tv_size);
 					}
 					break;
 				case TIFF_RATIONAL:
 				case TIFF_SRATIONAL:
+					/*-- Rational2Double: For Rationals tv_size is set above to 4 or 8 according to fip->set_field_type! */
+					{
+						if (tv_size == 8) {
+							double v2 = va_arg(ap, double);
+							_TIFFmemcpy(val, &v2, tv_size);
+						} else {
+							/*-- default should be tv_size == 4 */
+							float v3 = (float)va_arg(ap, double);
+							_TIFFmemcpy(val, &v3, tv_size);
+							/*-- ToDo: After Testing, this should be removed and tv_size==4 should be set as default. */
+							if (tv_size != 4) {
+								TIFFErrorExt(0,"TIFFLib: _TIFFVSetField()", "Rational2Double: .set_field_type in not 4 but %d", tv_size); 
+							}
+						}
+					}
+					break;
 				case TIFF_FLOAT:
 					{
 						float v2 = _TIFFClampDoubleToFloat(va_arg(ap, double));
@@ -733,7 +755,7 @@ badvalue:
         {
 		const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
 		TIFFErrorExt(tif->tif_clientdata, module,
-		     "%s: Bad value %u for \"%s\" tag",
+		     "%s: Bad value %"PRIu32" for \"%s\" tag",
 		     tif->tif_name, v,
 		     fip2 ? fip2->field_name : "Unknown");
 		va_end(ap);
@@ -743,7 +765,7 @@ badvalue32:
         {
 		const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
 		TIFFErrorExt(tif->tif_clientdata, module,
-		     "%s: Bad value %u for \"%s\" tag",
+		     "%s: Bad value %"PRIu32" for \"%s\" tag",
 		     tif->tif_name, v32,
 		     fip2 ? fip2->field_name : "Unknown");
 		va_end(ap);
@@ -771,11 +793,11 @@ badvaluedouble:
  * on the format of the data that is written.
  */
 static int
-OkToChangeTag(TIFF* tif, uint32 tag)
+OkToChangeTag(TIFF* tif, uint32_t tag)
 {
 	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
 	if (!fip) {			/* unknown tag */
-		TIFFErrorExt(tif->tif_clientdata, "TIFFSetField", "%s: Unknown %stag %u",
+		TIFFErrorExt(tif->tif_clientdata, "TIFFSetField", "%s: Unknown %stag %"PRIu32,
 		    tif->tif_name, isPseudoTag(tag) ? "pseudo-" : "", tag);
 		return (0);
 	}
@@ -803,7 +825,7 @@ OkToChangeTag(TIFF* tif, uint32 tag)
  * updated.
  */
 int
-TIFFSetField(TIFF* tif, uint32 tag, ...)
+TIFFSetField(TIFF* tif, uint32_t tag, ...)
 {
 	va_list ap;
 	int status;
@@ -818,7 +840,7 @@ TIFFSetField(TIFF* tif, uint32 tag, ...)
  * Clear the contents of the field in the internal structure.
  */
 int
-TIFFUnsetField(TIFF* tif, uint32 tag)
+TIFFUnsetField(TIFF* tif, uint32_t tag)
 {
     const TIFFField *fip =  TIFFFieldWithTag(tif, tag);
     TIFFDirectory* td = &tif->tif_dir;
@@ -862,18 +884,18 @@ TIFFUnsetField(TIFF* tif, uint32 tag)
  * top of the library.
  */
 int
-TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
+TIFFVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	return OkToChangeTag(tif, tag) ?
 	    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;
 }
 
 static int
-_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
+_TIFFVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	TIFFDirectory* td = &tif->tif_dir;
 	int ret_val = 1;
-	uint32 standard_tag = tag;
+	uint32_t standard_tag = tag;
 	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
 	if( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */
 	    return 0;
@@ -892,13 +914,13 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
         {
             int i;
             for (i = 0; i < td->td_customValueCount; i++) {
-                uint16 val;
+                uint16_t val;
                 TIFFTagValue *tv = td->td_customValues + i;
                 if (tv->info->field_tag != standard_tag)
                     continue;
                 if( tv->value == NULL )
                     return 0;
-                val = *(uint16 *)tv->value;
+                val = *(uint16_t *)tv->value;
                 /* Truncate to SamplesPerPixel, since the */
                 /* setting code for INKNAMES assume that there are SamplesPerPixel */
                 /* inknames. */
@@ -906,11 +928,11 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
                 if( val > td->td_samplesperpixel )
                 {
                     TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",
-                                   "Truncating NumberOfInks from %u to %u",
+                                   "Truncating NumberOfInks from %u to %"PRIu16,
                                    val, td->td_samplesperpixel);
                     val = td->td_samplesperpixel;
                 }
-                *va_arg(ap, uint16*) = val;
+                *va_arg(ap, uint16_t*) = val;
                 return 1;
             }
             return 0;
@@ -918,43 +940,43 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 
 	switch (standard_tag) {
 		case TIFFTAG_SUBFILETYPE:
-			*va_arg(ap, uint32*) = td->td_subfiletype;
+			*va_arg(ap, uint32_t*) = td->td_subfiletype;
 			break;
 		case TIFFTAG_IMAGEWIDTH:
-			*va_arg(ap, uint32*) = td->td_imagewidth;
+			*va_arg(ap, uint32_t*) = td->td_imagewidth;
 			break;
 		case TIFFTAG_IMAGELENGTH:
-			*va_arg(ap, uint32*) = td->td_imagelength;
+			*va_arg(ap, uint32_t*) = td->td_imagelength;
 			break;
 		case TIFFTAG_BITSPERSAMPLE:
-			*va_arg(ap, uint16*) = td->td_bitspersample;
+			*va_arg(ap, uint16_t*) = td->td_bitspersample;
 			break;
 		case TIFFTAG_COMPRESSION:
-			*va_arg(ap, uint16*) = td->td_compression;
+			*va_arg(ap, uint16_t*) = td->td_compression;
 			break;
 		case TIFFTAG_PHOTOMETRIC:
-			*va_arg(ap, uint16*) = td->td_photometric;
+			*va_arg(ap, uint16_t*) = td->td_photometric;
 			break;
 		case TIFFTAG_THRESHHOLDING:
-			*va_arg(ap, uint16*) = td->td_threshholding;
+			*va_arg(ap, uint16_t*) = td->td_threshholding;
 			break;
 		case TIFFTAG_FILLORDER:
-			*va_arg(ap, uint16*) = td->td_fillorder;
+			*va_arg(ap, uint16_t*) = td->td_fillorder;
 			break;
 		case TIFFTAG_ORIENTATION:
-			*va_arg(ap, uint16*) = td->td_orientation;
+			*va_arg(ap, uint16_t*) = td->td_orientation;
 			break;
 		case TIFFTAG_SAMPLESPERPIXEL:
-			*va_arg(ap, uint16*) = td->td_samplesperpixel;
+			*va_arg(ap, uint16_t*) = td->td_samplesperpixel;
 			break;
 		case TIFFTAG_ROWSPERSTRIP:
-			*va_arg(ap, uint32*) = td->td_rowsperstrip;
+			*va_arg(ap, uint32_t*) = td->td_rowsperstrip;
 			break;
 		case TIFFTAG_MINSAMPLEVALUE:
-			*va_arg(ap, uint16*) = td->td_minsamplevalue;
+			*va_arg(ap, uint16_t*) = td->td_minsamplevalue;
 			break;
 		case TIFFTAG_MAXSAMPLEVALUE:
-			*va_arg(ap, uint16*) = td->td_maxsamplevalue;
+			*va_arg(ap, uint16_t*) = td->td_maxsamplevalue;
 			break;
 		case TIFFTAG_SMINSAMPLEVALUE:
 			if (tif->tif_flags & TIFF_PERSAMPLE)
@@ -962,7 +984,7 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 			else
 			{
 				/* libtiff historically treats this as a single value. */
-				uint16 i;
+				uint16_t i;
 				double v = td->td_sminsamplevalue[0];
 				for (i=1; i < td->td_samplesperpixel; ++i)
 					if( td->td_sminsamplevalue[i] < v )
@@ -976,7 +998,7 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 			else
 			{
 				/* libtiff historically treats this as a single value. */
-				uint16 i;
+				uint16_t i;
 				double v = td->td_smaxsamplevalue[0];
 				for (i=1; i < td->td_samplesperpixel; ++i)
 					if( td->td_smaxsamplevalue[i] > v )
@@ -991,7 +1013,7 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 			*va_arg(ap, float*) = td->td_yresolution;
 			break;
 		case TIFFTAG_PLANARCONFIG:
-			*va_arg(ap, uint16*) = td->td_planarconfig;
+			*va_arg(ap, uint16_t*) = td->td_planarconfig;
 			break;
 		case TIFFTAG_XPOSITION:
 			*va_arg(ap, float*) = td->td_xposition;
@@ -1000,97 +1022,97 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 			*va_arg(ap, float*) = td->td_yposition;
 			break;
 		case TIFFTAG_RESOLUTIONUNIT:
-			*va_arg(ap, uint16*) = td->td_resolutionunit;
+			*va_arg(ap, uint16_t*) = td->td_resolutionunit;
 			break;
 		case TIFFTAG_PAGENUMBER:
-			*va_arg(ap, uint16*) = td->td_pagenumber[0];
-			*va_arg(ap, uint16*) = td->td_pagenumber[1];
+			*va_arg(ap, uint16_t*) = td->td_pagenumber[0];
+			*va_arg(ap, uint16_t*) = td->td_pagenumber[1];
 			break;
 		case TIFFTAG_HALFTONEHINTS:
-			*va_arg(ap, uint16*) = td->td_halftonehints[0];
-			*va_arg(ap, uint16*) = td->td_halftonehints[1];
+			*va_arg(ap, uint16_t*) = td->td_halftonehints[0];
+			*va_arg(ap, uint16_t*) = td->td_halftonehints[1];
 			break;
 		case TIFFTAG_COLORMAP:
-			*va_arg(ap, uint16**) = td->td_colormap[0];
-			*va_arg(ap, uint16**) = td->td_colormap[1];
-			*va_arg(ap, uint16**) = td->td_colormap[2];
+			*va_arg(ap, const uint16_t**) = td->td_colormap[0];
+			*va_arg(ap, const uint16_t**) = td->td_colormap[1];
+			*va_arg(ap, const uint16_t**) = td->td_colormap[2];
 			break;
 		case TIFFTAG_STRIPOFFSETS:
 		case TIFFTAG_TILEOFFSETS:
 			_TIFFFillStriles( tif );
-			*va_arg(ap, uint64**) = td->td_stripoffset_p;
+			*va_arg(ap, const uint64_t**) = td->td_stripoffset_p;
 			break;
 		case TIFFTAG_STRIPBYTECOUNTS:
 		case TIFFTAG_TILEBYTECOUNTS:
 			_TIFFFillStriles( tif );
-			*va_arg(ap, uint64**) = td->td_stripbytecount_p;
+			*va_arg(ap, const uint64_t**) = td->td_stripbytecount_p;
 			break;
 		case TIFFTAG_MATTEING:
-			*va_arg(ap, uint16*) =
+			*va_arg(ap, uint16_t*) =
 			    (td->td_extrasamples == 1 &&
 			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
 			break;
 		case TIFFTAG_EXTRASAMPLES:
-			*va_arg(ap, uint16*) = td->td_extrasamples;
-			*va_arg(ap, uint16**) = td->td_sampleinfo;
+			*va_arg(ap, uint16_t*) = td->td_extrasamples;
+			*va_arg(ap, const uint16_t**) = td->td_sampleinfo;
 			break;
 		case TIFFTAG_TILEWIDTH:
-			*va_arg(ap, uint32*) = td->td_tilewidth;
+			*va_arg(ap, uint32_t*) = td->td_tilewidth;
 			break;
 		case TIFFTAG_TILELENGTH:
-			*va_arg(ap, uint32*) = td->td_tilelength;
+			*va_arg(ap, uint32_t*) = td->td_tilelength;
 			break;
 		case TIFFTAG_TILEDEPTH:
-			*va_arg(ap, uint32*) = td->td_tiledepth;
+			*va_arg(ap, uint32_t*) = td->td_tiledepth;
 			break;
 		case TIFFTAG_DATATYPE:
 			switch (td->td_sampleformat) {
 				case SAMPLEFORMAT_UINT:
-					*va_arg(ap, uint16*) = DATATYPE_UINT;
+					*va_arg(ap, uint16_t*) = DATATYPE_UINT;
 					break;
 				case SAMPLEFORMAT_INT:
-					*va_arg(ap, uint16*) = DATATYPE_INT;
+					*va_arg(ap, uint16_t*) = DATATYPE_INT;
 					break;
 				case SAMPLEFORMAT_IEEEFP:
-					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;
+					*va_arg(ap, uint16_t*) = DATATYPE_IEEEFP;
 					break;
 				case SAMPLEFORMAT_VOID:
-					*va_arg(ap, uint16*) = DATATYPE_VOID;
+					*va_arg(ap, uint16_t*) = DATATYPE_VOID;
 					break;
 			}
 			break;
 		case TIFFTAG_SAMPLEFORMAT:
-			*va_arg(ap, uint16*) = td->td_sampleformat;
+			*va_arg(ap, uint16_t*) = td->td_sampleformat;
 			break;
 		case TIFFTAG_IMAGEDEPTH:
-			*va_arg(ap, uint32*) = td->td_imagedepth;
+			*va_arg(ap, uint32_t*) = td->td_imagedepth;
 			break;
 		case TIFFTAG_SUBIFD:
-			*va_arg(ap, uint16*) = td->td_nsubifd;
-			*va_arg(ap, uint64**) = td->td_subifd;
+			*va_arg(ap, uint16_t*) = td->td_nsubifd;
+			*va_arg(ap, const uint64_t**) = td->td_subifd;
 			break;
 		case TIFFTAG_YCBCRPOSITIONING:
-			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;
+			*va_arg(ap, uint16_t*) = td->td_ycbcrpositioning;
 			break;
 		case TIFFTAG_YCBCRSUBSAMPLING:
-			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];
-			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];
+			*va_arg(ap, uint16_t*) = td->td_ycbcrsubsampling[0];
+			*va_arg(ap, uint16_t*) = td->td_ycbcrsubsampling[1];
 			break;
 		case TIFFTAG_TRANSFERFUNCTION:
-			*va_arg(ap, uint16**) = td->td_transferfunction[0];
+			*va_arg(ap, const uint16_t**) = td->td_transferfunction[0];
 			if (td->td_samplesperpixel - td->td_extrasamples > 1) {
-				*va_arg(ap, uint16**) = td->td_transferfunction[1];
-				*va_arg(ap, uint16**) = td->td_transferfunction[2];
+				*va_arg(ap, const uint16_t**) = td->td_transferfunction[1];
+				*va_arg(ap, const uint16_t**) = td->td_transferfunction[2];
 			} else {
-				*va_arg(ap, uint16**) = NULL;
-				*va_arg(ap, uint16**) = NULL;
+				*va_arg(ap, const uint16_t**) = NULL;
+				*va_arg(ap, const uint16_t**) = NULL;
 			}
 			break;
 		case TIFFTAG_REFERENCEBLACKWHITE:
-			*va_arg(ap, float**) = td->td_refblackwhite;
+			*va_arg(ap, const float**) = td->td_refblackwhite;
 			break;
 		case TIFFTAG_INKNAMES:
-			*va_arg(ap, char**) = td->td_inknames;
+			*va_arg(ap, const char**) = td->td_inknames;
 			break;
 		default:
 			{
@@ -1129,10 +1151,10 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 
 					if (fip->field_passcount) {
 						if (fip->field_readcount == TIFF_VARIABLE2)
-							*va_arg(ap, uint32*) = (uint32)tv->count;
+							*va_arg(ap, uint32_t*) = (uint32_t)tv->count;
 						else  /* Assume TIFF_VARIABLE */
-							*va_arg(ap, uint16*) = (uint16)tv->count;
-						*va_arg(ap, void **) = tv->value;
+							*va_arg(ap, uint16_t*) = (uint16_t)tv->count;
+						*va_arg(ap, const void **) = tv->value;
 						ret_val = 1;
 					} else if (fip->field_tag == TIFFTAG_DOTRANGE
 						   && strcmp(fip->field_name,"DotRange") == 0) {
@@ -1140,8 +1162,8 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 						   handled this way ... likely best if we move it into
 						   the directory structure with an explicit field in 
 						   libtiff 4.1 and assign it a FIELD_ value */
-						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];
-						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];
+						*va_arg(ap, uint16_t*) = ((uint16_t *)tv->value)[0];
+						*va_arg(ap, uint16_t*) = ((uint16_t *)tv->value)[1];
 						ret_val = 1;
 					} else {
 						if (fip->field_type == TIFF_ASCII
@@ -1157,49 +1179,66 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 							switch (fip->field_type) {
 							case TIFF_BYTE:
 							case TIFF_UNDEFINED:
-								*va_arg(ap, uint8*) =
-									*(uint8 *)val;
+								*va_arg(ap, uint8_t*) =
+									*(uint8_t *)val;
 								ret_val = 1;
 								break;
 							case TIFF_SBYTE:
-								*va_arg(ap, int8*) =
-									*(int8 *)val;
+								*va_arg(ap, int8_t*) =
+									*(int8_t *)val;
 								ret_val = 1;
 								break;
 							case TIFF_SHORT:
-								*va_arg(ap, uint16*) =
-									*(uint16 *)val;
+								*va_arg(ap, uint16_t*) =
+									*(uint16_t *)val;
 								ret_val = 1;
 								break;
 							case TIFF_SSHORT:
-								*va_arg(ap, int16*) =
-									*(int16 *)val;
+								*va_arg(ap, int16_t*) =
+									*(int16_t *)val;
 								ret_val = 1;
 								break;
 							case TIFF_LONG:
 							case TIFF_IFD:
-								*va_arg(ap, uint32*) =
-									*(uint32 *)val;
+								*va_arg(ap, uint32_t*) =
+									*(uint32_t *)val;
 								ret_val = 1;
 								break;
 							case TIFF_SLONG:
-								*va_arg(ap, int32*) =
-									*(int32 *)val;
+								*va_arg(ap, int32_t*) =
+									*(int32_t *)val;
 								ret_val = 1;
 								break;
 							case TIFF_LONG8:
 							case TIFF_IFD8:
-								*va_arg(ap, uint64*) =
-									*(uint64 *)val;
+								*va_arg(ap, uint64_t*) =
+									*(uint64_t *)val;
 								ret_val = 1;
 								break;
 							case TIFF_SLONG8:
-								*va_arg(ap, int64*) =
-									*(int64 *)val;
+								*va_arg(ap, int64_t*) =
+									*(int64_t *)val;
 								ret_val = 1;
 								break;
 							case TIFF_RATIONAL:
 							case TIFF_SRATIONAL:
+								{
+									/*-- Rational2Double: For Rationals evaluate "set_field_type" to determine internal storage size and return value size. */
+									int tv_size = _TIFFSetGetFieldSize(fip->set_field_type);
+									if (tv_size == 8) {
+										*va_arg(ap, double*) = *(double *)val;
+										ret_val = 1;
+									} else {
+										/*-- default should be tv_size == 4  */
+										*va_arg(ap, float*) = *(float *)val;
+										ret_val = 1;
+										/*-- ToDo: After Testing, this should be removed and tv_size==4 should be set as default. */
+										if (tv_size != 4) {
+											TIFFErrorExt(0,"TIFFLib: _TIFFVGetField()", "Rational2Double: .set_field_type in not 4 but %d", tv_size); 
+										}
+									}
+								}
+								break;
 							case TIFF_FLOAT:
 								*va_arg(ap, float*) =
 									*(float *)val;
@@ -1228,7 +1267,7 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
  * internal directory structure.
  */
 int
-TIFFGetField(TIFF* tif, uint32 tag, ...)
+TIFFGetField(TIFF* tif, uint32_t tag, ...)
 {
 	int status;
 	va_list ap;
@@ -1246,7 +1285,7 @@ TIFFGetField(TIFF* tif, uint32 tag, ...)
  * top of the library.
  */
 int
-TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
+TIFFVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
 	return (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?
@@ -1329,8 +1368,8 @@ TIFFCreateDirectory(TIFF* tif)
 	tif->tif_diroff = 0;
 	tif->tif_nextdiroff = 0;
 	tif->tif_curoff = 0;
-	tif->tif_row = (uint32) -1;
-	tif->tif_curstrip = (uint32) -1;
+	tif->tif_row = (uint32_t) -1;
+	tif->tif_curstrip = (uint32_t) -1;
 
 	return 0;
 }
@@ -1342,7 +1381,7 @@ TIFFCreateCustomDirectory(TIFF* tif, const TIFFFieldArray* infoarray)
 
 	/*
 	 * Reset the field definitions to match the application provided list. 
-	 * Hopefully TIFFDefaultDirectory() won't have done anything irreversable
+	 * Hopefully TIFFDefaultDirectory() won't have done anything irreversible
 	 * based on it's assumption this is an image directory.
 	 */
 	_TIFFSetupFields(tif, infoarray);
@@ -1350,8 +1389,8 @@ TIFFCreateCustomDirectory(TIFF* tif, const TIFFFieldArray* infoarray)
 	tif->tif_diroff = 0;
 	tif->tif_nextdiroff = 0;
 	tif->tif_curoff = 0;
-	tif->tif_row = (uint32) -1;
-	tif->tif_curstrip = (uint32) -1;
+	tif->tif_row = (uint32_t) -1;
+	tif->tif_curstrip = (uint32_t) -1;
 
 	return 0;
 }
@@ -1364,6 +1403,17 @@ TIFFCreateEXIFDirectory(TIFF* tif)
 	return TIFFCreateCustomDirectory(tif, exifFieldArray);
 }
 
+/*
+ * Creates the EXIF GPS custom directory 
+ */
+int
+TIFFCreateGPSDirectory(TIFF* tif)
+{
+	const TIFFFieldArray* gpsFieldArray;
+	gpsFieldArray = _TIFFGetGpsFields();
+	return TIFFCreateCustomDirectory(tif, gpsFieldArray);
+}
+
 /*
  * Setup a default directory structure.
  */
@@ -1382,7 +1432,7 @@ TIFFDefaultDirectory(TIFF* tif)
 	td->td_threshholding = THRESHHOLD_BILEVEL;
 	td->td_orientation = ORIENTATION_TOPLEFT;
 	td->td_samplesperpixel = 1;
-	td->td_rowsperstrip = (uint32) -1;
+	td->td_rowsperstrip = (uint32_t) -1;
 	td->td_tilewidth = 0;
 	td->td_tilelength = 0;
 	td->td_tiledepth = 1;
@@ -1406,7 +1456,7 @@ TIFFDefaultDirectory(TIFF* tif)
 	 *  but do some prior cleanup first. (http://trac.osgeo.org/gdal/ticket/5054)
 	 */
 	if (tif->tif_nfieldscompat > 0) {
-		uint32 i;
+		uint32_t i;
 
 		for (i = 0; i < tif->tif_nfieldscompat; i++) {
 				if (tif->tif_fieldscompat[i].allocated_size)
@@ -1440,38 +1490,38 @@ TIFFDefaultDirectory(TIFF* tif)
 }
 
 static int
-TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
+TIFFAdvanceDirectory(TIFF* tif, uint64_t* nextdir, uint64_t* off)
 {
 	static const char module[] = "TIFFAdvanceDirectory";
 	if (isMapped(tif))
 	{
-		uint64 poff=*nextdir;
+		uint64_t poff=*nextdir;
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
 			tmsize_t poffa,poffb,poffc,poffd;
-			uint16 dircount;
-			uint32 nextdir32;
+			uint16_t dircount;
+			uint32_t nextdir32;
 			poffa=(tmsize_t)poff;
-			poffb=poffa+sizeof(uint16);
-			if (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint16))||(poffb>tif->tif_size))
+			poffb=poffa+sizeof(uint16_t);
+			if (((uint64_t)poffa != poff) || (poffb < poffa) || (poffb < (tmsize_t)sizeof(uint16_t)) || (poffb > tif->tif_size))
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
                                   *nextdir=0;
 				return(0);
 			}
-			_TIFFmemcpy(&dircount,tif->tif_base+poffa,sizeof(uint16));
+			_TIFFmemcpy(&dircount,tif->tif_base+poffa,sizeof(uint16_t));
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabShort(&dircount);
 			poffc=poffb+dircount*12;
-			poffd=poffc+sizeof(uint32);
-			if ((poffc<poffb)||(poffc<dircount*12)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint32))||(poffd>tif->tif_size))
+			poffd=poffc+sizeof(uint32_t);
+			if ((poffc<poffb) || (poffc<dircount*12) || (poffd<poffc) || (poffd<(tmsize_t)sizeof(uint32_t)) || (poffd > tif->tif_size))
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory link");
 				return(0);
 			}
 			if (off!=NULL)
-				*off=(uint64)poffc;
-			_TIFFmemcpy(&nextdir32,tif->tif_base+poffc,sizeof(uint32));
+				*off=(uint64_t)poffc;
+			_TIFFmemcpy(&nextdir32,tif->tif_base+poffc,sizeof(uint32_t));
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabLong(&nextdir32);
 			*nextdir=nextdir32;
@@ -1479,16 +1529,16 @@ TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
 		else
 		{
 			tmsize_t poffa,poffb,poffc,poffd;
-			uint64 dircount64;
-			uint16 dircount16;
+			uint64_t dircount64;
+			uint16_t dircount16;
 			poffa=(tmsize_t)poff;
-			poffb=poffa+sizeof(uint64);
-			if (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint64))||(poffb>tif->tif_size))
+			poffb=poffa+sizeof(uint64_t);
+			if (((uint64_t)poffa != poff) || (poffb < poffa) || (poffb < (tmsize_t)sizeof(uint64_t)) || (poffb > tif->tif_size))
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
 				return(0);
 			}
-			_TIFFmemcpy(&dircount64,tif->tif_base+poffa,sizeof(uint64));
+			_TIFFmemcpy(&dircount64,tif->tif_base+poffa,sizeof(uint64_t));
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabLong8(&dircount64);
 			if (dircount64>0xFFFF)
@@ -1496,17 +1546,17 @@ TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
 				TIFFErrorExt(tif->tif_clientdata,module,"Sanity check on directory count failed");
 				return(0);
 			}
-			dircount16=(uint16)dircount64;
+			dircount16=(uint16_t)dircount64;
 			poffc=poffb+dircount16*20;
-			poffd=poffc+sizeof(uint64);
-			if ((poffc<poffb)||(poffc<dircount16*20)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint64))||(poffd>tif->tif_size))
+			poffd=poffc+sizeof(uint64_t);
+			if ((poffc<poffb) || (poffc<dircount16*20) || (poffd<poffc) || (poffd<(tmsize_t)sizeof(uint64_t)) || (poffd > tif->tif_size))
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory link");
 				return(0);
 			}
 			if (off!=NULL)
-				*off=(uint64)poffc;
-			_TIFFmemcpy(nextdir,tif->tif_base+poffc,sizeof(uint64));
+				*off=(uint64_t)poffc;
+			_TIFFmemcpy(nextdir,tif->tif_base+poffc,sizeof(uint64_t));
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabLong8(nextdir);
 		}
@@ -1516,10 +1566,10 @@ TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
 	{
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
-			uint16 dircount;
-			uint32 nextdir32;
+			uint16_t dircount;
+			uint32_t nextdir32;
 			if (!SeekOK(tif, *nextdir) ||
-			    !ReadOK(tif, &dircount, sizeof (uint16))) {
+			    !ReadOK(tif, &dircount, sizeof (uint16_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
 				    tif->tif_name);
 				return (0);
@@ -1532,7 +1582,7 @@ TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
 			else
 				(void) TIFFSeekFile(tif,
 				    dircount*12, SEEK_CUR);
-			if (!ReadOK(tif, &nextdir32, sizeof (uint32))) {
+			if (!ReadOK(tif, &nextdir32, sizeof (uint32_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory link",
 				    tif->tif_name);
 				return (0);
@@ -1543,10 +1593,10 @@ TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
 		}
 		else
 		{
-			uint64 dircount64;
-			uint16 dircount16;
+			uint64_t dircount64;
+			uint16_t dircount16;
 			if (!SeekOK(tif, *nextdir) ||
-			    !ReadOK(tif, &dircount64, sizeof (uint64))) {
+			    !ReadOK(tif, &dircount64, sizeof (uint64_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
 				    tif->tif_name);
 				return (0);
@@ -1558,14 +1608,14 @@ TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
 				TIFFErrorExt(tif->tif_clientdata, module, "Error fetching directory count");
 				return(0);
 			}
-			dircount16 = (uint16)dircount64;
+			dircount16 = (uint16_t)dircount64;
 			if (off != NULL)
 				*off = TIFFSeekFile(tif,
 				    dircount16*20, SEEK_CUR);
 			else
 				(void) TIFFSeekFile(tif,
 				    dircount16*20, SEEK_CUR);
-			if (!ReadOK(tif, nextdir, sizeof (uint64))) {
+			if (!ReadOK(tif, nextdir, sizeof (uint64_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module,
                                              "%s: Error fetching directory link",
 				    tif->tif_name);
@@ -1581,12 +1631,12 @@ TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
 /*
  * Count the number of directories in a file.
  */
-uint16
+uint16_t
 TIFFNumberOfDirectories(TIFF* tif)
 {
 	static const char module[] = "TIFFNumberOfDirectories";
-	uint64 nextdir;
-	uint16 n;
+	uint64_t nextdir;
+	uint16_t n;
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 		nextdir = tif->tif_header.classic.tiff_diroff;
 	else
@@ -1613,10 +1663,10 @@ TIFFNumberOfDirectories(TIFF* tif)
  * NB: Directories are numbered starting at 0.
  */
 int
-TIFFSetDirectory(TIFF* tif, uint16 dirn)
+TIFFSetDirectory(TIFF* tif, uint16_t dirn)
 {
-	uint64 nextdir;
-	uint16 n;
+	uint64_t nextdir;
+	uint16_t n;
 
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 		nextdir = tif->tif_header.classic.tiff_diroff;
@@ -1647,7 +1697,7 @@ TIFFSetDirectory(TIFF* tif, uint16 dirn)
  * the SubIFD tag (e.g. thumbnail images).
  */
 int
-TIFFSetSubDirectory(TIFF* tif, uint64 diroff)
+TIFFSetSubDirectory(TIFF* tif, uint64_t diroff)
 {
 	tif->tif_nextdiroff = diroff;
 	/*
@@ -1661,7 +1711,7 @@ TIFFSetSubDirectory(TIFF* tif, uint64 diroff)
 /*
  * Return file offset of the current directory.
  */
-uint64
+uint64_t
 TIFFCurrentDirOffset(TIFF* tif)
 {
 	return (tif->tif_diroff);
@@ -1681,12 +1731,12 @@ TIFFLastDirectory(TIFF* tif)
  * Unlink the specified directory from the directory chain.
  */
 int
-TIFFUnlinkDirectory(TIFF* tif, uint16 dirn)
+TIFFUnlinkDirectory(TIFF* tif, uint16_t dirn)
 {
 	static const char module[] = "TIFFUnlinkDirectory";
-	uint64 nextdir;
-	uint64 off;
-	uint16 n;
+	uint64_t nextdir;
+	uint64_t off;
+	uint16_t n;
 
 	if (tif->tif_mode == O_RDONLY) {
 		TIFFErrorExt(tif->tif_clientdata, module,
@@ -1710,7 +1760,7 @@ TIFFUnlinkDirectory(TIFF* tif, uint16 dirn)
 	}
 	for (n = dirn-1; n > 0; n--) {
 		if (nextdir == 0) {
-			TIFFErrorExt(tif->tif_clientdata, module, "Directory %d does not exist", dirn);
+			TIFFErrorExt(tif->tif_clientdata, module, "Directory %"PRIu16" does not exist", dirn);
 			return (0);
 		}
 		if (!TIFFAdvanceDirectory(tif, &nextdir, &off))
@@ -1730,12 +1780,12 @@ TIFFUnlinkDirectory(TIFF* tif, uint16 dirn)
 	(void) TIFFSeekFile(tif, off, SEEK_SET);
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
-		uint32 nextdir32;
-		nextdir32=(uint32)nextdir;
-		assert((uint64)nextdir32==nextdir);
+		uint32_t nextdir32;
+		nextdir32=(uint32_t)nextdir;
+		assert((uint64_t)nextdir32 == nextdir);
 		if (tif->tif_flags & TIFF_SWAB)
 			TIFFSwabLong(&nextdir32);
-		if (!WriteOK(tif, &nextdir32, sizeof (uint32))) {
+		if (!WriteOK(tif, &nextdir32, sizeof (uint32_t))) {
 			TIFFErrorExt(tif->tif_clientdata, module, "Error writing directory link");
 			return (0);
 		}
@@ -1744,7 +1794,7 @@ TIFFUnlinkDirectory(TIFF* tif, uint16 dirn)
 	{
 		if (tif->tif_flags & TIFF_SWAB)
 			TIFFSwabLong8(&nextdir);
-		if (!WriteOK(tif, &nextdir, sizeof (uint64))) {
+		if (!WriteOK(tif, &nextdir, sizeof (uint64_t))) {
 			TIFFErrorExt(tif->tif_clientdata, module, "Error writing directory link");
 			return (0);
 		}
@@ -1770,8 +1820,8 @@ TIFFUnlinkDirectory(TIFF* tif, uint16 dirn)
 	tif->tif_diroff = 0;			/* force link on next write */
 	tif->tif_nextdiroff = 0;		/* next write must be at end */
 	tif->tif_curoff = 0;
-	tif->tif_row = (uint32) -1;
-	tif->tif_curstrip = (uint32) -1;
+	tif->tif_row = (uint32_t) -1;
+	tif->tif_curstrip = (uint32_t) -1;
 	return (1);
 }
 
diff --git a/src/3rdparty/libtiff/libtiff/tif_dir.h b/src/3rdparty/libtiff/libtiff/tif_dir.h
index e7f0667..1782b35 100644
--- a/src/3rdparty/libtiff/libtiff/tif_dir.h
+++ b/src/3rdparty/libtiff/libtiff/tif_dir.h
@@ -50,15 +50,15 @@ typedef struct {
  * it is left-justified in the offset field.
  */
 typedef struct {
-	uint16 tdir_tag;        /* see below */
-	uint16 tdir_type;       /* data type; see below */
-	uint64 tdir_count;      /* number of items; length in spec */
+	uint16_t tdir_tag;        /* see below */
+	uint16_t tdir_type;       /* data type; see below */
+	uint64_t tdir_count;      /* number of items; length in spec */
 	union {
-		uint16 toff_short;
-		uint32 toff_long;
-		uint64 toff_long8;
+		uint16_t toff_short;
+		uint32_t toff_long;
+		uint64_t toff_long8;
 	} tdir_offset;		/* either offset or the data itself if fits */
-	uint8  tdir_ignore;	/* flag status to ignore tag when parsing tags in tif_dirread.c */
+	uint8_t  tdir_ignore;	/* flag status to ignore tag when parsing tags in tif_dirread.c */
 } TIFFDirEntry;
 
 /*
@@ -69,50 +69,50 @@ typedef struct {
 	/* bit vector of fields that are set */
 	unsigned long td_fieldsset[FIELD_SETLONGS];
 
-	uint32  td_imagewidth, td_imagelength, td_imagedepth;
-	uint32  td_tilewidth, td_tilelength, td_tiledepth;
-	uint32  td_subfiletype;
-	uint16  td_bitspersample;
-	uint16  td_sampleformat;
-	uint16  td_compression;
-	uint16  td_photometric;
-	uint16  td_threshholding;
-	uint16  td_fillorder;
-	uint16  td_orientation;
-	uint16  td_samplesperpixel;
-	uint32  td_rowsperstrip;
-	uint16  td_minsamplevalue, td_maxsamplevalue;
+	uint32_t  td_imagewidth, td_imagelength, td_imagedepth;
+	uint32_t  td_tilewidth, td_tilelength, td_tiledepth;
+	uint32_t  td_subfiletype;
+	uint16_t  td_bitspersample;
+	uint16_t  td_sampleformat;
+	uint16_t  td_compression;
+	uint16_t  td_photometric;
+	uint16_t  td_threshholding;
+	uint16_t  td_fillorder;
+	uint16_t  td_orientation;
+	uint16_t  td_samplesperpixel;
+	uint32_t  td_rowsperstrip;
+	uint16_t  td_minsamplevalue, td_maxsamplevalue;
 	double* td_sminsamplevalue;
 	double* td_smaxsamplevalue;
 	float   td_xresolution, td_yresolution;
-	uint16  td_resolutionunit;
-	uint16  td_planarconfig;
+	uint16_t  td_resolutionunit;
+	uint16_t  td_planarconfig;
 	float   td_xposition, td_yposition;
-	uint16  td_pagenumber[2];
-	uint16* td_colormap[3];
-	uint16  td_halftonehints[2];
-	uint16  td_extrasamples;
-	uint16* td_sampleinfo;
+	uint16_t  td_pagenumber[2];
+	uint16_t* td_colormap[3];
+	uint16_t  td_halftonehints[2];
+	uint16_t  td_extrasamples;
+	uint16_t* td_sampleinfo;
 	/* even though the name is misleading, td_stripsperimage is the number
 	 * of striles (=strips or tiles) per plane, and td_nstrips the total
 	 * number of striles */
-	uint32  td_stripsperimage;  
-	uint32  td_nstrips;              /* size of offset & bytecount arrays */
-	uint64* td_stripoffset_p;        /* should be accessed with TIFFGetStrileOffset */
-	uint64* td_stripbytecount_p;     /* should be accessed with TIFFGetStrileByteCount */
-        uint32  td_stripoffsetbyteallocsize; /* number of elements currently allocated for td_stripoffset/td_stripbytecount. Only used if TIFF_LAZYSTRILELOAD is set */
+	uint32_t  td_stripsperimage;
+	uint32_t  td_nstrips;              /* size of offset & bytecount arrays */
+	uint64_t* td_stripoffset_p;        /* should be accessed with TIFFGetStrileOffset */
+	uint64_t* td_stripbytecount_p;     /* should be accessed with TIFFGetStrileByteCount */
+        uint32_t  td_stripoffsetbyteallocsize; /* number of elements currently allocated for td_stripoffset/td_stripbytecount. Only used if TIFF_LAZYSTRILELOAD is set */
 #ifdef STRIPBYTECOUNTSORTED_UNUSED
 	int     td_stripbytecountsorted; /* is the bytecount array sorted ascending? */
 #endif
         TIFFDirEntry td_stripoffset_entry;    /* for deferred loading */
         TIFFDirEntry td_stripbytecount_entry; /* for deferred loading */
-	uint16  td_nsubifd;
-	uint64* td_subifd;
+	uint16_t  td_nsubifd;
+	uint64_t* td_subifd;
 	/* YCbCr parameters */
-	uint16  td_ycbcrsubsampling[2];
-	uint16  td_ycbcrpositioning;
+	uint16_t  td_ycbcrsubsampling[2];
+	uint16_t  td_ycbcrpositioning;
 	/* Colorimetry parameters */
-	uint16* td_transferfunction[3];
+	uint16_t* td_transferfunction[3];
 	float*	td_refblackwhite;
 	/* CMYK parameters */
 	int     td_inknameslen;
@@ -261,6 +261,7 @@ extern "C" {
 
 extern const TIFFFieldArray* _TIFFGetFields(void);
 extern const TIFFFieldArray* _TIFFGetExifFields(void);
+extern const TIFFFieldArray* _TIFFGetGpsFields(void);
 extern void _TIFFSetupFields(TIFF* tif, const TIFFFieldArray* infoarray);
 extern void _TIFFPrintFieldInfo(TIFF*, FILE*);
 
@@ -269,22 +270,23 @@ extern int _TIFFFillStriles(TIFF*);
 typedef enum {
 	tfiatImage,
 	tfiatExif,
+	tfiatGps,		/* EXIF-GPS fields array type */
 	tfiatOther
 } TIFFFieldArrayType;
 
 struct _TIFFFieldArray {
 	TIFFFieldArrayType type;    /* array type, will be used to determine if IFD is image and such */
-	uint32 allocated_size;      /* 0 if array is constant, other if modified by future definition extension support */
-	uint32 count;               /* number of elements in fields array */
+	uint32_t allocated_size;      /* 0 if array is constant, other if modified by future definition extension support */
+	uint32_t count;               /* number of elements in fields array */
 	TIFFField* fields;          /* actual field info */
 };
 
 struct _TIFFField {
-	uint32 field_tag;                       /* field's tag */
+	uint32_t field_tag;                       /* field's tag */
 	short field_readcount;                  /* read count/TIFF_VARIABLE/TIFF_SPP */
 	short field_writecount;                 /* write count/TIFF_VARIABLE */
 	TIFFDataType field_type;                /* type of associated data */
-	uint32 reserved;                        /* reserved for future extension */
+	uint32_t reserved;                        /* reserved for future extension */
 	TIFFSetGetFieldType set_field_type;     /* type to be passed to TIFFSetField */
 	TIFFSetGetFieldType get_field_type;     /* type to be passed to TIFFGetField */
 	unsigned short field_bit;               /* bit in fieldsset bit vector */
@@ -294,9 +296,9 @@ struct _TIFFField {
 	TIFFFieldArray* field_subfields;        /* if field points to child ifds, child ifd field definition array */
 };
 
-extern int _TIFFMergeFields(TIFF*, const TIFFField[], uint32);
-extern const TIFFField* _TIFFFindOrRegisterField(TIFF *, uint32, TIFFDataType);
-extern  TIFFField* _TIFFCreateAnonField(TIFF *, uint32, TIFFDataType);
+extern int _TIFFMergeFields(TIFF*, const TIFFField[], uint32_t);
+extern const TIFFField* _TIFFFindOrRegisterField(TIFF *, uint32_t, TIFFDataType);
+extern  TIFFField* _TIFFCreateAnonField(TIFF *, uint32_t, TIFFDataType);
 extern int _TIFFCheckFieldIsValidForCodec(TIFF *tif, ttag_t tag);
 
 #if defined(__cplusplus)
diff --git a/src/3rdparty/libtiff/libtiff/tif_dirinfo.c b/src/3rdparty/libtiff/libtiff/tif_dirinfo.c
index e1f6b23..8565dfb 100644
--- a/src/3rdparty/libtiff/libtiff/tif_dirinfo.c
+++ b/src/3rdparty/libtiff/libtiff/tif_dirinfo.c
@@ -47,9 +47,19 @@
 #endif
 static const TIFFFieldArray tiffFieldArray;
 static const TIFFFieldArray exifFieldArray;
+static const TIFFFieldArray gpsFieldArray;
 #ifdef _MSC_VER
 #pragma warning( pop )
 #endif
+/*--: Rational2Double: --
+ * The Rational2Double upgraded libtiff functionality allows the definition and achievement of true double-precision accuracy
+ * for TIFF tags of RATIONAL type and field_bit=FIELD_CUSTOM using the set_field_type = TIFF_SETGET_DOUBLE.
+ * Unfortunately, that changes the old implemented interface for TIFFGetField().
+ * In order to keep the old TIFFGetField() interface behavior those tags have to be redefined with set_field_type = TIFF_SETGET_FLOAT!
+ *
+ *  Rational custom arrays are already defined as _Cxx_FLOAT, thus can stay.
+ *
+ */
 
 static const TIFFField
 tiffFields[] = {
@@ -75,12 +85,12 @@ tiffFields[] = {
 	{ TIFFTAG_STRIPBYTECOUNTS, -1, -1, TIFF_LONG8, 0, TIFF_SETGET_UNDEFINED, TIFF_SETGET_UNDEFINED, FIELD_STRIPBYTECOUNTS, 0, 0, "StripByteCounts", NULL },
 	{ TIFFTAG_MINSAMPLEVALUE, -2, -1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_MINSAMPLEVALUE, 1, 0, "MinSampleValue", NULL },
 	{ TIFFTAG_MAXSAMPLEVALUE, -2, -1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_MAXSAMPLEVALUE, 1, 0, "MaxSampleValue", NULL },
-	{ TIFFTAG_XRESOLUTION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_RESOLUTION, 1, 0, "XResolution", NULL },
-	{ TIFFTAG_YRESOLUTION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_RESOLUTION, 1, 0, "YResolution", NULL },
+	{ TIFFTAG_XRESOLUTION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_RESOLUTION, 1, 0, "XResolution", NULL },
+	{ TIFFTAG_YRESOLUTION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_RESOLUTION, 1, 0, "YResolution", NULL },
 	{ TIFFTAG_PLANARCONFIG, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_PLANARCONFIG, 0, 0, "PlanarConfiguration", NULL },
 	{ TIFFTAG_PAGENAME, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "PageName", NULL },
-	{ TIFFTAG_XPOSITION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_POSITION, 1, 0, "XPosition", NULL },
-	{ TIFFTAG_YPOSITION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_POSITION, 1, 0, "YPosition", NULL },
+	{ TIFFTAG_XPOSITION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_POSITION, 1, 0, "XPosition", NULL },
+	{ TIFFTAG_YPOSITION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_POSITION, 1, 0, "YPosition", NULL },
 	{ TIFFTAG_FREEOFFSETS, -1, -1, TIFF_LONG8, 0, TIFF_SETGET_UNDEFINED, TIFF_SETGET_UNDEFINED, FIELD_IGNORE, 0, 0, "FreeOffsets", NULL },
 	{ TIFFTAG_FREEBYTECOUNTS, -1, -1, TIFF_LONG8, 0, TIFF_SETGET_UNDEFINED, TIFF_SETGET_UNDEFINED, FIELD_IGNORE, 0, 0, "FreeByteCounts", NULL },
 	{ TIFFTAG_GRAYRESPONSEUNIT, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UNDEFINED, TIFF_SETGET_UNDEFINED, FIELD_IGNORE, 1, 0, "GrayResponseUnit", NULL },
@@ -135,14 +145,18 @@ tiffFields[] = {
 	{ TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, 16, 16, TIFF_FLOAT, 0, TIFF_SETGET_C0_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "MatrixWorldToScreen", NULL },
 	{ TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, 16, 16, TIFF_FLOAT, 0, TIFF_SETGET_C0_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "MatrixWorldToCamera", NULL },
 	{ TIFFTAG_CFAREPEATPATTERNDIM, 2, 2, TIFF_SHORT, 0, TIFF_SETGET_C0_UINT16, TIFF_SETGET_UNDEFINED,	FIELD_CUSTOM, 0,	0,	"CFARepeatPatternDim", NULL },
-	{ TIFFTAG_CFAPATTERN,	4, 4,	TIFF_BYTE, 0, TIFF_SETGET_C0_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0,	0,	"CFAPattern" , NULL},
+	{ TIFFTAG_CFAPATTERN, -1, -1, TIFF_BYTE, 0, TIFF_SETGET_C16_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "CFAPattern" , NULL},
 	{ TIFFTAG_COPYRIGHT, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Copyright", NULL },
 	/* end Pixar tags */
-	{ TIFFTAG_RICHTIFFIPTC, -3, -3, TIFF_LONG, 0, TIFF_SETGET_C32_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "RichTIFFIPTC", NULL },
+	{ TIFFTAG_RICHTIFFIPTC, -3, -3, TIFF_UNDEFINED, 0, TIFF_SETGET_C32_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "RichTIFFIPTC", NULL },
 	{ TIFFTAG_PHOTOSHOP, -3, -3, TIFF_BYTE, 0, TIFF_SETGET_C32_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "Photoshop", NULL },
-	{ TIFFTAG_EXIFIFD, 1, 1, TIFF_IFD8, 0, TIFF_SETGET_IFD8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "EXIFIFDOffset", (TIFFFieldArray*) &exifFieldArray },
+	/*--: EXIFIFD and GPSIFD specified as TIFF_LONG by Aware-Systems and not TIFF_IFD8 as in original LibTiff.
+	 *    However, for IFD-like tags, libtiff uses the data type TIFF_IFD8 in tiffFields[]-tag definition combined with
+	 *    a special handling procedure in order to write either a 32-bit value and the TIFF_IFD type-id into ClassicTIFF files 
+	 *    or a 64-bit value and the TIFF_IFD8 type-id into BigTIFF files. */
+	{ TIFFTAG_EXIFIFD, 1, 1, TIFF_IFD8, 0, TIFF_SETGET_IFD8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "EXIFIFDOffset", (TIFFFieldArray*) &exifFieldArray },
 	{ TIFFTAG_ICCPROFILE, -3, -3, TIFF_UNDEFINED, 0, TIFF_SETGET_C32_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "ICC Profile", NULL },
-	{ TIFFTAG_GPSIFD, 1, 1, TIFF_IFD8, 0, TIFF_SETGET_IFD8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "GPSIFDOffset", NULL },
+	{ TIFFTAG_GPSIFD, 1, 1, TIFF_IFD8, 0, TIFF_SETGET_IFD8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "GPSIFDOffset", (TIFFFieldArray*) &gpsFieldArray },
 	{ TIFFTAG_FAXRECVPARAMS, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UINT32, FIELD_CUSTOM, TRUE, FALSE, "FaxRecvParams", NULL },
 	{ TIFFTAG_FAXSUBADDRESS, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_ASCII, FIELD_CUSTOM, TRUE, FALSE, "FaxSubAddress", NULL },
 	{ TIFFTAG_FAXRECVTIME, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UINT32, FIELD_CUSTOM, TRUE, FALSE, "FaxRecvTime", NULL },
@@ -163,7 +177,7 @@ tiffFields[] = {
 	{ TIFFTAG_BLACKLEVELDELTAV, -1, -1, TIFF_SRATIONAL, 0, TIFF_SETGET_C16_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "BlackLevelDeltaV", NULL },
 	{ TIFFTAG_WHITELEVEL, -1, -1, TIFF_LONG, 0, TIFF_SETGET_C16_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "WhiteLevel", NULL },
 	{ TIFFTAG_DEFAULTSCALE, 2, 2, TIFF_RATIONAL, 0, TIFF_SETGET_C0_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "DefaultScale", NULL },
-	{ TIFFTAG_BESTQUALITYSCALE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BestQualityScale", NULL },
+	{ TIFFTAG_BESTQUALITYSCALE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BestQualityScale", NULL },
 	{ TIFFTAG_DEFAULTCROPORIGIN, 2, 2, TIFF_RATIONAL, 0, TIFF_SETGET_C0_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "DefaultCropOrigin", NULL },
 	{ TIFFTAG_DEFAULTCROPSIZE, 2, 2, TIFF_RATIONAL, 0, TIFF_SETGET_C0_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "DefaultCropSize", NULL },
 	{ TIFFTAG_COLORMATRIX1, -1, -1, TIFF_SRATIONAL, 0, TIFF_SETGET_C16_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "ColorMatrix1", NULL },
@@ -175,16 +189,16 @@ tiffFields[] = {
 	{ TIFFTAG_ANALOGBALANCE, -1, -1, TIFF_RATIONAL, 0, TIFF_SETGET_C16_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "AnalogBalance", NULL },
 	{ TIFFTAG_ASSHOTNEUTRAL, -1, -1, TIFF_RATIONAL, 0, TIFF_SETGET_C16_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "AsShotNeutral", NULL },
 	{ TIFFTAG_ASSHOTWHITEXY, 2, 2, TIFF_RATIONAL, 0, TIFF_SETGET_C0_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "AsShotWhiteXY", NULL },
-	{ TIFFTAG_BASELINEEXPOSURE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BaselineExposure", NULL },
-	{ TIFFTAG_BASELINENOISE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BaselineNoise", NULL },
-	{ TIFFTAG_BASELINESHARPNESS, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BaselineSharpness", NULL },
+	{ TIFFTAG_BASELINEEXPOSURE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BaselineExposure", NULL },
+	{ TIFFTAG_BASELINENOISE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BaselineNoise", NULL },
+	{ TIFFTAG_BASELINESHARPNESS, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BaselineSharpness", NULL },
 	{ TIFFTAG_BAYERGREENSPLIT, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "BayerGreenSplit", NULL },
-	{ TIFFTAG_LINEARRESPONSELIMIT, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "LinearResponseLimit", NULL },
+	{ TIFFTAG_LINEARRESPONSELIMIT, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "LinearResponseLimit", NULL },
 	{ TIFFTAG_CAMERASERIALNUMBER, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "CameraSerialNumber", NULL },
 	{ TIFFTAG_LENSINFO, 4, 4, TIFF_RATIONAL, 0, TIFF_SETGET_C0_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "LensInfo", NULL },
-	{ TIFFTAG_CHROMABLURRADIUS, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "ChromaBlurRadius", NULL },
-	{ TIFFTAG_ANTIALIASSTRENGTH, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "AntiAliasStrength", NULL },
-	{ TIFFTAG_SHADOWSCALE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "ShadowScale", NULL },
+	{ TIFFTAG_CHROMABLURRADIUS, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "ChromaBlurRadius", NULL },
+	{ TIFFTAG_ANTIALIASSTRENGTH, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "AntiAliasStrength", NULL },
+	{ TIFFTAG_SHADOWSCALE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "ShadowScale", NULL },
 	{ TIFFTAG_DNGPRIVATEDATA, -1, -1, TIFF_BYTE, 0, TIFF_SETGET_C16_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 1, "DNGPrivateData", NULL },
 	{ TIFFTAG_MAKERNOTESAFETY, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "MakerNoteSafety", NULL },
 	{ TIFFTAG_CALIBRATIONILLUMINANT1, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, "CalibrationIlluminant1", NULL },
@@ -217,47 +231,68 @@ tiffFields[] = {
 	/* begin pseudo tags */
 };
 
+/*
+ * EXIF tags  (Version 2.31, July 2016 plus version 2.32 May 2019)
+ */
 static const TIFFField
 exifFields[] = {
-	{ EXIFTAG_EXPOSURETIME, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExposureTime", NULL },
-	{ EXIFTAG_FNUMBER, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FNumber", NULL },
+	{ EXIFTAG_EXPOSURETIME, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExposureTime", NULL },
+	{ EXIFTAG_FNUMBER, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FNumber", NULL },
 	{ EXIFTAG_EXPOSUREPROGRAM, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExposureProgram", NULL },
 	{ EXIFTAG_SPECTRALSENSITIVITY, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SpectralSensitivity", NULL },
 	{ EXIFTAG_ISOSPEEDRATINGS, -1, -1, TIFF_SHORT, 0, TIFF_SETGET_C16_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 1, "ISOSpeedRatings", NULL },
 	{ EXIFTAG_OECF, -1, -1, TIFF_UNDEFINED, 0, TIFF_SETGET_C16_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 1, "OptoelectricConversionFactor", NULL },
+	{ EXIFTAG_SENSITIVITYTYPE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SensitivityType", NULL },
+	{ EXIFTAG_STANDARDOUTPUTSENSITIVITY, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "StandardOutputSensitivity", NULL },
+	{ EXIFTAG_RECOMMENDEDEXPOSUREINDEX, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "RecommendedExposureIndex", NULL },
+	{ EXIFTAG_ISOSPEED, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ISOSpeed", NULL },
+	{ EXIFTAG_ISOSPEEDLATITUDEYYY, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ISOSpeedLatitudeyyy", NULL },
+	{ EXIFTAG_ISOSPEEDLATITUDEZZZ, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ISOSpeedLatitudezzz", NULL },
 	{ EXIFTAG_EXIFVERSION, 4, 4, TIFF_UNDEFINED, 0, TIFF_SETGET_C0_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExifVersion", NULL },
 	{ EXIFTAG_DATETIMEORIGINAL, 20, 20, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "DateTimeOriginal", NULL },
 	{ EXIFTAG_DATETIMEDIGITIZED, 20, 20, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "DateTimeDigitized", NULL },
+	{ EXIFTAG_OFFSETTIME, 7, 7, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "OffsetTime", NULL },
+	{ EXIFTAG_OFFSETTIMEORIGINAL, 7, 7, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "OffsetTimeOriginal", NULL },
+	{ EXIFTAG_OFFSETTIMEDIGITIZED, 7, 7, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "OffsetTimeDigitized", NULL },
 	{ EXIFTAG_COMPONENTSCONFIGURATION, 4, 4, TIFF_UNDEFINED, 0, TIFF_SETGET_C0_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ComponentsConfiguration", NULL },
-	{ EXIFTAG_COMPRESSEDBITSPERPIXEL, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "CompressedBitsPerPixel", NULL },
-	{ EXIFTAG_SHUTTERSPEEDVALUE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ShutterSpeedValue", NULL },
-	{ EXIFTAG_APERTUREVALUE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ApertureValue", NULL },
-	{ EXIFTAG_BRIGHTNESSVALUE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "BrightnessValue", NULL },
-	{ EXIFTAG_EXPOSUREBIASVALUE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExposureBiasValue", NULL },
-	{ EXIFTAG_MAXAPERTUREVALUE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "MaxApertureValue", NULL },
-	{ EXIFTAG_SUBJECTDISTANCE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SubjectDistance", NULL },
+	{ EXIFTAG_COMPRESSEDBITSPERPIXEL, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "CompressedBitsPerPixel", NULL },
+	{ EXIFTAG_SHUTTERSPEEDVALUE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ShutterSpeedValue", NULL },
+	{ EXIFTAG_APERTUREVALUE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ApertureValue", NULL },
+	{ EXIFTAG_BRIGHTNESSVALUE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "BrightnessValue", NULL },
+	{ EXIFTAG_EXPOSUREBIASVALUE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExposureBiasValue", NULL },
+	{ EXIFTAG_MAXAPERTUREVALUE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "MaxApertureValue", NULL },
+	/*--: EXIFTAG_SUBJECTDISTANCE: LibTiff returns value of "-1" if numerator equals 4294967295 (0xFFFFFFFF) to indicate infinite distance!
+	 * However, there are two other EXIF tags where numerator indicates a special value and six other cases where the denominator indicates special values,
+	 * which are not treated within LibTiff!! */
+	{ EXIFTAG_SUBJECTDISTANCE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SubjectDistance", NULL },
 	{ EXIFTAG_METERINGMODE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "MeteringMode", NULL },
 	{ EXIFTAG_LIGHTSOURCE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "LightSource", NULL },
 	{ EXIFTAG_FLASH, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Flash", NULL },
-	{ EXIFTAG_FOCALLENGTH, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FocalLength", NULL },
+	{ EXIFTAG_FOCALLENGTH, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FocalLength", NULL },
 	{ EXIFTAG_SUBJECTAREA, -1, -1, TIFF_SHORT, 0, TIFF_SETGET_C16_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 1, "SubjectArea", NULL },
 	{ EXIFTAG_MAKERNOTE, -1, -1, TIFF_UNDEFINED, 0, TIFF_SETGET_C16_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 1, "MakerNote", NULL },
 	{ EXIFTAG_USERCOMMENT, -1, -1, TIFF_UNDEFINED, 0, TIFF_SETGET_C16_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 1, "UserComment", NULL },
 	{ EXIFTAG_SUBSECTIME, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SubSecTime", NULL },
 	{ EXIFTAG_SUBSECTIMEORIGINAL, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SubSecTimeOriginal", NULL },
 	{ EXIFTAG_SUBSECTIMEDIGITIZED, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SubSecTimeDigitized", NULL },
+	{ EXIFTAG_TEMPERATURE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Temperature", NULL },
+	{ EXIFTAG_HUMIDITY, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Humidity", NULL },
+	{ EXIFTAG_PRESSURE, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Pressure", NULL },
+	{ EXIFTAG_WATERDEPTH, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "WaterDepth", NULL },
+	{ EXIFTAG_ACCELERATION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Acceleration", NULL },
+	{ EXIFTAG_CAMERAELEVATIONANGLE, 1, 1, TIFF_SRATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "CameraElevationAngle", NULL },
 	{ EXIFTAG_FLASHPIXVERSION, 4, 4, TIFF_UNDEFINED, 0, TIFF_SETGET_C0_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FlashpixVersion", NULL },
 	{ EXIFTAG_COLORSPACE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ColorSpace", NULL },
 	{ EXIFTAG_PIXELXDIMENSION, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "PixelXDimension", NULL },
 	{ EXIFTAG_PIXELYDIMENSION, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "PixelYDimension", NULL },
 	{ EXIFTAG_RELATEDSOUNDFILE, 13, 13, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "RelatedSoundFile", NULL },
-	{ EXIFTAG_FLASHENERGY, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FlashEnergy", NULL },
+	{ EXIFTAG_FLASHENERGY, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FlashEnergy", NULL },
 	{ EXIFTAG_SPATIALFREQUENCYRESPONSE, -1, -1, TIFF_UNDEFINED, 0, TIFF_SETGET_C16_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 1, "SpatialFrequencyResponse", NULL },
-	{ EXIFTAG_FOCALPLANEXRESOLUTION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FocalPlaneXResolution", NULL },
-	{ EXIFTAG_FOCALPLANEYRESOLUTION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FocalPlaneYResolution", NULL },
+	{ EXIFTAG_FOCALPLANEXRESOLUTION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FocalPlaneXResolution", NULL },
+	{ EXIFTAG_FOCALPLANEYRESOLUTION, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FocalPlaneYResolution", NULL },
 	{ EXIFTAG_FOCALPLANERESOLUTIONUNIT, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FocalPlaneResolutionUnit", NULL },
 	{ EXIFTAG_SUBJECTLOCATION, 2, 2, TIFF_SHORT, 0, TIFF_SETGET_C0_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SubjectLocation", NULL },
-	{ EXIFTAG_EXPOSUREINDEX, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExposureIndex", NULL },
+	{ EXIFTAG_EXPOSUREINDEX, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExposureIndex", NULL },
 	{ EXIFTAG_SENSINGMETHOD, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SensingMethod", NULL },
 	{ EXIFTAG_FILESOURCE, 1, 1, TIFF_UNDEFINED, 0, TIFF_SETGET_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FileSource", NULL },
 	{ EXIFTAG_SCENETYPE, 1, 1, TIFF_UNDEFINED, 0, TIFF_SETGET_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SceneType", NULL },
@@ -265,22 +300,79 @@ exifFields[] = {
 	{ EXIFTAG_CUSTOMRENDERED, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "CustomRendered", NULL },
 	{ EXIFTAG_EXPOSUREMODE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ExposureMode", NULL },
 	{ EXIFTAG_WHITEBALANCE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "WhiteBalance", NULL },
-	{ EXIFTAG_DIGITALZOOMRATIO, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "DigitalZoomRatio", NULL },
+	{ EXIFTAG_DIGITALZOOMRATIO, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "DigitalZoomRatio", NULL },
 	{ EXIFTAG_FOCALLENGTHIN35MMFILM, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "FocalLengthIn35mmFilm", NULL },
 	{ EXIFTAG_SCENECAPTURETYPE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SceneCaptureType", NULL },
-	{ EXIFTAG_GAINCONTROL, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_DOUBLE, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "GainControl", NULL },
+	{ EXIFTAG_GAINCONTROL, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "GainControl", NULL },
 	{ EXIFTAG_CONTRAST, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Contrast", NULL },
 	{ EXIFTAG_SATURATION, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Saturation", NULL },
 	{ EXIFTAG_SHARPNESS, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Sharpness", NULL },
 	{ EXIFTAG_DEVICESETTINGDESCRIPTION, -1, -1, TIFF_UNDEFINED, 0, TIFF_SETGET_C16_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 1, "DeviceSettingDescription", NULL },
 	{ EXIFTAG_SUBJECTDISTANCERANGE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SubjectDistanceRange", NULL },
-	{ EXIFTAG_IMAGEUNIQUEID, 33, 33, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ImageUniqueID", NULL }
+	{ EXIFTAG_IMAGEUNIQUEID, 33, 33, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "ImageUniqueID", NULL },
+	{ EXIFTAG_CAMERAOWNERNAME, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "CameraOwnerName", NULL },
+	{ EXIFTAG_BODYSERIALNUMBER, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "BodySerialNumber", NULL },
+	{ EXIFTAG_LENSSPECIFICATION, 4, 4, TIFF_RATIONAL, 0, TIFF_SETGET_C0_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "LensSpecification", NULL },
+	{ EXIFTAG_LENSMAKE, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "LensMake", NULL },
+	{ EXIFTAG_LENSMODEL, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "LensModel", NULL },
+	{ EXIFTAG_LENSSERIALNUMBER, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "LensSerialNumber", NULL },
+	{ EXIFTAG_GAMMA, 1, 1, TIFF_RATIONAL, 0, TIFF_SETGET_FLOAT, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "Gamma", NULL },
+	{ EXIFTAG_COMPOSITEIMAGE, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "CompositeImage", NULL },
+	{ EXIFTAG_SOURCEIMAGENUMBEROFCOMPOSITEIMAGE, 2, 2, TIFF_SHORT, 0, TIFF_SETGET_C0_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, "SourceImageNumberOfCompositeImage", NULL },
+	{ EXIFTAG_SOURCEEXPOSURETIMESOFCOMPOSITEIMAGE, -1, -1, TIFF_UNDEFINED, 0, TIFF_SETGET_C16_UINT8, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 1, "SourceExposureTimesOfCompositeImage", NULL }
+};
+/*
+ * EXIF-GPS tags  (Version 2.31, July 2016; nothing changed for version 2.32 May 2019)
+ */
+
+static const TIFFField
+gpsFields[] = {
+	/*  For the GPS tag definitions in gpsFields[] the standard definition for Rationals is TIFF_SETGET_DOUBLE and TIFF_SETGET_C0_FLOAT.
+	 *-- ATTENTION: After the upgrade with Rational2Double, the GPSTAG values can now be written and also read in double precision!
+	 *              In order to achieve double precision for GPS tags:
+	 *              Standard definitions for GPSTAG is kept to TIFF_SETGET_DOUBLE 
+	 *              and TIFF_SETGET_C0_FLOAT is changed to TIFF_SETGET_C0_DOUBLE.
+	 */
+	{		GPSTAG_VERSIONID	, 4, 4, 	TIFF_BYTE	, 0, 	TIFF_SETGET_C0_UINT8	, TIFF_SETGET_UINT8	, FIELD_CUSTOM	, 1, 0, 	"VersionID", NULL },
+	{		GPSTAG_LATITUDEREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"LatitudeRef", NULL },
+	{		GPSTAG_LATITUDE	, 3, 3,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_C0_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"Latitude", NULL },
+	{		GPSTAG_LONGITUDEREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"LongitudeRef", NULL },
+	{		GPSTAG_LONGITUDE	, 3, 3,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_C0_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"Longitude", NULL },
+	{		GPSTAG_ALTITUDEREF	, 1, 1,	TIFF_BYTE	, 0, 	TIFF_SETGET_UINT8	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"AltitudeRef", NULL },
+	{		GPSTAG_ALTITUDE	, 1, 1,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"Altitude", NULL },
+	{		GPSTAG_TIMESTAMP	, 3, 3,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_C0_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"TimeStamp", NULL },
+	{		GPSTAG_SATELLITES	, -1, -1,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"Satellites", NULL },
+	{		GPSTAG_STATUS	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"Status", NULL },
+	{		GPSTAG_MEASUREMODE	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"MeasureMode", NULL },
+	{		GPSTAG_DOP	, 1, 1,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DOP", NULL },
+	{		GPSTAG_SPEEDREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"SpeedRef", NULL },
+	{		GPSTAG_SPEED	, 1, 1,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"Speed", NULL },
+	{		GPSTAG_TRACKREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"TrackRef", NULL },
+	{		GPSTAG_TRACK	, 1, 1,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"Track", NULL },
+	{		GPSTAG_IMGDIRECTIONREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"ImgDirectionRef", NULL },
+	{		GPSTAG_IMGDIRECTION	, 1, 1,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"ImgDirection", NULL },
+	{		GPSTAG_MAPDATUM	, -1, -1,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"MapDatum", NULL },
+	{		GPSTAG_DESTLATITUDEREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DestLatitudeRef", NULL },
+	{		GPSTAG_DESTLATITUDE	, 3, 3,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_C0_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DestLatitude", NULL },
+	{		GPSTAG_DESTLONGITUDEREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DestLongitudeRef", NULL },
+	{		GPSTAG_DESTLONGITUDE	, 3, 3,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_C0_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DestLongitude", NULL },
+	{		GPSTAG_DESTBEARINGREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DestBearingRef", NULL },
+	{		GPSTAG_DESTBEARING	, 1, 1,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DestBearing", NULL },
+	{		GPSTAG_DESTDISTANCEREF	, 2, 2,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DestDistanceRef", NULL },
+	{		GPSTAG_DESTDISTANCE	, 1, 1,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DestDistance", NULL },
+	{		GPSTAG_PROCESSINGMETHOD	, -1, -1,	TIFF_UNDEFINED	, 0, 	TIFF_SETGET_C16_UINT8	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 1, 	"ProcessingMethod", NULL },
+	{		GPSTAG_AREAINFORMATION	, -1, -1,	TIFF_UNDEFINED	, 0, 	TIFF_SETGET_C16_UINT8	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 1, 	"AreaInformation", NULL },
+	{		GPSTAG_DATESTAMP	, 11, 11,	TIFF_ASCII	, 0, 	TIFF_SETGET_ASCII	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"DateStamp", NULL },
+	{		GPSTAG_DIFFERENTIAL	, 1, 1,	TIFF_SHORT	, 0, 	TIFF_SETGET_UINT16	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"Differential", NULL },
+	{		GPSTAG_GPSHPOSITIONINGERROR	, 1, 1,	TIFF_RATIONAL	, 0, 	TIFF_SETGET_DOUBLE	, TIFF_SETGET_UNDEFINED	, FIELD_CUSTOM	, 1, 0, 	"HorizontalPositioningError", NULL }
 };
 
 static const TIFFFieldArray
 tiffFieldArray = { tfiatImage, 0, TIFFArrayCount(tiffFields), (TIFFField*) tiffFields };
 static const TIFFFieldArray
 exifFieldArray = { tfiatExif, 0, TIFFArrayCount(exifFields), (TIFFField*) exifFields };
+static const TIFFFieldArray
+gpsFieldArray = { tfiatGps, 0, TIFFArrayCount(gpsFields), (TIFFField*) gpsFields };
 
 /*
  *  We have our own local lfind() equivalent to avoid subtle differences
@@ -313,11 +405,17 @@ _TIFFGetExifFields(void)
 	return(&exifFieldArray);
 }
 
+const TIFFFieldArray*
+_TIFFGetGpsFields(void)
+{
+	return(&gpsFieldArray);
+}
+
 void
 _TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)
 {
 	if (tif->tif_fields && tif->tif_nfields > 0) {
-		uint32 i;
+		uint32_t i;
 
 		for (i = 0; i < tif->tif_nfields; i++) {
 			TIFFField *fld = tif->tif_fields[i];
@@ -366,12 +464,12 @@ tagNameCompare(const void* a, const void* b)
 }
 
 int
-_TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)
+_TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32_t n)
 {
 	static const char module[] = "_TIFFMergeFields";
 	static const char reason[] = "for fields array";
 	/* TIFFField** tp; */
-	uint32 i;
+	uint32_t i;
 
         tif->tif_foundfield = NULL;
 
@@ -413,7 +511,7 @@ _TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)
 void
 _TIFFPrintFieldInfo(TIFF* tif, FILE* fd)
 {
-	uint32 i;
+	uint32_t i;
 
 	fprintf(fd, "%s: \n", tif->tif_name);
 	for (i = 0; i < tif->tif_nfields; i++) {
@@ -502,8 +600,84 @@ _TIFFDataSize(TIFFDataType type)
 	}
 }
 
+/*
+ * Rational2Double: 
+ * Return size of TIFFSetGetFieldType in bytes.
+ *
+ * XXX: TIFF_RATIONAL values for FIELD_CUSTOM are stored internally as 4-byte float.
+ * However, some of them should be stored internally as 8-byte double. 
+ * This is now managed by the SetGetField of the tag-definition!
+ */
+int
+_TIFFSetGetFieldSize(TIFFSetGetFieldType setgettype)
+{
+	switch (setgettype)
+	{
+		case TIFF_SETGET_UNDEFINED:
+		case TIFF_SETGET_ASCII:
+		case TIFF_SETGET_C0_ASCII:
+		case TIFF_SETGET_C16_ASCII:
+		case TIFF_SETGET_C32_ASCII:
+		case TIFF_SETGET_OTHER:
+		    return 0;
+		case TIFF_SETGET_UINT8:
+		case TIFF_SETGET_SINT8:
+		case TIFF_SETGET_C0_UINT8:
+		case TIFF_SETGET_C0_SINT8:
+		case TIFF_SETGET_C16_UINT8:
+		case TIFF_SETGET_C16_SINT8:
+		case TIFF_SETGET_C32_UINT8:
+		case TIFF_SETGET_C32_SINT8:
+		    return 1;
+		case TIFF_SETGET_UINT16:
+		case TIFF_SETGET_SINT16:
+		case TIFF_SETGET_C0_UINT16:
+		case TIFF_SETGET_C0_SINT16:
+		case TIFF_SETGET_C16_UINT16:
+		case TIFF_SETGET_C16_SINT16:
+		case TIFF_SETGET_C32_UINT16:
+		case TIFF_SETGET_C32_SINT16:
+		    return 2;
+		case TIFF_SETGET_INT:
+		case TIFF_SETGET_UINT32:
+		case TIFF_SETGET_SINT32:
+		case TIFF_SETGET_FLOAT:
+		case TIFF_SETGET_UINT16_PAIR:
+		case TIFF_SETGET_C0_UINT32:
+		case TIFF_SETGET_C0_SINT32:
+		case TIFF_SETGET_C0_FLOAT:
+		case TIFF_SETGET_C16_UINT32:
+		case TIFF_SETGET_C16_SINT32:
+		case TIFF_SETGET_C16_FLOAT:
+		case TIFF_SETGET_C32_UINT32:
+		case TIFF_SETGET_C32_SINT32:
+		case TIFF_SETGET_C32_FLOAT:
+		    return 4;
+		case TIFF_SETGET_UINT64:
+		case TIFF_SETGET_SINT64:
+		case TIFF_SETGET_DOUBLE:
+		case TIFF_SETGET_IFD8:
+		case TIFF_SETGET_C0_UINT64:
+		case TIFF_SETGET_C0_SINT64:
+		case TIFF_SETGET_C0_DOUBLE:
+		case TIFF_SETGET_C0_IFD8:
+		case TIFF_SETGET_C16_UINT64:
+		case TIFF_SETGET_C16_SINT64:
+		case TIFF_SETGET_C16_DOUBLE:
+		case TIFF_SETGET_C16_IFD8:
+		case TIFF_SETGET_C32_UINT64:
+		case TIFF_SETGET_C32_SINT64:
+		case TIFF_SETGET_C32_DOUBLE:
+		case TIFF_SETGET_C32_IFD8:
+		    return 8;
+		default:
+		    return 0;
+	}
+} /*-- _TIFFSetGetFieldSize --- */
+
+
 const TIFFField*
-TIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)
+TIFFFindField(TIFF* tif, uint32_t tag, TIFFDataType dt)
 {
 	TIFFField key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0, 0, 0, NULL, NULL};
 	TIFFField* pkey = &key;
@@ -555,7 +729,7 @@ _TIFFFindFieldByName(TIFF* tif, const char *field_name, TIFFDataType dt)
 }
 
 const TIFFField*
-TIFFFieldWithTag(TIFF* tif, uint32 tag)
+TIFFFieldWithTag(TIFF* tif, uint32_t tag)
 {
 	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
 	if (!fip) {
@@ -578,7 +752,7 @@ TIFFFieldWithName(TIFF* tif, const char *field_name)
 	return (fip);
 }
 
-uint32
+uint32_t
 TIFFFieldTag(const TIFFField* fip)
 {
 	return fip->field_tag;
@@ -615,7 +789,7 @@ TIFFFieldWriteCount(const TIFFField* fip)
 }
 
 const TIFFField*
-_TIFFFindOrRegisterField(TIFF *tif, uint32 tag, TIFFDataType dt)
+_TIFFFindOrRegisterField(TIFF *tif, uint32_t tag, TIFFDataType dt)
 
 {
 	const TIFFField *fld;
@@ -631,7 +805,7 @@ _TIFFFindOrRegisterField(TIFF *tif, uint32 tag, TIFFDataType dt)
 }
 
 TIFFField*
-_TIFFCreateAnonField(TIFF *tif, uint32 tag, TIFFDataType field_type)
+_TIFFCreateAnonField(TIFF *tif, uint32_t tag, TIFFDataType field_type)
 {
 	TIFFField *fld;
 	(void) tif;
@@ -885,13 +1059,13 @@ _TIFFSetGetType(TIFFDataType type, short count, unsigned char passcount)
 }
 
 int
-TIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], uint32 n)
+TIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], uint32_t n)
 {
 	static const char module[] = "TIFFMergeFieldInfo";
 	static const char reason[] = "for fields array";
 	TIFFField *tp;
 	size_t nfields;
-	uint32 i;
+	uint32_t i;
 
 	if (tif->tif_nfieldscompat > 0) {
 		tif->tif_fieldscompat = (TIFFFieldArray *)
@@ -1062,10 +1236,6 @@ _TIFFCheckFieldIsValidForCodec(TIFF *tif, ttag_t tag)
 		if (tag == TIFFTAG_LERC_PARAMETERS)
 		    return 1;
 		break;
-		  case COMPRESSION_WEBP:
-		if (tag == TIFFTAG_PREDICTOR)
-				return 1;
-		break;
 	}
 	return 0;
 }
diff --git a/src/3rdparty/libtiff/libtiff/tif_dirread.c b/src/3rdparty/libtiff/libtiff/tif_dirread.c
index 6f90941..d84147a 100644
--- a/src/3rdparty/libtiff/libtiff/tif_dirread.c
+++ b/src/3rdparty/libtiff/libtiff/tif_dirread.c
@@ -34,23 +34,19 @@
  *   TIFFReadDirectory, so as to eliminate current possibly repetitive lookup.
  */
 
+#include "tiffconf.h"
 #include "tiffiop.h"
 #include <float.h>
 #include <stdlib.h>
 
-#define FAILED_FII    ((uint32) -1)
-
-/*
- * Largest 64-bit signed integer value.
- */
-#define TIFF_INT64_MAX ((int64)(TIFF_UINT64_MAX >> 1))
+#define FAILED_FII    ((uint32_t) -1)
 
 #ifdef HAVE_IEEEFP
 # define TIFFCvtIEEEFloatToNative(tif, n, fp)
 # define TIFFCvtIEEEDoubleToNative(tif, n, dp)
 #else
-extern void TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*);
-extern void TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*);
+extern void TIFFCvtIEEEFloatToNative(TIFF*, uint32_t, float*);
+extern void TIFFCvtIEEEDoubleToNative(TIFF*, uint32_t, double*);
 #endif
 
 enum TIFFReadDirEntryErr {
@@ -64,126 +60,126 @@ enum TIFFReadDirEntryErr {
 	TIFFReadDirEntryErrAlloc = 7,
 };
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8_t* value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16_t* value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32_t* value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64_t* value);
 static enum TIFFReadDirEntryErr TIFFReadDirEntryFloat(TIFF* tif, TIFFDirEntry* direntry, float* value);
 static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* direntry, uint64* value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEntry* direntry, int8** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEntry* direntry, int16** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntry* direntry, uint32** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEntry* direntry, int32** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* direntry, uint64_t* value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32_t* count, uint32_t desttypesize, void** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8_t** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEntry* direntry, int8_t** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16_t** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEntry* direntry, int16_t** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntry* direntry, uint32_t** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEntry* direntry, int32_t** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64_t** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64_t** value);
 static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEntry* direntry, float** value);
 static enum TIFFReadDirEntryErr TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntry* direntry, uint64_t** value);
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16_t* value);
 #if 0
 static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleDouble(TIFF* tif, TIFFDirEntry* direntry, double* value);
 #endif
 
-static void TIFFReadDirEntryCheckedByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value);
-static void TIFFReadDirEntryCheckedSbyte(TIFF* tif, TIFFDirEntry* direntry, int8* value);
-static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value);
-static void TIFFReadDirEntryCheckedSshort(TIFF* tif, TIFFDirEntry* direntry, int16* value);
-static void TIFFReadDirEntryCheckedLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value);
-static void TIFFReadDirEntryCheckedSlong(TIFF* tif, TIFFDirEntry* direntry, int32* value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDirEntry* direntry, int64* value);
+static void TIFFReadDirEntryCheckedByte(TIFF* tif, TIFFDirEntry* direntry, uint8_t* value);
+static void TIFFReadDirEntryCheckedSbyte(TIFF* tif, TIFFDirEntry* direntry, int8_t* value);
+static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16_t* value);
+static void TIFFReadDirEntryCheckedSshort(TIFF* tif, TIFFDirEntry* direntry, int16_t* value);
+static void TIFFReadDirEntryCheckedLong(TIFF* tif, TIFFDirEntry* direntry, uint32_t* value);
+static void TIFFReadDirEntryCheckedSlong(TIFF* tif, TIFFDirEntry* direntry, int32_t* value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64_t* value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDirEntry* direntry, int64_t* value);
 static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value);
 static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFFDirEntry* direntry, double* value);
 static void TIFFReadDirEntryCheckedFloat(TIFF* tif, TIFFDirEntry* direntry, float* value);
 static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedDouble(TIFF* tif, TIFFDirEntry* direntry, double* value);
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSbyte(int8 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSshort(int16 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong(int32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong8(uint64 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong8(int64 value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteByte(uint8 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteShort(uint16 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSshort(int16 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong(uint32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong(int32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong8(uint64 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong8(int64 value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSbyte(int8 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSshort(int16 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong(uint32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong(int32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong8(uint64 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong8(int64 value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortShort(uint16 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong(uint32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong(int32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong8(uint64 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong8(int64 value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSbyte(int8 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong(int32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongLong8(uint64 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong8(int64 value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongLong(uint32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongLong8(uint64 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongSlong8(int64 value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Sbyte(int8 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Sshort(int16 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Slong(int32 value);
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Slong8(int64 value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlong8Long8(uint64 value);
-
-static enum TIFFReadDirEntryErr TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSbyte(int8_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSshort(int16_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong(int32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong8(uint64_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong8(int64_t value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteByte(uint8_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteShort(uint16_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSshort(int16_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong(uint32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong(int32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong8(uint64_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong8(int64_t value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSbyte(int8_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSshort(int16_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong(uint32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong(int32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong8(uint64_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong8(int64_t value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortShort(uint16_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong(uint32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong(int32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong8(uint64_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong8(int64_t value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSbyte(int8_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong(int32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongLong8(uint64_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong8(int64_t value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongLong(uint32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongLong8(uint64_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongSlong8(int64_t value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Sbyte(int8_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Sshort(int16_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Slong(int32_t value);
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Slong8(int64_t value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlong8Long8(uint64_t value);
+
+static enum TIFFReadDirEntryErr TIFFReadDirEntryData(TIFF* tif, uint64_t offset, tmsize_t size, void* dest);
 static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover);
 
-static void TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount);
-static TIFFDirEntry* TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid);
-static void TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii);
+static void TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16_t dircount);
+static TIFFDirEntry* TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16_t dircount, uint16_t tagid);
+static void TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16_t tagid, uint32_t* fii);
 
-static int EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount);
+static int EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16_t dircount);
 static void MissingRequired(TIFF*, const char*);
-static int TIFFCheckDirOffset(TIFF* tif, uint64 diroff);
-static int CheckDirCount(TIFF*, TIFFDirEntry*, uint32);
-static uint16 TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir, uint64* nextdiroff);
+static int TIFFCheckDirOffset(TIFF* tif, uint64_t diroff);
+static int CheckDirCount(TIFF*, TIFFDirEntry*, uint32_t);
+static uint16_t TIFFFetchDirectory(TIFF* tif, uint64_t diroff, TIFFDirEntry** pdir, uint64_t* nextdiroff);
 static int TIFFFetchNormalTag(TIFF*, TIFFDirEntry*, int recover);
-static int TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp);
+static int TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32_t nstrips, uint64_t** lpp);
 static int TIFFFetchSubjectDistance(TIFF*, TIFFDirEntry*);
 static void ChopUpSingleUncompressedStrip(TIFF*);
 static void TryChopUpUncompressedBigTiff(TIFF*);
-static uint64 TIFFReadUInt64(const uint8 *value);
-static int _TIFFGetMaxColorChannels(uint16 photometric);
+static uint64_t TIFFReadUInt64(const uint8_t *value);
+static int _TIFFGetMaxColorChannels(uint16_t photometric);
 
 static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount );
 
 typedef union _UInt64Aligned_t
 {
         double d;
-	uint64 l;
-	uint32 i[2];
-	uint16 s[4];
-	uint8  c[8];
+	uint64_t l;
+	uint32_t i[2];
+	uint16_t s[4];
+	uint8_t  c[8];
 } UInt64Aligned_t;
 
 /*
-  Unaligned safe copy of a uint64 value from an octet array.
+  Unaligned safe copy of a uint64_t value from an octet array.
 */
-static uint64 TIFFReadUInt64(const uint8 *value)
+static uint64_t TIFFReadUInt64(const uint8_t *value)
 {
 	UInt64Aligned_t result;
 
@@ -199,7 +195,7 @@ static uint64 TIFFReadUInt64(const uint8 *value)
 	return result.l;
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8_t* value)
 {
 	enum TIFFReadDirEntryErr err;
 	if (direntry->tdir_count!=1)
@@ -212,76 +208,76 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* di
 			return(TIFFReadDirEntryErrOk);
 		case TIFF_SBYTE:
 			{
-				int8 m;
+				int8_t m;
 				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeByteSbyte(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint8)m;
+				*value=(uint8_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SHORT:
 			{
-				uint16 m;
+				uint16_t m;
 				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeByteShort(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint8)m;
+				*value=(uint8_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SSHORT:
 			{
-				int16 m;
+				int16_t m;
 				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeByteSshort(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint8)m;
+				*value=(uint8_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG:
 			{
-				uint32 m;
+				uint32_t m;
 				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeByteLong(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint8)m;
+				*value=(uint8_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG:
 			{
-				int32 m;
+				int32_t m;
 				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeByteSlong(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint8)m;
+				*value=(uint8_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG8:
 			{
-				uint64 m;
+				uint64_t m;
 				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
 				err=TIFFReadDirEntryCheckRangeByteLong8(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint8)m;
+				*value=(uint8_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG8:
 			{
-				int64 m;
+				int64_t m;
 				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
 				err=TIFFReadDirEntryCheckRangeByteSlong8(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint8)m;
+				*value=(uint8_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		default:
@@ -289,7 +285,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* di
 	}
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16_t* value)
 {
 	enum TIFFReadDirEntryErr err;
 	if (direntry->tdir_count!=1)
@@ -298,19 +294,19 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* d
 	{
 		case TIFF_BYTE:
 			{
-				uint8 m;
+				uint8_t m;
 				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
-				*value=(uint16)m;
+				*value=(uint16_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SBYTE:
 			{
-				int8 m;
+				int8_t m;
 				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeShortSbyte(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint16)m;
+				*value=(uint16_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SHORT:
@@ -318,56 +314,56 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* d
 			return(TIFFReadDirEntryErrOk);
 		case TIFF_SSHORT:
 			{
-				int16 m;
+				int16_t m;
 				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeShortSshort(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint16)m;
+				*value=(uint16_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG:
 			{
-				uint32 m;
+				uint32_t m;
 				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeShortLong(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint16)m;
+				*value=(uint16_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG:
 			{
-				int32 m;
+				int32_t m;
 				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeShortSlong(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint16)m;
+				*value=(uint16_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG8:
 			{
-				uint64 m;
+				uint64_t m;
 				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
 				err=TIFFReadDirEntryCheckRangeShortLong8(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint16)m;
+				*value=(uint16_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG8:
 			{
-				int64 m;
+				int64_t m;
 				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
 				err=TIFFReadDirEntryCheckRangeShortSlong8(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint16)m;
+				*value=(uint16_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		default:
@@ -375,7 +371,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* d
 	}
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32_t* value)
 {
 	enum TIFFReadDirEntryErr err;
 	if (direntry->tdir_count!=1)
@@ -384,36 +380,36 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* di
 	{
 		case TIFF_BYTE:
 			{
-				uint8 m;
+				uint8_t m;
 				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
-				*value=(uint32)m;
+				*value=(uint32_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SBYTE:
 			{
-				int8 m;
+				int8_t m;
 				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeLongSbyte(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint32)m;
+				*value=(uint32_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SHORT:
 			{
-				uint16 m;
+				uint16_t m;
 				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
-				*value=(uint32)m;
+				*value=(uint32_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SSHORT:
 			{
-				int16 m;
+				int16_t m;
 				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeLongSshort(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint32)m;
+				*value=(uint32_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG:
@@ -421,36 +417,36 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* di
 			return(TIFFReadDirEntryErrOk);
 		case TIFF_SLONG:
 			{
-				int32 m;
+				int32_t m;
 				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeLongSlong(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint32)m;
+				*value=(uint32_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG8:
 			{
-				uint64 m;
+				uint64_t m;
 				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
 				err=TIFFReadDirEntryCheckRangeLongLong8(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint32)m;
+				*value=(uint32_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG8:
 			{
-				int64 m;
+				int64_t m;
 				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
 				err=TIFFReadDirEntryCheckRangeLongSlong8(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint32)m;
+				*value=(uint32_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		default:
@@ -458,7 +454,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* di
 	}
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64_t* value)
 {
 	enum TIFFReadDirEntryErr err;
 	if (direntry->tdir_count!=1)
@@ -467,53 +463,53 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* d
 	{
 		case TIFF_BYTE:
 			{
-				uint8 m;
+				uint8_t m;
 				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
-				*value=(uint64)m;
+				*value=(uint64_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SBYTE:
 			{
-				int8 m;
+				int8_t m;
 				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeLong8Sbyte(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint64)m;
+				*value=(uint64_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SHORT:
 			{
-				uint16 m;
+				uint16_t m;
 				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
-				*value=(uint64)m;
+				*value=(uint64_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SSHORT:
 			{
-				int16 m;
+				int16_t m;
 				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeLong8Sshort(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint64)m;
+				*value=(uint64_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG:
 			{
-				uint32 m;
+				uint32_t m;
 				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
-				*value=(uint64)m;
+				*value=(uint64_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG:
 			{
-				int32 m;
+				int32_t m;
 				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
 				err=TIFFReadDirEntryCheckRangeLong8Slong(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint64)m;
+				*value=(uint64_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG8:
@@ -521,14 +517,14 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* d
 			return(err);
 		case TIFF_SLONG8:
 			{
-				int64 m;
+				int64_t m;
 				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
 				err=TIFFReadDirEntryCheckRangeLong8Slong8(m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				*value=(uint64)m;
+				*value=(uint64_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		default:
@@ -545,49 +541,49 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloat(TIFF* tif, TIFFDirEntry* d
 	{
 		case TIFF_BYTE:
 			{
-				uint8 m;
+				uint8_t m;
 				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
 				*value=(float)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SBYTE:
 			{
-				int8 m;
+				int8_t m;
 				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
 				*value=(float)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SHORT:
 			{
-				uint16 m;
+				uint16_t m;
 				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
 				*value=(float)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SSHORT:
 			{
-				int16 m;
+				int16_t m;
 				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
 				*value=(float)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG:
 			{
-				uint32 m;
+				uint32_t m;
 				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
 				*value=(float)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG:
 			{
-				int32 m;
+				int32_t m;
 				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
 				*value=(float)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG8:
 			{
-				uint64 m;
+				uint64_t m;
 				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
@@ -605,7 +601,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloat(TIFF* tif, TIFFDirEntry* d
 			}
 		case TIFF_SLONG8:
 			{
-				int64 m;
+				int64_t m;
 				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
@@ -639,7 +635,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloat(TIFF* tif, TIFFDirEntry* d
 				err=TIFFReadDirEntryCheckedDouble(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
-				if ((m > FLT_MAX) || (m < FLT_MIN))
+				if ((m > FLT_MAX) || (m < -FLT_MAX))
 					return(TIFFReadDirEntryErrRange);
 				*value=(float)m;
 				return(TIFFReadDirEntryErrOk);
@@ -658,49 +654,49 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry*
 	{
 		case TIFF_BYTE:
 			{
-				uint8 m;
+				uint8_t m;
 				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
 				*value=(double)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SBYTE:
 			{
-				int8 m;
+				int8_t m;
 				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
 				*value=(double)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SHORT:
 			{
-				uint16 m;
+				uint16_t m;
 				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
 				*value=(double)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SSHORT:
 			{
-				int16 m;
+				int16_t m;
 				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
 				*value=(double)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG:
 			{
-				uint32 m;
+				uint32_t m;
 				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
 				*value=(double)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG:
 			{
-				int32 m;
+				int32_t m;
 				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
 				*value=(double)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG8:
 			{
-				uint64 m;
+				uint64_t m;
 				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
@@ -718,7 +714,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry*
 			}
 		case TIFF_SLONG8:
 			{
-				int64 m;
+				int64_t m;
 				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
 				if (err!=TIFFReadDirEntryErrOk)
 					return(err);
@@ -746,7 +742,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry*
 	}
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* direntry, uint64_t* value)
 {
 	enum TIFFReadDirEntryErr err;
 	if (direntry->tdir_count!=1)
@@ -756,9 +752,9 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* di
 		case TIFF_LONG:
 		case TIFF_IFD:
 			{
-				uint32 m;
+				uint32_t m;
 				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
-				*value=(uint64)m;
+				*value=(uint64_t)m;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_LONG8:
@@ -776,7 +772,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* di
 #define MAX_THRESHOLD (THRESHOLD_MULTIPLIER * THRESHOLD_MULTIPLIER * THRESHOLD_MULTIPLIER * INITIAL_THRESHOLD)
 
 static enum TIFFReadDirEntryErr TIFFReadDirEntryDataAndRealloc(
-                    TIFF* tif, uint64 offset, tmsize_t size, void** pdest)
+        TIFF* tif, uint64_t offset, tmsize_t size, void** pdest)
 {
 #if SIZEOF_SIZE_T == 8
         tmsize_t threshold = INITIAL_THRESHOLD;
@@ -807,15 +803,15 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryDataAndRealloc(
             }
 #endif
 
-            new_dest = (uint8*) _TIFFrealloc(
+            new_dest = (uint8_t*) _TIFFrealloc(
                             *pdest, already_read + to_read);
             if( new_dest == NULL )
             {
                 TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                             "Failed to allocate memory for %s "
-                            "(%ld elements of %ld bytes each)",
+                            "(%"TIFF_SSIZE_FORMAT" elements of %"TIFF_SSIZE_FORMAT" bytes each)",
                             "TIFFReadDirEntryArray",
-                             (long) 1, (long) (already_read + to_read));
+                             (tmsize_t) 1, already_read + to_read);
                 return TIFFReadDirEntryErrAlloc;
             }
             *pdest = new_dest;
@@ -831,13 +827,14 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryDataAndRealloc(
 }
 
 static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(
-    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,
-    void** value, uint64 maxcount)
+        TIFF* tif, TIFFDirEntry* direntry, uint32_t* count, uint32_t desttypesize,
+        void** value, uint64_t maxcount)
 {
 	int typesize;
-	uint32 datasize;
+	uint32_t datasize;
 	void* data;
-        uint64 target_count64;
+        uint64_t target_count64;
+        int original_datasize_clamped;
 	typesize=TIFFDataWidth(direntry->tdir_type);
 
         target_count64 = (direntry->tdir_count > maxcount) ?
@@ -850,21 +847,27 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(
 	}
         (void) desttypesize;
 
+        /* We just want to know if the original tag size is more than 4 bytes
+         * (classic TIFF) or 8 bytes (BigTIFF)
+         */
+        original_datasize_clamped =
+            ((direntry->tdir_count > 10) ? 10 : (int)direntry->tdir_count) * typesize;
+
         /* 
          * As a sanity check, make sure we have no more than a 2GB tag array 
          * in either the current data type or the dest data type.  This also
          * avoids problems with overflow of tmsize_t on 32bit systems.
          */
-	if ((uint64)(2147483647/typesize)<target_count64)
+	if ((uint64_t)(2147483647 / typesize) < target_count64)
 		return(TIFFReadDirEntryErrSizesan);
-	if ((uint64)(2147483647/desttypesize)<target_count64)
+	if ((uint64_t)(2147483647 / desttypesize) < target_count64)
 		return(TIFFReadDirEntryErrSizesan);
 
-	*count=(uint32)target_count64;
+	*count=(uint32_t)target_count64;
 	datasize=(*count)*typesize;
 	assert((tmsize_t)datasize>0);
 
-	if( isMapped(tif) && datasize > (uint32)tif->tif_size )
+	if( isMapped(tif) && datasize > (uint64_t)tif->tif_size )
 		return TIFFReadDirEntryErrIo;
 
 	if( !isMapped(tif) &&
@@ -881,18 +884,20 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(
 	}
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
-		if (datasize<=4)
+		/* Only the condition on original_datasize_clamped. The second
+		 * one is implied, but Coverity Scan cannot see it. */
+		if (original_datasize_clamped<=4 && datasize <= 4 )
 			_TIFFmemcpy(data,&direntry->tdir_offset,datasize);
 		else
 		{
 			enum TIFFReadDirEntryErr err;
-			uint32 offset = direntry->tdir_offset.toff_long;
+			uint32_t offset = direntry->tdir_offset.toff_long;
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabLong(&offset);
 			if( isMapped(tif) )
-				err=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);
+				err=TIFFReadDirEntryData(tif, (uint64_t)offset, (tmsize_t)datasize, data);
 			else
-				err=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);
+				err=TIFFReadDirEntryDataAndRealloc(tif, (uint64_t)offset, (tmsize_t)datasize, &data);
 			if (err!=TIFFReadDirEntryErrOk)
 			{
 				_TIFFfree(data);
@@ -902,18 +907,19 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(
 	}
 	else
 	{
-		if (datasize<=8)
+		/* See above comment for the Classic TIFF case */
+		if (original_datasize_clamped<=8 && datasize <= 8 )
 			_TIFFmemcpy(data,&direntry->tdir_offset,datasize);
 		else
 		{
 			enum TIFFReadDirEntryErr err;
-			uint64 offset = direntry->tdir_offset.toff_long8;
+			uint64_t offset = direntry->tdir_offset.toff_long8;
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabLong8(&offset);
 			if( isMapped(tif) )
-				err=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);
+				err=TIFFReadDirEntryData(tif, (uint64_t)offset, (tmsize_t)datasize, data);
 			else
-				err=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);
+				err=TIFFReadDirEntryDataAndRealloc(tif, (uint64_t)offset, (tmsize_t)datasize, &data);
 			if (err!=TIFFReadDirEntryErrOk)
 			{
 				_TIFFfree(data);
@@ -925,18 +931,18 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32_t* count, uint32_t desttypesize, void** value)
 {
     return TIFFReadDirEntryArrayWithLimit(tif, direntry, count,
-                                          desttypesize, value, ~((uint64)0));
+                                          desttypesize, value, ~((uint64_t)0));
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8_t** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	uint8* data;
+	uint8_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_ASCII:
@@ -964,13 +970,13 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntr
 		case TIFF_ASCII:
 		case TIFF_UNDEFINED:
 		case TIFF_BYTE:
-			*value=(uint8*)origdata;
+			*value=(uint8_t*)origdata;
 			return(TIFFReadDirEntryErrOk);
 		case TIFF_SBYTE:
 			{
-				int8* m;
-				uint32 n;
-				m=(int8*)origdata;
+				int8_t* m;
+				uint32_t n;
+				m=(int8_t*)origdata;
 				for (n=0; n<count; n++)
 				{
 					err=TIFFReadDirEntryCheckRangeByteSbyte(*m);
@@ -981,11 +987,11 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntr
 					}
 					m++;
 				}
-				*value=(uint8*)origdata;
+				*value=(uint8_t*)origdata;
 				return(TIFFReadDirEntryErrOk);
 			}
 	}
-	data=(uint8*)_TIFFmalloc(count);
+	data=(uint8_t*)_TIFFmalloc(count);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -995,10 +1001,10 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntr
 	{
 		case TIFF_SHORT:
 			{
-				uint16* ma;
-				uint8* mb;
-				uint32 n;
-				ma=(uint16*)origdata;
+				uint16_t* ma;
+				uint8_t* mb;
+				uint32_t n;
+				ma=(uint16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1007,34 +1013,34 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntr
 					err=TIFFReadDirEntryCheckRangeByteShort(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint8)(*ma++);
+					*mb++=(uint8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SSHORT:
 			{
-				int16* ma;
-				uint8* mb;
-				uint32 n;
-				ma=(int16*)origdata;
+				int16_t* ma;
+				uint8_t* mb;
+				uint32_t n;
+				ma=(int16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)ma);
+						TIFFSwabShort((uint16_t*)ma);
 					err=TIFFReadDirEntryCheckRangeByteSshort(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint8)(*ma++);
+					*mb++=(uint8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG:
 			{
-				uint32* ma;
-				uint8* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t* ma;
+				uint8_t* mb;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1043,34 +1049,34 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntr
 					err=TIFFReadDirEntryCheckRangeByteLong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint8)(*ma++);
+					*mb++=(uint8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG:
 			{
-				int32* ma;
-				uint8* mb;
-				uint32 n;
-				ma=(int32*)origdata;
+				int32_t* ma;
+				uint8_t* mb;
+				uint32_t n;
+				ma=(int32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)ma);
+						TIFFSwabLong((uint32_t*)ma);
 					err=TIFFReadDirEntryCheckRangeByteSlong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint8)(*ma++);
+					*mb++=(uint8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG8:
 			{
-				uint64* ma;
-				uint8* mb;
-				uint32 n;
-				ma=(uint64*)origdata;
+				uint64_t* ma;
+				uint8_t* mb;
+				uint32_t n;
+				ma=(uint64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1079,25 +1085,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntr
 					err=TIFFReadDirEntryCheckRangeByteLong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint8)(*ma++);
+					*mb++=(uint8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG8:
 			{
-				int64* ma;
-				uint8* mb;
-				uint32 n;
-				ma=(int64*)origdata;
+				int64_t* ma;
+				uint8_t* mb;
+				uint32_t n;
+				ma=(int64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)ma);
+						TIFFSwabLong8((uint64_t*)ma);
 					err=TIFFReadDirEntryCheckRangeByteSlong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint8)(*ma++);
+					*mb++=(uint8_t)(*ma++);
 				}
 			}
 			break;
@@ -1112,12 +1118,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntr
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEntry* direntry, int8** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEntry* direntry, int8_t** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	int8* data;
+	int8_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_UNDEFINED:
@@ -1144,9 +1150,9 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEnt
 		case TIFF_UNDEFINED:
 		case TIFF_BYTE:
 			{
-				uint8* m;
-				uint32 n;
-				m=(uint8*)origdata;
+				uint8_t* m;
+				uint32_t n;
+				m=(uint8_t*)origdata;
 				for (n=0; n<count; n++)
 				{
 					err=TIFFReadDirEntryCheckRangeSbyteByte(*m);
@@ -1157,14 +1163,14 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEnt
 					}
 					m++;
 				}
-				*value=(int8*)origdata;
+				*value=(int8_t*)origdata;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SBYTE:
-			*value=(int8*)origdata;
+			*value=(int8_t*)origdata;
 			return(TIFFReadDirEntryErrOk);
 	}
-	data=(int8*)_TIFFmalloc(count);
+	data=(int8_t*)_TIFFmalloc(count);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -1174,10 +1180,10 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEnt
 	{
 		case TIFF_SHORT:
 			{
-				uint16* ma;
-				int8* mb;
-				uint32 n;
-				ma=(uint16*)origdata;
+				uint16_t* ma;
+				int8_t* mb;
+				uint32_t n;
+				ma=(uint16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1186,34 +1192,34 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEnt
 					err=TIFFReadDirEntryCheckRangeSbyteShort(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int8)(*ma++);
+					*mb++=(int8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SSHORT:
 			{
-				int16* ma;
-				int8* mb;
-				uint32 n;
-				ma=(int16*)origdata;
+				int16_t* ma;
+				int8_t* mb;
+				uint32_t n;
+				ma=(int16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)ma);
+						TIFFSwabShort((uint16_t*)ma);
 					err=TIFFReadDirEntryCheckRangeSbyteSshort(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int8)(*ma++);
+					*mb++=(int8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG:
 			{
-				uint32* ma;
-				int8* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t* ma;
+				int8_t* mb;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1222,34 +1228,34 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEnt
 					err=TIFFReadDirEntryCheckRangeSbyteLong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int8)(*ma++);
+					*mb++=(int8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG:
 			{
-				int32* ma;
-				int8* mb;
-				uint32 n;
-				ma=(int32*)origdata;
+				int32_t* ma;
+				int8_t* mb;
+				uint32_t n;
+				ma=(int32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)ma);
+						TIFFSwabLong((uint32_t*)ma);
 					err=TIFFReadDirEntryCheckRangeSbyteSlong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int8)(*ma++);
+					*mb++=(int8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG8:
 			{
-				uint64* ma;
-				int8* mb;
-				uint32 n;
-				ma=(uint64*)origdata;
+				uint64_t* ma;
+				int8_t* mb;
+				uint32_t n;
+				ma=(uint64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1258,25 +1264,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEnt
 					err=TIFFReadDirEntryCheckRangeSbyteLong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int8)(*ma++);
+					*mb++=(int8_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG8:
 			{
-				int64* ma;
-				int8* mb;
-				uint32 n;
-				ma=(int64*)origdata;
+				int64_t* ma;
+				int8_t* mb;
+				uint32_t n;
+				ma=(int64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)ma);
+						TIFFSwabLong8((uint64_t*)ma);
 					err=TIFFReadDirEntryCheckRangeSbyteSlong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int8)(*ma++);
+					*mb++=(int8_t)(*ma++);
 				}
 			}
 			break;
@@ -1291,12 +1297,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEnt
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16_t** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	uint16* data;
+	uint16_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_BYTE:
@@ -1320,19 +1326,19 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEnt
 	switch (direntry->tdir_type)
 	{
 		case TIFF_SHORT:
-			*value=(uint16*)origdata;
+			*value=(uint16_t*)origdata;
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabArrayOfShort(*value,count);  
 			return(TIFFReadDirEntryErrOk);
 		case TIFF_SSHORT:
 			{
-				int16* m;
-				uint32 n;
-				m=(int16*)origdata;
+				int16_t* m;
+				uint32_t n;
+				m=(int16_t*)origdata;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)m);
+						TIFFSwabShort((uint16_t*)m);
 					err=TIFFReadDirEntryCheckRangeShortSshort(*m);
 					if (err!=TIFFReadDirEntryErrOk)
 					{
@@ -1341,11 +1347,11 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEnt
 					}
 					m++;
 				}
-				*value=(uint16*)origdata;
+				*value=(uint16_t*)origdata;
 				return(TIFFReadDirEntryErrOk);
 			}
 	}
-	data=(uint16*)_TIFFmalloc(count*2);
+	data=(uint16_t*)_TIFFmalloc(count * 2);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -1355,37 +1361,37 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEnt
 	{
 		case TIFF_BYTE:
 			{
-				uint8* ma;
-				uint16* mb;
-				uint32 n;
-				ma=(uint8*)origdata;
+				uint8_t* ma;
+				uint16_t* mb;
+				uint32_t n;
+				ma=(uint8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(uint16)(*ma++);
+					*mb++=(uint16_t)(*ma++);
 			}
 			break;
 		case TIFF_SBYTE:
 			{
-				int8* ma;
-				uint16* mb;
-				uint32 n;
-				ma=(int8*)origdata;
+				int8_t* ma;
+				uint16_t* mb;
+				uint32_t n;
+				ma=(int8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					err=TIFFReadDirEntryCheckRangeShortSbyte(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint16)(*ma++);
+					*mb++=(uint16_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG:
 			{
-				uint32* ma;
-				uint16* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t* ma;
+				uint16_t* mb;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1394,34 +1400,34 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEnt
 					err=TIFFReadDirEntryCheckRangeShortLong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint16)(*ma++);
+					*mb++=(uint16_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG:
 			{
-				int32* ma;
-				uint16* mb;
-				uint32 n;
-				ma=(int32*)origdata;
+				int32_t* ma;
+				uint16_t* mb;
+				uint32_t n;
+				ma=(int32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)ma);
+						TIFFSwabLong((uint32_t*)ma);
 					err=TIFFReadDirEntryCheckRangeShortSlong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint16)(*ma++);
+					*mb++=(uint16_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG8:
 			{
-				uint64* ma;
-				uint16* mb;
-				uint32 n;
-				ma=(uint64*)origdata;
+				uint64_t* ma;
+				uint16_t* mb;
+				uint32_t n;
+				ma=(uint64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1430,25 +1436,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEnt
 					err=TIFFReadDirEntryCheckRangeShortLong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint16)(*ma++);
+					*mb++=(uint16_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG8:
 			{
-				int64* ma;
-				uint16* mb;
-				uint32 n;
-				ma=(int64*)origdata;
+				int64_t* ma;
+				uint16_t* mb;
+				uint32_t n;
+				ma=(int64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)ma);
+						TIFFSwabLong8((uint64_t*)ma);
 					err=TIFFReadDirEntryCheckRangeShortSlong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint16)(*ma++);
+					*mb++=(uint16_t)(*ma++);
 				}
 			}
 			break;
@@ -1463,12 +1469,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEnt
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEntry* direntry, int16** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEntry* direntry, int16_t** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	int16* data;
+	int16_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_BYTE:
@@ -1493,9 +1499,9 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEn
 	{
 		case TIFF_SHORT:
 			{
-				uint16* m;
-				uint32 n;
-				m=(uint16*)origdata;
+				uint16_t* m;
+				uint32_t n;
+				m=(uint16_t*)origdata;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
@@ -1508,16 +1514,16 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEn
 					}
 					m++;
 				}
-				*value=(int16*)origdata;
+				*value=(int16_t*)origdata;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SSHORT:
-			*value=(int16*)origdata;
+			*value=(int16_t*)origdata;
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabArrayOfShort((uint16*)(*value),count);
+				TIFFSwabArrayOfShort((uint16_t*)(*value), count);
 			return(TIFFReadDirEntryErrOk);
 	}
-	data=(int16*)_TIFFmalloc(count*2);
+	data=(int16_t*)_TIFFmalloc(count * 2);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -1527,32 +1533,32 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEn
 	{
 		case TIFF_BYTE:
 			{
-				uint8* ma;
-				int16* mb;
-				uint32 n;
-				ma=(uint8*)origdata;
+				uint8_t* ma;
+				int16_t* mb;
+				uint32_t n;
+				ma=(uint8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(int16)(*ma++);
+					*mb++=(int16_t)(*ma++);
 			}
 			break;
 		case TIFF_SBYTE:
 			{
-				int8* ma;
-				int16* mb;
-				uint32 n;
-				ma=(int8*)origdata;
+				int8_t* ma;
+				int16_t* mb;
+				uint32_t n;
+				ma=(int8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(int16)(*ma++);
+					*mb++=(int16_t)(*ma++);
 			}
 			break;
 		case TIFF_LONG:
 			{
-				uint32* ma;
-				int16* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t* ma;
+				int16_t* mb;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1561,34 +1567,34 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEn
 					err=TIFFReadDirEntryCheckRangeSshortLong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int16)(*ma++);
+					*mb++=(int16_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG:
 			{
-				int32* ma;
-				int16* mb;
-				uint32 n;
-				ma=(int32*)origdata;
+				int32_t* ma;
+				int16_t* mb;
+				uint32_t n;
+				ma=(int32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)ma);
+						TIFFSwabLong((uint32_t*)ma);
 					err=TIFFReadDirEntryCheckRangeSshortSlong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int16)(*ma++);
+					*mb++=(int16_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG8:
 			{
-				uint64* ma;
-				int16* mb;
-				uint32 n;
-				ma=(uint64*)origdata;
+				uint64_t* ma;
+				int16_t* mb;
+				uint32_t n;
+				ma=(uint64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1597,25 +1603,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEn
 					err=TIFFReadDirEntryCheckRangeSshortLong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int16)(*ma++);
+					*mb++=(int16_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG8:
 			{
-				int64* ma;
-				int16* mb;
-				uint32 n;
-				ma=(int64*)origdata;
+				int64_t* ma;
+				int16_t* mb;
+				uint32_t n;
+				ma=(int64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)ma);
+						TIFFSwabLong8((uint64_t*)ma);
 					err=TIFFReadDirEntryCheckRangeSshortSlong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int16)(*ma++);
+					*mb++=(int16_t)(*ma++);
 				}
 			}
 			break;
@@ -1630,12 +1636,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEn
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntry* direntry, uint32** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntry* direntry, uint32_t** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	uint32* data;
+	uint32_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_BYTE:
@@ -1659,19 +1665,19 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntr
 	switch (direntry->tdir_type)
 	{
 		case TIFF_LONG:
-			*value=(uint32*)origdata;
+			*value=(uint32_t*)origdata;
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabArrayOfLong(*value,count);
 			return(TIFFReadDirEntryErrOk);
 		case TIFF_SLONG:
 			{
-				int32* m;
-				uint32 n;
-				m=(int32*)origdata;
+				int32_t* m;
+				uint32_t n;
+				m=(int32_t*)origdata;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)m);
+						TIFFSwabLong((uint32_t*)m);
 					err=TIFFReadDirEntryCheckRangeLongSlong(*m);
 					if (err!=TIFFReadDirEntryErrOk)
 					{
@@ -1680,11 +1686,11 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntr
 					}
 					m++;
 				}
-				*value=(uint32*)origdata;
+				*value=(uint32_t*)origdata;
 				return(TIFFReadDirEntryErrOk);
 			}
 	}
-	data=(uint32*)_TIFFmalloc(count*4);
+	data=(uint32_t*)_TIFFmalloc(count * 4);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -1694,70 +1700,70 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntr
 	{
 		case TIFF_BYTE:
 			{
-				uint8* ma;
-				uint32* mb;
-				uint32 n;
-				ma=(uint8*)origdata;
+				uint8_t* ma;
+				uint32_t* mb;
+				uint32_t n;
+				ma=(uint8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(uint32)(*ma++);
+					*mb++=(uint32_t)(*ma++);
 			}
 			break;
 		case TIFF_SBYTE:
 			{
-				int8* ma;
-				uint32* mb;
-				uint32 n;
-				ma=(int8*)origdata;
+				int8_t* ma;
+				uint32_t* mb;
+				uint32_t n;
+				ma=(int8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					err=TIFFReadDirEntryCheckRangeLongSbyte(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint32)(*ma++);
+					*mb++=(uint32_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SHORT:
 			{
-				uint16* ma;
-				uint32* mb;
-				uint32 n;
-				ma=(uint16*)origdata;
+				uint16_t* ma;
+				uint32_t* mb;
+				uint32_t n;
+				ma=(uint16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabShort(ma);
-					*mb++=(uint32)(*ma++);
+					*mb++=(uint32_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SSHORT:
 			{
-				int16* ma;
-				uint32* mb;
-				uint32 n;
-				ma=(int16*)origdata;
+				int16_t* ma;
+				uint32_t* mb;
+				uint32_t n;
+				ma=(int16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)ma);
+						TIFFSwabShort((uint16_t*)ma);
 					err=TIFFReadDirEntryCheckRangeLongSshort(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint32)(*ma++);
+					*mb++=(uint32_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG8:
 			{
-				uint64* ma;
-				uint32* mb;
-				uint32 n;
-				ma=(uint64*)origdata;
+				uint64_t* ma;
+				uint32_t* mb;
+				uint32_t n;
+				ma=(uint64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1766,25 +1772,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntr
 					err=TIFFReadDirEntryCheckRangeLongLong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint32)(*ma++);
+					*mb++=(uint32_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG8:
 			{
-				int64* ma;
-				uint32* mb;
-				uint32 n;
-				ma=(int64*)origdata;
+				int64_t* ma;
+				uint32_t* mb;
+				uint32_t n;
+				ma=(int64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)ma);
+						TIFFSwabLong8((uint64_t*)ma);
 					err=TIFFReadDirEntryCheckRangeLongSlong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint32)(*ma++);
+					*mb++=(uint32_t)(*ma++);
 				}
 			}
 			break;
@@ -1799,12 +1805,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntr
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEntry* direntry, int32** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEntry* direntry, int32_t** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	int32* data;
+	int32_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_BYTE:
@@ -1829,13 +1835,13 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEnt
 	{
 		case TIFF_LONG:
 			{
-				uint32* m;
-				uint32 n;
-				m=(uint32*)origdata;
+				uint32_t* m;
+				uint32_t n;
+				m=(uint32_t*)origdata;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)m);
+						TIFFSwabLong((uint32_t*)m);
 					err=TIFFReadDirEntryCheckRangeSlongLong(*m);
 					if (err!=TIFFReadDirEntryErrOk)
 					{
@@ -1844,16 +1850,16 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEnt
 					}
 					m++;
 				}
-				*value=(int32*)origdata;
+				*value=(int32_t*)origdata;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG:
-			*value=(int32*)origdata;
+			*value=(int32_t*)origdata;
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabArrayOfLong((uint32*)(*value),count);
+				TIFFSwabArrayOfLong((uint32_t*)(*value), count);
 			return(TIFFReadDirEntryErrOk);
 	}
-	data=(int32*)_TIFFmalloc(count*4);
+	data=(int32_t*)_TIFFmalloc(count * 4);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -1863,62 +1869,62 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEnt
 	{
 		case TIFF_BYTE:
 			{
-				uint8* ma;
-				int32* mb;
-				uint32 n;
-				ma=(uint8*)origdata;
+				uint8_t* ma;
+				int32_t* mb;
+				uint32_t n;
+				ma=(uint8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(int32)(*ma++);
+					*mb++=(int32_t)(*ma++);
 			}
 			break;
 		case TIFF_SBYTE:
 			{
-				int8* ma;
-				int32* mb;
-				uint32 n;
-				ma=(int8*)origdata;
+				int8_t* ma;
+				int32_t* mb;
+				uint32_t n;
+				ma=(int8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(int32)(*ma++);
+					*mb++=(int32_t)(*ma++);
 			}
 			break;
 		case TIFF_SHORT:
 			{
-				uint16* ma;
-				int32* mb;
-				uint32 n;
-				ma=(uint16*)origdata;
+				uint16_t* ma;
+				int32_t* mb;
+				uint32_t n;
+				ma=(uint16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabShort(ma);
-					*mb++=(int32)(*ma++);
+					*mb++=(int32_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SSHORT:
 			{
-				int16* ma;
-				int32* mb;
-				uint32 n;
-				ma=(int16*)origdata;
+				int16_t* ma;
+				int32_t* mb;
+				uint32_t n;
+				ma=(int16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)ma);
-					*mb++=(int32)(*ma++);
+						TIFFSwabShort((uint16_t*)ma);
+					*mb++=(int32_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG8:
 			{
-				uint64* ma;
-				int32* mb;
-				uint32 n;
-				ma=(uint64*)origdata;
+				uint64_t* ma;
+				int32_t* mb;
+				uint32_t n;
+				ma=(uint64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -1927,25 +1933,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEnt
 					err=TIFFReadDirEntryCheckRangeSlongLong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int32)(*ma++);
+					*mb++=(int32_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG8:
 			{
-				int64* ma;
-				int32* mb;
-				uint32 n;
-				ma=(int64*)origdata;
+				int64_t* ma;
+				int32_t* mb;
+				uint32_t n;
+				ma=(int64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)ma);
+						TIFFSwabLong8((uint64_t*)ma);
 					err=TIFFReadDirEntryCheckRangeSlongSlong8(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(int32)(*ma++);
+					*mb++=(int32_t)(*ma++);
 				}
 			}
 			break;
@@ -1961,12 +1967,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEnt
 }
 
 static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8ArrayWithLimit(
-        TIFF* tif, TIFFDirEntry* direntry, uint64** value, uint64 maxcount)
+        TIFF* tif, TIFFDirEntry* direntry, uint64_t** value, uint64_t maxcount)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	uint64* data;
+	uint64_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_BYTE:
@@ -1990,19 +1996,19 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8ArrayWithLimit(
 	switch (direntry->tdir_type)
 	{
 		case TIFF_LONG8:
-			*value=(uint64*)origdata;
+			*value=(uint64_t*)origdata;
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabArrayOfLong8(*value,count);
 			return(TIFFReadDirEntryErrOk);
 		case TIFF_SLONG8:
 			{
-				int64* m;
-				uint32 n;
-				m=(int64*)origdata;
+				int64_t* m;
+				uint32_t n;
+				m=(int64_t*)origdata;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)m);
+						TIFFSwabLong8((uint64_t*)m);
 					err=TIFFReadDirEntryCheckRangeLong8Slong8(*m);
 					if (err!=TIFFReadDirEntryErrOk)
 					{
@@ -2011,11 +2017,11 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8ArrayWithLimit(
 					}
 					m++;
 				}
-				*value=(uint64*)origdata;
+				*value=(uint64_t*)origdata;
 				return(TIFFReadDirEntryErrOk);
 			}
 	}
-	data=(uint64*)_TIFFmalloc(count*8);
+	data=(uint64_t*)_TIFFmalloc(count * 8);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -2025,94 +2031,94 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8ArrayWithLimit(
 	{
 		case TIFF_BYTE:
 			{
-				uint8* ma;
-				uint64* mb;
-				uint32 n;
-				ma=(uint8*)origdata;
+				uint8_t* ma;
+				uint64_t* mb;
+				uint32_t n;
+				ma=(uint8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(uint64)(*ma++);
+					*mb++=(uint64_t)(*ma++);
 			}
 			break;
 		case TIFF_SBYTE:
 			{
-				int8* ma;
-				uint64* mb;
-				uint32 n;
-				ma=(int8*)origdata;
+				int8_t* ma;
+				uint64_t* mb;
+				uint32_t n;
+				ma=(int8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					err=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint64)(*ma++);
+					*mb++=(uint64_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SHORT:
 			{
-				uint16* ma;
-				uint64* mb;
-				uint32 n;
-				ma=(uint16*)origdata;
+				uint16_t* ma;
+				uint64_t* mb;
+				uint32_t n;
+				ma=(uint16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabShort(ma);
-					*mb++=(uint64)(*ma++);
+					*mb++=(uint64_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SSHORT:
 			{
-				int16* ma;
-				uint64* mb;
-				uint32 n;
-				ma=(int16*)origdata;
+				int16_t* ma;
+				uint64_t* mb;
+				uint32_t n;
+				ma=(int16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)ma);
+						TIFFSwabShort((uint16_t*)ma);
 					err=TIFFReadDirEntryCheckRangeLong8Sshort(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint64)(*ma++);
+					*mb++=(uint64_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG:
 			{
-				uint32* ma;
-				uint64* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t* ma;
+				uint64_t* mb;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabLong(ma);
-					*mb++=(uint64)(*ma++);
+					*mb++=(uint64_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG:
 			{
-				int32* ma;
-				uint64* mb;
-				uint32 n;
-				ma=(int32*)origdata;
+				int32_t* ma;
+				uint64_t* mb;
+				uint32_t n;
+				ma=(int32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)ma);
+						TIFFSwabLong((uint32_t*)ma);
 					err=TIFFReadDirEntryCheckRangeLong8Slong(*ma);
 					if (err!=TIFFReadDirEntryErrOk)
 						break;
-					*mb++=(uint64)(*ma++);
+					*mb++=(uint64_t)(*ma++);
 				}
 			}
 			break;
@@ -2127,17 +2133,17 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8ArrayWithLimit(
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64_t** value)
 {
-    return TIFFReadDirEntryLong8ArrayWithLimit(tif, direntry, value, ~((uint64)0));
+    return TIFFReadDirEntryLong8ArrayWithLimit(tif, direntry, value, ~((uint64_t)0));
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64_t** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	int64* data;
+	int64_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_BYTE:
@@ -2162,9 +2168,9 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEn
 	{
 		case TIFF_LONG8:
 			{
-				uint64* m;
-				uint32 n;
-				m=(uint64*)origdata;
+				uint64_t* m;
+				uint32_t n;
+				m=(uint64_t*)origdata;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
@@ -2177,16 +2183,16 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEn
 					}
 					m++;
 				}
-				*value=(int64*)origdata;
+				*value=(int64_t*)origdata;
 				return(TIFFReadDirEntryErrOk);
 			}
 		case TIFF_SLONG8:
-			*value=(int64*)origdata;
+			*value=(int64_t*)origdata;
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabArrayOfLong8((uint64*)(*value),count);
+				TIFFSwabArrayOfLong8((uint64_t*)(*value), count);
 			return(TIFFReadDirEntryErrOk);
 	}
-	data=(int64*)_TIFFmalloc(count*8);
+	data=(int64_t*)_TIFFmalloc(count * 8);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -2196,83 +2202,83 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEn
 	{
 		case TIFF_BYTE:
 			{
-				uint8* ma;
-				int64* mb;
-				uint32 n;
-				ma=(uint8*)origdata;
+				uint8_t* ma;
+				int64_t* mb;
+				uint32_t n;
+				ma=(uint8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(int64)(*ma++);
+					*mb++=(int64_t)(*ma++);
 			}
 			break;
 		case TIFF_SBYTE:
 			{
-				int8* ma;
-				int64* mb;
-				uint32 n;
-				ma=(int8*)origdata;
+				int8_t* ma;
+				int64_t* mb;
+				uint32_t n;
+				ma=(int8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
-					*mb++=(int64)(*ma++);
+					*mb++=(int64_t)(*ma++);
 			}
 			break;
 		case TIFF_SHORT:
 			{
-				uint16* ma;
-				int64* mb;
-				uint32 n;
-				ma=(uint16*)origdata;
+				uint16_t* ma;
+				int64_t* mb;
+				uint32_t n;
+				ma=(uint16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabShort(ma);
-					*mb++=(int64)(*ma++);
+					*mb++=(int64_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SSHORT:
 			{
-				int16* ma;
-				int64* mb;
-				uint32 n;
-				ma=(int16*)origdata;
+				int16_t* ma;
+				int64_t* mb;
+				uint32_t n;
+				ma=(int16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)ma);
-					*mb++=(int64)(*ma++);
+						TIFFSwabShort((uint16_t*)ma);
+					*mb++=(int64_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG:
 			{
-				uint32* ma;
-				int64* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t* ma;
+				int64_t* mb;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabLong(ma);
-					*mb++=(int64)(*ma++);
+					*mb++=(int64_t)(*ma++);
 				}
 			}
 			break;
 		case TIFF_SLONG:
 			{
-				int32* ma;
-				int64* mb;
-				uint32 n;
-				ma=(int32*)origdata;
+				int32_t* ma;
+				int64_t* mb;
+				uint32_t n;
+				ma=(int32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)ma);
-					*mb++=(int64)(*ma++);
+						TIFFSwabLong((uint32_t*)ma);
+					*mb++=(int64_t)(*ma++);
 				}
 			}
 			break;
@@ -2285,7 +2291,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEn
 static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEntry* direntry, float** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
 	float* data;
 	switch (direntry->tdir_type)
@@ -2316,7 +2322,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 	{
 		case TIFF_FLOAT:
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabArrayOfLong((uint32*)origdata,count);  
+				TIFFSwabArrayOfLong((uint32_t*)origdata, count);
 			TIFFCvtIEEEDoubleToNative(tif,count,(float*)origdata);
 			*value=(float*)origdata;
 			return(TIFFReadDirEntryErrOk);
@@ -2331,10 +2337,10 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 	{
 		case TIFF_BYTE:
 			{
-				uint8* ma;
+				uint8_t* ma;
 				float* mb;
-				uint32 n;
-				ma=(uint8*)origdata;
+				uint32_t n;
+				ma=(uint8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 					*mb++=(float)(*ma++);
@@ -2342,10 +2348,10 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 			break;
 		case TIFF_SBYTE:
 			{
-				int8* ma;
+				int8_t* ma;
 				float* mb;
-				uint32 n;
-				ma=(int8*)origdata;
+				uint32_t n;
+				ma=(int8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 					*mb++=(float)(*ma++);
@@ -2353,10 +2359,10 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 			break;
 		case TIFF_SHORT:
 			{
-				uint16* ma;
+				uint16_t* ma;
 				float* mb;
-				uint32 n;
-				ma=(uint16*)origdata;
+				uint32_t n;
+				ma=(uint16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -2368,25 +2374,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 			break;
 		case TIFF_SSHORT:
 			{
-				int16* ma;
+				int16_t* ma;
 				float* mb;
-				uint32 n;
-				ma=(int16*)origdata;
+				uint32_t n;
+				ma=(int16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)ma);
+						TIFFSwabShort((uint16_t*)ma);
 					*mb++=(float)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG:
 			{
-				uint32* ma;
+				uint32_t* ma;
 				float* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -2398,25 +2404,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 			break;
 		case TIFF_SLONG:
 			{
-				int32* ma;
+				int32_t* ma;
 				float* mb;
-				uint32 n;
-				ma=(int32*)origdata;
+				uint32_t n;
+				ma=(int32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)ma);
+						TIFFSwabLong((uint32_t*)ma);
 					*mb++=(float)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG8:
 			{
-				uint64* ma;
+				uint64_t* ma;
 				float* mb;
-				uint32 n;
-				ma=(uint64*)origdata;
+				uint32_t n;
+				ma=(uint64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -2437,27 +2443,27 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 			break;
 		case TIFF_SLONG8:
 			{
-				int64* ma;
+				int64_t* ma;
 				float* mb;
-				uint32 n;
-				ma=(int64*)origdata;
+				uint32_t n;
+				ma=(int64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)ma);
+						TIFFSwabLong8((uint64_t*)ma);
 					*mb++=(float)(*ma++);
 				}
 			}
 			break;
 		case TIFF_RATIONAL:
 			{
-				uint32* ma;
-				uint32 maa;
-				uint32 mab;
+				uint32_t* ma;
+				uint32_t maa;
+				uint32_t mab;
 				float* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -2476,18 +2482,18 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 			break;
 		case TIFF_SRATIONAL:
 			{
-				uint32* ma;
-				int32 maa;
-				uint32 mab;
+				uint32_t* ma;
+				int32_t maa;
+				uint32_t mab;
 				float* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabLong(ma);
-					maa=*(int32*)ma;
+					maa=*(int32_t*)ma;
 					ma++;
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabLong(ma);
@@ -2503,9 +2509,9 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEnt
 			{
 				double* ma;
 				float* mb;
-				uint32 n;
+				uint32_t n;
 				if (tif->tif_flags&TIFF_SWAB)
-					TIFFSwabArrayOfLong8((uint64*)origdata,count);
+					TIFFSwabArrayOfLong8((uint64_t*)origdata, count);
 				TIFFCvtIEEEDoubleToNative(tif,count,(double*)origdata);
 				ma=(double*)origdata;
 				mb=data;
@@ -2530,7 +2536,7 @@ static enum TIFFReadDirEntryErr
 TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
 	double* data;
 	switch (direntry->tdir_type)
@@ -2561,7 +2567,7 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 	{
 		case TIFF_DOUBLE:
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabArrayOfLong8((uint64*)origdata,count);
+				TIFFSwabArrayOfLong8((uint64_t*)origdata, count);
 			TIFFCvtIEEEDoubleToNative(tif,count,(double*)origdata);
 			*value=(double*)origdata;
 			return(TIFFReadDirEntryErrOk);
@@ -2576,10 +2582,10 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 	{
 		case TIFF_BYTE:
 			{
-				uint8* ma;
+				uint8_t* ma;
 				double* mb;
-				uint32 n;
-				ma=(uint8*)origdata;
+				uint32_t n;
+				ma=(uint8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 					*mb++=(double)(*ma++);
@@ -2587,10 +2593,10 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 			break;
 		case TIFF_SBYTE:
 			{
-				int8* ma;
+				int8_t* ma;
 				double* mb;
-				uint32 n;
-				ma=(int8*)origdata;
+				uint32_t n;
+				ma=(int8_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 					*mb++=(double)(*ma++);
@@ -2598,10 +2604,10 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 			break;
 		case TIFF_SHORT:
 			{
-				uint16* ma;
+				uint16_t* ma;
 				double* mb;
-				uint32 n;
-				ma=(uint16*)origdata;
+				uint32_t n;
+				ma=(uint16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -2613,25 +2619,25 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 			break;
 		case TIFF_SSHORT:
 			{
-				int16* ma;
+				int16_t* ma;
 				double* mb;
-				uint32 n;
-				ma=(int16*)origdata;
+				uint32_t n;
+				ma=(int16_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabShort((uint16*)ma);
+						TIFFSwabShort((uint16_t*)ma);
 					*mb++=(double)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG:
 			{
-				uint32* ma;
+				uint32_t* ma;
 				double* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -2643,25 +2649,25 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 			break;
 		case TIFF_SLONG:
 			{
-				int32* ma;
+				int32_t* ma;
 				double* mb;
-				uint32 n;
-				ma=(int32*)origdata;
+				uint32_t n;
+				ma=(int32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong((uint32*)ma);
+						TIFFSwabLong((uint32_t*)ma);
 					*mb++=(double)(*ma++);
 				}
 			}
 			break;
 		case TIFF_LONG8:
 			{
-				uint64* ma;
+				uint64_t* ma;
 				double* mb;
-				uint32 n;
-				ma=(uint64*)origdata;
+				uint32_t n;
+				ma=(uint64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -2682,27 +2688,27 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 			break;
 		case TIFF_SLONG8:
 			{
-				int64* ma;
+				int64_t* ma;
 				double* mb;
-				uint32 n;
-				ma=(int64*)origdata;
+				uint32_t n;
+				ma=(int64_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
-						TIFFSwabLong8((uint64*)ma);
+						TIFFSwabLong8((uint64_t*)ma);
 					*mb++=(double)(*ma++);
 				}
 			}
 			break;
 		case TIFF_RATIONAL:
 			{
-				uint32* ma;
-				uint32 maa;
-				uint32 mab;
+				uint32_t* ma;
+				uint32_t maa;
+				uint32_t mab;
 				double* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
@@ -2721,18 +2727,18 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 			break;
 		case TIFF_SRATIONAL:
 			{
-				uint32* ma;
-				int32 maa;
-				uint32 mab;
+				uint32_t* ma;
+				int32_t maa;
+				uint32_t mab;
 				double* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabLong(ma);
-					maa=*(int32*)ma;
+					maa=*(int32_t*)ma;
 					ma++;
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabLong(ma);
@@ -2748,9 +2754,9 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 			{
 				float* ma;
 				double* mb;
-				uint32 n;
+				uint32_t n;
 				if (tif->tif_flags&TIFF_SWAB)
-					TIFFSwabArrayOfLong((uint32*)origdata,count);  
+					TIFFSwabArrayOfLong((uint32_t*)origdata, count);
 				TIFFCvtIEEEFloatToNative(tif,count,(float*)origdata);
 				ma=(float*)origdata;
 				mb=data;
@@ -2764,12 +2770,12 @@ TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntry* direntry, uint64_t** value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint32 count;
+	uint32_t count;
 	void* origdata;
-	uint64* data;
+	uint64_t* data;
 	switch (direntry->tdir_type)
 	{
 		case TIFF_LONG:
@@ -2790,12 +2796,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntr
 	{
 		case TIFF_LONG8:
 		case TIFF_IFD8:
-			*value=(uint64*)origdata;
+			*value=(uint64_t*)origdata;
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabArrayOfLong8(*value,count);
 			return(TIFFReadDirEntryErrOk);
 	}
-	data=(uint64*)_TIFFmalloc(count*8);
+	data=(uint64_t*)_TIFFmalloc(count * 8);
 	if (data==0)
 	{
 		_TIFFfree(origdata);
@@ -2806,16 +2812,16 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntr
 		case TIFF_LONG:
 		case TIFF_IFD:
 			{
-				uint32* ma;
-				uint64* mb;
-				uint32 n;
-				ma=(uint32*)origdata;
+				uint32_t* ma;
+				uint64_t* mb;
+				uint32_t n;
+				ma=(uint32_t*)origdata;
 				mb=data;
 				for (n=0; n<count; n++)
 				{
 					if (tif->tif_flags&TIFF_SWAB)
 						TIFFSwabLong(ma);
-					*mb++=(uint64)(*ma++);
+					*mb++=(uint64_t)(*ma++);
 				}
 			}
 			break;
@@ -2825,13 +2831,13 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntr
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16_t* value)
 {
 	enum TIFFReadDirEntryErr err;
-	uint16* m;
-	uint16* na;
-	uint16 nb;
-	if (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)
+	uint16_t* m;
+	uint16_t* na;
+	uint16_t nb;
+	if (direntry->tdir_count<(uint64_t)tif->tif_dir.td_samplesperpixel)
 		return(TIFFReadDirEntryErrCount);
 	err=TIFFReadDirEntryShortArray(tif,direntry,&m);
 	if (err!=TIFFReadDirEntryErrOk || m == NULL)
@@ -2859,8 +2865,8 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleDouble(TIFF* tif, TIFFD
 	enum TIFFReadDirEntryErr err;
 	double* m;
 	double* na;
-	uint16 nb;
-	if (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)
+	uint16_t nb;
+	if (direntry->tdir_count<(uint64_t)tif->tif_dir.td_samplesperpixel)
 		return(TIFFReadDirEntryErrCount);
 	err=TIFFReadDirEntryDoubleArray(tif,direntry,&m);
 	if (err!=TIFFReadDirEntryErrOk)
@@ -2883,53 +2889,53 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleDouble(TIFF* tif, TIFFD
 }
 #endif
 
-static void TIFFReadDirEntryCheckedByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)
+static void TIFFReadDirEntryCheckedByte(TIFF* tif, TIFFDirEntry* direntry, uint8_t* value)
 {
 	(void) tif;
-	*value=*(uint8*)(&direntry->tdir_offset);
+	*value=*(uint8_t*)(&direntry->tdir_offset);
 }
 
-static void TIFFReadDirEntryCheckedSbyte(TIFF* tif, TIFFDirEntry* direntry, int8* value)
+static void TIFFReadDirEntryCheckedSbyte(TIFF* tif, TIFFDirEntry* direntry, int8_t* value)
 {
 	(void) tif;
-	*value=*(int8*)(&direntry->tdir_offset);
+	*value=*(int8_t*)(&direntry->tdir_offset);
 }
 
-static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)
+static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16_t* value)
 {
 	*value = direntry->tdir_offset.toff_short;
-	/* *value=*(uint16*)(&direntry->tdir_offset); */
+	/* *value=*(uint16_t*)(&direntry->tdir_offset); */
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabShort(value);
 }
 
-static void TIFFReadDirEntryCheckedSshort(TIFF* tif, TIFFDirEntry* direntry, int16* value)
+static void TIFFReadDirEntryCheckedSshort(TIFF* tif, TIFFDirEntry* direntry, int16_t* value)
 {
-	*value=*(int16*)(&direntry->tdir_offset);
+	*value=*(int16_t*)(&direntry->tdir_offset);
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabShort((uint16*)value);
+		TIFFSwabShort((uint16_t*)value);
 }
 
-static void TIFFReadDirEntryCheckedLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)
+static void TIFFReadDirEntryCheckedLong(TIFF* tif, TIFFDirEntry* direntry, uint32_t* value)
 {
-	*value=*(uint32*)(&direntry->tdir_offset);
+	*value=*(uint32_t*)(&direntry->tdir_offset);
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabLong(value);
 }
 
-static void TIFFReadDirEntryCheckedSlong(TIFF* tif, TIFFDirEntry* direntry, int32* value)
+static void TIFFReadDirEntryCheckedSlong(TIFF* tif, TIFFDirEntry* direntry, int32_t* value)
 {
-	*value=*(int32*)(&direntry->tdir_offset);
+	*value=*(int32_t*)(&direntry->tdir_offset);
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabLong((uint32*)value);
+		TIFFSwabLong((uint32_t*)value);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64_t* value)
 {
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
 		enum TIFFReadDirEntryErr err;
-		uint32 offset = direntry->tdir_offset.toff_long;
+		uint32_t offset = direntry->tdir_offset.toff_long;
 		if (tif->tif_flags&TIFF_SWAB)
 			TIFFSwabLong(&offset);
 		err=TIFFReadDirEntryData(tif,offset,8,value);
@@ -2943,12 +2949,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirE
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDirEntry* direntry, int64* value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDirEntry* direntry, int64_t* value)
 {
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
 		enum TIFFReadDirEntryErr err;
-		uint32 offset = direntry->tdir_offset.toff_long;
+		uint32_t offset = direntry->tdir_offset.toff_long;
 		if (tif->tif_flags&TIFF_SWAB)
 			TIFFSwabLong(&offset);
 		err=TIFFReadDirEntryData(tif,offset,8,value);
@@ -2956,9 +2962,9 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDir
 			return(err);
 	}
 	else
-		*value=*(int64*)(&direntry->tdir_offset);
+		*value=*(int64_t*)(&direntry->tdir_offset);
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabLong8((uint64*)value);
+		TIFFSwabLong8((uint64_t*)value);
 	return(TIFFReadDirEntryErrOk);
 }
 
@@ -2967,12 +2973,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFD
 	UInt64Aligned_t m;
 
 	assert(sizeof(double)==8);
-	assert(sizeof(uint64)==8);
-	assert(sizeof(uint32)==4);
+	assert(sizeof(uint64_t) == 8);
+	assert(sizeof(uint32_t) == 4);
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
 		enum TIFFReadDirEntryErr err;
-		uint32 offset = direntry->tdir_offset.toff_long;
+		uint32_t offset = direntry->tdir_offset.toff_long;
 		if (tif->tif_flags&TIFF_SWAB)
 			TIFFSwabLong(&offset);
 		err=TIFFReadDirEntryData(tif,offset,8,m.i);
@@ -2997,13 +3003,13 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFF
 {
 	UInt64Aligned_t m;
 	assert(sizeof(double)==8);
-	assert(sizeof(uint64)==8);
-	assert(sizeof(int32)==4);
-	assert(sizeof(uint32)==4);
+	assert(sizeof(uint64_t) == 8);
+	assert(sizeof(int32_t) == 4);
+	assert(sizeof(uint32_t) == 4);
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
 		enum TIFFReadDirEntryErr err;
-		uint32 offset = direntry->tdir_offset.toff_long;
+		uint32_t offset = direntry->tdir_offset.toff_long;
 		if (tif->tif_flags&TIFF_SWAB)
 			TIFFSwabLong(&offset);
 		err=TIFFReadDirEntryData(tif,offset,8,m.i);
@@ -3017,10 +3023,10 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFF
         /* Not completely sure what we should do when m.i[1]==0, but some */
         /* sanitizers do not like division by 0.0: */
         /* http://bugzilla.maptools.org/show_bug.cgi?id=2644 */
-	if ((int32)m.i[0]==0 || m.i[1]==0)
+	if ((int32_t)m.i[0] == 0 || m.i[1] == 0)
 		*value=0.0;
 	else
-		*value=(double)((int32)m.i[0])/(double)m.i[1];
+		*value= (double)((int32_t)m.i[0]) / (double)m.i[1];
 	return(TIFFReadDirEntryErrOk);
 }
 
@@ -3029,26 +3035,26 @@ static void TIFFReadDirEntryCheckedFloat(TIFF* tif, TIFFDirEntry* direntry, floa
          union
 	 {
 	   float  f;
-	   uint32 i;
+	   uint32_t i;
 	 } float_union;
 	assert(sizeof(float)==4);
-	assert(sizeof(uint32)==4);
+	assert(sizeof(uint32_t) == 4);
 	assert(sizeof(float_union)==4);
-	float_union.i=*(uint32*)(&direntry->tdir_offset);
+	float_union.i=*(uint32_t*)(&direntry->tdir_offset);
 	*value=float_union.f;
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabLong((uint32*)value);
+		TIFFSwabLong((uint32_t*)value);
 }
 
 static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)
 {
 	assert(sizeof(double)==8);
-	assert(sizeof(uint64)==8);
+	assert(sizeof(uint64_t) == 8);
 	assert(sizeof(UInt64Aligned_t)==8);
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
 		enum TIFFReadDirEntryErr err;
-		uint32 offset = direntry->tdir_offset.toff_long;
+		uint32_t offset = direntry->tdir_offset.toff_long;
 		if (tif->tif_flags&TIFF_SWAB)
 			TIFFSwabLong(&offset);
 		err=TIFFReadDirEntryData(tif,offset,8,value);
@@ -3062,11 +3068,11 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedDouble(TIFF* tif, TIFFDir
 	       *value=uint64_union.d;
 	}
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabLong8((uint64*)value);
+		TIFFSwabLong8((uint64_t*)value);
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSbyte(int8 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSbyte(int8_t value)
 {
 	if (value<0)
 		return(TIFFReadDirEntryErrRange);
@@ -3074,7 +3080,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSbyte(int8 value)
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16_t value)
 {
 	if (value>0xFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3082,7 +3088,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSshort(int16 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSshort(int16_t value)
 {
 	if ((value<0)||(value>0xFF))
 		return(TIFFReadDirEntryErrRange);
@@ -3090,7 +3096,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSshort(int16 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32_t value)
 {
 	if (value>0xFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3098,7 +3104,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32 value)
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong(int32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong(int32_t value)
 {
 	if ((value<0)||(value>0xFF))
 		return(TIFFReadDirEntryErrRange);
@@ -3106,7 +3112,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong(int32 value)
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong8(uint64 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong8(uint64_t value)
 {
 	if (value>0xFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3114,7 +3120,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong8(uint64 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong8(int64 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong8(int64_t value)
 {
 	if ((value<0)||(value>0xFF))
 		return(TIFFReadDirEntryErrRange);
@@ -3122,7 +3128,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong8(int64 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteByte(uint8 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteByte(uint8_t value)
 {
 	if (value>0x7F)
 		return(TIFFReadDirEntryErrRange);
@@ -3130,7 +3136,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteByte(uint8 value)
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteShort(uint16 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteShort(uint16_t value)
 {
 	if (value>0x7F)
 		return(TIFFReadDirEntryErrRange);
@@ -3138,7 +3144,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteShort(uint16 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSshort(int16 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSshort(int16_t value)
 {
 	if ((value<-0x80)||(value>0x7F))
 		return(TIFFReadDirEntryErrRange);
@@ -3146,7 +3152,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSshort(int16 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong(uint32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong(uint32_t value)
 {
 	if (value>0x7F)
 		return(TIFFReadDirEntryErrRange);
@@ -3154,7 +3160,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong(uint32 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong(int32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong(int32_t value)
 {
 	if ((value<-0x80)||(value>0x7F))
 		return(TIFFReadDirEntryErrRange);
@@ -3162,7 +3168,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong(int32 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong8(uint64 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong8(uint64_t value)
 {
 	if (value>0x7F)
 		return(TIFFReadDirEntryErrRange);
@@ -3170,7 +3176,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong8(uint64 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong8(int64 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong8(int64_t value)
 {
 	if ((value<-0x80)||(value>0x7F))
 		return(TIFFReadDirEntryErrRange);
@@ -3178,7 +3184,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong8(int64 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSbyte(int8 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSbyte(int8_t value)
 {
 	if (value<0)
 		return(TIFFReadDirEntryErrRange);
@@ -3186,7 +3192,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSbyte(int8 value)
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSshort(int16 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSshort(int16_t value)
 {
 	if (value<0)
 		return(TIFFReadDirEntryErrRange);
@@ -3194,7 +3200,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSshort(int16 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong(uint32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong(uint32_t value)
 {
 	if (value>0xFFFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3202,7 +3208,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong(uint32 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong(int32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong(int32_t value)
 {
 	if ((value<0)||(value>0xFFFF))
 		return(TIFFReadDirEntryErrRange);
@@ -3210,7 +3216,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong(int32 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong8(uint64 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong8(uint64_t value)
 {
 	if (value>0xFFFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3218,7 +3224,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong8(uint64 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong8(int64 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong8(int64_t value)
 {
 	if ((value<0)||(value>0xFFFF))
 		return(TIFFReadDirEntryErrRange);
@@ -3226,7 +3232,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong8(int64 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortShort(uint16 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortShort(uint16_t value)
 {
 	if (value>0x7FFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3234,7 +3240,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortShort(uint16 val
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong(uint32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong(uint32_t value)
 {
 	if (value>0x7FFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3242,7 +3248,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong(uint32 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong(int32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong(int32_t value)
 {
 	if ((value<-0x8000)||(value>0x7FFF))
 		return(TIFFReadDirEntryErrRange);
@@ -3250,7 +3256,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong(int32 valu
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong8(uint64 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong8(uint64_t value)
 {
 	if (value>0x7FFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3258,7 +3264,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong8(uint64 val
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong8(int64 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong8(int64_t value)
 {
 	if ((value<-0x8000)||(value>0x7FFF))
 		return(TIFFReadDirEntryErrRange);
@@ -3266,7 +3272,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong8(int64 val
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSbyte(int8 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSbyte(int8_t value)
 {
 	if (value<0)
 		return(TIFFReadDirEntryErrRange);
@@ -3274,7 +3280,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSbyte(int8 value)
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16_t value)
 {
 	if (value<0)
 		return(TIFFReadDirEntryErrRange);
@@ -3282,7 +3288,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16 value
 		return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong(int32 value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong(int32_t value)
 {
 	if (value<0)
 		return(TIFFReadDirEntryErrRange);
@@ -3291,25 +3297,25 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong(int32 value)
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeLongLong8(uint64 value)
+TIFFReadDirEntryCheckRangeLongLong8(uint64_t value)
 {
-	if (value > TIFF_UINT32_MAX)
+	if (value > UINT32_MAX)
 		return(TIFFReadDirEntryErrRange);
 	else
 		return(TIFFReadDirEntryErrOk);
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeLongSlong8(int64 value)
+TIFFReadDirEntryCheckRangeLongSlong8(int64_t value)
 {
-	if ((value < 0) || (value > (int64) TIFF_UINT32_MAX))
+	if ((value < 0) || (value > (int64_t) UINT32_MAX))
 		return(TIFFReadDirEntryErrRange);
 	else
 		return(TIFFReadDirEntryErrOk);
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeSlongLong(uint32 value)
+TIFFReadDirEntryCheckRangeSlongLong(uint32_t value)
 {
 	if (value > 0x7FFFFFFFUL)
 		return(TIFFReadDirEntryErrRange);
@@ -3319,7 +3325,7 @@ TIFFReadDirEntryCheckRangeSlongLong(uint32 value)
 
 /* Check that the 8-byte unsigned value can fit in a 4-byte unsigned range */
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeSlongLong8(uint64 value)
+TIFFReadDirEntryCheckRangeSlongLong8(uint64_t value)
 {
 	if (value > 0x7FFFFFFF)
 		return(TIFFReadDirEntryErrRange);
@@ -3329,16 +3335,16 @@ TIFFReadDirEntryCheckRangeSlongLong8(uint64 value)
 
 /* Check that the 8-byte signed value can fit in a 4-byte signed range */
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeSlongSlong8(int64 value)
+TIFFReadDirEntryCheckRangeSlongSlong8(int64_t value)
 {
-        if ((value < 0-((int64) 0x7FFFFFFF+1)) || (value > 0x7FFFFFFF))
+        if ((value < 0-((int64_t) 0x7FFFFFFF + 1)) || (value > 0x7FFFFFFF))
 		return(TIFFReadDirEntryErrRange);
 	else
 		return(TIFFReadDirEntryErrOk);
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeLong8Sbyte(int8 value)
+TIFFReadDirEntryCheckRangeLong8Sbyte(int8_t value)
 {
 	if (value < 0)
 		return(TIFFReadDirEntryErrRange);
@@ -3347,7 +3353,7 @@ TIFFReadDirEntryCheckRangeLong8Sbyte(int8 value)
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeLong8Sshort(int16 value)
+TIFFReadDirEntryCheckRangeLong8Sshort(int16_t value)
 {
 	if (value < 0)
 		return(TIFFReadDirEntryErrRange);
@@ -3356,7 +3362,7 @@ TIFFReadDirEntryCheckRangeLong8Sshort(int16 value)
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeLong8Slong(int32 value)
+TIFFReadDirEntryCheckRangeLong8Slong(int32_t value)
 {
 	if (value < 0)
 		return(TIFFReadDirEntryErrRange);
@@ -3365,7 +3371,7 @@ TIFFReadDirEntryCheckRangeLong8Slong(int32 value)
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeLong8Slong8(int64 value)
+TIFFReadDirEntryCheckRangeLong8Slong8(int64_t value)
 {
 	if (value < 0)
 		return(TIFFReadDirEntryErrRange);
@@ -3374,16 +3380,16 @@ TIFFReadDirEntryCheckRangeLong8Slong8(int64 value)
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryCheckRangeSlong8Long8(uint64 value)
+TIFFReadDirEntryCheckRangeSlong8Long8(uint64_t value)
 {
-	if (value > TIFF_INT64_MAX)
+	if (value > INT64_MAX)
 		return(TIFFReadDirEntryErrRange);
 	else
 		return(TIFFReadDirEntryErrOk);
 }
 
 static enum TIFFReadDirEntryErr
-TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)
+TIFFReadDirEntryData(TIFF* tif, uint64_t offset, tmsize_t size, void* dest)
 {
 	assert(size>0);
 	if (!isMapped(tif)) {
@@ -3394,13 +3400,13 @@ TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)
 	} else {
 		size_t ma,mb;
 		ma=(size_t)offset;
-                if( (uint64)ma!=offset ||
+                if((uint64_t)ma != offset ||
                     ma > (~(size_t)0) - (size_t)size )
                 {
                     return TIFFReadDirEntryErrIo;
                 }
 		mb=ma+size;
-		if (mb > (size_t)tif->tif_size)
+		if (mb > (uint64_t)tif->tif_size)
 			return(TIFFReadDirEntryErrIo);
 		_TIFFmemcpy(dest,tif->tif_base+ma,size);
 	}
@@ -3499,7 +3505,7 @@ static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, c
  * type. 0 is returned if photometric type isn't supported or no default value
  * is defined by the specification.
  */
-static int _TIFFGetMaxColorChannels( uint16 photometric )
+static int _TIFFGetMaxColorChannels(uint16_t photometric )
 {
     switch (photometric) {
 	case PHOTOMETRIC_PALETTE:
@@ -3538,9 +3544,9 @@ static int ByteCountLooksBad(TIFF* tif)
         *     until the whole image will be written and directory
         *     dumped out.
         */
-    uint64 bytecount = TIFFGetStrileByteCount(tif, 0);
-    uint64 offset = TIFFGetStrileOffset(tif, 0);
-    uint64 filesize;
+    uint64_t bytecount = TIFFGetStrileByteCount(tif, 0);
+    uint64_t offset = TIFFGetStrileOffset(tif, 0);
+    uint64_t filesize;
 
     if( offset == 0 )
         return 0;
@@ -3553,9 +3559,9 @@ static int ByteCountLooksBad(TIFF* tif)
         return 1;
     if( tif->tif_mode == O_RDONLY )
     {
-        uint64 scanlinesize = TIFFScanlineSize64(tif);
+        uint64_t scanlinesize = TIFFScanlineSize64(tif);
         if( tif->tif_dir.td_imagelength > 0 &&
-            scanlinesize > TIFF_UINT64_MAX / tif->tif_dir.td_imagelength )
+            scanlinesize > UINT64_MAX / tif->tif_dir.td_imagelength )
         {
             return 1;
         }
@@ -3575,11 +3581,11 @@ TIFFReadDirectory(TIFF* tif)
 {
 	static const char module[] = "TIFFReadDirectory";
 	TIFFDirEntry* dir;
-	uint16 dircount;
+	uint16_t dircount;
 	TIFFDirEntry* dp;
-	uint16 di;
+	uint16_t di;
 	const TIFFField* fip;
-	uint32 fii=FAILED_FII;
+	uint32_t fii=FAILED_FII;
         toff_t nextdiroff;
     int bitspersample_read = FALSE;
         int color_channels;
@@ -3594,7 +3600,7 @@ TIFFReadDirectory(TIFF* tif)
 	if (!dircount)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,
-		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);
+		    "Failed to read directory at offset %" PRIu64, nextdiroff);
 		return 0;
 	}
 	TIFFReadDirectoryCheckOrder(tif,dir,dircount);
@@ -3605,11 +3611,11 @@ TIFFReadDirectory(TIFF* tif)
          */
 	{
 		TIFFDirEntry* ma;
-		uint16 mb;
+		uint16_t mb;
 		for (ma=dir, mb=0; mb<dircount; ma++, mb++)
 		{
 			TIFFDirEntry* na;
-			uint16 nb;
+			uint16_t nb;
 			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)
 			{
 				if (ma->tdir_tag == na->tdir_tag) {
@@ -3666,7 +3672,7 @@ TIFFReadDirectory(TIFF* tif)
 		 * this, we accept the tag if one value is supplied with either
 		 * count.
 		 */
-		uint16 value;
+		uint16_t value;
 		enum TIFFReadDirEntryErr err;
 		err=TIFFReadDirEntryShort(tif,dp,&value);
 		if (err==TIFFReadDirEntryErrCount)
@@ -3696,7 +3702,7 @@ TIFFReadDirectory(TIFF* tif)
 			if (fii == FAILED_FII)
 			{
 				TIFFWarningExt(tif->tif_clientdata, module,
-				    "Unknown field with tag %d (0x%x) encountered",
+				    "Unknown field with tag %"PRIu16" (0x%"PRIx16") encountered",
 				    dp->tdir_tag,dp->tdir_tag);
 				/* the following knowingly leaks the 
 				   anonymous field structure */
@@ -3707,7 +3713,7 @@ TIFFReadDirectory(TIFF* tif)
 					1)) {
 					TIFFWarningExt(tif->tif_clientdata,
 					    module,
-					    "Registering anonymous field with tag %d (0x%x) failed",
+					    "Registering anonymous field with tag %"PRIu16" (0x%"PRIx16") failed",
 					    dp->tdir_tag,
 					    dp->tdir_tag);
 					dp->tdir_ignore = TRUE;
@@ -3856,7 +3862,7 @@ TIFFReadDirectory(TIFF* tif)
 					 * too.
 					 */
 					{
-						uint16 value;
+						uint16_t value;
 						enum TIFFReadDirEntryErr err;
 						err=TIFFReadDirEntryShort(tif,dp,&value);
 						if (err==TIFFReadDirEntryErrCount)
@@ -3879,9 +3885,9 @@ TIFFReadDirectory(TIFF* tif)
 
 						double *data = NULL;
 						enum TIFFReadDirEntryErr err;
-						uint32 saved_flags;
+						uint32_t saved_flags;
 						int m;
-						if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)
+						if (dp->tdir_count != (uint64_t)tif->tif_dir.td_samplesperpixel)
 							err = TIFFReadDirEntryErrCount;
 						else
 							err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
@@ -3902,11 +3908,51 @@ TIFFReadDirectory(TIFF* tif)
 					break;
 				case TIFFTAG_STRIPOFFSETS:
 				case TIFFTAG_TILEOFFSETS:
+					switch( dp->tdir_type )
+					{
+					    case TIFF_SHORT:
+					    case TIFF_LONG:
+					    case TIFF_LONG8:
+					        break;
+					    default:
+                                                /* Warn except if directory typically created with TIFFDeferStrileArrayWriting() */
+                                                if( !(tif->tif_mode == O_RDWR &&
+                                                      dp->tdir_count == 0 &&
+                                                      dp->tdir_type == 0 &&
+                                                      dp->tdir_offset.toff_long8 == 0) )
+                                                {
+                                                    fip = TIFFFieldWithTag(tif,dp->tdir_tag);
+                                                    TIFFWarningExt(tif->tif_clientdata,module,
+                                                                   "Invalid data type for tag %s",
+                                                                   fip ? fip->field_name : "unknown tagname");
+                                                }
+                                                break;
+                                        }
 					_TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),
 					   dp, sizeof(TIFFDirEntry) );
 					break;
 				case TIFFTAG_STRIPBYTECOUNTS:
 				case TIFFTAG_TILEBYTECOUNTS:
+					switch( dp->tdir_type )
+					{
+					    case TIFF_SHORT:
+					    case TIFF_LONG:
+					    case TIFF_LONG8:
+					        break;
+					    default:
+						/* Warn except if directory typically created with TIFFDeferStrileArrayWriting() */
+                                                if( !(tif->tif_mode == O_RDWR &&
+                                                      dp->tdir_count == 0 &&
+                                                      dp->tdir_type == 0 &&
+                                                      dp->tdir_offset.toff_long8 == 0) )
+                                                {
+                                                    fip = TIFFFieldWithTag(tif,dp->tdir_tag);
+                                                    TIFFWarningExt(tif->tif_clientdata,module,
+                                                                   "Invalid data type for tag %s",
+                                                                   fip ? fip->field_name : "unknown tagname");
+                                                }
+                                                break;
+                                        }
 					_TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),
 					   dp, sizeof(TIFFDirEntry) );
 					break;
@@ -3914,10 +3960,10 @@ TIFFReadDirectory(TIFF* tif)
 				case TIFFTAG_TRANSFERFUNCTION:
 					{
 						enum TIFFReadDirEntryErr err;
-						uint32 countpersample;
-						uint32 countrequired;
-						uint32 incrementpersample;
-						uint16* value=NULL;
+						uint32_t countpersample;
+						uint32_t countrequired;
+						uint32_t incrementpersample;
+						uint16_t* value=NULL;
 						/* It would be dangerous to instantiate those tag values */
 						/* since if td_bitspersample has not yet been read (due to */
 						/* unordered tags), it could be read afterwards with a */
@@ -3938,13 +3984,13 @@ TIFFReadDirectory(TIFF* tif)
 						{
 							fip = TIFFFieldWithTag(tif,dp->tdir_tag);
 							TIFFWarningExt(tif->tif_clientdata,module,
-								"Ignoring %s because BitsPerSample=%d>24",
+								"Ignoring %s because BitsPerSample=%"PRIu16">24",
 								fip ? fip->field_name : "unknown tagname",
 								tif->tif_dir.td_bitspersample);
 							continue;
 						}
 						countpersample=(1U<<tif->tif_dir.td_bitspersample);
-						if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))
+						if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64_t)countpersample))
 						{
 							countrequired=countpersample;
 							incrementpersample=0;
@@ -3954,7 +4000,7 @@ TIFFReadDirectory(TIFF* tif)
 							countrequired=3*countpersample;
 							incrementpersample=countpersample;
 						}
-						if (dp->tdir_count!=(uint64)countrequired)
+						if (dp->tdir_count!=(uint64_t)countrequired)
 							err=TIFFReadDirEntryErrCount;
 						else
 							err=TIFFReadDirEntryShortArray(tif,dp,&value);
@@ -3973,8 +4019,8 @@ TIFFReadDirectory(TIFF* tif)
 /* BEGIN REV 4.0 COMPATIBILITY */
 				case TIFFTAG_OSUBFILETYPE:
 					{
-						uint16 valueo;
-						uint32 value;
+						uint16_t valueo;
+						uint32_t value;
 						if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)
 						{
 							switch (valueo)
@@ -4107,26 +4153,27 @@ TIFFReadDirectory(TIFF* tif)
 	 */
         color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);
         if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {
-                uint16 old_extrasamples;
-                uint16 *new_sampleinfo;
+                uint16_t old_extrasamples;
+                uint16_t *new_sampleinfo;
 
                 TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "
                     "color channels and ExtraSamples doesn't match SamplesPerPixel. "
                     "Defining non-color channels as ExtraSamples.");
 
                 old_extrasamples = tif->tif_dir.td_extrasamples;
-                tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels);
+                tif->tif_dir.td_extrasamples = (uint16_t) (tif->tif_dir.td_samplesperpixel - color_channels);
 
                 // sampleinfo should contain information relative to these new extra samples
-                new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));
+                new_sampleinfo = (uint16_t*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16_t));
                 if (!new_sampleinfo) {
                     TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "
-                                "temporary new sampleinfo array (%d 16 bit elements)",
+                                                              "temporary new sampleinfo array "
+                                                              "(%"PRIu16" 16 bit elements)",
                                 tif->tif_dir.td_extrasamples);
                     goto bad;
                 }
 
-                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));
+                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16_t));
                 _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);
                 _TIFFfree(new_sampleinfo);
         }
@@ -4164,7 +4211,7 @@ TIFFReadDirectory(TIFF* tif)
 			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&
 			    tif->tif_dir.td_nstrips > 1) ||
 			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&
-			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {
+			     tif->tif_dir.td_nstrips != (uint32_t)tif->tif_dir.td_samplesperpixel)) {
 			    MissingRequired(tif, "StripByteCounts");
 			    goto bad;
 			}
@@ -4221,7 +4268,7 @@ TIFFReadDirectory(TIFF* tif)
 		if (tif->tif_dir.td_bitspersample>=16)
 			tif->tif_dir.td_maxsamplevalue=0xFFFF;
 		else
-			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);
+			tif->tif_dir.td_maxsamplevalue = (uint16_t)((1L << tif->tif_dir.td_bitspersample) - 1);
 	}
 
 #ifdef STRIPBYTECOUNTSORTED_UNUSED
@@ -4231,7 +4278,7 @@ TIFFReadDirectory(TIFF* tif)
 	 * function in tif_write.c.
 	 */
 	if (!(tif->tif_flags&TIFF_DEFERSTRILELOAD) && tif->tif_dir.td_nstrips > 1) {
-		uint32 strip;
+		uint32_t strip;
 
 		tif->tif_dir.td_stripbytecountsorted = 1;
 		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {
@@ -4286,10 +4333,10 @@ TIFFReadDirectory(TIFF* tif)
 	/*
 	 * Reinitialize i/o since we are starting on a new directory.
 	 */
-	tif->tif_row = (uint32) -1;
-	tif->tif_curstrip = (uint32) -1;
-	tif->tif_col = (uint32) -1;
-	tif->tif_curtile = (uint32) -1;
+	tif->tif_row = (uint32_t) -1;
+	tif->tif_curstrip = (uint32_t) -1;
+	tif->tif_col = (uint32_t) -1;
+	tif->tif_curtile = (uint32_t) -1;
 	tif->tif_tilesize = (tmsize_t) -1;
 
 	tif->tif_scanlinesize = TIFFScanlineSize(tif);
@@ -4321,11 +4368,11 @@ bad:
 }
 
 static void
-TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
+TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16_t dircount)
 {
 	static const char module[] = "TIFFReadDirectoryCheckOrder";
-	uint16 m;
-	uint16 n;
+	uint16_t m;
+	uint16_t n;
 	TIFFDirEntry* o;
 	m=0;
 	for (n=0, o=dir; n<dircount; n++, o++)
@@ -4341,10 +4388,10 @@ TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
 }
 
 static TIFFDirEntry*
-TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)
+TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16_t dircount, uint16_t tagid)
 {
 	TIFFDirEntry* m;
-	uint16 n;
+	uint16_t n;
 	(void) tif;
 	for (m=dir, n=0; n<dircount; m++, n++)
 	{
@@ -4355,11 +4402,11 @@ TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16
 }
 
 static void
-TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)
+TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16_t tagid, uint32_t* fii)
 {
-	int32 ma,mb,mc;
+	int32_t ma,mb,mc;
 	ma=-1;
-	mc=(int32)tif->tif_nfields;
+	mc=(int32_t)tif->tif_nfields;
 	while (1)
 	{
 		if (ma+1==mc)
@@ -4368,9 +4415,9 @@ TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)
 			return;
 		}
 		mb=(ma+mc)/2;
-		if (tif->tif_fields[mb]->field_tag==(uint32)tagid)
+		if (tif->tif_fields[mb]->field_tag==(uint32_t)tagid)
 			break;
-		if (tif->tif_fields[mb]->field_tag<(uint32)tagid)
+		if (tif->tif_fields[mb]->field_tag<(uint32_t)tagid)
 			ma=mb;
 		else
 			mc=mb;
@@ -4379,7 +4426,7 @@ TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)
 	{
 		if (mb==0)
 			break;
-		if (tif->tif_fields[mb-1]->field_tag!=(uint32)tagid)
+		if (tif->tif_fields[mb-1]->field_tag!=(uint32_t)tagid)
 			break;
 		mb--;
 	}
@@ -4396,17 +4443,18 @@ TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,
 {
 	static const char module[] = "TIFFReadCustomDirectory";
 	TIFFDirEntry* dir;
-	uint16 dircount;
+	uint16_t dircount;
 	TIFFDirEntry* dp;
-	uint16 di;
+	uint16_t di;
 	const TIFFField* fip;
-	uint32 fii;
+	uint32_t fii;
+        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */
 	_TIFFSetupFields(tif, infoarray);
 	dircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);
 	if (!dircount)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,
-		    "Failed to read custom directory at offset " TIFF_UINT64_FORMAT,diroff);
+		    "Failed to read custom directory at offset %" PRIu64,diroff);
 		return 0;
 	}
 	TIFFFreeDirectory(tif);
@@ -4418,14 +4466,14 @@ TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,
 		if (fii == FAILED_FII)
 		{
 			TIFFWarningExt(tif->tif_clientdata, module,
-			    "Unknown field with tag %d (0x%x) encountered",
+			    "Unknown field with tag %"PRIu16" (0x%"PRIx16") encountered",
 			    dp->tdir_tag, dp->tdir_tag);
 			if (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,
 						dp->tdir_tag,
 						(TIFFDataType) dp->tdir_type),
 					     1)) {
 				TIFFWarningExt(tif->tif_clientdata, module,
-				    "Registering anonymous field with tag %d (0x%x) failed",
+				    "Registering anonymous field with tag %"PRIu16" (0x%"PRIx16") failed",
 				    dp->tdir_tag, dp->tdir_tag);
 				dp->tdir_ignore = TRUE;
 			} else {
@@ -4445,7 +4493,7 @@ TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,
 				{
 					fii++;
 					if ((fii==tif->tif_nfields)||
-					    (tif->tif_fields[fii]->field_tag!=(uint32)dp->tdir_tag))
+					    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))
 					{
 						fii=0xFFFF;
 						break;
@@ -4455,7 +4503,7 @@ TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,
 				if (fii==0xFFFF)
 				{
 					TIFFWarningExt(tif->tif_clientdata, module,
-					    "Wrong data type %d for \"%s\"; tag ignored",
+					    "Wrong data type %"PRIu16" for \"%s\"; tag ignored",
 					    dp->tdir_type,fip->field_name);
 					dp->tdir_ignore = TRUE;
 				}
@@ -4465,11 +4513,11 @@ TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,
 					if ((fip->field_readcount!=TIFF_VARIABLE)&&
 					    (fip->field_readcount!=TIFF_VARIABLE2))
 					{
-						uint32 expected;
+						uint32_t expected;
 						if (fip->field_readcount==TIFF_SPP)
-							expected=(uint32)tif->tif_dir.td_samplesperpixel;
+							expected=(uint32_t)tif->tif_dir.td_samplesperpixel;
 						else
-							expected=(uint32)fip->field_readcount;
+							expected=(uint32_t)fip->field_readcount;
 						if (!CheckDirCount(tif,dp,expected))
 							dp->tdir_ignore = TRUE;
 					}
@@ -4505,14 +4553,25 @@ TIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)
 	return TIFFReadCustomDirectory(tif, diroff, exifFieldArray);  
 }
 
+/*
+ *--: EXIF-GPS custom directory reading as another special case of custom IFD.
+ */
+int
+TIFFReadGPSDirectory(TIFF* tif, toff_t diroff)
+{
+	const TIFFFieldArray* gpsFieldArray;
+	gpsFieldArray = _TIFFGetGpsFields();
+	return TIFFReadCustomDirectory(tif, diroff, gpsFieldArray);  
+}
+
 static int
-EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
+EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16_t dircount)
 {
 	static const char module[] = "EstimateStripByteCounts";
 
 	TIFFDirEntry *dp;
 	TIFFDirectory *td = &tif->tif_dir;
-	uint32 strip;
+	uint32_t strip;
 
     /* Do not try to load stripbytecount as we will compute it */
         if( !_TIFFFillStrilesInternal( tif, 0 ) )
@@ -4520,16 +4579,16 @@ EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
 
 	if (td->td_stripbytecount_p)
 		_TIFFfree(td->td_stripbytecount_p);
-	td->td_stripbytecount_p = (uint64*)
-	    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),
+	td->td_stripbytecount_p = (uint64_t*)
+	    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64_t),
 		"for \"StripByteCounts\" array");
         if( td->td_stripbytecount_p == NULL )
             return -1;
 
 	if (td->td_compression != COMPRESSION_NONE) {
-		uint64 space;
-		uint64 filesize;
-		uint16 n;
+		uint64_t space;
+		uint64_t filesize;
+		uint16_t n;
 		filesize = TIFFGetFileSize(tif);
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 			space=sizeof(TIFFHeaderClassic)+2+dircount*12+4;
@@ -4538,18 +4597,18 @@ EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
 		/* calculate amount of space used by indirect values */
 		for (dp = dir, n = dircount; n > 0; n--, dp++)
 		{
-			uint32 typewidth;
-			uint64 datasize;
+			uint32_t typewidth;
+			uint64_t datasize;
 			typewidth = TIFFDataWidth((TIFFDataType) dp->tdir_type);
 			if (typewidth == 0) {
 				TIFFErrorExt(tif->tif_clientdata, module,
-				    "Cannot determine size of unknown tag type %d",
+				    "Cannot determine size of unknown tag type %"PRIu16,
 				    dp->tdir_type);
 				return -1;
 			}
-			if( dp->tdir_count > TIFF_UINT64_MAX / typewidth )
+			if( dp->tdir_count > UINT64_MAX / typewidth )
                             return -1;
-			datasize=(uint64)typewidth*dp->tdir_count;
+			datasize= (uint64_t)typewidth * dp->tdir_count;
 			if (!(tif->tif_flags&TIFF_BIGTIFF))
 			{
 				if (datasize<=4)
@@ -4560,7 +4619,7 @@ EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
 				if (datasize<=8)
 					datasize=0;
 			}
-			if( space > TIFF_UINT64_MAX - datasize )
+			if( space > UINT64_MAX - datasize )
                             return -1;
 			space+=datasize;
 		}
@@ -4581,7 +4640,7 @@ EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
 		 * of data in the strip and trim this number back accordingly.
 		 */
 		strip--;
-                if (td->td_stripoffset_p[strip] > TIFF_UINT64_MAX - td->td_stripbytecount_p[strip])
+                if (td->td_stripoffset_p[strip] > UINT64_MAX - td->td_stripbytecount_p[strip])
                     return -1;
 		if (td->td_stripoffset_p[strip]+td->td_stripbytecount_p[strip] > filesize) {
                     if( td->td_stripoffset_p[strip] >= filesize ) {
@@ -4592,16 +4651,16 @@ EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
                     }
                 }
 	} else if (isTiled(tif)) {
-		uint64 bytespertile = TIFFTileSize64(tif);
+		uint64_t bytespertile = TIFFTileSize64(tif);
 
 		for (strip = 0; strip < td->td_nstrips; strip++)
 		    td->td_stripbytecount_p[strip] = bytespertile;
 	} else {
-		uint64 rowbytes = TIFFScanlineSize64(tif);
-		uint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;
+		uint64_t rowbytes = TIFFScanlineSize64(tif);
+		uint32_t rowsperstrip = td->td_imagelength / td->td_stripsperimage;
 		for (strip = 0; strip < td->td_nstrips; strip++)
                 {
-                    if( rowbytes > 0 && rowsperstrip > TIFF_UINT64_MAX / rowbytes )
+                    if( rowbytes > 0 && rowsperstrip > UINT64_MAX / rowbytes )
                         return -1;
                     td->td_stripbytecount_p[strip] = rowbytes * rowsperstrip;
                 }
@@ -4629,9 +4688,9 @@ MissingRequired(TIFF* tif, const char* tagname)
  * seen directories and check every IFD offset against that list.
  */
 static int
-TIFFCheckDirOffset(TIFF* tif, uint64 diroff)
+TIFFCheckDirOffset(TIFF* tif, uint64_t diroff)
 {
-	uint16 n;
+	uint16_t n;
 
 	if (diroff == 0)			/* no more directories */
 		return 0;
@@ -4649,14 +4708,14 @@ TIFFCheckDirOffset(TIFF* tif, uint64 diroff)
 	tif->tif_dirnumber++;
 
 	if (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {
-		uint64* new_dirlist;
+		uint64_t* new_dirlist;
 
 		/*
 		 * XXX: Reduce memory allocation granularity of the dirlist
 		 * array.
 		 */
-		new_dirlist = (uint64*)_TIFFCheckRealloc(tif, tif->tif_dirlist,
-		    tif->tif_dirnumber, 2 * sizeof(uint64), "for IFD list");
+		new_dirlist = (uint64_t*)_TIFFCheckRealloc(tif, tif->tif_dirlist,
+                                                   tif->tif_dirnumber, 2 * sizeof(uint64_t), "for IFD list");
 		if (!new_dirlist)
 			return 0;
 		if( tif->tif_dirnumber >= 32768 )
@@ -4676,19 +4735,19 @@ TIFFCheckDirOffset(TIFF* tif, uint64 diroff)
  * caller is expected to skip/ignore the tag if there is a mismatch.
  */
 static int
-CheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)
+CheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32_t count)
 {
-	if ((uint64)count > dir->tdir_count) {
+	if ((uint64_t)count > dir->tdir_count) {
 		const TIFFField* fip = TIFFFieldWithTag(tif, dir->tdir_tag);
 		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-	"incorrect count for field \"%s\" (" TIFF_UINT64_FORMAT ", expecting %u); tag ignored",
+	"incorrect count for field \"%s\" (%" PRIu64 ", expecting %"PRIu32"); tag ignored",
 		    fip ? fip->field_name : "unknown tagname",
 		    dir->tdir_count, count);
 		return (0);
-	} else if ((uint64)count < dir->tdir_count) {
+	} else if ((uint64_t)count < dir->tdir_count) {
 		const TIFFField* fip = TIFFFieldWithTag(tif, dir->tdir_tag);
 		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-	"incorrect count for field \"%s\" (" TIFF_UINT64_FORMAT ", expecting %u); tag trimmed",
+	"incorrect count for field \"%s\" (%" PRIu64 ", expecting %"PRIu32"); tag trimmed",
 		    fip ? fip->field_name : "unknown tagname",
 		    dir->tdir_count, count);
 		dir->tdir_count = count;
@@ -4702,19 +4761,19 @@ CheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)
  * nextdiroff variable has been specified, read it too. Function returns a
  * number of fields in the directory or 0 if failed.
  */
-static uint16
-TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
-                   uint64 *nextdiroff)
+static uint16_t
+TIFFFetchDirectory(TIFF* tif, uint64_t diroff, TIFFDirEntry** pdir,
+                   uint64_t *nextdiroff)
 {
 	static const char module[] = "TIFFFetchDirectory";
 
 	void* origdir;
-	uint16 dircount16;
-	uint32 dirsize;
+	uint16_t dircount16;
+	uint32_t dirsize;
 	TIFFDirEntry* dir;
-	uint8* ma;
+	uint8_t* ma;
 	TIFFDirEntry* mb;
-	uint16 n;
+	uint16_t n;
 
 	assert(pdir);
 
@@ -4730,7 +4789,7 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 		}
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
-			if (!ReadOK(tif, &dircount16, sizeof (uint16))) {
+			if (!ReadOK(tif, &dircount16, sizeof (uint16_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module,
 				    "%s: Can not read TIFF directory count",
 				    tif->tif_name);
@@ -4746,8 +4805,8 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 			}
 			dirsize = 12;
 		} else {
-			uint64 dircount64;
-			if (!ReadOK(tif, &dircount64, sizeof (uint64))) {
+			uint64_t dircount64;
+			if (!ReadOK(tif, &dircount64, sizeof (uint64_t))) {
 				TIFFErrorExt(tif->tif_clientdata, module,
 					"%s: Can not read TIFF directory count",
 					tif->tif_name);
@@ -4761,7 +4820,7 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 				    "Sanity check on directory count failed, this is probably not a valid IFD offset");
 				return 0;
 			}
-			dircount16 = (uint16)dircount64;
+			dircount16 = (uint16_t)dircount64;
 			dirsize = 20;
 		}
 		origdir = _TIFFCheckMalloc(tif, dircount16,
@@ -4783,14 +4842,14 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 		{
 			if (!(tif->tif_flags&TIFF_BIGTIFF))
 			{
-				uint32 nextdiroff32;
-				if (!ReadOK(tif, &nextdiroff32, sizeof(uint32)))
+				uint32_t nextdiroff32;
+				if (!ReadOK(tif, &nextdiroff32, sizeof(uint32_t)))
 					nextdiroff32 = 0;
 				if (tif->tif_flags&TIFF_SWAB)
 					TIFFSwabLong(&nextdiroff32);
 				*nextdiroff=nextdiroff32;
 			} else {
-				if (!ReadOK(tif, nextdiroff, sizeof(uint64)))
+				if (!ReadOK(tif, nextdiroff, sizeof(uint64_t)))
 					*nextdiroff = 0;
 				if (tif->tif_flags&TIFF_SWAB)
 					TIFFSwabLong8(nextdiroff);
@@ -4799,7 +4858,7 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 	} else {
 		tmsize_t m;
 		tmsize_t off;
-		if (tif->tif_diroff > (uint64)TIFF_INT64_MAX)
+		if (tif->tif_diroff > (uint64_t)INT64_MAX)
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"Can not read TIFF directory count");
 			return(0);
@@ -4811,22 +4870,22 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 		 * otherwise a very high offset may cause an OOB read and
 		 * crash the client. Make two comparisons instead of
 		 *
-		 *  off + sizeof(uint16) > tif->tif_size
+		 *  off + sizeof(uint16_t) > tif->tif_size
 		 *
 		 * to avoid overflow.
 		 */
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
-			m=off+sizeof(uint16);
-			if ((m<off)||(m<(tmsize_t)sizeof(uint16))||(m>tif->tif_size)) {
+			m=off+sizeof(uint16_t);
+			if ((m<off) || (m<(tmsize_t)sizeof(uint16_t)) || (m > tif->tif_size)) {
 				TIFFErrorExt(tif->tif_clientdata, module,
 					"Can not read TIFF directory count");
 				return 0;
 			} else {
 				_TIFFmemcpy(&dircount16, tif->tif_base + off,
-					    sizeof(uint16));
+					    sizeof(uint16_t));
 			}
-			off += sizeof (uint16);
+			off += sizeof (uint16_t);
 			if (tif->tif_flags & TIFF_SWAB)
 				TIFFSwabShort(&dircount16);
 			if (dircount16>4096)
@@ -4839,17 +4898,17 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 		}
 		else
 		{
-			uint64 dircount64;
-			m=off+sizeof(uint64);
-			if ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size)) {
+			uint64_t dircount64;
+			m=off+sizeof(uint64_t);
+			if ((m<off) || (m<(tmsize_t)sizeof(uint64_t)) || (m > tif->tif_size)) {
 				TIFFErrorExt(tif->tif_clientdata, module,
 					"Can not read TIFF directory count");
 				return 0;
 			} else {
 				_TIFFmemcpy(&dircount64, tif->tif_base + off,
-					    sizeof(uint64));
+					    sizeof(uint64_t));
 			}
-			off += sizeof (uint64);
+			off += sizeof (uint64_t);
 			if (tif->tif_flags & TIFF_SWAB)
 				TIFFSwabLong8(&dircount64);
 			if (dircount64>4096)
@@ -4858,7 +4917,7 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 				    "Sanity check on directory count failed, this is probably not a valid IFD offset");
 				return 0;
 			}
-			dircount16 = (uint16)dircount64;
+			dircount16 = (uint16_t)dircount64;
 			dirsize = 20;
 		}
 		if (dircount16 == 0 )
@@ -4886,25 +4945,25 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 			off += dircount16 * dirsize;
 			if (!(tif->tif_flags&TIFF_BIGTIFF))
 			{
-				uint32 nextdiroff32;
-				m=off+sizeof(uint32);
-				if ((m<off)||(m<(tmsize_t)sizeof(uint32))||(m>tif->tif_size))
+				uint32_t nextdiroff32;
+				m=off+sizeof(uint32_t);
+				if ((m<off) || (m<(tmsize_t)sizeof(uint32_t)) || (m > tif->tif_size))
 					nextdiroff32 = 0;
 				else
 					_TIFFmemcpy(&nextdiroff32, tif->tif_base + off,
-						    sizeof (uint32));
+						    sizeof (uint32_t));
 				if (tif->tif_flags&TIFF_SWAB)
 					TIFFSwabLong(&nextdiroff32);
 				*nextdiroff = nextdiroff32;
 			}
 			else
 			{
-				m=off+sizeof(uint64);
-				if ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size))
+				m=off+sizeof(uint64_t);
+				if ((m<off) || (m<(tmsize_t)sizeof(uint64_t)) || (m > tif->tif_size))
 					*nextdiroff = 0;
 				else
 					_TIFFmemcpy(nextdiroff, tif->tif_base + off,
-						    sizeof (uint64));
+						    sizeof (uint64_t));
 				if (tif->tif_flags&TIFF_SWAB)
 					TIFFSwabLong8(nextdiroff);
 			}
@@ -4918,37 +4977,37 @@ TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
 		_TIFFfree(origdir);
 		return 0;
 	}
-	ma=(uint8*)origdir;
+	ma=(uint8_t*)origdir;
 	mb=dir;
 	for (n=0; n<dircount16; n++)
 	{
 		mb->tdir_ignore = FALSE;
 		if (tif->tif_flags&TIFF_SWAB)
-			TIFFSwabShort((uint16*)ma);
-		mb->tdir_tag=*(uint16*)ma;
-		ma+=sizeof(uint16);
+			TIFFSwabShort((uint16_t*)ma);
+		mb->tdir_tag=*(uint16_t*)ma;
+		ma+=sizeof(uint16_t);
 		if (tif->tif_flags&TIFF_SWAB)
-			TIFFSwabShort((uint16*)ma);
-		mb->tdir_type=*(uint16*)ma;
-		ma+=sizeof(uint16);
+			TIFFSwabShort((uint16_t*)ma);
+		mb->tdir_type=*(uint16_t*)ma;
+		ma+=sizeof(uint16_t);
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabLong((uint32*)ma);
-			mb->tdir_count=(uint64)(*(uint32*)ma);
-			ma+=sizeof(uint32);
+				TIFFSwabLong((uint32_t*)ma);
+			mb->tdir_count=(uint64_t)(*(uint32_t*)ma);
+			ma+=sizeof(uint32_t);
 			mb->tdir_offset.toff_long8=0;
-			*(uint32*)(&mb->tdir_offset)=*(uint32*)ma;
-			ma+=sizeof(uint32);
+			*(uint32_t*)(&mb->tdir_offset)=*(uint32_t*)ma;
+			ma+=sizeof(uint32_t);
 		}
 		else
 		{
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabLong8((uint64*)ma);
+				TIFFSwabLong8((uint64_t*)ma);
                         mb->tdir_count=TIFFReadUInt64(ma);
-			ma+=sizeof(uint64);
+			ma+=sizeof(uint64_t);
 			mb->tdir_offset.toff_long8=TIFFReadUInt64(ma);
-			ma+=sizeof(uint64);
+			ma+=sizeof(uint64_t);
 		}
 		mb++;
 	}
@@ -4965,13 +5024,13 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 {
 	static const char module[] = "TIFFFetchNormalTag";
 	enum TIFFReadDirEntryErr err;
-	uint32 fii;
+	uint32_t fii;
 	const TIFFField* fip = NULL;
 	TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
         if( fii == FAILED_FII )
         {
             TIFFErrorExt(tif->tif_clientdata, "TIFFFetchNormalTag",
-                         "No definition found for tag %d",
+                         "No definition found for tag %"PRIu16,
                          dp->tdir_tag);
             return 0;
         }
@@ -4986,17 +5045,17 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_ASCII:
 			{
-				uint8* data;
+				uint8_t* data;
 				assert(fip->field_passcount==0);
 				err=TIFFReadDirEntryByteArray(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
-					uint32 mb = 0;
+					uint32_t mb = 0;
 					int n;
 					if (data != NULL)
 					{
-					    uint8* ma = data;
-					    while (mb<(uint32)dp->tdir_count)
+					    uint8_t* ma = data;
+					    while (mb<(uint32_t)dp->tdir_count)
 					    {
 					            if (*ma==0)
 					                    break;
@@ -5004,24 +5063,24 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					            mb++;
 					    }
 					}
-					if (mb+1<(uint32)dp->tdir_count)
+					if (mb+1<(uint32_t)dp->tdir_count)
 						TIFFWarningExt(tif->tif_clientdata,module,"ASCII value for tag \"%s\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations",fip->field_name);
-					else if (mb+1>(uint32)dp->tdir_count)
+					else if (mb+1>(uint32_t)dp->tdir_count)
 					{
-						uint8* o;
+						uint8_t* o;
 						TIFFWarningExt(tif->tif_clientdata,module,"ASCII value for tag \"%s\" does not end in null byte",fip->field_name);
-						if ((uint32)dp->tdir_count+1!=dp->tdir_count+1)
+						if ((uint32_t)dp->tdir_count + 1 != dp->tdir_count + 1)
 							o=NULL;
 						else
-							o=_TIFFmalloc((uint32)dp->tdir_count+1);
+							o=_TIFFmalloc((uint32_t)dp->tdir_count + 1);
 						if (o==NULL)
 						{
 							if (data!=NULL)
 								_TIFFfree(data);
 							return(0);
 						}
-						_TIFFmemcpy(o,data,(uint32)dp->tdir_count);
-						o[(uint32)dp->tdir_count]=0;
+						_TIFFmemcpy(o,data,(uint32_t)dp->tdir_count);
+						o[(uint32_t)dp->tdir_count]=0;
 						if (data!=0)
 							_TIFFfree(data);
 						data=o;
@@ -5036,7 +5095,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_UINT8:
 			{
-				uint8 data=0;
+				uint8_t data=0;
 				assert(fip->field_readcount==1);
 				assert(fip->field_passcount==0);
 				err=TIFFReadDirEntryByte(tif,dp,&data);
@@ -5049,7 +5108,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_UINT16:
 			{
-				uint16 data;
+				uint16_t data;
 				assert(fip->field_readcount==1);
 				assert(fip->field_passcount==0);
 				err=TIFFReadDirEntryShort(tif,dp,&data);
@@ -5062,7 +5121,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_UINT32:
 			{
-				uint32 data;
+				uint32_t data;
 				assert(fip->field_readcount==1);
 				assert(fip->field_passcount==0);
 				err=TIFFReadDirEntryLong(tif,dp,&data);
@@ -5075,7 +5134,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_UINT64:
 			{
-				uint64 data;
+				uint64_t data;
 				assert(fip->field_readcount==1);
 				assert(fip->field_passcount==0);
 				err=TIFFReadDirEntryLong8(tif,dp,&data);
@@ -5114,7 +5173,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_IFD8:
 			{
-				uint64 data;
+				uint64_t data;
 				assert(fip->field_readcount==1);
 				assert(fip->field_passcount==0);
 				err=TIFFReadDirEntryIfd8(tif,dp,&data);
@@ -5127,19 +5186,20 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_UINT16_PAIR:
 			{
-				uint16* data;
+				uint16_t* data;
 				assert(fip->field_readcount==2);
 				assert(fip->field_passcount==0);
 				if (dp->tdir_count!=2) {
 					TIFFWarningExt(tif->tif_clientdata,module,
-						       "incorrect count for field \"%s\", expected 2, got %d",
-						       fip->field_name,(int)dp->tdir_count);
+						       "incorrect count for field \"%s\", expected 2, got %"PRIu64,
+						       fip->field_name, dp->tdir_count);
 					return(0);
 				}
 				err=TIFFReadDirEntryShortArray(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
+                                        assert(data); /* avoid CLang static Analyzer false positive */
 					m=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);
 					_TIFFfree(data);
 					if (!m)
@@ -5149,13 +5209,13 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C0_UINT8:
 			{
-				uint8* data;
+				uint8_t* data;
 				assert(fip->field_readcount>=1);
 				assert(fip->field_passcount==0);
-				if (dp->tdir_count!=(uint64)fip->field_readcount) {
+				if (dp->tdir_count!=(uint64_t)fip->field_readcount) {
 					TIFFWarningExt(tif->tif_clientdata,module,
-						       "incorrect count for field \"%s\", expected %d, got %d",
-						       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);
+						       "incorrect count for field \"%s\", expected %d, got %"PRIu64,
+						       fip->field_name,(int) fip->field_readcount, dp->tdir_count);
 					return 0;
 				}
 				else
@@ -5175,10 +5235,10 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C0_UINT16:
 			{
-				uint16* data;
+				uint16_t* data;
 				assert(fip->field_readcount>=1);
 				assert(fip->field_passcount==0);
-				if (dp->tdir_count!=(uint64)fip->field_readcount)
+				if (dp->tdir_count!=(uint64_t)fip->field_readcount)
                                     /* corrupt file */;
 				else
 				{
@@ -5197,10 +5257,10 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C0_UINT32:
 			{
-				uint32* data;
+				uint32_t* data;
 				assert(fip->field_readcount>=1);
 				assert(fip->field_passcount==0);
-				if (dp->tdir_count!=(uint64)fip->field_readcount)
+				if (dp->tdir_count!=(uint64_t)fip->field_readcount)
                                     /* corrupt file */;
 				else
 				{
@@ -5222,8 +5282,8 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 				float* data;
 				assert(fip->field_readcount>=1);
 				assert(fip->field_passcount==0);
-				if (dp->tdir_count!=(uint64)fip->field_readcount)
-                                    /* corrupt file */;
+				if (dp->tdir_count!=(uint64_t)fip->field_readcount)
+					/* corrupt file */;
 				else
 				{
 					err=TIFFReadDirEntryFloatArray(tif,dp,&data);
@@ -5239,9 +5299,32 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 				}
 			}
 			break;
+		/*--: Rational2Double: Extend for Double Arrays and Rational-Arrays read into Double-Arrays. */
+		case TIFF_SETGET_C0_DOUBLE:
+			{
+				double* data;
+				assert(fip->field_readcount>=1);
+				assert(fip->field_passcount==0);
+				if (dp->tdir_count!=(uint64_t)fip->field_readcount)
+					/* corrupt file */;
+				else
+				{
+					err=TIFFReadDirEntryDoubleArray(tif,dp,&data);
+					if (err==TIFFReadDirEntryErrOk)
+					{
+						int m;
+						m=TIFFSetField(tif,dp->tdir_tag,data);
+						if (data!=0)
+							_TIFFfree(data);
+						if (!m)
+							return(0);
+					}
+				}
+			}
+			break;
 		case TIFF_SETGET_C16_ASCII:
 			{
-				uint8* data;
+				uint8_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE);
 				assert(fip->field_passcount==1);
 				if (dp->tdir_count>0xFFFF)
@@ -5257,7 +5340,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 						    TIFFWarningExt(tif->tif_clientdata,module,"ASCII value for tag \"%s\" does not end in null byte. Forcing it to be null",fip->field_name);
 						    data[dp->tdir_count-1] = '\0';
 						}
-						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
+						m=TIFFSetField(tif, dp->tdir_tag, (uint16_t)(dp->tdir_count), data);
 						if (data!=0)
 							_TIFFfree(data);
 						if (!m)
@@ -5268,7 +5351,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C16_UINT8:
 			{
-				uint8* data;
+				uint8_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE);
 				assert(fip->field_passcount==1);
 				if (dp->tdir_count>0xFFFF)
@@ -5279,7 +5362,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					if (err==TIFFReadDirEntryErrOk)
 					{
 						int m;
-						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
+						m=TIFFSetField(tif, dp->tdir_tag, (uint16_t)(dp->tdir_count), data);
 						if (data!=0)
 							_TIFFfree(data);
 						if (!m)
@@ -5290,7 +5373,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C16_UINT16:
 			{
-				uint16* data;
+				uint16_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE);
 				assert(fip->field_passcount==1);
 				if (dp->tdir_count>0xFFFF)
@@ -5301,7 +5384,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					if (err==TIFFReadDirEntryErrOk)
 					{
 						int m;
-						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
+						m=TIFFSetField(tif, dp->tdir_tag, (uint16_t)(dp->tdir_count), data);
 						if (data!=0)
 							_TIFFfree(data);
 						if (!m)
@@ -5312,7 +5395,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C16_UINT32:
 			{
-				uint32* data;
+				uint32_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE);
 				assert(fip->field_passcount==1);
 				if (dp->tdir_count>0xFFFF)
@@ -5323,7 +5406,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					if (err==TIFFReadDirEntryErrOk)
 					{
 						int m;
-						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
+						m=TIFFSetField(tif, dp->tdir_tag, (uint16_t)(dp->tdir_count), data);
 						if (data!=0)
 							_TIFFfree(data);
 						if (!m)
@@ -5334,7 +5417,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C16_UINT64:
 			{
-				uint64* data;
+				uint64_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE);
 				assert(fip->field_passcount==1);
 				if (dp->tdir_count>0xFFFF)
@@ -5345,7 +5428,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					if (err==TIFFReadDirEntryErrOk)
 					{
 						int m;
-						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
+						m=TIFFSetField(tif, dp->tdir_tag, (uint16_t)(dp->tdir_count), data);
 						if (data!=0)
 							_TIFFfree(data);
 						if (!m)
@@ -5367,7 +5450,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					if (err==TIFFReadDirEntryErrOk)
 					{
 						int m;
-						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
+						m=TIFFSetField(tif, dp->tdir_tag, (uint16_t)(dp->tdir_count), data);
 						if (data!=0)
 							_TIFFfree(data);
 						if (!m)
@@ -5389,7 +5472,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					if (err==TIFFReadDirEntryErrOk)
 					{
 						int m;
-						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
+						m=TIFFSetField(tif, dp->tdir_tag, (uint16_t)(dp->tdir_count), data);
 						if (data!=0)
 							_TIFFfree(data);
 						if (!m)
@@ -5400,7 +5483,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C16_IFD8:
 			{
-				uint64* data;
+				uint64_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE);
 				assert(fip->field_passcount==1);
 				if (dp->tdir_count>0xFFFF)
@@ -5411,7 +5494,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					if (err==TIFFReadDirEntryErrOk)
 					{
 						int m;
-						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
+						m=TIFFSetField(tif, dp->tdir_tag, (uint16_t)(dp->tdir_count), data);
 						if (data!=0)
 							_TIFFfree(data);
 						if (!m)
@@ -5422,7 +5505,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_ASCII:
 			{
-				uint8* data;
+				uint8_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntryByteArray(tif,dp,&data);
@@ -5434,7 +5517,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 					    TIFFWarningExt(tif->tif_clientdata,module,"ASCII value for tag \"%s\" does not end in null byte. Forcing it to be null",fip->field_name);
                                             data[dp->tdir_count-1] = '\0';
 					}
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5444,14 +5527,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_UINT8:
 			{
-				uint8* data;
+				uint8_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntryByteArray(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5461,14 +5544,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_SINT8:
 			{
-				int8* data = NULL;
+				int8_t* data = NULL;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntrySbyteArray(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5478,14 +5561,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_UINT16:
 			{
-				uint16* data;
+				uint16_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntryShortArray(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5495,14 +5578,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_SINT16:
 			{
-				int16* data = NULL;
+				int16_t* data = NULL;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntrySshortArray(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5512,14 +5595,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_UINT32:
 			{
-				uint32* data;
+				uint32_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntryLongArray(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5529,14 +5612,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_SINT32:
 			{
-				int32* data = NULL;
+				int32_t* data = NULL;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntrySlongArray(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5546,14 +5629,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_UINT64:
 			{
-				uint64* data;
+				uint64_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntryLong8Array(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5563,14 +5646,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_SINT64:
 			{
-				int64* data = NULL;
+				int64_t* data = NULL;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntrySlong8Array(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5587,7 +5670,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5604,7 +5687,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5614,14 +5697,14 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 			break;
 		case TIFF_SETGET_C32_IFD8:
 			{
-				uint64* data;
+				uint64_t* data;
 				assert(fip->field_readcount==TIFF_VARIABLE2);
 				assert(fip->field_passcount==1);
 				err=TIFFReadDirEntryIfd8Array(tif,dp,&data);
 				if (err==TIFFReadDirEntryErrOk)
 				{
 					int m;
-					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
+					m=TIFFSetField(tif, dp->tdir_tag, (uint32_t)(dp->tdir_count), data);
 					if (data!=0)
 						_TIFFfree(data);
 					if (!m)
@@ -5646,11 +5729,11 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
  * While this routine says "strips", in fact it's also used for tiles.
  */
 static int
-TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)
+TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32_t nstrips, uint64_t** lpp)
 {
 	static const char module[] = "TIFFFetchStripThing";
 	enum TIFFReadDirEntryErr err;
-	uint64* data;
+	uint64_t* data;
 	err=TIFFReadDirEntryLong8ArrayWithLimit(tif,dir,&data,nstrips);
 	if (err!=TIFFReadDirEntryErrOk)
 	{
@@ -5658,14 +5741,14 @@ TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)
 		TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
 		return(0);
 	}
-	if (dir->tdir_count<(uint64)nstrips)
+	if (dir->tdir_count<(uint64_t)nstrips)
 	{
-		uint64* resizeddata;
+		uint64_t* resizeddata;
 		const TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag);
 		const char* pszMax = getenv("LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT");
-		uint32 max_nstrips = 1000000;
+		uint32_t max_nstrips = 1000000;
 		if( pszMax )
-			max_nstrips = (uint32) atoi(pszMax);
+			max_nstrips = (uint32_t) atoi(pszMax);
 		TIFFReadDirEntryOutputErr(tif,TIFFReadDirEntryErrCount,
 		            module,
 		            fip ? fip->field_name : "unknown tagname",
@@ -5677,13 +5760,13 @@ TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)
 			return(0);
 		}
 
-		resizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),"for strip array");
+		resizeddata=(uint64_t*)_TIFFCheckMalloc(tif, nstrips, sizeof(uint64_t), "for strip array");
 		if (resizeddata==0) {
 			_TIFFfree(data);
 			return(0);
 		}
-                _TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));
-                _TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));
+                _TIFFmemcpy(resizeddata,data, (uint32_t)dir->tdir_count * sizeof(uint64_t));
+                _TIFFmemset(resizeddata+(uint32_t)dir->tdir_count, 0, (nstrips - (uint32_t)dir->tdir_count) * sizeof(uint64_t));
 		_TIFFfree(data);
 		data=resizeddata;
 	}
@@ -5702,8 +5785,8 @@ TIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)
 	UInt64Aligned_t m;
     m.l=0;
 	assert(sizeof(double)==8);
-	assert(sizeof(uint64)==8);
-	assert(sizeof(uint32)==4);
+	assert(sizeof(uint64_t) == 8);
+	assert(sizeof(uint32_t) == 4);
 	if (dir->tdir_count!=1)
 		err=TIFFReadDirEntryErrCount;
 	else if (dir->tdir_type!=TIFF_RATIONAL)
@@ -5712,8 +5795,8 @@ TIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)
 	{
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
-			uint32 offset;
-			offset=*(uint32*)(&dir->tdir_offset);
+			uint32_t offset;
+			offset=*(uint32_t*)(&dir->tdir_offset);
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabLong(&offset);
 			err=TIFFReadDirEntryData(tif,offset,8,m.i);
@@ -5749,32 +5832,32 @@ TIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)
 	}
 }
 
-static void allocChoppedUpStripArrays(TIFF* tif, uint32 nstrips,
-                                      uint64 stripbytes, uint32 rowsperstrip)
+static void allocChoppedUpStripArrays(TIFF* tif, uint32_t nstrips,
+                                      uint64_t stripbytes, uint32_t rowsperstrip)
 {
     TIFFDirectory *td = &tif->tif_dir;
-    uint64 bytecount;
-    uint64 offset;
-    uint64 last_offset;
-    uint64 last_bytecount;
-    uint32 i;
-    uint64 *newcounts;
-    uint64 *newoffsets;
+    uint64_t bytecount;
+    uint64_t offset;
+    uint64_t last_offset;
+    uint64_t last_bytecount;
+    uint32_t i;
+    uint64_t *newcounts;
+    uint64_t *newoffsets;
 
     offset = TIFFGetStrileOffset(tif, 0);
     last_offset = TIFFGetStrileOffset(tif, td->td_nstrips-1);
     last_bytecount = TIFFGetStrileByteCount(tif, td->td_nstrips-1);
-    if( last_offset > TIFF_UINT64_MAX - last_bytecount ||
+    if( last_offset > UINT64_MAX - last_bytecount ||
         last_offset + last_bytecount < offset )
     {
         return;
     }
     bytecount = last_offset + last_bytecount - offset;
 
-    newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
-                            "for chopped \"StripByteCounts\" array");
-    newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
-                            "for chopped \"StripOffsets\" array");
+    newcounts = (uint64_t*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64_t),
+                                             "for chopped \"StripByteCounts\" array");
+    newoffsets = (uint64_t*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64_t),
+                                              "for chopped \"StripOffsets\" array");
     if (newcounts == NULL || newoffsets == NULL) {
         /*
         * Unable to allocate new strip information, give up and use
@@ -5828,13 +5911,13 @@ static void
 ChopUpSingleUncompressedStrip(TIFF* tif)
 {
 	register TIFFDirectory *td = &tif->tif_dir;
-	uint64 bytecount;
-	uint64 offset;
-	uint32 rowblock;
-	uint64 rowblockbytes;
-	uint64 stripbytes;
-	uint32 nstrips;
-	uint32 rowsperstrip;
+	uint64_t bytecount;
+	uint64_t offset;
+	uint32_t rowblock;
+	uint64_t rowblockbytes;
+	uint64_t stripbytes;
+	uint32_t nstrips;
+	uint32_t rowsperstrip;
 
 	bytecount = TIFFGetStrileByteCount(tif, 0);
         /* On a newly created file, just re-opened to be filled, we */
@@ -5858,8 +5941,8 @@ ChopUpSingleUncompressedStrip(TIFF* tif)
 		stripbytes = rowblockbytes;
 		rowsperstrip = rowblock;
 	} else if (rowblockbytes > 0 ) {
-		uint32 rowblocksperstrip;
-		rowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);
+		uint32_t rowblocksperstrip;
+		rowblocksperstrip = (uint32_t) (STRIP_SIZE_DEFAULT / rowblockbytes);
 		rowsperstrip = rowblocksperstrip * rowblock;
 		stripbytes = rowblocksperstrip * rowblockbytes;
 	}
@@ -5898,14 +5981,14 @@ ChopUpSingleUncompressedStrip(TIFF* tif)
 static void TryChopUpUncompressedBigTiff( TIFF* tif )
 {
     TIFFDirectory *td = &tif->tif_dir;
-    uint32 rowblock;
-    uint64 rowblockbytes;
-    uint32 i;
-    uint64 stripsize;
-    uint32 rowblocksperstrip;
-    uint32 rowsperstrip;
-    uint64 stripbytes;
-    uint32 nstrips;
+    uint32_t rowblock;
+    uint64_t rowblockbytes;
+    uint32_t i;
+    uint64_t stripsize;
+    uint32_t rowblocksperstrip;
+    uint32_t rowsperstrip;
+    uint64_t stripbytes;
+    uint32_t nstrips;
 
     stripsize = TIFFStripSize64(tif);
 
@@ -5958,7 +6041,7 @@ static void TryChopUpUncompressedBigTiff( TIFF* tif )
     }
 
     /* Aim for 512 MB strips (that will still be manageable by 32 bit builds */
-    rowblocksperstrip = (uint32) (512 * 1024 * 1024 / rowblockbytes);
+    rowblocksperstrip = (uint32_t) (512 * 1024 * 1024 / rowblockbytes);
     if( rowblocksperstrip == 0 )
         rowblocksperstrip = 1;
     rowsperstrip = rowblocksperstrip * rowblock;
@@ -5974,9 +6057,9 @@ static void TryChopUpUncompressedBigTiff( TIFF* tif )
     if( tif->tif_mode == O_RDONLY &&
         nstrips > 1000000 )
     {
-        uint64 last_offset = TIFFGetStrileOffset(tif, td->td_nstrips-1);
-        uint64 filesize = TIFFGetFileSize(tif);
-        uint64 last_bytecount = TIFFGetStrileByteCount(tif, td->td_nstrips-1);
+        uint64_t last_offset = TIFFGetStrileOffset(tif, td->td_nstrips - 1);
+        uint64_t filesize = TIFFGetFileSize(tif);
+        uint64_t last_bytecount = TIFFGetStrileByteCount(tif, td->td_nstrips - 1);
         if( last_offset > filesize ||
             last_bytecount > filesize - last_offset )
         {
@@ -5989,7 +6072,7 @@ static void TryChopUpUncompressedBigTiff( TIFF* tif )
 
 
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
-static uint64 _TIFFUnsanitizedAddUInt64AndInt(uint64 a, int b)
+static uint64_t _TIFFUnsanitizedAddUInt64AndInt(uint64_t a, int b)
 {
     return a + b;
 }
@@ -5999,8 +6082,8 @@ static uint64 _TIFFUnsanitizedAddUInt64AndInt(uint64 a, int b)
  * 4096 byte page size.
  */
 static
-int _TIFFPartialReadStripArray( TIFF* tif, TIFFDirEntry* dirent,
-                                int strile, uint64* panVals )
+int _TIFFPartialReadStripArray(TIFF* tif, TIFFDirEntry* dirent,
+                               int strile, uint64_t* panVals )
 {
     static const char module[] = "_TIFFPartialReadStripArray";
 #define IO_CACHE_PAGE_SIZE 4096
@@ -6008,31 +6091,37 @@ int _TIFFPartialReadStripArray( TIFF* tif, TIFFDirEntry* dirent,
     size_t sizeofval;
     const int bSwab = (tif->tif_flags & TIFF_SWAB) != 0;
     int sizeofvalint;
-    uint64 nBaseOffset;
-    uint64 nOffset;
-    uint64 nOffsetStartPage;
-    uint64 nOffsetEndPage;
+    uint64_t nBaseOffset;
+    uint64_t nOffset;
+    uint64_t nOffsetStartPage;
+    uint64_t nOffsetEndPage;
     tmsize_t nToRead;
     tmsize_t nRead;
-    uint64 nLastStripOffset;
+    uint64_t nLastStripOffset;
     int iStartBefore;
     int i;
-    const uint32 arraySize = tif->tif_dir.td_stripoffsetbyteallocsize;
+    const uint32_t arraySize = tif->tif_dir.td_stripoffsetbyteallocsize;
     unsigned char buffer[2 * IO_CACHE_PAGE_SIZE];
 
     assert( dirent->tdir_count > 4 );
 
     if( dirent->tdir_type == TIFF_SHORT )
     {
-        sizeofval = sizeof(uint16);
+        sizeofval = sizeof(uint16_t);
     }
     else if( dirent->tdir_type == TIFF_LONG )
     {
-        sizeofval = sizeof(uint32);
+        sizeofval = sizeof(uint32_t);
     }
     else if( dirent->tdir_type == TIFF_LONG8 )
     {
-        sizeofval = sizeof(uint64);
+        sizeofval = sizeof(uint64_t);
+    }
+    else if( dirent->tdir_type == TIFF_SLONG8 )
+    {
+        /* Non conformant but used by some images as in */
+        /* https://github.com/OSGeo/gdal/issues/2165 */
+        sizeofval = sizeof(int64_t);
     }
     else
     {
@@ -6045,20 +6134,20 @@ int _TIFFPartialReadStripArray( TIFF* tif, TIFFDirEntry* dirent,
 
     if( tif->tif_flags&TIFF_BIGTIFF )
     {
-        uint64 offset = dirent->tdir_offset.toff_long8;
+        uint64_t offset = dirent->tdir_offset.toff_long8;
         if( bSwab )
             TIFFSwabLong8(&offset);
         nBaseOffset = offset;
     }
     else
     {
-        uint32 offset = dirent->tdir_offset.toff_long;
+        uint32_t offset = dirent->tdir_offset.toff_long;
         if( bSwab )
             TIFFSwabLong(&offset);
         nBaseOffset = offset;
     }
     /* To avoid later unsigned integer overflows */
-    if( nBaseOffset > (uint64)TIFF_INT64_MAX )
+    if( nBaseOffset > (uint64_t)INT64_MAX )
     {
         TIFFErrorExt(tif->tif_clientdata, module,
                  "Cannot read offset/size for strile %d", strile);
@@ -6102,13 +6191,13 @@ int _TIFFPartialReadStripArray( TIFF* tif, TIFFDirEntry* dirent,
     if( strile + iStartBefore < 0 )
         iStartBefore = -strile;
     for( i = iStartBefore;
-         (uint32)(strile + i) < arraySize &&
+         (uint32_t)(strile + i) < arraySize &&
          _TIFFUnsanitizedAddUInt64AndInt(nOffset, (i + 1) * sizeofvalint) <= nOffsetEndPage;
          ++i )
     {
-        if( sizeofval == sizeof(uint16) )
+        if( dirent->tdir_type == TIFF_SHORT )
         {
-            uint16 val;
+            uint16_t val;
             memcpy(&val,
                    buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,
                    sizeof(val));
@@ -6116,9 +6205,9 @@ int _TIFFPartialReadStripArray( TIFF* tif, TIFFDirEntry* dirent,
                 TIFFSwabShort(&val);
             panVals[strile + i] = val;
         }
-        else if( sizeofval == sizeof(uint32) )
+        else if( dirent->tdir_type == TIFF_LONG )
         {
-            uint32 val;
+            uint32_t val;
             memcpy(&val,
                    buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,
                    sizeof(val));
@@ -6126,9 +6215,9 @@ int _TIFFPartialReadStripArray( TIFF* tif, TIFFDirEntry* dirent,
                 TIFFSwabLong(&val);
             panVals[strile + i] = val;
         }
-        else
+        else if( dirent->tdir_type == TIFF_LONG8 )
         {
-            uint64 val;
+            uint64_t val;
             memcpy(&val,
                    buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,
                    sizeof(val));
@@ -6136,14 +6225,25 @@ int _TIFFPartialReadStripArray( TIFF* tif, TIFFDirEntry* dirent,
                 TIFFSwabLong8(&val);
             panVals[strile + i] = val;
         }
+        else /* if( dirent->tdir_type == TIFF_SLONG8 ) */
+        {
+            /* Non conformant data type */
+            int64_t val;
+            memcpy(&val,
+                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,
+                   sizeof(val));
+            if( bSwab )
+                TIFFSwabLong8((uint64_t*) &val);
+            panVals[strile + i] = (uint64_t) val;
+        }
     }
     return 1;
 }
 
 static int _TIFFFetchStrileValue(TIFF* tif,
-                                 uint32 strile,
+                                 uint32_t strile,
                                  TIFFDirEntry* dirent,
-                                 uint64** parray)
+                                 uint64_t** parray)
 {
     static const char module[] = "_TIFFFetchStrileValue";
     TIFFDirectory *td = &tif->tif_dir;
@@ -6153,20 +6253,20 @@ static int _TIFFFetchStrileValue(TIFF* tif,
     }
     if( strile >= td->td_stripoffsetbyteallocsize )
     {
-        uint32 nStripArrayAllocBefore = td->td_stripoffsetbyteallocsize;
-        uint32 nStripArrayAllocNew;
-        uint64 nArraySize64;
+        uint32_t nStripArrayAllocBefore = td->td_stripoffsetbyteallocsize;
+        uint32_t nStripArrayAllocNew;
+        uint64_t nArraySize64;
         size_t nArraySize;
-        uint64* offsetArray;
-        uint64* bytecountArray;
+        uint64_t* offsetArray;
+        uint64_t* bytecountArray;
 
         if( strile > 1000000 )
         {
-            uint64 filesize = TIFFGetFileSize(tif);
+            uint64_t filesize = TIFFGetFileSize(tif);
             /* Avoid excessive memory allocation attempt */
             /* For such a big blockid we need at least a TIFF_LONG per strile */
             /* for the offset array. */
-            if( strile > filesize / sizeof(uint32) )
+            if( strile > filesize / sizeof(uint32_t) )
             {
                 TIFFErrorExt(tif->tif_clientdata, module, "File too short");
                 return 0;
@@ -6188,7 +6288,7 @@ static int _TIFFFetchStrileValue(TIFF* tif,
             nStripArrayAllocNew = TIFF_MIN(nStripArrayAllocNew, td->td_nstrips);
         }
         assert( strile < nStripArrayAllocNew );
-        nArraySize64 = (uint64)sizeof(uint64) * nStripArrayAllocNew;
+        nArraySize64 = (uint64_t)sizeof(uint64_t) * nStripArrayAllocNew;
         nArraySize = (size_t)(nArraySize64);
 #if SIZEOF_SIZE_T == 4
         if( nArraySize != nArraySize64 )
@@ -6198,9 +6298,9 @@ static int _TIFFFetchStrileValue(TIFF* tif,
             return 0;
         }
 #endif
-        offsetArray = (uint64*)(
+        offsetArray = (uint64_t*)(
             _TIFFrealloc( td->td_stripoffset_p, nArraySize ) );
-        bytecountArray = (uint64*)(
+        bytecountArray = (uint64_t*)(
             _TIFFrealloc( td->td_stripbytecount_p, nArraySize ) );
         if( offsetArray )
             td->td_stripoffset_p = offsetArray;
@@ -6212,10 +6312,10 @@ static int _TIFFFetchStrileValue(TIFF* tif,
             /* Initialize new entries to ~0 / -1 */
             memset(td->td_stripoffset_p + nStripArrayAllocBefore,
                 0xFF,
-                (td->td_stripoffsetbyteallocsize - nStripArrayAllocBefore) * sizeof(uint64) );
+                (td->td_stripoffsetbyteallocsize - nStripArrayAllocBefore) * sizeof(uint64_t) );
             memset(td->td_stripbytecount_p + nStripArrayAllocBefore,
                 0xFF,
-                (td->td_stripoffsetbyteallocsize - nStripArrayAllocBefore) * sizeof(uint64) );
+                (td->td_stripoffsetbyteallocsize - nStripArrayAllocBefore) * sizeof(uint64_t) );
         }
         else
         {
@@ -6243,10 +6343,10 @@ static int _TIFFFetchStrileValue(TIFF* tif,
     return 1;
 }
 
-static uint64 _TIFFGetStrileOffsetOrByteCountValue(TIFF *tif, uint32 strile,
-                                                   TIFFDirEntry* dirent,
-                                                   uint64** parray,
-                                                   int *pbErr)
+static uint64_t _TIFFGetStrileOffsetOrByteCountValue(TIFF *tif, uint32_t strile,
+                                                     TIFFDirEntry* dirent,
+                                                     uint64_t** parray,
+                                                     int *pbErr)
 {
     TIFFDirectory *td = &tif->tif_dir;
     if( pbErr )
@@ -6287,13 +6387,13 @@ static uint64 _TIFFGetStrileOffsetOrByteCountValue(TIFF *tif, uint32 strile,
 }
 
 /* Return the value of the TileOffsets/StripOffsets array for the specified tile/strile */
-uint64 TIFFGetStrileOffset(TIFF *tif, uint32 strile)
+uint64_t TIFFGetStrileOffset(TIFF *tif, uint32_t strile)
 {
     return TIFFGetStrileOffsetWithErr(tif, strile, NULL);
 }
 
 /* Return the value of the TileOffsets/StripOffsets array for the specified tile/strile */
-uint64 TIFFGetStrileOffsetWithErr(TIFF *tif, uint32 strile, int *pbErr)
+uint64_t TIFFGetStrileOffsetWithErr(TIFF *tif, uint32_t strile, int *pbErr)
 {
     TIFFDirectory *td = &tif->tif_dir;
     return _TIFFGetStrileOffsetOrByteCountValue(tif, strile,
@@ -6302,13 +6402,13 @@ uint64 TIFFGetStrileOffsetWithErr(TIFF *tif, uint32 strile, int *pbErr)
 }
 
 /* Return the value of the TileByteCounts/StripByteCounts array for the specified tile/strile */
-uint64 TIFFGetStrileByteCount(TIFF *tif, uint32 strile)
+uint64_t TIFFGetStrileByteCount(TIFF *tif, uint32_t strile)
 {
     return TIFFGetStrileByteCountWithErr(tif, strile, NULL);
 }
 
 /* Return the value of the TileByteCounts/StripByteCounts array for the specified tile/strile */
-uint64 TIFFGetStrileByteCountWithErr(TIFF *tif, uint32 strile, int *pbErr)
+uint64_t TIFFGetStrileByteCountWithErr(TIFF *tif, uint32_t strile, int *pbErr)
 {
     TIFFDirectory *td = &tif->tif_dir;
     return _TIFFGetStrileOffsetOrByteCountValue(tif, strile,
@@ -6346,7 +6446,7 @@ static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )
     if( td->td_stripoffset_p != NULL )
             return 1;
 
-    /* If tdir_count was cancelled, then we already got there, but in error */
+    /* If tdir_count was canceled, then we already got there, but in error */
     if( td->td_stripoffset_entry.tdir_count == 0 )
             return 0;
 
@@ -6368,7 +6468,7 @@ static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )
 
 #ifdef STRIPBYTECOUNTSORTED_UNUSED
     if (tif->tif_dir.td_nstrips > 1 && return_value == 1 ) {
-            uint32 strip;
+            uint32_t strip;
 
             tif->tif_dir.td_stripbytecountsorted = 1;
             for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {
diff --git a/src/3rdparty/libtiff/libtiff/tif_dirwrite.c b/src/3rdparty/libtiff/libtiff/tif_dirwrite.c
index 9e4d306..12d67be 100644
--- a/src/3rdparty/libtiff/libtiff/tif_dirwrite.c
+++ b/src/3rdparty/libtiff/libtiff/tif_dirwrite.c
@@ -28,144 +28,159 @@
  * Directory Write Support Routines.
  */
 #include "tiffiop.h"
+#include <float.h>		/*--: for Rational2Double */
+#include <math.h>		/*--: for Rational2Double */
 
 #ifdef HAVE_IEEEFP
 #define TIFFCvtNativeToIEEEFloat(tif, n, fp)
 #define TIFFCvtNativeToIEEEDouble(tif, n, dp)
 #else
-extern void TIFFCvtNativeToIEEEFloat(TIFF* tif, uint32 n, float* fp);
-extern void TIFFCvtNativeToIEEEDouble(TIFF* tif, uint32 n, double* dp);
+extern void TIFFCvtNativeToIEEEFloat(TIFF* tif, uint32_t n, float* fp);
+extern void TIFFCvtNativeToIEEEDouble(TIFF* tif, uint32_t n, double* dp);
 #endif
 
-static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff);
+static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64_t* pdiroff);
 
-static int TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value);
+static int TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value);
 #if 0
-static int TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value);
+static int TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value);
 #endif
 
-static int TIFFWriteDirectoryTagAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value);
-static int TIFFWriteDirectoryTagUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value);
+static int TIFFWriteDirectoryTagAscii(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, char* value);
+static int TIFFWriteDirectoryTagUndefinedArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint8_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value);
+static int TIFFWriteDirectoryTagByte(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint8_t value);
 #endif
-static int TIFFWriteDirectoryTagByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value);
+static int TIFFWriteDirectoryTagByteArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint8_t* value);
 #if 0
-static int TIFFWriteDirectoryTagBytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value);
+static int TIFFWriteDirectoryTagBytePerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint8_t value);
 #endif
 #ifdef notdef
-static int TIFFWriteDirectoryTagSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value);
+static int TIFFWriteDirectoryTagSbyte(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int8_t value);
 #endif
-static int TIFFWriteDirectoryTagSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value);
+static int TIFFWriteDirectoryTagSbyteArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int8_t* value);
 #if 0
-static int TIFFWriteDirectoryTagSbytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value);
+static int TIFFWriteDirectoryTagSbytePerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int8_t value);
 #endif
-static int TIFFWriteDirectoryTagShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value);
-static int TIFFWriteDirectoryTagShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value);
-static int TIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value);
+static int TIFFWriteDirectoryTagShort(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint16_t value);
+static int TIFFWriteDirectoryTagShortArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint16_t* value);
+static int TIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint16_t value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value);
+static int TIFFWriteDirectoryTagSshort(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int16_t value);
 #endif
-static int TIFFWriteDirectoryTagSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value);
+static int TIFFWriteDirectoryTagSshortArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int16_t* value);
 #if 0
-static int TIFFWriteDirectoryTagSshortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value);
+static int TIFFWriteDirectoryTagSshortPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int16_t value);
 #endif
-static int TIFFWriteDirectoryTagLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value);
-static int TIFFWriteDirectoryTagLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value);
+static int TIFFWriteDirectoryTagLong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t value);
+static int TIFFWriteDirectoryTagLongArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint32_t* value);
 #if 0
-static int TIFFWriteDirectoryTagLongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value);
+static int TIFFWriteDirectoryTagLongPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t value);
 #endif
 #ifdef notdef
-static int TIFFWriteDirectoryTagSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value);
+static int TIFFWriteDirectoryTagSlong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int32_t value);
 #endif
-static int TIFFWriteDirectoryTagSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value);
+static int TIFFWriteDirectoryTagSlongArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int32_t* value);
 #if 0
-static int TIFFWriteDirectoryTagSlongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value);
+static int TIFFWriteDirectoryTagSlongPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int32_t value);
 #endif
 #ifdef notdef
-static int TIFFWriteDirectoryTagLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value);
+static int TIFFWriteDirectoryTagLong8(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint64_t value);
 #endif
-static int TIFFWriteDirectoryTagLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value);
+static int TIFFWriteDirectoryTagLong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value);
+static int TIFFWriteDirectoryTagSlong8(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int64_t value);
 #endif
-static int TIFFWriteDirectoryTagSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value);
-static int TIFFWriteDirectoryTagRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value);
-static int TIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value);
-static int TIFFWriteDirectoryTagSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value);
+static int TIFFWriteDirectoryTagSlong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int64_t* value);
+static int TIFFWriteDirectoryTagRational(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value);
+static int TIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value);
+static int TIFFWriteDirectoryTagSrationalArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value);
+static int TIFFWriteDirectoryTagFloat(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, float value);
 #endif
-static int TIFFWriteDirectoryTagFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value);
+static int TIFFWriteDirectoryTagFloatArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value);
 #if 0
-static int TIFFWriteDirectoryTagFloatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value);
+static int TIFFWriteDirectoryTagFloatPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, float value);
 #endif
 #ifdef notdef
-static int TIFFWriteDirectoryTagDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value);
+static int TIFFWriteDirectoryTagDouble(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value);
 #endif
-static int TIFFWriteDirectoryTagDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value);
+static int TIFFWriteDirectoryTagDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value);
 #if 0
-static int TIFFWriteDirectoryTagDoublePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value);
+static int TIFFWriteDirectoryTagDoublePerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value);
 #endif
-static int TIFFWriteDirectoryTagIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value);
+static int TIFFWriteDirectoryTagIfdArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint32_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value);
+static int TIFFWriteDirectoryTagIfd8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value);
 #endif
-static int TIFFWriteDirectoryTagShortLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value);
-static int TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value);
-static int TIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value);
+static int TIFFWriteDirectoryTagShortLong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t value);
+static int TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value);
+static int TIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value);
+static int TIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value);
 #endif
-static int TIFFWriteDirectoryTagColormap(TIFF* tif, uint32* ndir, TIFFDirEntry* dir);
-static int TIFFWriteDirectoryTagTransferfunction(TIFF* tif, uint32* ndir, TIFFDirEntry* dir);
-static int TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir);
+static int TIFFWriteDirectoryTagColormap(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir);
+static int TIFFWriteDirectoryTagTransferfunction(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir);
+static int TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir);
 
-static int TIFFWriteDirectoryTagCheckedAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value);
-static int TIFFWriteDirectoryTagCheckedUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value);
+static int TIFFWriteDirectoryTagCheckedAscii(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, char* value);
+static int TIFFWriteDirectoryTagCheckedUndefinedArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint8_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagCheckedByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value);
+static int TIFFWriteDirectoryTagCheckedByte(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint8_t value);
 #endif
-static int TIFFWriteDirectoryTagCheckedByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value);
+static int TIFFWriteDirectoryTagCheckedByteArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint8_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagCheckedSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value);
+static int TIFFWriteDirectoryTagCheckedSbyte(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int8_t value);
 #endif
-static int TIFFWriteDirectoryTagCheckedSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value);
-static int TIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value);
-static int TIFFWriteDirectoryTagCheckedShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value);
+static int TIFFWriteDirectoryTagCheckedSbyteArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int8_t* value);
+static int TIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint16_t value);
+static int TIFFWriteDirectoryTagCheckedShortArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint16_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagCheckedSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value);
+static int TIFFWriteDirectoryTagCheckedSshort(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int16_t value);
 #endif
-static int TIFFWriteDirectoryTagCheckedSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value);
-static int TIFFWriteDirectoryTagCheckedLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value);
-static int TIFFWriteDirectoryTagCheckedLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value);
+static int TIFFWriteDirectoryTagCheckedSshortArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int16_t* value);
+static int TIFFWriteDirectoryTagCheckedLong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t value);
+static int TIFFWriteDirectoryTagCheckedLongArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint32_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagCheckedSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value);
+static int TIFFWriteDirectoryTagCheckedSlong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int32_t value);
 #endif
-static int TIFFWriteDirectoryTagCheckedSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value);
+static int TIFFWriteDirectoryTagCheckedSlongArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int32_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value);
+static int TIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint64_t value);
 #endif
-static int TIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value);
+static int TIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagCheckedSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value);
+static int TIFFWriteDirectoryTagCheckedSlong8(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int64_t value);
 #endif
-static int TIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value);
-static int TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value);
-static int TIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value);
-static int TIFFWriteDirectoryTagCheckedSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value);
+static int TIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int64_t* value);
+static int TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value);
+static int TIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value);
+static int TIFFWriteDirectoryTagCheckedSrationalArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value);
+
+/*--: Rational2Double: New functions to support true double-precision for custom rational tag types. */
+static int TIFFWriteDirectoryTagRationalDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value);
+static int TIFFWriteDirectoryTagSrationalDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value);
+static int TIFFWriteDirectoryTagCheckedRationalDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value);
+static int TIFFWriteDirectoryTagCheckedSrationalDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value);
+static void DoubleToRational(double value, uint32_t *num, uint32_t *denom);
+static void DoubleToSrational(double value, int32_t *num, int32_t *denom);
+#if 0
+static void DoubleToRational_direct(double value, unsigned long *num, unsigned long *denom);
+static void DoubleToSrational_direct(double value, long *num, long *denom);
+#endif
+
 #ifdef notdef
-static int TIFFWriteDirectoryTagCheckedFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value);
+static int TIFFWriteDirectoryTagCheckedFloat(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, float value);
 #endif
-static int TIFFWriteDirectoryTagCheckedFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value);
+static int TIFFWriteDirectoryTagCheckedFloatArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value);
 #ifdef notdef
-static int TIFFWriteDirectoryTagCheckedDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value);
+static int TIFFWriteDirectoryTagCheckedDouble(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value);
 #endif
-static int TIFFWriteDirectoryTagCheckedDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value);
-static int TIFFWriteDirectoryTagCheckedIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value);
-static int TIFFWriteDirectoryTagCheckedIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value);
+static int TIFFWriteDirectoryTagCheckedDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value);
+static int TIFFWriteDirectoryTagCheckedIfdArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint32_t* value);
+static int TIFFWriteDirectoryTagCheckedIfd8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value);
 
-static int TIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 datatype, uint32 count, uint32 datalength, void* data);
+static int TIFFWriteDirectoryTagData(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint16_t datatype, uint32_t count, uint32_t datalength, void* data);
 
 static int TIFFLinkDirectory(TIFF*);
 
@@ -245,7 +260,7 @@ TIFFCheckpointDirectory(TIFF* tif)
 }
 
 int
-TIFFWriteCustomDirectory(TIFF* tif, uint64* pdiroff)
+TIFFWriteCustomDirectory(TIFF* tif, uint64_t* pdiroff)
 {
 	return TIFFWriteDirectorySec(tif,FALSE,FALSE,pdiroff);
 }
@@ -287,11 +302,11 @@ TIFFRewriteDirectory( TIFF *tif )
 		}
 		else
 		{
-			uint32 nextdir;
+			uint32_t nextdir;
 			nextdir = tif->tif_header.classic.tiff_diroff;
 			while(1) {
-				uint16 dircount;
-				uint32 nextnextdir;
+				uint16_t dircount;
+				uint32_t nextnextdir;
 
 				if (!SeekOK(tif, nextdir) ||
 				    !ReadOK(tif, &dircount, 2)) {
@@ -312,7 +327,7 @@ TIFFRewriteDirectory( TIFF *tif )
 					TIFFSwabLong(&nextnextdir);
 				if (nextnextdir==tif->tif_diroff)
 				{
-					uint32 m;
+					uint32_t m;
 					m=0;
 					(void) TIFFSeekFile(tif,
 					    nextdir+2+dircount*12, SEEK_SET);
@@ -345,12 +360,12 @@ TIFFRewriteDirectory( TIFF *tif )
 		}
 		else
 		{
-			uint64 nextdir;
+			uint64_t nextdir;
 			nextdir = tif->tif_header.big.tiff_diroff;
 			while(1) {
-				uint64 dircount64;
-				uint16 dircount;
-				uint64 nextnextdir;
+				uint64_t dircount64;
+				uint16_t dircount;
+				uint64_t nextnextdir;
 
 				if (!SeekOK(tif, nextdir) ||
 				    !ReadOK(tif, &dircount64, 8)) {
@@ -366,7 +381,7 @@ TIFFRewriteDirectory( TIFF *tif )
 					     "Sanity check on tag count failed, likely corrupt TIFF");
 					return (0);
 				}
-				dircount=(uint16)dircount64;
+				dircount=(uint16_t)dircount64;
 				(void) TIFFSeekFile(tif,
 				    nextdir+8+dircount*20, SEEK_SET);
 				if (!ReadOK(tif, &nextnextdir, 8)) {
@@ -378,7 +393,7 @@ TIFFRewriteDirectory( TIFF *tif )
 					TIFFSwabLong8(&nextnextdir);
 				if (nextnextdir==tif->tif_diroff)
 				{
-					uint64 m;
+					uint64_t m;
 					m=0;
 					(void) TIFFSeekFile(tif,
 					    nextdir+8+dircount*20, SEEK_SET);
@@ -403,14 +418,14 @@ TIFFRewriteDirectory( TIFF *tif )
 }
 
 static int
-TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
+TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64_t* pdiroff)
 {
 	static const char module[] = "TIFFWriteDirectorySec";
-	uint32 ndir;
+	uint32_t ndir;
 	TIFFDirEntry* dir;
-	uint32 dirsize;
+	uint32_t dirsize;
 	void* dirmem;
-	uint32 m;
+	uint32_t m;
 	if (tif->tif_mode == O_RDONLY)
 		return (1);
 
@@ -615,8 +630,8 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 			{
 				if (tif->tif_dir.td_extrasamples)
 				{
-					uint16 na;
-					uint16* nb;
+					uint16_t na;
+					uint16_t* nb;
 					TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);
 					if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))
 						goto bad;
@@ -683,7 +698,7 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 					goto bad;
 			}
 			{
-				uint32 n;
+				uint32_t n;
 				for (n=0; n<tif->tif_nfields; n++) {
 					const TIFFField* o;
 					o = tif->tif_fields[n];
@@ -693,54 +708,54 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 						{
 							case TIFF_SETGET_ASCII:
 								{
-									uint32 pa;
+									uint32_t pa;
 									char* pb;
 									assert(o->field_type==TIFF_ASCII);
 									assert(o->field_readcount==TIFF_VARIABLE);
 									assert(o->field_passcount==0);
 									TIFFGetField(tif,o->field_tag,&pb);
-									pa=(uint32)(strlen(pb));
-									if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))
+									pa=(uint32_t)(strlen(pb));
+									if (!TIFFWriteDirectoryTagAscii(tif, &ndir, dir, (uint16_t)o->field_tag, pa, pb))
 										goto bad;
 								}
 								break;
 							case TIFF_SETGET_UINT16:
 								{
-									uint16 p;
+									uint16_t p;
 									assert(o->field_type==TIFF_SHORT);
 									assert(o->field_readcount==1);
 									assert(o->field_passcount==0);
 									TIFFGetField(tif,o->field_tag,&p);
-									if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))
+									if (!TIFFWriteDirectoryTagShort(tif, &ndir, dir, (uint16_t)o->field_tag, p))
 										goto bad;
 								}
 								break;
 							case TIFF_SETGET_UINT32:
 								{
-									uint32 p;
+									uint32_t p;
 									assert(o->field_type==TIFF_LONG);
 									assert(o->field_readcount==1);
 									assert(o->field_passcount==0);
 									TIFFGetField(tif,o->field_tag,&p);
-									if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))
+									if (!TIFFWriteDirectoryTagLong(tif, &ndir, dir, (uint16_t)o->field_tag, p))
 										goto bad;
 								}
 								break;
 							case TIFF_SETGET_C32_UINT8:
 								{
-									uint32 pa;
+									uint32_t pa;
 									void* pb;
 									assert(o->field_type==TIFF_UNDEFINED);
 									assert(o->field_readcount==TIFF_VARIABLE2);
 									assert(o->field_passcount==1);
 									TIFFGetField(tif,o->field_tag,&pa,&pb);
-									if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))
+									if (!TIFFWriteDirectoryTagUndefinedArray(tif, &ndir, dir, (uint16_t)o->field_tag, pa, pb))
 										goto bad;
 								}
 								break;
 							default:
 								TIFFErrorExt(tif->tif_clientdata,module,
-								            "Cannot write tag %d (%s)",
+								            "Cannot write tag %"PRIu32" (%s)",
 								            TIFFFieldTag(o),
                                                                             o->field_name ? o->field_name : "unknown");
 								goto bad;
@@ -749,10 +764,10 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 				}
 			}
 		}
-		for (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)
+		for (m=0; m<(uint32_t)(tif->tif_dir.td_customValueCount); m++)
 		{
-                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;
-                        uint32 count = tif->tif_dir.td_customValues[m].count;
+                        uint16_t tag = (uint16_t)tif->tif_dir.td_customValues[m].info->field_tag;
+                        uint32_t count = tif->tif_dir.td_customValues[m].count;
 			switch (tif->tif_dir.td_customValues[m].info->field_type)
 			{
 				case TIFF_ASCII:
@@ -796,12 +811,42 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 						goto bad;
 					break;
 				case TIFF_RATIONAL:
-					if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))
-						goto bad;
+					{
+						/*-- Rational2Double: For Rationals evaluate "set_field_type" to determine internal storage size. */
+						int tv_size;
+						tv_size = _TIFFSetGetFieldSize(tif->tif_dir.td_customValues[m].info->set_field_type);
+						if (tv_size == 8) {
+							if (!TIFFWriteDirectoryTagRationalDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))
+								goto bad;
+						} else {
+							/*-- default should be tv_size == 4 */
+							if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))
+								goto bad;
+							/*-- ToDo: After Testing, this should be removed and tv_size==4 should be set as default. */
+							if (tv_size != 4) {
+								TIFFErrorExt(0,"TIFFLib: _TIFFWriteDirectorySec()", "Rational2Double: .set_field_type in not 4 but %d", tv_size); 
+							}
+						}
+					}
 					break;
 				case TIFF_SRATIONAL:
-					if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))
-						goto bad;
+					{
+						/*-- Rational2Double: For Rationals evaluate "set_field_type" to determine internal storage size. */
+						int tv_size;
+						tv_size = _TIFFSetGetFieldSize(tif->tif_dir.td_customValues[m].info->set_field_type);
+						if (tv_size == 8) {
+							if (!TIFFWriteDirectoryTagSrationalDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))
+								goto bad;
+						} else {
+							/*-- default should be tv_size == 4 */
+							if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))
+								goto bad;
+							/*-- ToDo: After Testing, this should be removed and tv_size==4 should be set as default. */
+							if (tv_size != 4) {
+								TIFFErrorExt(0,"TIFFLib: _TIFFWriteDirectorySec()", "Rational2Double: .set_field_type in not 4 but %d", tv_size); 
+							}
+						}
+					}
 					break;
 				case TIFF_FLOAT:
 					if (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))
@@ -847,8 +892,8 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 			dirsize=8+ndir*20+8;
 		tif->tif_dataoff=tif->tif_diroff+dirsize;
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
-			tif->tif_dataoff=(uint32)tif->tif_dataoff;
-		if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))
+			tif->tif_dataoff=(uint32_t)tif->tif_dataoff;
+		if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64_t)dirsize))
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"Maximum TIFF file size exceeded");
 			goto bad;
@@ -862,7 +907,7 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 	{
 		if (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))
 		{
-			uint32 na;
+			uint32_t na;
 			TIFFDirEntry* nb;
 			for (na=0, nb=dir; ; na++, nb++)
 			{
@@ -889,29 +934,29 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 	}
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
-		uint8* n;
-		uint32 nTmp;
+		uint8_t* n;
+		uint32_t nTmp;
 		TIFFDirEntry* o;
 		n=dirmem;
-		*(uint16*)n=(uint16)ndir;
+		*(uint16_t*)n=(uint16_t)ndir;
 		if (tif->tif_flags&TIFF_SWAB)
-			TIFFSwabShort((uint16*)n);
+			TIFFSwabShort((uint16_t*)n);
 		n+=2;
 		o=dir;
 		for (m=0; m<ndir; m++)
 		{
-			*(uint16*)n=o->tdir_tag;
+			*(uint16_t*)n=o->tdir_tag;
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabShort((uint16*)n);
+				TIFFSwabShort((uint16_t*)n);
 			n+=2;
-			*(uint16*)n=o->tdir_type;
+			*(uint16_t*)n=o->tdir_type;
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabShort((uint16*)n);
+				TIFFSwabShort((uint16_t*)n);
 			n+=2;
-			nTmp = (uint32)o->tdir_count;
+			nTmp = (uint32_t)o->tdir_count;
 			_TIFFmemcpy(n,&nTmp,4);
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabLong((uint32*)n);
+				TIFFSwabLong((uint32_t*)n);
 			n+=4;
 			/* This is correct. The data has been */
 			/* swabbed previously in TIFFWriteDirectoryTagData */
@@ -919,34 +964,34 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 			n+=4;
 			o++;
 		}
-		nTmp = (uint32)tif->tif_nextdiroff;
+		nTmp = (uint32_t)tif->tif_nextdiroff;
 		if (tif->tif_flags&TIFF_SWAB)
 			TIFFSwabLong(&nTmp);
 		_TIFFmemcpy(n,&nTmp,4);
 	}
 	else
 	{
-		uint8* n;
+		uint8_t* n;
 		TIFFDirEntry* o;
 		n=dirmem;
-		*(uint64*)n=ndir;
+		*(uint64_t*)n=ndir;
 		if (tif->tif_flags&TIFF_SWAB)
-			TIFFSwabLong8((uint64*)n);
+			TIFFSwabLong8((uint64_t*)n);
 		n+=8;
 		o=dir;
 		for (m=0; m<ndir; m++)
 		{
-			*(uint16*)n=o->tdir_tag;
+			*(uint16_t*)n=o->tdir_tag;
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabShort((uint16*)n);
+				TIFFSwabShort((uint16_t*)n);
 			n+=2;
-			*(uint16*)n=o->tdir_type;
+			*(uint16_t*)n=o->tdir_type;
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabShort((uint16*)n);
+				TIFFSwabShort((uint16_t*)n);
 			n+=2;
 			_TIFFmemcpy(n,&o->tdir_count,8);
 			if (tif->tif_flags&TIFF_SWAB)
-				TIFFSwabLong8((uint64*)n);
+				TIFFSwabLong8((uint64_t*)n);
 			n+=8;
 			_TIFFmemcpy(n,&o->tdir_offset,8);
 			n+=8;
@@ -954,7 +999,7 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 		}
 		_TIFFmemcpy(n,&tif->tif_nextdiroff,8);
 		if (tif->tif_flags&TIFF_SWAB)
-			TIFFSwabLong8((uint64*)n);
+			TIFFSwabLong8((uint64_t*)n);
 	}
 	_TIFFfree(dir);
 	dir=NULL;
@@ -990,66 +1035,66 @@ bad:
 	return(0);
 }
 
-static int8 TIFFClampDoubleToInt8( double val )
+static int8_t TIFFClampDoubleToInt8(double val )
 {
     if( val > 127 )
         return 127;
     if( val < -128 || val != val )
         return -128;
-    return (int8)val;
+    return (int8_t)val;
 }
 
-static int16 TIFFClampDoubleToInt16( double val )
+static int16_t TIFFClampDoubleToInt16(double val )
 {
     if( val > 32767 )
         return 32767;
     if( val < -32768 || val != val )
         return -32768;
-    return (int16)val;
+    return (int16_t)val;
 }
 
-static int32 TIFFClampDoubleToInt32( double val )
+static int32_t TIFFClampDoubleToInt32(double val )
 {
     if( val > 0x7FFFFFFF )
         return 0x7FFFFFFF;
     if( val < -0x7FFFFFFF-1 || val != val )
         return -0x7FFFFFFF-1;
-    return (int32)val;
+    return (int32_t)val;
 }
 
-static uint8 TIFFClampDoubleToUInt8( double val )
+static uint8_t TIFFClampDoubleToUInt8(double val )
 {
     if( val < 0 )
         return 0;
     if( val > 255 || val != val )
         return 255;
-    return (uint8)val;
+    return (uint8_t)val;
 }
 
-static uint16 TIFFClampDoubleToUInt16( double val )
+static uint16_t TIFFClampDoubleToUInt16(double val )
 {
     if( val < 0 )
         return 0;
     if( val > 65535 || val != val )
         return 65535;
-    return (uint16)val;
+    return (uint16_t)val;
 }
 
-static uint32 TIFFClampDoubleToUInt32( double val )
+static uint32_t TIFFClampDoubleToUInt32(double val )
 {
     if( val < 0 )
         return 0;
     if( val > 0xFFFFFFFFU || val != val )
         return 0xFFFFFFFFU;
-    return (uint32)val;
+    return (uint32_t)val;
 }
 
 static int
-TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)
+TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagSampleformatArray";
 	void* conv;
-	uint32 i;
+	uint32_t i;
 	int ok;
 	conv = _TIFFmalloc(count*sizeof(double));
 	if (conv == NULL)
@@ -1076,40 +1121,40 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			if (tif->tif_dir.td_bitspersample<=8)
 			{
 				for (i = 0; i < count; ++i)
-					((int8*)conv)[i] = TIFFClampDoubleToInt8(value[i]);
-				ok = TIFFWriteDirectoryTagSbyteArray(tif,ndir,dir,tag,count,(int8*)conv);
+					((int8_t*)conv)[i] = TIFFClampDoubleToInt8(value[i]);
+				ok = TIFFWriteDirectoryTagSbyteArray(tif,ndir,dir,tag,count,(int8_t*)conv);
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
 			{
 				for (i = 0; i < count; ++i)
-					((int16*)conv)[i] = TIFFClampDoubleToInt16(value[i]);
-				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);
+					((int16_t*)conv)[i] = TIFFClampDoubleToInt16(value[i]);
+				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16_t*)conv);
 			}
 			else
 			{
 				for (i = 0; i < count; ++i)
-					((int32*)conv)[i] = TIFFClampDoubleToInt32(value[i]);
-				ok = TIFFWriteDirectoryTagSlongArray(tif,ndir,dir,tag,count,(int32*)conv);
+					((int32_t*)conv)[i] = TIFFClampDoubleToInt32(value[i]);
+				ok = TIFFWriteDirectoryTagSlongArray(tif,ndir,dir,tag,count,(int32_t*)conv);
 			}
 			break;
 		case SAMPLEFORMAT_UINT:
 			if (tif->tif_dir.td_bitspersample<=8)
 			{
 				for (i = 0; i < count; ++i)
-					((uint8*)conv)[i] = TIFFClampDoubleToUInt8(value[i]);
-				ok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8*)conv);
+					((uint8_t*)conv)[i] = TIFFClampDoubleToUInt8(value[i]);
+				ok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8_t*)conv);
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
 			{
 				for (i = 0; i < count; ++i)
-					((uint16*)conv)[i] = TIFFClampDoubleToUInt16(value[i]);
-				ok = TIFFWriteDirectoryTagShortArray(tif,ndir,dir,tag,count,(uint16*)conv);
+					((uint16_t*)conv)[i] = TIFFClampDoubleToUInt16(value[i]);
+				ok = TIFFWriteDirectoryTagShortArray(tif,ndir,dir,tag,count,(uint16_t*)conv);
 			}
 			else
 			{
 				for (i = 0; i < count; ++i)
-					((uint32*)conv)[i] = TIFFClampDoubleToUInt32(value[i]);
-				ok = TIFFWriteDirectoryTagLongArray(tif,ndir,dir,tag,count,(uint32*)conv);
+					((uint32_t*)conv)[i] = TIFFClampDoubleToUInt32(value[i]);
+				ok = TIFFWriteDirectoryTagLongArray(tif,ndir,dir,tag,count,(uint32_t*)conv);
 			}
 			break;
 		default:
@@ -1122,7 +1167,7 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 
 #if 0
 static int
-TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
+TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value)
 {
 	switch (tif->tif_dir.td_sampleformat)
 	{
@@ -1133,18 +1178,18 @@ TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry
 				return(TIFFWriteDirectoryTagDoublePerSample(tif,ndir,dir,tag,value));
 		case SAMPLEFORMAT_INT:
 			if (tif->tif_dir.td_bitspersample<=8)
-				return(TIFFWriteDirectoryTagSbytePerSample(tif,ndir,dir,tag,(int8)value));
+				return(TIFFWriteDirectoryTagSbytePerSample(tif,ndir,dir,tag,(int8_t)value));
 			else if (tif->tif_dir.td_bitspersample<=16)
-				return(TIFFWriteDirectoryTagSshortPerSample(tif,ndir,dir,tag,(int16)value));
+				return(TIFFWriteDirectoryTagSshortPerSample(tif,ndir,dir,tag,(int16_t)value));
 			else
-				return(TIFFWriteDirectoryTagSlongPerSample(tif,ndir,dir,tag,(int32)value));
+				return(TIFFWriteDirectoryTagSlongPerSample(tif,ndir,dir,tag,(int32_t)value));
 		case SAMPLEFORMAT_UINT:
 			if (tif->tif_dir.td_bitspersample<=8)
-				return(TIFFWriteDirectoryTagBytePerSample(tif,ndir,dir,tag,(uint8)value));
+				return(TIFFWriteDirectoryTagBytePerSample(tif,ndir,dir,tag,(uint8_t)value));
 			else if (tif->tif_dir.td_bitspersample<=16)
-				return(TIFFWriteDirectoryTagShortPerSample(tif,ndir,dir,tag,(uint16)value));
+				return(TIFFWriteDirectoryTagShortPerSample(tif,ndir,dir,tag,(uint16_t)value));
 			else
-				return(TIFFWriteDirectoryTagLongPerSample(tif,ndir,dir,tag,(uint32)value));
+				return(TIFFWriteDirectoryTagLongPerSample(tif,ndir,dir,tag,(uint32_t)value));
 		default:
 			return(1);
 	}
@@ -1152,7 +1197,7 @@ TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry
 #endif
 
 static int
-TIFFWriteDirectoryTagAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)
+TIFFWriteDirectoryTagAscii(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, char* value)
 {
 	if (dir==NULL)
 	{
@@ -1163,7 +1208,7 @@ TIFFWriteDirectoryTagAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 ta
 }
 
 static int
-TIFFWriteDirectoryTagUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)
+TIFFWriteDirectoryTagUndefinedArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint8_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1175,7 +1220,7 @@ TIFFWriteDirectoryTagUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)
+TIFFWriteDirectoryTagByte(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint8_t value)
 {
 	if (dir==NULL)
 	{
@@ -1187,7 +1232,7 @@ TIFFWriteDirectoryTagByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag
 #endif
 
 static int
-TIFFWriteDirectoryTagByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)
+TIFFWriteDirectoryTagByteArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint8_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1199,19 +1244,19 @@ TIFFWriteDirectoryTagByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint1
 
 #if 0
 static int
-TIFFWriteDirectoryTagBytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)
+TIFFWriteDirectoryTagBytePerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint8_t value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagBytePerSample";
-	uint8* m;
-	uint8* na;
-	uint16 nb;
+	uint8_t* m;
+	uint8_t* na;
+	uint16_t nb;
 	int o;
 	if (dir==NULL)
 	{
 		(*ndir)++;
 		return(1);
 	}
-	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint8));
+	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint8_t));
 	if (m==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -1227,7 +1272,7 @@ TIFFWriteDirectoryTagBytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, u
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)
+TIFFWriteDirectoryTagSbyte(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int8_t value)
 {
 	if (dir==NULL)
 	{
@@ -1239,7 +1284,7 @@ TIFFWriteDirectoryTagSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 ta
 #endif
 
 static int
-TIFFWriteDirectoryTagSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value)
+TIFFWriteDirectoryTagSbyteArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int8_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1251,19 +1296,19 @@ TIFFWriteDirectoryTagSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint
 
 #if 0
 static int
-TIFFWriteDirectoryTagSbytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)
+TIFFWriteDirectoryTagSbytePerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int8_t value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagSbytePerSample";
-	int8* m;
-	int8* na;
-	uint16 nb;
+	int8_t* m;
+	int8_t* na;
+	uint16_t nb;
 	int o;
 	if (dir==NULL)
 	{
 		(*ndir)++;
 		return(1);
 	}
-	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int8));
+	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int8_t));
 	if (m==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -1278,7 +1323,7 @@ TIFFWriteDirectoryTagSbytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 #endif
 
 static int
-TIFFWriteDirectoryTagShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)
+TIFFWriteDirectoryTagShort(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint16_t value)
 {
 	if (dir==NULL)
 	{
@@ -1289,7 +1334,7 @@ TIFFWriteDirectoryTagShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 ta
 }
 
 static int
-TIFFWriteDirectoryTagShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)
+TIFFWriteDirectoryTagShortArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint16_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1300,19 +1345,19 @@ TIFFWriteDirectoryTagShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint
 }
 
 static int
-TIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)
+TIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint16_t value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagShortPerSample";
-	uint16* m;
-	uint16* na;
-	uint16 nb;
+	uint16_t* m;
+	uint16_t* na;
+	uint16_t nb;
 	int o;
 	if (dir==NULL)
 	{
 		(*ndir)++;
 		return(1);
 	}
-	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint16));
+	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint16_t));
 	if (m==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -1327,7 +1372,7 @@ TIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)
+TIFFWriteDirectoryTagSshort(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int16_t value)
 {
 	if (dir==NULL)
 	{
@@ -1339,7 +1384,7 @@ TIFFWriteDirectoryTagSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 t
 #endif
 
 static int
-TIFFWriteDirectoryTagSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value)
+TIFFWriteDirectoryTagSshortArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int16_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1351,19 +1396,19 @@ TIFFWriteDirectoryTagSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uin
 
 #if 0
 static int
-TIFFWriteDirectoryTagSshortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)
+TIFFWriteDirectoryTagSshortPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int16_t value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagSshortPerSample";
-	int16* m;
-	int16* na;
-	uint16 nb;
+	int16_t* m;
+	int16_t* na;
+	uint16_t nb;
 	int o;
 	if (dir==NULL)
 	{
 		(*ndir)++;
 		return(1);
 	}
-	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int16));
+	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int16_t));
 	if (m==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -1378,7 +1423,7 @@ TIFFWriteDirectoryTagSshortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 #endif
 
 static int
-TIFFWriteDirectoryTagLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)
+TIFFWriteDirectoryTagLong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t value)
 {
 	if (dir==NULL)
 	{
@@ -1389,7 +1434,7 @@ TIFFWriteDirectoryTagLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag
 }
 
 static int
-TIFFWriteDirectoryTagLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)
+TIFFWriteDirectoryTagLongArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint32_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1401,19 +1446,19 @@ TIFFWriteDirectoryTagLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint1
 
 #if 0
 static int
-TIFFWriteDirectoryTagLongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)
+TIFFWriteDirectoryTagLongPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagLongPerSample";
-	uint32* m;
-	uint32* na;
-	uint16 nb;
+	uint32_t* m;
+	uint32_t* na;
+	uint16_t nb;
 	int o;
 	if (dir==NULL)
 	{
 		(*ndir)++;
 		return(1);
 	}
-	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint32));
+	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint32_t));
 	if (m==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -1429,7 +1474,7 @@ TIFFWriteDirectoryTagLongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, u
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)
+TIFFWriteDirectoryTagSlong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int32_t value)
 {
 	if (dir==NULL)
 	{
@@ -1441,7 +1486,7 @@ TIFFWriteDirectoryTagSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 ta
 #endif
 
 static int
-TIFFWriteDirectoryTagSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value)
+TIFFWriteDirectoryTagSlongArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int32_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1453,19 +1498,19 @@ TIFFWriteDirectoryTagSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint
 
 #if 0
 static int
-TIFFWriteDirectoryTagSlongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)
+TIFFWriteDirectoryTagSlongPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int32_t value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagSlongPerSample";
-	int32* m;
-	int32* na;
-	uint16 nb;
+	int32_t* m;
+	int32_t* na;
+	uint16_t nb;
 	int o;
 	if (dir==NULL)
 	{
 		(*ndir)++;
 		return(1);
 	}
-	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int32));
+	m=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int32_t));
 	if (m==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -1481,7 +1526,7 @@ TIFFWriteDirectoryTagSlongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)
+TIFFWriteDirectoryTagLong8(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint64_t value)
 {
 	if (dir==NULL)
 	{
@@ -1493,7 +1538,7 @@ TIFFWriteDirectoryTagLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 ta
 #endif
 
 static int
-TIFFWriteDirectoryTagLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)
+TIFFWriteDirectoryTagLong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1505,7 +1550,7 @@ TIFFWriteDirectoryTagLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value)
+TIFFWriteDirectoryTagSlong8(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int64_t value)
 {
 	if (dir==NULL)
 	{
@@ -1517,7 +1562,7 @@ TIFFWriteDirectoryTagSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 t
 #endif
 
 static int
-TIFFWriteDirectoryTagSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)
+TIFFWriteDirectoryTagSlong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int64_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1528,7 +1573,7 @@ TIFFWriteDirectoryTagSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uin
 }
 
 static int
-TIFFWriteDirectoryTagRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
+TIFFWriteDirectoryTagRational(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value)
 {
 	if (dir==NULL)
 	{
@@ -1539,7 +1584,7 @@ TIFFWriteDirectoryTagRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16
 }
 
 static int
-TIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)
+TIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value)
 {
 	if (dir==NULL)
 	{
@@ -1550,7 +1595,7 @@ TIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, u
 }
 
 static int
-TIFFWriteDirectoryTagSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)
+TIFFWriteDirectoryTagSrationalArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value)
 {
 	if (dir==NULL)
 	{
@@ -1560,8 +1605,31 @@ TIFFWriteDirectoryTagSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 	return(TIFFWriteDirectoryTagCheckedSrationalArray(tif,ndir,dir,tag,count,value));
 }
 
+/*-- Rational2Double: additional write functions */
+static int
+TIFFWriteDirectoryTagRationalDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value)
+{
+	if (dir==NULL)
+	{
+		(*ndir)++;
+		return(1);
+	}
+	return(TIFFWriteDirectoryTagCheckedRationalDoubleArray(tif,ndir,dir,tag,count,value));
+}
+
+static int
+TIFFWriteDirectoryTagSrationalDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value)
+{
+	if (dir==NULL)
+	{
+		(*ndir)++;
+		return(1);
+	}
+	return(TIFFWriteDirectoryTagCheckedSrationalDoubleArray(tif,ndir,dir,tag,count,value));
+}
+
 #ifdef notdef
-static int TIFFWriteDirectoryTagFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)
+static int TIFFWriteDirectoryTagFloat(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, float value)
 {
 	if (dir==NULL)
 	{
@@ -1572,7 +1640,7 @@ static int TIFFWriteDirectoryTagFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir
 }
 #endif
 
-static int TIFFWriteDirectoryTagFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)
+static int TIFFWriteDirectoryTagFloatArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value)
 {
 	if (dir==NULL)
 	{
@@ -1583,12 +1651,12 @@ static int TIFFWriteDirectoryTagFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry
 }
 
 #if 0
-static int TIFFWriteDirectoryTagFloatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)
+static int TIFFWriteDirectoryTagFloatPerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, float value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagFloatPerSample";
 	float* m;
 	float* na;
-	uint16 nb;
+	uint16_t nb;
 	int o;
 	if (dir==NULL)
 	{
@@ -1610,7 +1678,7 @@ static int TIFFWriteDirectoryTagFloatPerSample(TIFF* tif, uint32* ndir, TIFFDirE
 #endif
 
 #ifdef notdef
-static int TIFFWriteDirectoryTagDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
+static int TIFFWriteDirectoryTagDouble(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value)
 {
 	if (dir==NULL)
 	{
@@ -1621,7 +1689,7 @@ static int TIFFWriteDirectoryTagDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 }
 #endif
 
-static int TIFFWriteDirectoryTagDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)
+static int TIFFWriteDirectoryTagDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value)
 {
 	if (dir==NULL)
 	{
@@ -1632,12 +1700,12 @@ static int TIFFWriteDirectoryTagDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntr
 }
 
 #if 0
-static int TIFFWriteDirectoryTagDoublePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
+static int TIFFWriteDirectoryTagDoublePerSample(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagDoublePerSample";
 	double* m;
 	double* na;
-	uint16 nb;
+	uint16_t nb;
 	int o;
 	if (dir==NULL)
 	{
@@ -1659,7 +1727,7 @@ static int TIFFWriteDirectoryTagDoublePerSample(TIFF* tif, uint32* ndir, TIFFDir
 #endif
 
 static int
-TIFFWriteDirectoryTagIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)
+TIFFWriteDirectoryTagIfdArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint32_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1671,7 +1739,7 @@ TIFFWriteDirectoryTagIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)
+TIFFWriteDirectoryTagIfd8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value)
 {
 	if (dir==NULL)
 	{
@@ -1683,7 +1751,7 @@ TIFFWriteDirectoryTagIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint1
 #endif
 
 static int
-TIFFWriteDirectoryTagShortLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)
+TIFFWriteDirectoryTagShortLong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t value)
 {
 	if (dir==NULL)
 	{
@@ -1691,14 +1759,14 @@ TIFFWriteDirectoryTagShortLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint1
 		return(1);
 	}
 	if (value<=0xFFFF)
-		return(TIFFWriteDirectoryTagCheckedShort(tif,ndir,dir,tag,(uint16)value));
+		return(TIFFWriteDirectoryTagCheckedShort(tif,ndir,dir,tag,(uint16_t)value));
 	else
 		return(TIFFWriteDirectoryTagCheckedLong(tif,ndir,dir,tag,value));
 }
 
-static int _WriteAsType(TIFF* tif, uint64 strile_size, uint64 uncompressed_threshold)
+static int _WriteAsType(TIFF* tif, uint64_t strile_size, uint64_t uncompressed_threshold)
 {
-    const uint16 compression = tif->tif_dir.td_compression;
+    const uint16_t compression = tif->tif_dir.td_compression;
     if ( compression == COMPRESSION_NONE )
     {
         return strile_size > uncompressed_threshold;
@@ -1719,12 +1787,12 @@ static int _WriteAsType(TIFF* tif, uint64 strile_size, uint64 uncompressed_thres
     return 1;
 }
 
-static int WriteAsLong8(TIFF* tif, uint64 strile_size)
+static int WriteAsLong8(TIFF* tif, uint64_t strile_size)
 {
     return _WriteAsType(tif, strile_size, 0xFFFFFFFFU);
 }
 
-static int WriteAsLong4(TIFF* tif, uint64 strile_size)
+static int WriteAsLong4(TIFF* tif, uint64_t strile_size)
 {
     return _WriteAsType(tif, strile_size, 0xFFFFU);
 }
@@ -1737,7 +1805,7 @@ static int WriteAsLong4(TIFF* tif, uint64 strile_size)
 /************************************************************************/
 
 static int
-TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)
+TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value)
 {
     static const char module[] = "TIFFWriteDirectoryTagLongLong8Array";
     int o;
@@ -1794,10 +1862,10 @@ TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
         ** and convert to long format.
         */
 
-        uint32* p = _TIFFmalloc(count*sizeof(uint32));
-        uint32* q;
-        uint64* ma;
-        uint32 mb;
+        uint32_t* p = _TIFFmalloc(count * sizeof(uint32_t));
+        uint32_t* q;
+        uint64_t* ma;
+        uint32_t mb;
 
         if (p==NULL)
         {
@@ -1814,7 +1882,7 @@ TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
                 _TIFFfree(p);
                 return(0);
             }
-            *q= (uint32)(*ma);
+            *q= (uint32_t)(*ma);
         }
 
         o=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p);
@@ -1822,10 +1890,10 @@ TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
     }
     else
     {
-        uint16* p = _TIFFmalloc(count*sizeof(uint16));
-        uint16* q;
-        uint64* ma;
-        uint32 mb;
+        uint16_t* p = _TIFFmalloc(count * sizeof(uint16_t));
+        uint16_t* q;
+        uint64_t* ma;
+        uint32_t mb;
 
         if (p==NULL)
         {
@@ -1843,7 +1911,7 @@ TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
                 _TIFFfree(p);
                 return(0);
             }
-            *q= (uint16)(*ma);
+            *q= (uint16_t)(*ma);
         }
 
         o=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,count,p);
@@ -1860,13 +1928,13 @@ TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 /************************************************************************/
 
 static int
-TIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)
+TIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value)
 {
     static const char module[] = "TIFFWriteDirectoryTagIfdIfd8Array";
-    uint64* ma;
-    uint32 mb;
-    uint32* p;
-    uint32* q;
+    uint64_t* ma;
+    uint32_t mb;
+    uint32_t* p;
+    uint32_t* q;
     int o;
 
     /* is this just a counting pass? */
@@ -1886,7 +1954,7 @@ TIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, ui
     ** and convert to long format.
     */
 
-    p = _TIFFmalloc(count*sizeof(uint32));
+    p = _TIFFmalloc(count*sizeof(uint32_t));
     if (p==NULL)
     {
         TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -1902,7 +1970,7 @@ TIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, ui
             _TIFFfree(p);
             return(0);
         }
-        *q= (uint32)(*ma);
+        *q= (uint32_t)(*ma);
     }
 
     o=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,tag,count,p);
@@ -1913,12 +1981,12 @@ TIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, ui
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)
+TIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagShortLongLong8Array";
-	uint64* ma;
-	uint32 mb;
-	uint8 n;
+	uint64_t* ma;
+	uint32_t mb;
+	uint8_t n;
 	int o;
 	if (dir==NULL)
 	{
@@ -1938,31 +2006,31 @@ TIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry*
 	}
 	if (n==0)
 	{
-		uint16* p;
-		uint16* q;
-		p=_TIFFmalloc(count*sizeof(uint16));
+		uint16_t* p;
+		uint16_t* q;
+		p=_TIFFmalloc(count*sizeof(uint16_t));
 		if (p==NULL)
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 			return(0);
 		}
 		for (ma=value, mb=0, q=p; mb<count; ma++, mb++, q++)
-			*q=(uint16)(*ma);
+			*q=(uint16_t)(*ma);
 		o=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,count,p);
 		_TIFFfree(p);
 	}
 	else if (n==1)
 	{
-		uint32* p;
-		uint32* q;
-		p=_TIFFmalloc(count*sizeof(uint32));
+		uint32_t* p;
+		uint32_t* q;
+		p=_TIFFmalloc(count*sizeof(uint32_t));
 		if (p==NULL)
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 			return(0);
 		}
 		for (ma=value, mb=0, q=p; mb<count; ma++, mb++, q++)
-			*q=(uint32)(*ma);
+			*q=(uint32_t)(*ma);
 		o=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p);
 		_TIFFfree(p);
 	}
@@ -1975,11 +2043,11 @@ TIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry*
 }
 #endif
 static int
-TIFFWriteDirectoryTagColormap(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)
+TIFFWriteDirectoryTagColormap(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir)
 {
 	static const char module[] = "TIFFWriteDirectoryTagColormap";
-	uint32 m;
-	uint16* n;
+	uint32_t m;
+	uint16_t* n;
 	int o;
 	if (dir==NULL)
 	{
@@ -1987,27 +2055,27 @@ TIFFWriteDirectoryTagColormap(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)
 		return(1);
 	}
 	m=(1<<tif->tif_dir.td_bitspersample);
-	n=_TIFFmalloc(3*m*sizeof(uint16));
+	n=_TIFFmalloc(3*m*sizeof(uint16_t));
 	if (n==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 		return(0);
 	}
-	_TIFFmemcpy(&n[0],tif->tif_dir.td_colormap[0],m*sizeof(uint16));
-	_TIFFmemcpy(&n[m],tif->tif_dir.td_colormap[1],m*sizeof(uint16));
-	_TIFFmemcpy(&n[2*m],tif->tif_dir.td_colormap[2],m*sizeof(uint16));
+	_TIFFmemcpy(&n[0],tif->tif_dir.td_colormap[0],m*sizeof(uint16_t));
+	_TIFFmemcpy(&n[m],tif->tif_dir.td_colormap[1],m*sizeof(uint16_t));
+	_TIFFmemcpy(&n[2*m],tif->tif_dir.td_colormap[2],m*sizeof(uint16_t));
 	o=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,TIFFTAG_COLORMAP,3*m,n);
 	_TIFFfree(n);
 	return(o);
 }
 
 static int
-TIFFWriteDirectoryTagTransferfunction(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)
+TIFFWriteDirectoryTagTransferfunction(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir)
 {
 	static const char module[] = "TIFFWriteDirectoryTagTransferfunction";
-	uint32 m;
-	uint16 n;
-	uint16* o;
+	uint32_t m;
+	uint16_t n;
+	uint16_t* o;
 	int p;
 	if (dir==NULL)
 	{
@@ -2027,38 +2095,38 @@ TIFFWriteDirectoryTagTransferfunction(TIFF* tif, uint32* ndir, TIFFDirEntry* dir
 	if (n==3)
 	{
 		if (tif->tif_dir.td_transferfunction[2] == NULL ||
-		    !_TIFFmemcmp(tif->tif_dir.td_transferfunction[0],tif->tif_dir.td_transferfunction[2],m*sizeof(uint16)))
+		    !_TIFFmemcmp(tif->tif_dir.td_transferfunction[0],tif->tif_dir.td_transferfunction[2],m*sizeof(uint16_t)))
 			n=2;
 	}
 	if (n==2)
 	{
 		if (tif->tif_dir.td_transferfunction[1] == NULL ||
-		    !_TIFFmemcmp(tif->tif_dir.td_transferfunction[0],tif->tif_dir.td_transferfunction[1],m*sizeof(uint16)))
+		    !_TIFFmemcmp(tif->tif_dir.td_transferfunction[0],tif->tif_dir.td_transferfunction[1],m*sizeof(uint16_t)))
 			n=1;
 	}
 	if (n==0)
 		n=1;
-	o=_TIFFmalloc(n*m*sizeof(uint16));
+	o=_TIFFmalloc(n*m*sizeof(uint16_t));
 	if (o==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 		return(0);
 	}
-	_TIFFmemcpy(&o[0],tif->tif_dir.td_transferfunction[0],m*sizeof(uint16));
+	_TIFFmemcpy(&o[0],tif->tif_dir.td_transferfunction[0],m*sizeof(uint16_t));
 	if (n>1)
-		_TIFFmemcpy(&o[m],tif->tif_dir.td_transferfunction[1],m*sizeof(uint16));
+		_TIFFmemcpy(&o[m],tif->tif_dir.td_transferfunction[1],m*sizeof(uint16_t));
 	if (n>2)
-		_TIFFmemcpy(&o[2*m],tif->tif_dir.td_transferfunction[2],m*sizeof(uint16));
+		_TIFFmemcpy(&o[2*m],tif->tif_dir.td_transferfunction[2],m*sizeof(uint16_t));
 	p=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,TIFFTAG_TRANSFERFUNCTION,n*m,o);
 	_TIFFfree(o);
 	return(p);
 }
 
 static int
-TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)
+TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir)
 {
 	static const char module[] = "TIFFWriteDirectoryTagSubifd";
-	uint64 m;
+	uint64_t m;
 	int n;
 	if (tif->tif_dir.td_nsubifd==0)
 		return(1);
@@ -2070,11 +2138,11 @@ TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)
 	m=tif->tif_dataoff;
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
-		uint32* o;
-		uint64* pa;
-		uint32* pb;
-		uint16 p;
-		o=_TIFFmalloc(tif->tif_dir.td_nsubifd*sizeof(uint32));
+		uint32_t* o;
+		uint64_t* pa;
+		uint32_t* pb;
+		uint16_t p;
+		o=_TIFFmalloc(tif->tif_dir.td_nsubifd*sizeof(uint32_t));
 		if (o==NULL)
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -2093,7 +2161,7 @@ TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)
                             _TIFFfree(o);
                             return(0);
                         }
-			*pb++=(uint32)(*pa++);
+			*pb++=(uint32_t)(*pa++);
 		}
 		n=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,o);
 		_TIFFfree(o);
@@ -2120,56 +2188,56 @@ TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)
 }
 
 static int
-TIFFWriteDirectoryTagCheckedAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)
+TIFFWriteDirectoryTagCheckedAscii(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, char* value)
 {
 	assert(sizeof(char)==1);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_ASCII,count,count,value));
 }
 
 static int
-TIFFWriteDirectoryTagCheckedUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)
+TIFFWriteDirectoryTagCheckedUndefinedArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint8_t* value)
 {
-	assert(sizeof(uint8)==1);
+	assert(sizeof(uint8_t) == 1);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_UNDEFINED,count,count,value));
 }
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagCheckedByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)
+TIFFWriteDirectoryTagCheckedByte(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint8_t value)
 {
-	assert(sizeof(uint8)==1);
+	assert(sizeof(uint8_t)==1);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_BYTE,1,1,&value));
 }
 #endif
 
 static int
-TIFFWriteDirectoryTagCheckedByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)
+TIFFWriteDirectoryTagCheckedByteArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint8_t* value)
 {
-	assert(sizeof(uint8)==1);
+	assert(sizeof(uint8_t) == 1);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_BYTE,count,count,value));
 }
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagCheckedSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)
+TIFFWriteDirectoryTagCheckedSbyte(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int8_t value)
 {
-	assert(sizeof(int8)==1);
+	assert(sizeof(int8_t)==1);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SBYTE,1,1,&value));
 }
 #endif
 
 static int
-TIFFWriteDirectoryTagCheckedSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value)
+TIFFWriteDirectoryTagCheckedSbyteArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int8_t* value)
 {
-	assert(sizeof(int8)==1);
+	assert(sizeof(int8_t) == 1);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SBYTE,count,count,value));
 }
 
 static int
-TIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)
+TIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint16_t value)
 {
-	uint16 m;
-	assert(sizeof(uint16)==2);
+	uint16_t m;
+	assert(sizeof(uint16_t) == 2);
 	m=value;
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabShort(&m);
@@ -2177,10 +2245,10 @@ TIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, ui
 }
 
 static int
-TIFFWriteDirectoryTagCheckedShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)
+TIFFWriteDirectoryTagCheckedShortArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint16_t* value)
 {
 	assert(count<0x80000000);
-	assert(sizeof(uint16)==2);
+	assert(sizeof(uint16_t) == 2);
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabArrayOfShort(value,count);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SHORT,count,count*2,value));
@@ -2188,32 +2256,32 @@ TIFFWriteDirectoryTagCheckedShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagCheckedSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)
+TIFFWriteDirectoryTagCheckedSshort(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int16_t value)
 {
-	int16 m;
-	assert(sizeof(int16)==2);
+	int16_t m;
+	assert(sizeof(int16_t)==2);
 	m=value;
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabShort((uint16*)(&m));
+		TIFFSwabShort((uint16_t*)(&m));
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SSHORT,1,2,&m));
 }
 #endif
 
 static int
-TIFFWriteDirectoryTagCheckedSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value)
+TIFFWriteDirectoryTagCheckedSshortArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int16_t* value)
 {
 	assert(count<0x80000000);
-	assert(sizeof(int16)==2);
+	assert(sizeof(int16_t) == 2);
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabArrayOfShort((uint16*)value,count);
+		TIFFSwabArrayOfShort((uint16_t*)value, count);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SSHORT,count,count*2,value));
 }
 
 static int
-TIFFWriteDirectoryTagCheckedLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)
+TIFFWriteDirectoryTagCheckedLong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t value)
 {
-	uint32 m;
-	assert(sizeof(uint32)==4);
+	uint32_t m;
+	assert(sizeof(uint32_t) == 4);
 	m=value;
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabLong(&m);
@@ -2221,10 +2289,10 @@ TIFFWriteDirectoryTagCheckedLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uin
 }
 
 static int
-TIFFWriteDirectoryTagCheckedLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)
+TIFFWriteDirectoryTagCheckedLongArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint32_t* value)
 {
 	assert(count<0x40000000);
-	assert(sizeof(uint32)==4);
+	assert(sizeof(uint32_t) == 4);
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabArrayOfLong(value,count);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG,count,count*4,value));
@@ -2232,33 +2300,33 @@ TIFFWriteDirectoryTagCheckedLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagCheckedSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)
+TIFFWriteDirectoryTagCheckedSlong(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int32_t value)
 {
-	int32 m;
-	assert(sizeof(int32)==4);
+	int32_t m;
+	assert(sizeof(int32_t)==4);
 	m=value;
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabLong((uint32*)(&m));
+		TIFFSwabLong((uint32_t*)(&m));
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG,1,4,&m));
 }
 #endif
 
 static int
-TIFFWriteDirectoryTagCheckedSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value)
+TIFFWriteDirectoryTagCheckedSlongArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int32_t* value)
 {
 	assert(count<0x40000000);
-	assert(sizeof(int32)==4);
+	assert(sizeof(int32_t) == 4);
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabArrayOfLong((uint32*)value,count);
+		TIFFSwabArrayOfLong((uint32_t*)value, count);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG,count,count*4,value));
 }
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)
+TIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint64_t value)
 {
-	uint64 m;
-	assert(sizeof(uint64)==8);
+	uint64_t m;
+	assert(sizeof(uint64_t)==8);
 	if( !(tif->tif_flags&TIFF_BIGTIFF) ) {
 		TIFFErrorExt(tif->tif_clientdata,"TIFFWriteDirectoryTagCheckedLong8","LONG8 not allowed for ClassicTIFF");
 		return(0);
@@ -2271,10 +2339,10 @@ TIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, ui
 #endif
 
 static int
-TIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)
+TIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value)
 {
 	assert(count<0x20000000);
-	assert(sizeof(uint64)==8);
+	assert(sizeof(uint64_t) == 8);
 	if( !(tif->tif_flags&TIFF_BIGTIFF) ) {
 		TIFFErrorExt(tif->tif_clientdata,"TIFFWriteDirectoryTagCheckedLong8Array","LONG8 not allowed for ClassicTIFF");
 		return(0);
@@ -2286,71 +2354,81 @@ TIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagCheckedSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value)
+TIFFWriteDirectoryTagCheckedSlong8(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, int64_t value)
 {
-	int64 m;
-	assert(sizeof(int64)==8);
+	int64_t m;
+	assert(sizeof(int64_t)==8);
 	if( !(tif->tif_flags&TIFF_BIGTIFF) ) {
 		TIFFErrorExt(tif->tif_clientdata,"TIFFWriteDirectoryTagCheckedSlong8","SLONG8 not allowed for ClassicTIFF");
 		return(0);
 	}
 	m=value;
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabLong8((uint64*)(&m));
+		TIFFSwabLong8((uint64_t*)(&m));
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG8,1,8,&m));
 }
 #endif
 
 static int
-TIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)
+TIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, int64_t* value)
 {
 	assert(count<0x20000000);
-	assert(sizeof(int64)==8);
+	assert(sizeof(int64_t) == 8);
 	if( !(tif->tif_flags&TIFF_BIGTIFF) ) {
 		TIFFErrorExt(tif->tif_clientdata,"TIFFWriteDirectoryTagCheckedSlong8Array","SLONG8 not allowed for ClassicTIFF");
 		return(0);
 	}
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabArrayOfLong8((uint64*)value,count);
+		TIFFSwabArrayOfLong8((uint64_t*)value, count);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG8,count,count*8,value));
 }
 
 static int
-TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
+TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value)
 {
-        static const char module[] = "TIFFWriteDirectoryTagCheckedRational";
-	uint32 m[2];
-	assert(sizeof(uint32)==4);
-        if( value < 0 )
-        {
-            TIFFErrorExt(tif->tif_clientdata,module,"Negative value is illegal");
-            return 0;
-        }
-        else if( value != value )
-        {
-            TIFFErrorExt(tif->tif_clientdata,module,"Not-a-number value is illegal");
-            return 0;
-        }
+	static const char module[] = "TIFFWriteDirectoryTagCheckedRational";
+	uint32_t m[2];
+	assert(sizeof(uint32_t) == 4);
+	if (value < 0) 
+	{
+		TIFFErrorExt(tif->tif_clientdata, module, "Negative value is illegal");
+		return 0;
+	} 
+	else if (value != value) 
+	{
+		TIFFErrorExt(tif->tif_clientdata, module, "Not-a-number value is illegal");
+		return 0;
+	}
+#ifdef not_def
 	else if (value==0.0)
 	{
 		m[0]=0;
 		m[1]=1;
 	}
-	else if (value <= 0xFFFFFFFFU && value==(double)(uint32)value)
+	else if (value <= 0xFFFFFFFFU && value==(double)(uint32_t)value)
 	{
-		m[0]=(uint32)value;
+		m[0]=(uint32_t)value;
 		m[1]=1;
 	}
 	else if (value<1.0)
 	{
-		m[0]=(uint32)(value*0xFFFFFFFF);
+		m[0]=(uint32_t)(value*0xFFFFFFFF);
 		m[1]=0xFFFFFFFF;
 	}
 	else
 	{
 		m[0]=0xFFFFFFFF;
-		m[1]=(uint32)(0xFFFFFFFF/value);
+		m[1]=(uint32_t)(0xFFFFFFFF/value);
+	}
+#else
+	/*--Rational2Double: New function also used for non-custom rational tags. 
+	 *  However, could be omitted here, because TIFFWriteDirectoryTagCheckedRational() is not used by code for custom tags,
+	 *  only by code for named-tiff-tags like FIELD_RESOLUTION and FIELD_POSITION */
+	else {
+	DoubleToRational(value, &m[0], &m[1]);
 	}
+#endif
+
 	if (tif->tif_flags&TIFF_SWAB)
 	{
 		TIFFSwabLong(&m[0]);
@@ -2360,16 +2438,16 @@ TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 }
 
 static int
-TIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)
+TIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagCheckedRationalArray";
-	uint32* m;
+	uint32_t* m;
 	float* na;
-	uint32* nb;
-	uint32 nc;
+	uint32_t* nb;
+	uint32_t nc;
 	int o;
-	assert(sizeof(uint32)==4);
-	m=_TIFFmalloc(count*2*sizeof(uint32));
+	assert(sizeof(uint32_t) == 4);
+	m=_TIFFmalloc(count*2*sizeof(uint32_t));
 	if (m==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -2377,27 +2455,32 @@ TIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry*
 	}
 	for (na=value, nb=m, nc=0; nc<count; na++, nb+=2, nc++)
 	{
+#ifdef not_def
 		if (*na<=0.0 || *na != *na)
 		{
 			nb[0]=0;
 			nb[1]=1;
 		}
 		else if (*na >= 0 && *na <= (float)0xFFFFFFFFU &&
-                         *na==(float)(uint32)(*na))
+                         *na==(float)(uint32_t)(*na))
 		{
-			nb[0]=(uint32)(*na);
+			nb[0]=(uint32_t)(*na);
 			nb[1]=1;
 		}
 		else if (*na<1.0)
 		{
-			nb[0]=(uint32)((double)(*na)*0xFFFFFFFF);
+			nb[0]=(uint32_t)((double)(*na)*0xFFFFFFFF);
 			nb[1]=0xFFFFFFFF;
 		}
 		else
 		{
 			nb[0]=0xFFFFFFFF;
-			nb[1]=(uint32)((double)0xFFFFFFFF/(*na));
+			nb[1]=(uint32_t)((double)0xFFFFFFFF/(*na));
 		}
+#else
+		/*-- Rational2Double: Also for float precision accuracy is sometimes enhanced --*/
+		DoubleToRational(*na, &nb[0], &nb[1]);
+#endif
 	}
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabArrayOfLong(m,count*2);
@@ -2407,16 +2490,16 @@ TIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry*
 }
 
 static int
-TIFFWriteDirectoryTagCheckedSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)
+TIFFWriteDirectoryTagCheckedSrationalArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value)
 {
 	static const char module[] = "TIFFWriteDirectoryTagCheckedSrationalArray";
-	int32* m;
+	int32_t* m;
 	float* na;
-	int32* nb;
-	uint32 nc;
+	int32_t* nb;
+	uint32_t nc;
 	int o;
-	assert(sizeof(int32)==4);
-	m=_TIFFmalloc(count*2*sizeof(int32));
+	assert(sizeof(int32_t) == 4);
+	m=_TIFFmalloc(count*2*sizeof(int32_t));
 	if (m==NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
@@ -2424,53 +2507,442 @@ TIFFWriteDirectoryTagCheckedSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry
 	}
 	for (na=value, nb=m, nc=0; nc<count; na++, nb+=2, nc++)
 	{
+#ifdef not_def
 		if (*na<0.0)
 		{
-			if (*na==(int32)(*na))
+			if (*na==(int32_t)(*na))
 			{
-				nb[0]=(int32)(*na);
+				nb[0]=(int32_t)(*na);
 				nb[1]=1;
 			}
 			else if (*na>-1.0)
 			{
-				nb[0]=-(int32)((double)(-*na)*0x7FFFFFFF);
+				nb[0]=-(int32_t)((double)(-*na)*0x7FFFFFFF);
 				nb[1]=0x7FFFFFFF;
 			}
 			else
 			{
 				nb[0]=-0x7FFFFFFF;
-				nb[1]=(int32)((double)0x7FFFFFFF/(-*na));
+				nb[1]=(int32_t)((double)0x7FFFFFFF/(-*na));
 			}
 		}
 		else
 		{
-			if (*na==(int32)(*na))
+			if (*na==(int32_t)(*na))
 			{
-				nb[0]=(int32)(*na);
+				nb[0]=(int32_t)(*na);
 				nb[1]=1;
 			}
 			else if (*na<1.0)
 			{
-				nb[0]=(int32)((double)(*na)*0x7FFFFFFF);
+				nb[0]=(int32_t)((double)(*na)*0x7FFFFFFF);
 				nb[1]=0x7FFFFFFF;
 			}
 			else
 			{
 				nb[0]=0x7FFFFFFF;
-				nb[1]=(int32)((double)0x7FFFFFFF/(*na));
+				nb[1]=(int32_t)((double)0x7FFFFFFF/(*na));
 			}
 		}
+#else
+		/*-- Rational2Double: Also for float precision accuracy is sometimes enhanced --*/
+		DoubleToSrational(*na, &nb[0], &nb[1]);
+#endif
 	}
 	if (tif->tif_flags&TIFF_SWAB)
-		TIFFSwabArrayOfLong((uint32*)m,count*2);
+		TIFFSwabArrayOfLong((uint32_t*)m, count * 2);
 	o=TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SRATIONAL,count,count*8,&m[0]);
 	_TIFFfree(m);
 	return(o);
 }
 
+/*-- Rational2Double: additional write functions for double arrays */
+static int
+TIFFWriteDirectoryTagCheckedRationalDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value)
+{
+	static const char module[] = "TIFFWriteDirectoryTagCheckedRationalDoubleArray";
+	uint32_t* m;
+	double* na;
+	uint32_t* nb;
+	uint32_t nc;
+	int o;
+	assert(sizeof(uint32_t) == 4);
+	m=_TIFFmalloc(count*2*sizeof(uint32_t));
+	if (m==NULL)
+	{
+		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
+		return(0);
+	}
+	for (na=value, nb=m, nc=0; nc<count; na++, nb+=2, nc++)
+	{
+		DoubleToRational(*na, &nb[0], &nb[1]);
+	}
+	if (tif->tif_flags&TIFF_SWAB)
+		TIFFSwabArrayOfLong(m,count*2);
+	o=TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,count,count*8,&m[0]);
+	_TIFFfree(m);
+	return(o);
+} /*-- TIFFWriteDirectoryTagCheckedRationalDoubleArray() ------- */
+
+static int
+TIFFWriteDirectoryTagCheckedSrationalDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value)
+{
+	static const char module[] = "TIFFWriteDirectoryTagCheckedSrationalDoubleArray";
+	int32_t* m;
+	double* na;
+	int32_t* nb;
+	uint32_t nc;
+	int o;
+	assert(sizeof(int32_t) == 4);
+	m=_TIFFmalloc(count*2*sizeof(int32_t));
+	if (m==NULL)
+	{
+		TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
+		return(0);
+	}
+	for (na=value, nb=m, nc=0; nc<count; na++, nb+=2, nc++)
+	{
+		DoubleToSrational(*na, &nb[0], &nb[1]);
+	}
+	if (tif->tif_flags&TIFF_SWAB)
+		TIFFSwabArrayOfLong((uint32_t*)m, count * 2);
+	o=TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SRATIONAL,count,count*8,&m[0]);
+	_TIFFfree(m);
+	return(o);
+} /*--- TIFFWriteDirectoryTagCheckedSrationalDoubleArray() -------- */
+
+#if 0
+static
+void DoubleToRational_direct(double value, unsigned long *num, unsigned long *denom)
+{
+	/*--- OLD Code for debugging and comparison  ---- */
+	/* code merged from TIFFWriteDirectoryTagCheckedRationalArray() and TIFFWriteDirectoryTagCheckedRational() */
+
+	/* First check for zero and also check for negative numbers (which are illegal for RATIONAL) 
+	 * and also check for "not-a-number". In each case just set this to zero to support also rational-arrays.
+	  */
+	if (value<=0.0 || value != value)
+	{
+		*num=0;
+		*denom=1;
+	}
+	else if (value <= 0xFFFFFFFFU &&  (value==(double)(uint32_t)(value)))	/* check for integer values */
+	{
+		*num=(uint32_t)(value);
+		*denom=1;
+	}
+	else if (value<1.0)
+	{
+		*num = (uint32_t)((value) * (double)0xFFFFFFFFU);
+		*denom=0xFFFFFFFFU;
+	}
+	else
+	{
+		*num=0xFFFFFFFFU;
+		*denom=(uint32_t)((double)0xFFFFFFFFU/(value));
+	}
+}  /*-- DoubleToRational_direct() -------------- */
+#endif
+
+#if 0
+static
+void DoubleToSrational_direct(double value,  long *num,  long *denom)
+{
+	/*--- OLD Code for debugging and comparison -- SIGNED-version ----*/
+	/*  code was amended from original TIFFWriteDirectoryTagCheckedSrationalArray() */
+
+	/* First check for zero and also check for negative numbers (which are illegal for RATIONAL)
+	 * and also check for "not-a-number". In each case just set this to zero to support also rational-arrays.
+	  */
+	if (value<0.0)
+		{
+			if (value==(int32_t)(value))
+			{
+				*num=(int32_t)(value);
+				*denom=1;
+			}
+			else if (value>-1.0)
+			{
+				*num=-(int32_t)((-value) * (double)0x7FFFFFFF);
+				*denom=0x7FFFFFFF;
+			}
+			else
+			{
+				*num=-0x7FFFFFFF;
+				*denom=(int32_t)((double)0x7FFFFFFF / (-value));
+			}
+		}
+		else
+		{
+			if (value==(int32_t)(value))
+			{
+				*num=(int32_t)(value);
+				*denom=1;
+			}
+			else if (value<1.0)
+			{
+				*num=(int32_t)((value)  *(double)0x7FFFFFFF);
+				*denom=0x7FFFFFFF;
+			}
+			else
+			{
+				*num=0x7FFFFFFF;
+				*denom=(int32_t)((double)0x7FFFFFFF / (value));
+			}
+		}
+}  /*-- DoubleToSrational_direct() --------------*/
+#endif
+
+//#define DOUBLE2RAT_DEBUGOUTPUT
+/** -----  Rational2Double: Double To Rational Conversion ----------------------------------------------------------
+* There is a mathematical theorem to convert real numbers into a rational (integer fraction) number.
+* This is called "continuous fraction" which uses the Euclidean algorithm to find the greatest common divisor (GCD).
+*  (ref. e.g. https://de.wikipedia.org/wiki/Kettenbruch or https://en.wikipedia.org/wiki/Continued_fraction
+*             https://en.wikipedia.org/wiki/Euclidean_algorithm)
+* The following functions implement the
+* - ToRationalEuclideanGCD()		auxiliary function which mainly implements euclidean GCD
+* - DoubleToRational()			conversion function for un-signed rationals
+* - DoubleToSrational()			conversion function for signed rationals
+------------------------------------------------------------------------------------------------------------------*/
+
+/**---- ToRationalEuclideanGCD() -----------------------------------------
+* Calculates the rational fractional of a double input value
+* using the Euclidean algorithm to find the greatest common divisor (GCD)
+------------------------------------------------------------------------*/
+static
+void ToRationalEuclideanGCD(double value, int blnUseSignedRange, int blnUseSmallRange, uint64_t *ullNum, uint64_t *ullDenom)
+{
+	/* Internally, the integer variables can be bigger than the external ones,
+	* as long as the result will fit into the external variable size.
+	*/
+	uint64_t numSum[3] = { 0, 1, 0 }, denomSum[3] = { 1, 0, 0 };
+	uint64_t aux, bigNum, bigDenom;
+	uint64_t returnLimit;
+	int i;
+	uint64_t nMax;
+	double fMax;
+	unsigned long maxDenom;
+	/*-- nMax and fMax defines the initial accuracy of the starting fractional,
+	*   or better, the highest used integer numbers used within the starting fractional (bigNum/bigDenom).
+	*   There are two approaches, which can accidentally lead to different accuracies just depending on the value.
+	*   Therefore, blnUseSmallRange steers this behavior.
+	*   For long long nMax = ((9223372036854775807-1)/2); for long nMax = ((2147483647-1)/2);
+	*/
+	if (blnUseSmallRange) {
+		nMax = (uint64_t)((2147483647 - 1) / 2); /* for ULONG range */
+	}
+	else {
+		nMax = ((9223372036854775807 - 1) / 2);				/* for ULLONG range */
+	}
+	fMax = (double)nMax;
+
+	/*-- For the Euclidean GCD define the denominator range, so that it stays within size of unsigned long variables.
+	*   maxDenom should be LONG_MAX for negative values and ULONG_MAX for positive ones.
+	*   Also the final returned value of ullNum and ullDenom is limited according to signed- or unsigned-range.
+	*/
+	if (blnUseSignedRange) {
+		maxDenom = 2147483647UL;  /*LONG_MAX = 0x7FFFFFFFUL*/
+		returnLimit = maxDenom;
+	}
+	else {
+		maxDenom = 0xFFFFFFFFUL;  /*ULONG_MAX = 0xFFFFFFFFUL*/
+		returnLimit = maxDenom;
+	}
+
+	/*-- First generate a rational fraction (bigNum/bigDenom) which represents the value
+	*   as a rational number with the highest accuracy. Therefore, uint64_t (uint64_t) is needed.
+	*   This rational fraction is then reduced using the Euclidean algorithm to find the greatest common divisor (GCD).
+	*   bigNum   = big numinator of value without fraction (or cut residual fraction)
+	*   bigDenom = big denominator of value
+	*-- Break-criteria so that uint64_t cast to "bigNum" introduces no error and bigDenom has no overflow,
+	*   and stop with enlargement of fraction when the double-value of it reaches an integer number without fractional part.
+	*/
+	bigDenom = 1;
+	while ((value != floor(value)) && (value < fMax) && (bigDenom < nMax)) {
+		bigDenom <<= 1;
+		value *= 2;
+	}
+	bigNum = (uint64_t)value;
+
+	/*-- Start Euclidean algorithm to find the greatest common divisor (GCD) -- */
+#define MAX_ITERATIONS 64
+	for (i = 0; i < MAX_ITERATIONS; i++) {
+		uint64_t val;
+		/* if bigDenom is not zero, calculate integer part of fraction. */
+		if (bigDenom == 0) {
+			break;
+		}
+		val = bigNum / bigDenom;
+
+		/* Set bigDenom to reminder of bigNum/bigDenom and bigNum to previous denominator bigDenom. */
+		aux = bigNum;
+		bigNum = bigDenom;
+		bigDenom = aux % bigDenom;
+
+		/* calculate next denominator and check for its given maximum */
+		aux = val;
+		if (denomSum[1] * val + denomSum[0] >= maxDenom) {
+			aux = (maxDenom - denomSum[0]) / denomSum[1];
+			if (aux * 2 >= val || denomSum[1] >= maxDenom)
+				i = (MAX_ITERATIONS + 1);			/* exit but execute rest of for-loop */
+			else
+				break;
+		}
+		/* calculate next numerator to numSum2 and save previous one to numSum0; numSum1 just copy of numSum2. */
+		numSum[2] = aux * numSum[1] + numSum[0];
+		numSum[0] = numSum[1];
+		numSum[1] = numSum[2];
+		/* calculate next denominator to denomSum2 and save previous one to denomSum0; denomSum1 just copy of denomSum2. */
+		denomSum[2] = aux * denomSum[1] + denomSum[0];
+		denomSum[0] = denomSum[1];
+		denomSum[1] = denomSum[2];
+	}
+
+	/*-- Check and adapt for final variable size and return values; reduces internal accuracy; denominator is kept in ULONG-range with maxDenom -- */
+	while (numSum[1] > returnLimit || denomSum[1] > returnLimit) {
+		numSum[1] = numSum[1] / 2;
+		denomSum[1] = denomSum[1] / 2;
+	}
+
+	/* return values */
+	*ullNum = numSum[1];
+	*ullDenom = denomSum[1];
+
+}  /*-- ToRationalEuclideanGCD() -------------- */
+
+
+/**---- DoubleToRational() -----------------------------------------------
+* Calculates the rational fractional of a double input value
+* for UN-SIGNED rationals,
+* using the Euclidean algorithm to find the greatest common divisor (GCD)
+------------------------------------------------------------------------*/
+static
+void DoubleToRational(double value, uint32_t *num, uint32_t *denom)
+{
+	/*---- UN-SIGNED RATIONAL ---- */
+	double dblDiff, dblDiff2;
+	uint64_t ullNum, ullDenom, ullNum2, ullDenom2;
+
+	/*-- Check for negative values. If so it is an error. */
+        /* Test written that way to catch NaN */
+	if (!(value >= 0)) {
+		*num = *denom = 0;
+		TIFFErrorExt(0, "TIFFLib: DoubleToRational()", " Negative Value for Unsigned Rational given.");
+		return;
+	}
+
+	/*-- Check for too big numbers (> ULONG_MAX) -- */
+	if (value > 0xFFFFFFFFUL) {
+		*num = 0xFFFFFFFFU;
+		*denom = 0;
+		return;
+	}
+	/*-- Check for easy integer numbers -- */
+	if (value == (uint32_t)(value)) {
+		*num = (uint32_t)value;
+		*denom = 1;
+		return;
+	}
+	/*-- Check for too small numbers for "unsigned long" type rationals -- */
+	if (value < 1.0 / (double)0xFFFFFFFFUL) {
+		*num = 0;
+		*denom = 0xFFFFFFFFU;
+		return;
+	}
+
+	/*-- There are two approaches using the Euclidean algorithm,
+	*   which can accidentally lead to different accuracies just depending on the value.
+	*   Try both and define which one was better.
+	*/
+	ToRationalEuclideanGCD(value, FALSE, FALSE, &ullNum, &ullDenom);
+	ToRationalEuclideanGCD(value, FALSE, TRUE, &ullNum2, &ullDenom2);
+	/*-- Double-Check, that returned values fit into ULONG :*/
+	if (ullNum > 0xFFFFFFFFUL || ullDenom > 0xFFFFFFFFUL || ullNum2 > 0xFFFFFFFFUL || ullDenom2 > 0xFFFFFFFFUL) {
+		TIFFErrorExt(0, "TIFFLib: DoubleToRational()", " Num or Denom exceeds ULONG: val=%14.6f, num=%12"PRIu64", denom=%12"PRIu64" | num2=%12"PRIu64", denom2=%12"PRIu64"", value, ullNum, ullDenom, ullNum2, ullDenom2);
+		assert(0);
+	}
+
+	/* Check, which one has higher accuracy and take that. */
+	dblDiff = fabs(value - ((double)ullNum / (double)ullDenom));
+	dblDiff2 = fabs(value - ((double)ullNum2 / (double)ullDenom2));
+	if (dblDiff < dblDiff2) {
+		*num = (uint32_t)ullNum;
+		*denom = (uint32_t)ullDenom;
+	}
+	else {
+		*num = (uint32_t)ullNum2;
+		*denom = (uint32_t)ullDenom2;
+	}
+}  /*-- DoubleToRational() -------------- */
+
+/**---- DoubleToSrational() -----------------------------------------------
+* Calculates the rational fractional of a double input value
+* for SIGNED rationals,
+* using the Euclidean algorithm to find the greatest common divisor (GCD)
+------------------------------------------------------------------------*/
+static
+void DoubleToSrational(double value, int32_t *num, int32_t *denom)
+{
+	/*---- SIGNED RATIONAL ----*/
+	int neg = 1;
+	double dblDiff, dblDiff2;
+	uint64_t ullNum, ullDenom, ullNum2, ullDenom2;
+
+	/*-- Check for negative values and use then the positive one for internal calculations, but take the sign into account before returning. */
+	if (value < 0) { neg = -1; value = -value; }
+
+	/*-- Check for too big numbers (> LONG_MAX) -- */
+	if (value > 0x7FFFFFFFL) {
+		*num = 0x7FFFFFFFL;
+		*denom = 0;
+		return;
+	}
+	/*-- Check for easy numbers -- */
+	if (value == (int32_t)(value)) {
+		*num = (int32_t)(neg * value);
+		*denom = 1;
+		return;
+	}
+	/*-- Check for too small numbers for "long" type rationals -- */
+	if (value < 1.0 / (double)0x7FFFFFFFL) {
+		*num = 0;
+		*denom = 0x7FFFFFFFL;
+		return;
+	}
+
+	/*-- There are two approaches using the Euclidean algorithm,
+	*   which can accidentally lead to different accuracies just depending on the value.
+	*   Try both and define which one was better.
+	*   Furthermore, set behavior of ToRationalEuclideanGCD() to the range of signed-long.
+	*/
+	ToRationalEuclideanGCD(value, TRUE, FALSE, &ullNum, &ullDenom);
+	ToRationalEuclideanGCD(value, TRUE, TRUE, &ullNum2, &ullDenom2);
+	/*-- Double-Check, that returned values fit into LONG :*/
+	if (ullNum > 0x7FFFFFFFL || ullDenom > 0x7FFFFFFFL || ullNum2 > 0x7FFFFFFFL || ullDenom2 > 0x7FFFFFFFL) {
+		TIFFErrorExt(0, "TIFFLib: DoubleToSrational()", " Num or Denom exceeds LONG: val=%14.6f, num=%12"PRIu64", denom=%12"PRIu64" | num2=%12"PRIu64", denom2=%12"PRIu64"", neg*value, ullNum, ullDenom, ullNum2, ullDenom2);
+		assert(0);
+	}
+
+	/* Check, which one has higher accuracy and take that. */
+	dblDiff = fabs(value - ((double)ullNum / (double)ullDenom));
+	dblDiff2 = fabs(value - ((double)ullNum2 / (double)ullDenom2));
+	if (dblDiff < dblDiff2) {
+		*num = (int32_t)(neg * (long)ullNum);
+		*denom = (int32_t)ullDenom;
+	}
+	else {
+		*num = (int32_t)(neg * (long)ullNum2);
+		*denom = (int32_t)ullDenom2;
+	}
+}  /*-- DoubleToSrational() --------------*/
+
+
+
+
+
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagCheckedFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)
+TIFFWriteDirectoryTagCheckedFloat(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, float value)
 {
 	float m;
 	assert(sizeof(float)==4);
@@ -2483,7 +2955,7 @@ TIFFWriteDirectoryTagCheckedFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, ui
 #endif
 
 static int
-TIFFWriteDirectoryTagCheckedFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)
+TIFFWriteDirectoryTagCheckedFloatArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, float* value)
 {
 	assert(count<0x40000000);
 	assert(sizeof(float)==4);
@@ -2495,7 +2967,7 @@ TIFFWriteDirectoryTagCheckedFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 
 #ifdef notdef
 static int
-TIFFWriteDirectoryTagCheckedDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
+TIFFWriteDirectoryTagCheckedDouble(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, double value)
 {
 	double m;
 	assert(sizeof(double)==8);
@@ -2508,7 +2980,7 @@ TIFFWriteDirectoryTagCheckedDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, u
 #endif
 
 static int
-TIFFWriteDirectoryTagCheckedDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)
+TIFFWriteDirectoryTagCheckedDoubleArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, double* value)
 {
 	assert(count<0x20000000);
 	assert(sizeof(double)==8);
@@ -2519,20 +2991,20 @@ TIFFWriteDirectoryTagCheckedDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* d
 }
 
 static int
-TIFFWriteDirectoryTagCheckedIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)
+TIFFWriteDirectoryTagCheckedIfdArray(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint32_t* value)
 {
 	assert(count<0x40000000);
-	assert(sizeof(uint32)==4);
+	assert(sizeof(uint32_t) == 4);
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabArrayOfLong(value,count);
 	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_IFD,count,count*4,value));
 }
 
 static int
-TIFFWriteDirectoryTagCheckedIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)
+TIFFWriteDirectoryTagCheckedIfd8Array(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint32_t count, uint64_t* value)
 {
 	assert(count<0x20000000);
-	assert(sizeof(uint64)==8);
+	assert(sizeof(uint64_t) == 8);
 	assert(tif->tif_flags&TIFF_BIGTIFF);
 	if (tif->tif_flags&TIFF_SWAB)
 		TIFFSwabArrayOfLong8(value,count);
@@ -2540,10 +3012,10 @@ TIFFWriteDirectoryTagCheckedIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir
 }
 
 static int
-TIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 datatype, uint32 count, uint32 datalength, void* data)
+TIFFWriteDirectoryTagData(TIFF* tif, uint32_t* ndir, TIFFDirEntry* dir, uint16_t tag, uint16_t datatype, uint32_t count, uint32_t datalength, void* data)
 {
 	static const char module[] = "TIFFWriteDirectoryTagData";
-	uint32 m;
+	uint32_t m;
 	m=0;
 	while (m<(*ndir))
 	{
@@ -2554,7 +3026,7 @@ TIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag
 	}
 	if (m<(*ndir))
 	{
-		uint32 n;
+		uint32_t n;
 		for (n=*ndir; n>m; n--)
 			dir[n]=dir[n-1];
 	}
@@ -2571,11 +3043,11 @@ TIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag
         }
 	else
 	{
-		uint64 na,nb;
+		uint64_t na,nb;
 		na=tif->tif_dataoff;
 		nb=na+datalength;
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
-			nb=(uint32)nb;
+			nb=(uint32_t)nb;
 		if ((nb<na)||(nb<datalength))
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"Maximum TIFF file size exceeded");
@@ -2597,8 +3069,8 @@ TIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag
 			tif->tif_dataoff++;
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
-			uint32 o;
-			o=(uint32)na;
+			uint32_t o;
+			o=(uint32_t)na;
 			if (tif->tif_flags&TIFF_SWAB)
 				TIFFSwabLong(&o);
 			_TIFFmemcpy(&dir[m].tdir_offset,&o,4);
@@ -2631,8 +3103,8 @@ TIFFLinkDirectory(TIFF* tif)
 	{
 		if (!(tif->tif_flags&TIFF_BIGTIFF))
 		{
-			uint32 m;
-			m = (uint32)tif->tif_diroff;
+			uint32_t m;
+			m = (uint32_t)tif->tif_diroff;
 			if (tif->tif_flags & TIFF_SWAB)
 				TIFFSwabLong(&m);
 			(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);
@@ -2654,7 +3126,7 @@ TIFFLinkDirectory(TIFF* tif)
 		}
 		else
 		{
-			uint64 m;
+			uint64_t m;
 			m = tif->tif_diroff;
 			if (tif->tif_flags & TIFF_SWAB)
 				TIFFSwabLong8(&m);
@@ -2679,16 +3151,16 @@ TIFFLinkDirectory(TIFF* tif)
 
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
 	{
-		uint32 m;
-		uint32 nextdir;
-		m = (uint32)(tif->tif_diroff);
+		uint32_t m;
+		uint32_t nextdir;
+		m = (uint32_t)(tif->tif_diroff);
 		if (tif->tif_flags & TIFF_SWAB)
 			TIFFSwabLong(&m);
 		if (tif->tif_header.classic.tiff_diroff == 0) {
 			/*
 			 * First directory, overwrite offset in header.
 			 */
-			tif->tif_header.classic.tiff_diroff = (uint32) tif->tif_diroff;
+			tif->tif_header.classic.tiff_diroff = (uint32_t) tif->tif_diroff;
 			(void) TIFFSeekFile(tif,4, SEEK_SET);
 			if (!WriteOK(tif, &m, 4)) {
 				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
@@ -2702,8 +3174,8 @@ TIFFLinkDirectory(TIFF* tif)
 		 */
 		nextdir = tif->tif_header.classic.tiff_diroff;
 		while(1) {
-			uint16 dircount;
-			uint32 nextnextdir;
+			uint16_t dircount;
+			uint32_t nextnextdir;
 
 			if (!SeekOK(tif, nextdir) ||
 			    !ReadOK(tif, &dircount, 2)) {
@@ -2738,8 +3210,8 @@ TIFFLinkDirectory(TIFF* tif)
 	}
 	else
 	{
-		uint64 m;
-		uint64 nextdir;
+		uint64_t m;
+		uint64_t nextdir;
 		m = tif->tif_diroff;
 		if (tif->tif_flags & TIFF_SWAB)
 			TIFFSwabLong8(&m);
@@ -2761,9 +3233,9 @@ TIFFLinkDirectory(TIFF* tif)
 		 */
 		nextdir = tif->tif_header.big.tiff_diroff;
 		while(1) {
-			uint64 dircount64;
-			uint16 dircount;
-			uint64 nextnextdir;
+			uint64_t dircount64;
+			uint16_t dircount;
+			uint64_t nextnextdir;
 
 			if (!SeekOK(tif, nextdir) ||
 			    !ReadOK(tif, &dircount64, 8)) {
@@ -2779,7 +3251,7 @@ TIFFLinkDirectory(TIFF* tif)
 					     "Sanity check on tag count failed, likely corrupt TIFF");
 				return (0);
 			}
-			dircount=(uint16)dircount64;
+			dircount=(uint16_t)dircount64;
 			(void) TIFFSeekFile(tif,
 			    nextdir+8+dircount*20, SEEK_SET);
 			if (!ReadOK(tif, &nextnextdir, 8)) {
@@ -2820,21 +3292,21 @@ TIFFLinkDirectory(TIFF* tif)
 /************************************************************************/
 
 int
-_TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype, 
+_TIFFRewriteField(TIFF* tif, uint16_t tag, TIFFDataType in_datatype,
                   tmsize_t count, void* data)
 {
     static const char module[] = "TIFFResetField";
     /* const TIFFField* fip = NULL; */
-    uint16 dircount;
+    uint16_t dircount;
     tmsize_t dirsize;
-    uint8 direntry_raw[20];
-    uint16 entry_tag = 0;
-    uint16 entry_type = 0;
-    uint64 entry_count = 0;
-    uint64 entry_offset = 0;
+    uint8_t direntry_raw[20];
+    uint16_t entry_tag = 0;
+    uint16_t entry_type = 0;
+    uint64_t entry_count = 0;
+    uint64_t entry_offset = 0;
     int    value_in_entry = 0;
-    uint64 read_offset;
-    uint8 *buf_to_write = NULL;
+    uint64_t read_offset;
+    uint8_t *buf_to_write = NULL;
     TIFFDataType datatype;
 
 /* -------------------------------------------------------------------- */
@@ -2873,7 +3345,7 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
 
     if (!(tif->tif_flags&TIFF_BIGTIFF))
     {
-        if (!ReadOK(tif, &dircount, sizeof (uint16))) {
+        if (!ReadOK(tif, &dircount, sizeof (uint16_t))) {
             TIFFErrorExt(tif->tif_clientdata, module,
                          "%s: Can not read TIFF directory count",
                          tif->tif_name);
@@ -2884,8 +3356,8 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
         dirsize = 12;
         read_offset += 2;
     } else {
-        uint64 dircount64;
-        if (!ReadOK(tif, &dircount64, sizeof (uint64))) {
+        uint64_t dircount64;
+        if (!ReadOK(tif, &dircount64, sizeof (uint64_t))) {
             TIFFErrorExt(tif->tif_clientdata, module,
                          "%s: Can not read TIFF directory count",
                          tif->tif_name);
@@ -2893,7 +3365,7 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
         }
         if (tif->tif_flags & TIFF_SWAB)
             TIFFSwabLong8(&dircount64);
-        dircount = (uint16)dircount64;
+        dircount = (uint16_t)dircount64;
         dirsize = 20;
         read_offset += 8;
     }
@@ -2910,7 +3382,7 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
             return 0;
         }
 
-        memcpy( &entry_tag, direntry_raw + 0, sizeof(uint16) );
+        memcpy( &entry_tag, direntry_raw + 0, sizeof(uint16_t) );
         if (tif->tif_flags&TIFF_SWAB)
             TIFFSwabShort( &entry_tag );
 
@@ -2923,7 +3395,7 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
     if( entry_tag != tag )
     {
         TIFFErrorExt(tif->tif_clientdata, module,
-                     "%s: Could not find tag %d.",
+                     "%s: Could not find tag %"PRIu16".",
                      tif->tif_name, tag );
         return 0;
     }
@@ -2931,31 +3403,31 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
 /* -------------------------------------------------------------------- */
 /*      Extract the type, count and offset for this entry.              */
 /* -------------------------------------------------------------------- */
-    memcpy( &entry_type, direntry_raw + 2, sizeof(uint16) );
+    memcpy( &entry_type, direntry_raw + 2, sizeof(uint16_t) );
     if (tif->tif_flags&TIFF_SWAB)
         TIFFSwabShort( &entry_type );
 
     if (!(tif->tif_flags&TIFF_BIGTIFF))
     {
-        uint32 value;
+        uint32_t value;
         
-        memcpy( &value, direntry_raw + 4, sizeof(uint32) );
+        memcpy( &value, direntry_raw + 4, sizeof(uint32_t) );
         if (tif->tif_flags&TIFF_SWAB)
             TIFFSwabLong( &value );
         entry_count = value;
 
-        memcpy( &value, direntry_raw + 8, sizeof(uint32) );
+        memcpy( &value, direntry_raw + 8, sizeof(uint32_t) );
         if (tif->tif_flags&TIFF_SWAB)
             TIFFSwabLong( &value );
         entry_offset = value;
     }
     else
     {
-        memcpy( &entry_count, direntry_raw + 4, sizeof(uint64) );
+        memcpy( &entry_count, direntry_raw + 4, sizeof(uint64_t) );
         if (tif->tif_flags&TIFF_SWAB)
             TIFFSwabLong8( &entry_count );
 
-        memcpy( &entry_offset, direntry_raw + 12, sizeof(uint64) );
+        memcpy( &entry_offset, direntry_raw + 12, sizeof(uint64_t) );
         if (tif->tif_flags&TIFF_SWAB)
             TIFFSwabLong8( &entry_offset );
     }
@@ -3042,8 +3514,8 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
 /*      swabbing as needed.                                             */
 /* -------------------------------------------------------------------- */
     buf_to_write =
-	    (uint8 *)_TIFFCheckMalloc(tif, count, TIFFDataWidth(datatype),
-				      "for field buffer.");
+	    (uint8_t *)_TIFFCheckMalloc(tif, count, TIFFDataWidth(datatype),
+                                    "for field buffer.");
     if (!buf_to_write)
         return 0;
 
@@ -3055,9 +3527,9 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
 
         for( i = 0; i < count; i++ )
         {
-            ((int32 *) buf_to_write)[i] = 
-                (int32) ((int64 *) data)[i];
-            if( (int64) ((int32 *) buf_to_write)[i] != ((int64 *) data)[i] )
+            ((int32_t *) buf_to_write)[i] =
+                (int32_t) ((int64_t *) data)[i];
+            if((int64_t) ((int32_t *) buf_to_write)[i] != ((int64_t *) data)[i] )
             {
                 _TIFFfree( buf_to_write );
                 TIFFErrorExt( tif->tif_clientdata, module, 
@@ -3073,9 +3545,9 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
 
         for( i = 0; i < count; i++ )
         {
-            ((uint32 *) buf_to_write)[i] = 
-                (uint32) ((uint64 *) data)[i];
-            if( (uint64) ((uint32 *) buf_to_write)[i] != ((uint64 *) data)[i] )
+            ((uint32_t *) buf_to_write)[i] =
+                (uint32_t) ((uint64_t *) data)[i];
+            if((uint64_t) ((uint32_t *) buf_to_write)[i] != ((uint64_t *) data)[i] )
             {
                 _TIFFfree( buf_to_write );
                 TIFFErrorExt( tif->tif_clientdata, module, 
@@ -3090,9 +3562,9 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
 
         for( i = 0; i < count; i++ )
         {
-            ((uint16 *) buf_to_write)[i] =
-                (uint16) ((uint64 *) data)[i];
-            if( (uint64) ((uint16 *) buf_to_write)[i] != ((uint64 *) data)[i] )
+            ((uint16_t *) buf_to_write)[i] =
+                (uint16_t) ((uint64_t *) data)[i];
+            if((uint64_t) ((uint16_t *) buf_to_write)[i] != ((uint64_t *) data)[i] )
             {
                 _TIFFfree( buf_to_write );
                 TIFFErrorExt( tif->tif_clientdata, module,
@@ -3111,11 +3583,11 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
     if( TIFFDataWidth(datatype) > 1 && (tif->tif_flags&TIFF_SWAB) )
     {
         if( TIFFDataWidth(datatype) == 2 )
-            TIFFSwabArrayOfShort( (uint16 *) buf_to_write, count );
+            TIFFSwabArrayOfShort((uint16_t *) buf_to_write, count );
         else if( TIFFDataWidth(datatype) == 4 )
-            TIFFSwabArrayOfLong( (uint32 *) buf_to_write, count );
+            TIFFSwabArrayOfLong((uint32_t *) buf_to_write, count );
         else if( TIFFDataWidth(datatype) == 8 )
-            TIFFSwabArrayOfLong8( (uint64 *) buf_to_write, count );
+            TIFFSwabArrayOfLong8((uint64_t *) buf_to_write, count );
     }
 
 /* -------------------------------------------------------------------- */
@@ -3160,7 +3632,7 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
 /*      over the old values without altering the directory entry at     */
 /*      all.                                                            */
 /* -------------------------------------------------------------------- */
-    if( entry_count == (uint64)count && entry_type == (uint16) datatype )
+    if( entry_count == (uint64_t)count && entry_type == (uint16_t) datatype )
     {
         if (!SeekOK(tif, entry_offset)) {
             _TIFFfree( buf_to_write );
@@ -3206,34 +3678,34 @@ _TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype,
 /*      Adjust the directory entry.                                     */
 /* -------------------------------------------------------------------- */
     entry_type = datatype;
-    entry_count = (uint64)count;
-    memcpy( direntry_raw + 2, &entry_type, sizeof(uint16) );
+    entry_count = (uint64_t)count;
+    memcpy( direntry_raw + 2, &entry_type, sizeof(uint16_t) );
     if (tif->tif_flags&TIFF_SWAB)
-        TIFFSwabShort( (uint16 *) (direntry_raw + 2) );
+        TIFFSwabShort( (uint16_t *) (direntry_raw + 2) );
 
     if (!(tif->tif_flags&TIFF_BIGTIFF))
     {
-        uint32 value;
+        uint32_t value;
 
-        value = (uint32) entry_count;
-        memcpy( direntry_raw + 4, &value, sizeof(uint32) );
+        value = (uint32_t) entry_count;
+        memcpy( direntry_raw + 4, &value, sizeof(uint32_t) );
         if (tif->tif_flags&TIFF_SWAB)
-            TIFFSwabLong( (uint32 *) (direntry_raw + 4) );
+            TIFFSwabLong( (uint32_t *) (direntry_raw + 4) );
 
-        value = (uint32) entry_offset;
-        memcpy( direntry_raw + 8, &value, sizeof(uint32) );
+        value = (uint32_t) entry_offset;
+        memcpy( direntry_raw + 8, &value, sizeof(uint32_t) );
         if (tif->tif_flags&TIFF_SWAB)
-            TIFFSwabLong( (uint32 *) (direntry_raw + 8) );
+            TIFFSwabLong( (uint32_t *) (direntry_raw + 8) );
     }
     else
     {
-        memcpy( direntry_raw + 4, &entry_count, sizeof(uint64) );
+        memcpy( direntry_raw + 4, &entry_count, sizeof(uint64_t) );
         if (tif->tif_flags&TIFF_SWAB)
-            TIFFSwabLong8( (uint64 *) (direntry_raw + 4) );
+            TIFFSwabLong8( (uint64_t *) (direntry_raw + 4) );
 
-        memcpy( direntry_raw + 12, &entry_offset, sizeof(uint64) );
+        memcpy( direntry_raw + 12, &entry_offset, sizeof(uint64_t) );
         if (tif->tif_flags&TIFF_SWAB)
-            TIFFSwabLong8( (uint64 *) (direntry_raw + 12) );
+            TIFFSwabLong8( (uint64_t *) (direntry_raw + 12) );
     }
 
 /* -------------------------------------------------------------------- */
diff --git a/src/3rdparty/libtiff/libtiff/tif_dumpmode.c b/src/3rdparty/libtiff/libtiff/tif_dumpmode.c
index 4a0b07f..f1d3c4a 100644
--- a/src/3rdparty/libtiff/libtiff/tif_dumpmode.c
+++ b/src/3rdparty/libtiff/libtiff/tif_dumpmode.c
@@ -40,7 +40,7 @@ DumpFixupTags(TIFF* tif)
  * Encode a hunk of pixels.
  */
 static int
-DumpModeEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
+DumpModeEncode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s)
 {
 	(void) s;
 	while (cc > 0) {
@@ -73,24 +73,16 @@ DumpModeEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
  * Decode a hunk of pixels.
  */
 static int
-DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+DumpModeDecode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "DumpModeDecode";
 	(void) s;
 	if (tif->tif_rawcc < cc) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
-"Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed __int64) tif->tif_rawcc,
-		             (signed __int64) cc);
-#else
-		TIFFErrorExt(tif->tif_clientdata, module,
-"Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed long long) tif->tif_rawcc,
-		             (signed long long) cc);
-#endif
+"Not enough data for scanline %"PRIu32", expected a request for at most %"TIFF_SSIZE_FORMAT" bytes, got a request for %"TIFF_SSIZE_FORMAT" bytes",
+		             tif->tif_row,
+		             tif->tif_rawcc,
+		             cc);
 		return (0);
 	}
 	/*
@@ -108,7 +100,7 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
  * Seek forwards nrows in the current strip.
  */
 static int
-DumpModeSeek(TIFF* tif, uint32 nrows)
+DumpModeSeek(TIFF* tif, uint32_t nrows)
 {
 	tif->tif_rawcp += nrows * tif->tif_scanlinesize;
 	tif->tif_rawcc -= nrows * tif->tif_scanlinesize;
diff --git a/src/3rdparty/libtiff/libtiff/tif_extension.c b/src/3rdparty/libtiff/libtiff/tif_extension.c
index 87d3cfc..9d46d3e 100644
--- a/src/3rdparty/libtiff/libtiff/tif_extension.c
+++ b/src/3rdparty/libtiff/libtiff/tif_extension.c
@@ -39,13 +39,13 @@ int TIFFGetTagListCount( TIFF *tif )
     return td->td_customValueCount;
 }
 
-uint32 TIFFGetTagListEntry( TIFF *tif, int tag_index )
+uint32_t TIFFGetTagListEntry(TIFF *tif, int tag_index )
 
 {
     TIFFDirectory* td = &tif->tif_dir;
 
     if( tag_index < 0 || tag_index >= td->td_customValueCount )
-        return (uint32)(-1);
+        return (uint32_t)(-1);
     else
         return td->td_customValues[tag_index].info->field_tag;
 }
diff --git a/src/3rdparty/libtiff/libtiff/tif_fax3.c b/src/3rdparty/libtiff/libtiff/tif_fax3.c
index d11c968..b79f1f3 100644
--- a/src/3rdparty/libtiff/libtiff/tif_fax3.c
+++ b/src/3rdparty/libtiff/libtiff/tif_fax3.c
@@ -49,12 +49,12 @@ typedef struct {
 	int      rw_mode;                /* O_RDONLY for decode, else encode */
 	int      mode;                   /* operating mode */
 	tmsize_t rowbytes;               /* bytes in a decoded scanline */
-	uint32   rowpixels;              /* pixels in a scanline */
+	uint32_t   rowpixels;              /* pixels in a scanline */
 
-	uint16   cleanfaxdata;           /* CleanFaxData tag */
-	uint32   badfaxrun;              /* BadFaxRun tag */
-	uint32   badfaxlines;            /* BadFaxLines tag */
-	uint32   groupoptions;           /* Group 3/4 options tag */
+	uint16_t   cleanfaxdata;           /* CleanFaxData tag */
+	uint32_t   badfaxrun;              /* BadFaxRun tag */
+	uint32_t   badfaxlines;            /* BadFaxLines tag */
+	uint32_t   groupoptions;           /* Group 3/4 options tag */
 
 	TIFFVGetMethod  vgetparent;      /* super-class method */
 	TIFFVSetMethod  vsetparent;      /* super-class method */
@@ -68,13 +68,14 @@ typedef struct {
 
 	/* Decoder state info */
 	const unsigned char* bitmap;	/* bit reversal table */
-	uint32	data;			/* current i/o byte/word */
+	uint32_t	data;			/* current i/o byte/word */
 	int	bit;			/* current i/o bit in byte */
 	int	EOLcnt;			/* count of EOL codes recognized */
 	TIFFFaxFillFunc fill;		/* fill routine */
-	uint32*	runs;			/* b&w runs for current/previous row */
-	uint32*	refruns;		/* runs for reference line */
-	uint32*	curruns;		/* runs for current line */
+	uint32_t*	runs;			/* b&w runs for current/previous row */
+	uint32_t	nruns;			/* size of the refruns / curruns arrays */
+	uint32_t*	refruns;		/* runs for reference line */
+	uint32_t*	curruns;		/* runs for current line */
 
 	/* Encoder state info */
 	Ttag    tag;			/* encoding state */
@@ -103,20 +104,20 @@ typedef struct {
     Fax3CodecState* sp = DecoderState(tif);				\
     int a0;				/* reference element */		\
     int lastx = sp->b.rowpixels;	/* last element in row */	\
-    uint32 BitAcc;			/* bit accumulator */		\
+    uint32_t BitAcc;			/* bit accumulator */		\
     int BitsAvail;			/* # valid bits in BitAcc */	\
     int RunLength;			/* length of current run */	\
     unsigned char* cp;			/* next byte of input data */	\
     unsigned char* ep;			/* end of input data */		\
-    uint32* pa;				/* place to stuff next run */	\
-    uint32* thisrun;			/* current row's run array */	\
+    uint32_t* pa;				/* place to stuff next run */	\
+    uint32_t* thisrun;			/* current row's run array */	\
     int EOLcnt;				/* # EOL codes recognized */	\
     const unsigned char* bitmap = sp->bitmap;	/* input data bit reverser */	\
     const TIFFFaxTabEnt* TabEnt
 #define	DECLARE_STATE_2D(tif, sp, mod)					\
     DECLARE_STATE(tif, sp, mod);					\
     int b1;				/* next change on prev line */	\
-    uint32* pb				/* next run in reference line */\
+    uint32_t* pb				/* next run in reference line */\
 /*
  * Load any state that may be changed during decoding.
  */
@@ -134,15 +135,15 @@ typedef struct {
     sp->bit = BitsAvail;						\
     sp->data = BitAcc;							\
     sp->EOLcnt = EOLcnt;						\
-    tif->tif_rawcc -= (tmsize_t)((uint8*) cp - tif->tif_rawcp);		\
-    tif->tif_rawcp = (uint8*) cp;					\
+    tif->tif_rawcc -= (tmsize_t)((uint8_t*) cp - tif->tif_rawcp);		\
+    tif->tif_rawcp = (uint8_t*) cp;					\
 } while (0)
 
 /*
  * Setup state for decoding a strip.
  */
 static int
-Fax3PreDecode(TIFF* tif, uint16 s)
+Fax3PreDecode(TIFF* tif, uint16_t s)
 {
 	Fax3CodecState* sp = DecoderState(tif);
 
@@ -160,8 +161,10 @@ Fax3PreDecode(TIFF* tif, uint16 s)
 	 */
 	sp->bitmap =
 	    TIFFGetBitRevTable(tif->tif_dir.td_fillorder != FILLORDER_LSB2MSB);
+	sp->curruns = sp->runs;
 	if (sp->refruns) {		/* init reference line to white */
-		sp->refruns[0] = (uint32) sp->b.rowpixels;
+		sp->refruns = sp->runs + sp->nruns;
+		sp->refruns[0] = (uint32_t) sp->b.rowpixels;
 		sp->refruns[1] = 0;
 	}
 	sp->line = 0;
@@ -175,9 +178,9 @@ Fax3PreDecode(TIFF* tif, uint16 s)
  */
 
 static void
-Fax3Unexpected(const char* module, TIFF* tif, uint32 line, uint32 a0)
+Fax3Unexpected(const char* module, TIFF* tif, uint32_t line, uint32_t a0)
 {
-	TIFFErrorExt(tif->tif_clientdata, module, "Bad code word at line %u of %s %u (x %u)",
+	TIFFErrorExt(tif->tif_clientdata, module, "Bad code word at line %"PRIu32" of %s %"PRIu32" (x %"PRIu32")",
 	    line, isTiled(tif) ? "tile" : "strip",
 	    (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),
 	    a0);
@@ -185,10 +188,10 @@ Fax3Unexpected(const char* module, TIFF* tif, uint32 line, uint32 a0)
 #define	unexpected(table, a0)	Fax3Unexpected(module, tif, sp->line, a0)
 
 static void
-Fax3Extension(const char* module, TIFF* tif, uint32 line, uint32 a0)
+Fax3Extension(const char* module, TIFF* tif, uint32_t line, uint32_t a0)
 {
 	TIFFErrorExt(tif->tif_clientdata, module,
-	    "Uncompressed data (not supported) at line %u of %s %u (x %u)",
+	    "Uncompressed data (not supported) at line %"PRIu32" of %s %"PRIu32" (x %"PRIu32")",
 	    line, isTiled(tif) ? "tile" : "strip",
 	    (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),
 	    a0);
@@ -196,9 +199,9 @@ Fax3Extension(const char* module, TIFF* tif, uint32 line, uint32 a0)
 #define	extension(a0)	Fax3Extension(module, tif, sp->line, a0)
 
 static void
-Fax3BadLength(const char* module, TIFF* tif, uint32 line, uint32 a0, uint32 lastx)
+Fax3BadLength(const char* module, TIFF* tif, uint32_t line, uint32_t a0, uint32_t lastx)
 {
-	TIFFWarningExt(tif->tif_clientdata, module, "%s at line %u of %s %u (got %u, expected %u)",
+	TIFFWarningExt(tif->tif_clientdata, module, "%s at line %"PRIu32" of %s %"PRIu32" (got %"PRIu32", expected %"PRIu32")",
 	    a0 < lastx ? "Premature EOL" : "Line length mismatch",
 	    line, isTiled(tif) ? "tile" : "strip",
 	    (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),
@@ -207,9 +210,9 @@ Fax3BadLength(const char* module, TIFF* tif, uint32 line, uint32 a0, uint32 last
 #define	badlength(a0,lastx)	Fax3BadLength(module, tif, sp->line, a0, lastx)
 
 static void
-Fax3PrematureEOF(const char* module, TIFF* tif, uint32 line, uint32 a0)
+Fax3PrematureEOF(const char* module, TIFF* tif, uint32_t line, uint32_t a0)
 {
-	TIFFWarningExt(tif->tif_clientdata, module, "Premature EOF at line %u of %s %u (x %u)",
+	TIFFWarningExt(tif->tif_clientdata, module, "Premature EOF at line %"PRIu32" of %s %"PRIu32" (x %"PRIu32")",
 	    line, isTiled(tif) ? "tile" : "strip",
 	    (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),
 	    a0);
@@ -218,11 +221,15 @@ Fax3PrematureEOF(const char* module, TIFF* tif, uint32 line, uint32 a0)
 
 #define	Nop
 
-/*
+/**
  * Decode the requested amount of G3 1D-encoded data.
+ * @param buf destination buffer
+ * @param occ available bytes in destination buffer
+ * @param s number of planes (ignored)
+ * @returns 1 for success, -1 in case of error
  */
 static int
-Fax3Decode1D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
+Fax3Decode1D(TIFF* tif, uint8_t* buf, tmsize_t occ, uint16_t s)
 {
 	DECLARE_STATE(tif, sp, "Fax3Decode1D");
 	(void) s;
@@ -238,8 +245,8 @@ Fax3Decode1D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		RunLength = 0;
 		pa = thisrun;
 #ifdef FAX3_DEBUG
-		printf("\nBitAcc=%08X, BitsAvail = %d\n", BitAcc, BitsAvail);
-		printf("-------------------- %d\n", tif->tif_row);
+		printf("\nBitAcc=%08"PRIX32", BitsAvail = %d\n", BitAcc, BitsAvail);
+		printf("-------------------- %"PRIu32"\n", tif->tif_row);
 		fflush(stdout);
 #endif
 		SYNC_EOL(EOF1D);
@@ -265,7 +272,7 @@ Fax3Decode1D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
  * Decode the requested amount of G3 2D-encoded data.
  */
 static int
-Fax3Decode2D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
+Fax3Decode2D(TIFF* tif, uint8_t* buf, tmsize_t occ, uint16_t s)
 {
 	DECLARE_STATE_2D(tif, sp, "Fax3Decode2D");
 	int is1D;			/* current line is 1d/2d-encoded */
@@ -281,7 +288,7 @@ Fax3Decode2D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		RunLength = 0;
 		pa = thisrun = sp->curruns;
 #ifdef FAX3_DEBUG
-		printf("\nBitAcc=%08X, BitsAvail = %d EOLcnt = %d",
+		printf("\nBitAcc=%08"PRIX32", BitsAvail = %d EOLcnt = %d",
 		    BitAcc, BitsAvail, EOLcnt);
 #endif
 		SYNC_EOL(EOF2D);
@@ -289,7 +296,7 @@ Fax3Decode2D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		is1D = GetBits(1);	/* 1D/2D-encoding tag bit */
 		ClrBits(1);
 #ifdef FAX3_DEBUG
-		printf(" %s\n-------------------- %d\n",
+		printf(" %s\n-------------------- %"PRIu32"\n",
 		    is1D ? "1D" : "2D", tif->tif_row);
 		fflush(stdout);
 #endif
@@ -300,8 +307,10 @@ Fax3Decode2D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		else
 			EXPAND2D(EOF2Da);
 		(*sp->fill)(buf, thisrun, pa, lastx);
-		SETVALUE(0);		/* imaginary change for reference */
-		SWAP(uint32*, sp->curruns, sp->refruns);
+		if (pa < thisrun + sp->nruns) {
+			SETVALUE(0);	/* imaginary change for reference */
+		}
+		SWAP(uint32_t*, sp->curruns, sp->refruns);
 		buf += sp->b.rowbytes;
 		occ -= sp->b.rowbytes;
 		sp->line++;
@@ -318,89 +327,37 @@ Fax3Decode2D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 }
 #undef SWAP
 
-/*
- * The ZERO & FILL macros must handle spans < 2*sizeof(long) bytes.
- * For machines with 64-bit longs this is <16 bytes; otherwise
- * this is <8 bytes.  We optimize the code here to reflect the
- * machine characteristics.
- */
-#if SIZEOF_UNSIGNED_LONG == 8
-# define FILL(n, cp)							    \
-    switch (n) {							    \
-    case 15:(cp)[14] = 0xff; /*-fallthrough*/ \
-    case 14:(cp)[13] = 0xff; /*-fallthrough*/ \
-    case 13:(cp)[12] = 0xff; /*-fallthrough*/ \
-    case 12:(cp)[11] = 0xff; /*-fallthrough*/ \
-    case 11:(cp)[10] = 0xff; /*-fallthrough*/ \
-    case 10: (cp)[9] = 0xff; /*-fallthrough*/ \
-    case  9: (cp)[8] = 0xff; /*-fallthrough*/ \
-    case  8: (cp)[7] = 0xff; /*-fallthrough*/ \
-    case  7: (cp)[6] = 0xff; /*-fallthrough*/ \
-    case  6: (cp)[5] = 0xff; /*-fallthrough*/ \
-    case  5: (cp)[4] = 0xff; /*-fallthrough*/ \
-    case  4: (cp)[3] = 0xff; /*-fallthrough*/ \
-    case  3: (cp)[2] = 0xff; /*-fallthrough*/ \
-    case  2: (cp)[1] = 0xff; /*-fallthrough*/ \
-    case  1: (cp)[0] = 0xff; (cp) += (n); /*-fallthrough*/ \
-    case 0:  ;			      \
-    }
-# define ZERO(n, cp)							\
-    switch (n) {							\
-    case 15:(cp)[14] = 0; /*-fallthrough*/ \
-    case 14:(cp)[13] = 0; /*-fallthrough*/ \
-    case 13:(cp)[12] = 0; /*-fallthrough*/ \
-    case 12:(cp)[11] = 0; /*-fallthrough*/ \
-    case 11:(cp)[10] = 0; /*-fallthrough*/ \
-    case 10: (cp)[9] = 0; /*-fallthrough*/ \
-    case  9: (cp)[8] = 0; /*-fallthrough*/ \
-    case  8: (cp)[7] = 0; /*-fallthrough*/ \
-    case  7: (cp)[6] = 0; /*-fallthrough*/ \
-    case  6: (cp)[5] = 0; /*-fallthrough*/ \
-    case  5: (cp)[4] = 0; /*-fallthrough*/ \
-    case  4: (cp)[3] = 0; /*-fallthrough*/ \
-    case  3: (cp)[2] = 0; /*-fallthrough*/ \
-    case  2: (cp)[1] = 0; /*-fallthrough*/ \
-    case  1: (cp)[0] = 0; (cp) += (n); /*-fallthrough*/ \
-    case 0:  ;			\
-    }
-#else
-# define FILL(n, cp)							    \
-    switch (n) {							    \
-    case 7: (cp)[6] = 0xff; /*-fallthrough*/ \
-    case 6: (cp)[5] = 0xff; /*-fallthrough*/ \
-    case 5: (cp)[4] = 0xff; /*-fallthrough*/ \
-    case 4: (cp)[3] = 0xff; /*-fallthrough*/ \
-    case 3: (cp)[2] = 0xff; /*-fallthrough*/ \
-    case 2: (cp)[1] = 0xff; /*-fallthrough*/ \
-    case 1: (cp)[0] = 0xff; (cp) += (n);  /*-fallthrough*/ \
-    case 0:  ;			    \
-    }
-# define ZERO(n, cp)							\
-    switch (n) {							\
-    case 7: (cp)[6] = 0; /*-fallthrough*/ \
-    case 6: (cp)[5] = 0; /*-fallthrough*/ \
-    case 5: (cp)[4] = 0; /*-fallthrough*/ \
-    case 4: (cp)[3] = 0; /*-fallthrough*/ \
-    case 3: (cp)[2] = 0; /*-fallthrough*/ \
-    case 2: (cp)[1] = 0; /*-fallthrough*/ \
-    case 1: (cp)[0] = 0; (cp) += (n); /*-fallthrough*/ \
-    case 0:  ;			\
-    }
-#endif
+# define FILL(n, cp) {                            \
+    int32_t ifill;                                \
+    for (ifill = 0; ifill < (n); ++ifill)         \
+    {                                             \
+        (cp)[ifill] = 0xff;                       \
+    }                                             \
+    (cp) += (n);                                  \
+}
+
+# define ZERO(n, cp) {                            \
+    int32_t izero;                                \
+    for (izero = 0; izero < (n); ++izero)         \
+    {                                             \
+        (cp)[izero] = 0;                          \
+    }                                             \
+    (cp) += (n);                                  \
+}
 
 /*
  * Bit-fill a row according to the white/black
  * runs generated during G3/G4 decoding.
  */
 void
-_TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)
+_TIFFFax3fillruns(unsigned char* buf, uint32_t* runs, uint32_t* erun, uint32_t lastx)
 {
 	static const unsigned char _fillmasks[] =
 	    { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };
 	unsigned char* cp;
-	uint32 x, bx, run;
-	int32 n, nw;
-	long* lp;
+	uint32_t x, bx, run;
+	int32_t n, nw;
+	int64_t* lp;
 
 	if ((erun-runs)&1)
 	    *erun++ = 0;
@@ -408,7 +365,7 @@ _TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)
 	for (; runs < erun; runs += 2) {
 	    run = runs[0];
 	    if (x+run > lastx || run > lastx )
-		run = runs[0] = (uint32) (lastx - x);
+		run = runs[0] = (uint32_t) (lastx - x);
 	    if (run) {
 		cp = buf + (x>>3);
 		bx = x&7;
@@ -418,15 +375,15 @@ _TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)
 			run -= 8-bx;
 		    }
 		    if( (n = run >> 3) != 0 ) {	/* multiple bytes to fill */
-			if ((n/sizeof (long)) > 1) {
+			if ((n/sizeof (int64_t)) > 1) {
 			    /*
-			     * Align to longword boundary and fill.
+			     * Align to int64_tword boundary and fill.
 			     */
-			    for (; n && !isAligned(cp, long); n--)
+			    for (; n && !isAligned(cp, int64_t); n--)
 				    *cp++ = 0x00;
-			    lp = (long*) cp;
-			    nw = (int32)(n / sizeof (long));
-			    n -= nw * sizeof (long);
+			    lp = (int64_t*) cp;
+			    nw = (int32_t)(n / sizeof (int64_t));
+			    n -= nw * sizeof (int64_t);
 			    do {
 				    *lp++ = 0L;
 			    } while (--nw);
@@ -453,15 +410,15 @@ _TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)
 			run -= 8-bx;
 		    }
 		    if( (n = run>>3) != 0 ) {	/* multiple bytes to fill */
-			if ((n/sizeof (long)) > 1) {
+			if ((n/sizeof (int64_t)) > 1) {
 			    /*
-			     * Align to longword boundary and fill.
+			     * Align to int64_t boundary and fill.
 			     */
-			    for (; n && !isAligned(cp, long); n--)
+			    for (; n && !isAligned(cp, int64_t); n--)
 				*cp++ = 0xff;
-			    lp = (long*) cp;
-			    nw = (int32)(n / sizeof (long));
-			    n -= nw * sizeof (long);
+			    lp = (int64_t*) cp;
+			    nw = (int32_t)(n / sizeof (int64_t));
+			    n -= nw * sizeof (int64_t);
 			    do {
 				*lp++ = -1L;
 			    } while (--nw);
@@ -506,7 +463,7 @@ Fax3SetupState(TIFF* tif)
 	int needsRefLine;
 	Fax3CodecState* dsp = (Fax3CodecState*) Fax3State(tif);
 	tmsize_t rowbytes;
-	uint32 rowpixels, nruns;
+	uint32_t rowpixels;
 
 	if (td->td_bitspersample != 1) {
 		TIFFErrorExt(tif->tif_clientdata, module,
@@ -523,6 +480,13 @@ Fax3SetupState(TIFF* tif)
 		rowbytes = TIFFScanlineSize(tif);
 		rowpixels = td->td_imagewidth;
 	}
+	if ((int64_t)rowbytes < ((int64_t)rowpixels + 7) / 8)
+	{
+		TIFFErrorExt(tif->tif_clientdata, module,
+			"Inconsistent number of bytes per row : rowbytes=%" PRId64 " rowpixels=%" PRIu32,
+                     (int64_t) rowbytes, rowpixels);
+		return (0);
+	}
 	sp->rowbytes = rowbytes;
 	sp->rowpixels = rowpixels;
 	/*
@@ -538,27 +502,27 @@ Fax3SetupState(TIFF* tif)
 	  
 	  TIFFroundup and TIFFSafeMultiply return zero on integer overflow
 	*/
-	dsp->runs=(uint32*) NULL;
-	nruns = TIFFroundup_32(rowpixels,32);
+	dsp->runs=(uint32_t*) NULL;
+	dsp->nruns = TIFFroundup_32(rowpixels,32);
 	if (needsRefLine) {
-		nruns = TIFFSafeMultiply(uint32,nruns,2);
+		dsp->nruns = TIFFSafeMultiply(uint32_t, dsp->nruns, 2);
 	}
-	if ((nruns == 0) || (TIFFSafeMultiply(uint32,nruns,2) == 0)) {
+	if ((dsp->nruns == 0) || (TIFFSafeMultiply(uint32_t, dsp->nruns, 2) == 0)) {
 		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Row pixels integer overflow (rowpixels %u)",
+			     "Row pixels integer overflow (rowpixels %"PRIu32")",
 			     rowpixels);
 		return (0);
 	}
-	dsp->runs = (uint32*) _TIFFCheckMalloc(tif,
-					       TIFFSafeMultiply(uint32,nruns,2),
-					       sizeof (uint32),
-					       "for Group 3/4 run arrays");
+	dsp->runs = (uint32_t*) _TIFFCheckMalloc(tif,
+                                             TIFFSafeMultiply(uint32_t, dsp->nruns, 2),
+                                             sizeof (uint32_t),
+                                             "for Group 3/4 run arrays");
 	if (dsp->runs == NULL)
 		return (0);
-	memset( dsp->runs, 0, TIFFSafeMultiply(uint32,nruns,2)*sizeof(uint32));
+	memset( dsp->runs, 0, TIFFSafeMultiply(uint32_t,dsp->nruns,2)*sizeof(uint32_t));
 	dsp->curruns = dsp->runs;
 	if (needsRefLine)
-		dsp->refruns = dsp->runs + nruns;
+		dsp->refruns = dsp->runs + dsp->nruns;
 	else
 		dsp->refruns = NULL;
 	if (td->td_compression == COMPRESSION_CCITTFAX3
@@ -594,16 +558,20 @@ Fax3SetupState(TIFF* tif)
  */
 
 #define	Fax3FlushBits(tif, sp) {				\
-	if ((tif)->tif_rawcc >= (tif)->tif_rawdatasize)		\
-		(void) TIFFFlushData1(tif);			\
-	*(tif)->tif_rawcp++ = (uint8) (sp)->data;		\
+	if ((tif)->tif_rawcc >= (tif)->tif_rawdatasize) {	\
+		if( !TIFFFlushData1(tif) )			\
+			return 0;				\
+        }							\
+	*(tif)->tif_rawcp++ = (uint8_t) (sp)->data;		\
 	(tif)->tif_rawcc++;					\
 	(sp)->data = 0, (sp)->bit = 8;				\
 }
 #define	_FlushBits(tif) {					\
-	if ((tif)->tif_rawcc >= (tif)->tif_rawdatasize)		\
-		(void) TIFFFlushData1(tif);			\
-	*(tif)->tif_rawcp++ = (uint8) data;		\
+	if ((tif)->tif_rawcc >= (tif)->tif_rawdatasize) {	\
+		if( !TIFFFlushData1(tif) )			\
+			return 0;				\
+        }							\
+	*(tif)->tif_rawcp++ = (uint8_t) data;		\
 	(tif)->tif_rawcc++;					\
 	data = 0, bit = 8;					\
 }
@@ -627,7 +595,7 @@ static const int _msbmask[9] =
  * the output stream.  Values are
  * assumed to be at most 16 bits.
  */
-static void
+static int
 Fax3PutBits(TIFF* tif, unsigned int bits, unsigned int length)
 {
 	Fax3CodecState* sp = EncoderState(tif);
@@ -638,6 +606,7 @@ Fax3PutBits(TIFF* tif, unsigned int bits, unsigned int length)
 
 	sp->data = data;
 	sp->bit = bit;
+        return 1;
 }
 
 /*
@@ -649,7 +618,7 @@ Fax3PutBits(TIFF* tif, unsigned int bits, unsigned int length)
 #define	DEBUG_COLOR(w) (tab == TIFFFaxWhiteCodes ? w "W" : w "B")
 #define	DEBUG_PRINT(what,len) {						\
     int t;								\
-    printf("%08X/%-2d: %s%5d\t", data, bit, DEBUG_COLOR(what), len);	\
+    printf("%08"PRIX32"/%-2d: %s%5d\t", data, bit, DEBUG_COLOR(what), len);	\
     for (t = length-1; t >= 0; t--)					\
 	putchar(code & (1<<t) ? '1' : '0');				\
     putchar('\n');							\
@@ -662,8 +631,8 @@ Fax3PutBits(TIFF* tif, unsigned int bits, unsigned int length)
  * appropriate table that holds the make-up and
  * terminating codes is supplied.
  */
-static void
-putspan(TIFF* tif, int32 span, const tableentry* tab)
+static int
+putspan(TIFF* tif, int32_t span, const tableentry* tab)
 {
 	Fax3CodecState* sp = EncoderState(tif);
 	unsigned int bit = sp->bit;
@@ -700,6 +669,8 @@ putspan(TIFF* tif, int32 span, const tableentry* tab)
 
 	sp->data = data;
 	sp->bit = bit;
+
+        return 1;
 }
 
 /*
@@ -708,7 +679,7 @@ putspan(TIFF* tif, int32 span, const tableentry* tab)
  * here.  We also handle writing the tag bit for the next
  * scanline when doing 2d encoding.
  */
-static void
+static int
 Fax3PutEOL(TIFF* tif)
 {
 	Fax3CodecState* sp = EncoderState(tif);
@@ -742,13 +713,15 @@ Fax3PutEOL(TIFF* tif)
 
 	sp->data = data;
 	sp->bit = bit;
+
+        return 1;
 }
 
 /*
  * Reset encoding state at the start of a strip.
  */
 static int
-Fax3PreEncode(TIFF* tif, uint16 s)
+Fax3PreEncode(TIFF* tif, uint16_t s)
 {
 	Fax3CodecState* sp = EncoderState(tif);
 
@@ -823,26 +796,16 @@ static const unsigned char oneruns[256] = {
     4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8,	/* 0xf0 - 0xff */
 };
 
-/*
- * On certain systems it pays to inline
- * the routines that find pixel spans.
- */
-#ifdef VAXC
-static	int32 find0span(unsigned char*, int32, int32);
-static	int32 find1span(unsigned char*, int32, int32);
-#pragma inline(find0span,find1span)
-#endif
-
 /*
  * Find a span of ones or zeros using the supplied
  * table.  The ``base'' of the bit string is supplied
  * along with the start+end bit indices.
  */
-inline static int32
-find0span(unsigned char* bp, int32 bs, int32 be)
+static inline int32_t
+find0span(unsigned char* bp, int32_t bs, int32_t be)
 {
-	int32 bits = be - bs;
-	int32 n, span;
+	int32_t bits = be - bs;
+	int32_t n, span;
 
 	bp += bs>>3;
 	/*
@@ -860,22 +823,22 @@ find0span(unsigned char* bp, int32 bs, int32 be)
 		bp++;
 	} else
 		span = 0;
-	if (bits >= (int32)(2 * 8 * sizeof(long))) {
-		long* lp;
+	if (bits >= (int32_t)(2 * 8 * sizeof(int64_t))) {
+		int64_t* lp;
 		/*
-		 * Align to longword boundary and check longwords.
+		 * Align to int64_t boundary and check int64_t words.
 		 */
-		while (!isAligned(bp, long)) {
+		while (!isAligned(bp, int64_t)) {
 			if (*bp != 0x00)
 				return (span + zeroruns[*bp]);
 			span += 8;
 			bits -= 8;
 			bp++;
 		}
-		lp = (long*) bp;
-		while ((bits >= (int32)(8 * sizeof(long))) && (0 == *lp)) {
-			span += 8*sizeof (long);
-			bits -= 8*sizeof (long);
+		lp = (int64_t*) bp;
+		while ((bits >= (int32_t)(8 * sizeof(int64_t))) && (0 == *lp)) {
+			span += 8*sizeof (int64_t);
+			bits -= 8*sizeof (int64_t);
 			lp++;
 		}
 		bp = (unsigned char*) lp;
@@ -900,11 +863,11 @@ find0span(unsigned char* bp, int32 bs, int32 be)
 	return (span);
 }
 
-inline static int32
-find1span(unsigned char* bp, int32 bs, int32 be)
+static inline int32_t
+find1span(unsigned char* bp, int32_t bs, int32_t be)
 {
-	int32 bits = be - bs;
-	int32 n, span;
+	int32_t bits = be - bs;
+	int32_t n, span;
 
 	bp += bs>>3;
 	/*
@@ -922,22 +885,22 @@ find1span(unsigned char* bp, int32 bs, int32 be)
 		bp++;
 	} else
 		span = 0;
-	if (bits >= (int32)(2 * 8 * sizeof(long))) {
-		long* lp;
+	if (bits >= (int32_t)(2 * 8 * sizeof(int64_t))) {
+		int64_t* lp;
 		/*
-		 * Align to longword boundary and check longwords.
+		 * Align to int64_t boundary and check int64_t words.
 		 */
-		while (!isAligned(bp, long)) {
+		while (!isAligned(bp, int64_t)) {
 			if (*bp != 0xff)
 				return (span + oneruns[*bp]);
 			span += 8;
 			bits -= 8;
 			bp++;
 		}
-		lp = (long*) bp;
-		while ((bits >= (int32)(8 * sizeof(long))) && (~0 == *lp)) {
-			span += 8*sizeof (long);
-			bits -= 8*sizeof (long);
+		lp = (int64_t*) bp;
+		while ((bits >= (int32_t)(8 * sizeof(int64_t))) && (~((uint64_t)0) == (uint64_t)*lp)) {
+			span += 8*sizeof (int64_t);
+			bits -= 8*sizeof (int64_t);
 			lp++;
 		}
 		bp = (unsigned char*) lp;
@@ -983,20 +946,22 @@ find1span(unsigned char* bp, int32 bs, int32 be)
  * of pixels encoded with Huffman codes.
  */
 static int
-Fax3Encode1DRow(TIFF* tif, unsigned char* bp, uint32 bits)
+Fax3Encode1DRow(TIFF* tif, unsigned char* bp, uint32_t bits)
 {
 	Fax3CodecState* sp = EncoderState(tif);
-	int32 span;
-        uint32 bs = 0;
+	int32_t span;
+        uint32_t bs = 0;
 
 	for (;;) {
 		span = find0span(bp, bs, bits);		/* white span */
-		putspan(tif, span, TIFFFaxWhiteCodes);
+		if( !putspan(tif, span, TIFFFaxWhiteCodes) )
+                    return 0;
 		bs += span;
 		if (bs >= bits)
 			break;
 		span = find1span(bp, bs, bits);		/* black span */
-		putspan(tif, span, TIFFFaxBlackCodes);
+		if( !putspan(tif, span, TIFFFaxBlackCodes) )
+                    return 0;
 		bs += span;
 		if (bs >= bits)
 			break;
@@ -1005,7 +970,7 @@ Fax3Encode1DRow(TIFF* tif, unsigned char* bp, uint32 bits)
 		if (sp->bit != 8)			/* byte-align */
 			Fax3FlushBits(tif, sp);
 		if ((sp->b.mode&FAXMODE_WORDALIGN) &&
-		    !isAligned(tif->tif_rawcp, uint16))
+		    !isAligned(tif->tif_rawcp, uint16_t))
 			Fax3FlushBits(tif, sp);
 	}
 	return (1);
@@ -1030,39 +995,46 @@ static const tableentry vcodes[7] = {
  * documentation for the algorithm.
  */
 static int
-Fax3Encode2DRow(TIFF* tif, unsigned char* bp, unsigned char* rp, uint32 bits)
+Fax3Encode2DRow(TIFF* tif, unsigned char* bp, unsigned char* rp, uint32_t bits)
 {
 #define	PIXEL(buf,ix)	((((buf)[(ix)>>3]) >> (7-((ix)&7))) & 1)
-        uint32 a0 = 0;
-	uint32 a1 = (PIXEL(bp, 0) != 0 ? 0 : finddiff(bp, 0, bits, 0));
-	uint32 b1 = (PIXEL(rp, 0) != 0 ? 0 : finddiff(rp, 0, bits, 0));
-	uint32 a2, b2;
+        uint32_t a0 = 0;
+	uint32_t a1 = (PIXEL(bp, 0) != 0 ? 0 : finddiff(bp, 0, bits, 0));
+	uint32_t b1 = (PIXEL(rp, 0) != 0 ? 0 : finddiff(rp, 0, bits, 0));
+	uint32_t a2, b2;
 
 	for (;;) {
 		b2 = finddiff2(rp, b1, bits, PIXEL(rp,b1));
 		if (b2 >= a1) {
 			/* Naive computation triggers -fsanitize=undefined,unsigned-integer-overflow */
 			/* although it is correct unless the difference between both is < 31 bit */
-			/* int32 d = b1 - a1; */
-			int32 d = (b1 >= a1 && b1 - a1 <= 3U) ? (int32)(b1 - a1):
-			          (b1 < a1 && a1 - b1 <= 3U) ? -(int32)(a1 - b1) : 0x7FFFFFFF;
+			/* int32_t d = b1 - a1; */
+			int32_t d = (b1 >= a1 && b1 - a1 <= 3U) ? (int32_t)(b1 - a1) :
+                        (b1 < a1 && a1 - b1 <= 3U) ? -(int32_t)(a1 - b1) : 0x7FFFFFFF;
 			if (!(-3 <= d && d <= 3)) {	/* horizontal mode */
 				a2 = finddiff2(bp, a1, bits, PIXEL(bp,a1));
-				putcode(tif, &horizcode);
+				if( !putcode(tif, &horizcode) )
+                                    return 0;
 				if (a0+a1 == 0 || PIXEL(bp, a0) == 0) {
-					putspan(tif, a1-a0, TIFFFaxWhiteCodes);
-					putspan(tif, a2-a1, TIFFFaxBlackCodes);
+					if( !putspan(tif, a1-a0, TIFFFaxWhiteCodes) )
+                                            return 0;
+					if( !putspan(tif, a2-a1, TIFFFaxBlackCodes) )
+                                            return 0;
 				} else {
-					putspan(tif, a1-a0, TIFFFaxBlackCodes);
-					putspan(tif, a2-a1, TIFFFaxWhiteCodes);
+					if( !putspan(tif, a1-a0, TIFFFaxBlackCodes) )
+                                            return 0;
+					if( !putspan(tif, a2-a1, TIFFFaxWhiteCodes) )
+                                            return 0;
 				}
 				a0 = a2;
 			} else {			/* vertical mode */
-				putcode(tif, &vcodes[d+3]);
+				if( !putcode(tif, &vcodes[d+3]) )
+                                    return 0;
 				a0 = a1;
 			}
 		} else {				/* pass mode */
-			putcode(tif, &passcode);
+			if( !putcode(tif, &passcode) )
+                            return 0;
 			a0 = b2;
 		}
 		if (a0 >= bits)
@@ -1079,7 +1051,7 @@ Fax3Encode2DRow(TIFF* tif, unsigned char* bp, unsigned char* rp, uint32 bits)
  * Encode a buffer of pixels.
  */
 static int
-Fax3Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+Fax3Encode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "Fax3Encode";
 	Fax3CodecState* sp = EncoderState(tif);
@@ -1091,7 +1063,10 @@ Fax3Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 	}
 	while (cc > 0) {
 		if ((sp->b.mode & FAXMODE_NOEOL) == 0)
-			Fax3PutEOL(tif);
+                {
+			if( !Fax3PutEOL(tif) )
+                            return 0;
+                }
 		if (is2DEncoding(sp)) {
 			if (sp->tag == G3_1D) {
 				if (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels))
@@ -1128,8 +1103,8 @@ Fax3PostEncode(TIFF* tif)
 	return (1);
 }
 
-static void
-Fax3Close(TIFF* tif)
+static int
+_Fax3Close(TIFF* tif)
 {
 	if ((Fax3State(tif)->mode & FAXMODE_NORTC) == 0 && tif->tif_rawcp) {
 		Fax3CodecState* sp = EncoderState(tif);
@@ -1145,6 +1120,13 @@ Fax3Close(TIFF* tif)
 			Fax3PutBits(tif, code, length);
 		Fax3FlushBits(tif, sp);
 	}
+	return 1;
+}
+
+static void
+Fax3Close(TIFF* tif)
+{
+    _Fax3Close(tif);
 }
 
 static void
@@ -1189,7 +1171,7 @@ static const TIFFField fax4Fields[] = {
 };
 
 static int
-Fax3VSetField(TIFF* tif, uint32 tag, va_list ap)
+Fax3VSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	Fax3BaseState* sp = Fax3State(tif);
 	const TIFFField* fip;
@@ -1207,21 +1189,21 @@ Fax3VSetField(TIFF* tif, uint32 tag, va_list ap)
 	case TIFFTAG_GROUP3OPTIONS:
 		/* XXX: avoid reading options if compression mismatches. */
 		if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX3)
-			sp->groupoptions = (uint32) va_arg(ap, uint32);
+			sp->groupoptions = (uint32_t) va_arg(ap, uint32_t);
 		break;
 	case TIFFTAG_GROUP4OPTIONS:
 		/* XXX: avoid reading options if compression mismatches. */
 		if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4)
-			sp->groupoptions = (uint32) va_arg(ap, uint32);
+			sp->groupoptions = (uint32_t) va_arg(ap, uint32_t);
 		break;
 	case TIFFTAG_BADFAXLINES:
-		sp->badfaxlines = (uint32) va_arg(ap, uint32);
+		sp->badfaxlines = (uint32_t) va_arg(ap, uint32_t);
 		break;
 	case TIFFTAG_CLEANFAXDATA:
-		sp->cleanfaxdata = (uint16) va_arg(ap, uint16_vap);
+		sp->cleanfaxdata = (uint16_t) va_arg(ap, uint16_vap);
 		break;
 	case TIFFTAG_CONSECUTIVEBADFAXLINES:
-		sp->badfaxrun = (uint32) va_arg(ap, uint32);
+		sp->badfaxrun = (uint32_t) va_arg(ap, uint32_t);
 		break;
 	default:
 		return (*sp->vsetparent)(tif, tag, ap);
@@ -1237,7 +1219,7 @@ Fax3VSetField(TIFF* tif, uint32 tag, va_list ap)
 }
 
 static int
-Fax3VGetField(TIFF* tif, uint32 tag, va_list ap)
+Fax3VGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	Fax3BaseState* sp = Fax3State(tif);
 
@@ -1252,16 +1234,16 @@ Fax3VGetField(TIFF* tif, uint32 tag, va_list ap)
 		break;
 	case TIFFTAG_GROUP3OPTIONS:
 	case TIFFTAG_GROUP4OPTIONS:
-		*va_arg(ap, uint32*) = sp->groupoptions;
+		*va_arg(ap, uint32_t*) = sp->groupoptions;
 		break;
 	case TIFFTAG_BADFAXLINES:
-		*va_arg(ap, uint32*) = sp->badfaxlines;
+		*va_arg(ap, uint32_t*) = sp->badfaxlines;
 		break;
 	case TIFFTAG_CLEANFAXDATA:
-		*va_arg(ap, uint16*) = sp->cleanfaxdata;
+		*va_arg(ap, uint16_t*) = sp->cleanfaxdata;
 		break;
 	case TIFFTAG_CONSECUTIVEBADFAXLINES:
-		*va_arg(ap, uint32*) = sp->badfaxrun;
+		*va_arg(ap, uint32_t*) = sp->badfaxrun;
 		break;
 	default:
 		return (*sp->vgetparent)(tif, tag, ap);
@@ -1297,9 +1279,9 @@ Fax3PrintDir(TIFF* tif, FILE* fd, long flags)
 			if (sp->groupoptions & GROUP3OPT_UNCOMPRESSED)
 				fprintf(fd, "%suncompressed data", sep);
 		}
-		fprintf(fd, " (%lu = 0x%lx)\n",
-                        (unsigned long) sp->groupoptions,
-                        (unsigned long) sp->groupoptions);
+		fprintf(fd, " (%" PRIu32 " = 0x%" PRIx32 ")\n",
+                        sp->groupoptions,
+                        sp->groupoptions);
 	}
 	if (TIFFFieldSet(tif,FIELD_CLEANFAXDATA)) {
 		fprintf(fd, "  Fax Data:");
@@ -1314,15 +1296,15 @@ Fax3PrintDir(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, " uncorrected errors");
 			break;
 		}
-		fprintf(fd, " (%u = 0x%x)\n",
+		fprintf(fd, " (%"PRIu16" = 0x%"PRIx16")\n",
 		    sp->cleanfaxdata, sp->cleanfaxdata);
 	}
 	if (TIFFFieldSet(tif,FIELD_BADFAXLINES))
-		fprintf(fd, "  Bad Fax Lines: %lu\n",
-                        (unsigned long) sp->badfaxlines);
+		fprintf(fd, "  Bad Fax Lines: %" PRIu32 "\n",
+            sp->badfaxlines);
 	if (TIFFFieldSet(tif,FIELD_BADFAXRUN))
-		fprintf(fd, "  Consecutive Bad Fax Lines: %lu\n",
-		    (unsigned long) sp->badfaxrun);
+		fprintf(fd, "  Consecutive Bad Fax Lines: %" PRIu32 "\n",
+		    sp->badfaxrun);
 	if (sp->printdir)
 		(*sp->printdir)(tif, fd, flags);
 }
@@ -1345,7 +1327,7 @@ InitCCITTFax3(TIFF* tif)
 	/*
 	 * Allocate state block so tag methods have storage to record values.
 	 */
-	tif->tif_data = (uint8*)
+	tif->tif_data = (uint8_t*)
 		_TIFFmalloc(sizeof (Fax3CodecState));
 
 	if (tif->tif_data == NULL) {
@@ -1429,7 +1411,7 @@ TIFFInitCCITTFax3(TIFF* tif, int scheme)
  * Decode the requested amount of G4-encoded data.
  */
 static int
-Fax4Decode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
+Fax4Decode(TIFF* tif, uint8_t* buf, tmsize_t occ, uint16_t s)
 {
 	DECLARE_STATE_2D(tif, sp, "Fax4Decode");
 	(void) s;
@@ -1446,16 +1428,23 @@ Fax4Decode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		pb = sp->refruns;
 		b1 = *pb++;
 #ifdef FAX3_DEBUG
-		printf("\nBitAcc=%08X, BitsAvail = %d\n", BitAcc, BitsAvail);
+		printf("\nBitAcc=%08"PRIX32", BitsAvail = %d\n", BitAcc, BitsAvail);
 		printf("-------------------- %d\n", tif->tif_row);
 		fflush(stdout);
 #endif
 		EXPAND2D(EOFG4);
                 if (EOLcnt)
                     goto EOFG4;
+		if (((lastx + 7) >> 3) > (int)occ)	/* check for buffer overrun */
+		{
+			TIFFErrorExt(tif->tif_clientdata, module,
+			             "Buffer overrun detected : %"TIFF_SSIZE_FORMAT" bytes available, %d bits needed",
+			             occ, lastx);
+			return -1;
+		}
 		(*sp->fill)(buf, thisrun, pa, lastx);
 		SETVALUE(0);		/* imaginary change for reference */
-		SWAP(uint32*, sp->curruns, sp->refruns);
+		SWAP(uint32_t*, sp->curruns, sp->refruns);
 		buf += sp->b.rowbytes;
 		occ -= sp->b.rowbytes;
 		sp->line++;
@@ -1468,6 +1457,13 @@ Fax4Decode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
                     fputs( "Bad EOFB\n", stderr );
 #endif                
                 ClrBits( 13 );
+		if (((lastx + 7) >> 3) > (int)occ)	/* check for buffer overrun */
+		{
+			TIFFErrorExt(tif->tif_clientdata, module,
+			             "Buffer overrun detected : %"TIFF_SSIZE_FORMAT" bytes available, %d bits needed",
+			             occ, lastx);
+			return -1;
+		}
 		(*sp->fill)(buf, thisrun, pa, lastx);
 		UNCACHE_STATE(tif, sp);
 		return ( sp->line ? 1 : -1);	/* don't error on badly-terminated strips */
@@ -1481,7 +1477,7 @@ Fax4Decode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
  * Encode the requested amount of data.
  */
 static int
-Fax4Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+Fax4Encode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "Fax4Encode";
 	Fax3CodecState *sp = EncoderState(tif);
@@ -1553,7 +1549,7 @@ TIFFInitCCITTFax4(TIFF* tif, int scheme)
  * Decode the requested amount of RLE-encoded data.
  */
 static int
-Fax3DecodeRLE(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
+Fax3DecodeRLE(TIFF* tif, uint8_t* buf, tmsize_t occ, uint16_t s)
 {
 	DECLARE_STATE(tif, sp, "Fax3DecodeRLE");
 	int mode = sp->b.mode;
@@ -1570,8 +1566,8 @@ Fax3DecodeRLE(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		RunLength = 0;
 		pa = thisrun;
 #ifdef FAX3_DEBUG
-		printf("\nBitAcc=%08X, BitsAvail = %d\n", BitAcc, BitsAvail);
-		printf("-------------------- %d\n", tif->tif_row);
+		printf("\nBitAcc=%08"PRIX32", BitsAvail = %d\n", BitAcc, BitsAvail);
+		printf("-------------------- %"PRIu32"\n", tif->tif_row);
 		fflush(stdout);
 #endif
 		EXPAND1D(EOFRLE);
@@ -1585,7 +1581,7 @@ Fax3DecodeRLE(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		} else if (mode & FAXMODE_WORDALIGN) {
 			int n = BitsAvail - (BitsAvail &~ 15);
 			ClrBits(n);
-			if (BitsAvail == 0 && !isAligned(cp, uint16))
+			if (BitsAvail == 0 && !isAligned(cp, uint16_t))
 			    cp++;
 		}
 		buf += sp->b.rowbytes;
diff --git a/src/3rdparty/libtiff/libtiff/tif_fax3.h b/src/3rdparty/libtiff/libtiff/tif_fax3.h
index abadcd9..fdafe49 100644
--- a/src/3rdparty/libtiff/libtiff/tif_fax3.h
+++ b/src/3rdparty/libtiff/libtiff/tif_fax3.h
@@ -41,7 +41,7 @@
  * The routine must have the type signature given below;
  * for example:
  *
- * fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)
+ * fillruns(unsigned char* buf, uint32_t* runs, uint32_t* erun, uint32_t lastx)
  *
  * where buf is place to set the bits, runs is the array of b&w run
  * lengths (white then black), erun is the last run in the array, and
@@ -50,7 +50,7 @@
  * data in the run array as needed (e.g. to append zero runs to bring
  * the count up to a nice multiple).
  */
-typedef void (*TIFFFaxFillFunc)(unsigned char*, uint32*, uint32*, uint32);
+typedef void (*TIFFFaxFillFunc)(unsigned char*, uint32_t*, uint32_t*, uint32_t);
 
 /*
  * The default run filler; made external for other decoders.
@@ -58,7 +58,7 @@ typedef void (*TIFFFaxFillFunc)(unsigned char*, uint32*, uint32*, uint32);
 #if defined(__cplusplus)
 extern "C" {
 #endif
-extern void _TIFFFax3fillruns(unsigned char*, uint32*, uint32*, uint32);
+extern void _TIFFFax3fillruns(unsigned char*, uint32_t*, uint32_t*, uint32_t);
 #if defined(__cplusplus)
 }
 #endif
@@ -84,7 +84,7 @@ extern void _TIFFFax3fillruns(unsigned char*, uint32*, uint32*, uint32);
 typedef struct {                /* state table entry */
 	unsigned char State;    /* see above */
 	unsigned char Width;    /* width of code in bits */
-	uint32 Param;           /* unsigned 32-bit run length in bits (holds on 16 bit actually, but cannot be changed. See above warning) */
+	uint32_t Param;           /* unsigned 32-bit run length in bits (holds on 16 bit actually, but cannot be changed. See above warning) */
 } TIFFFaxTabEnt;
 
 extern const TIFFFaxTabEnt TIFFFaxMainTable[];
@@ -141,7 +141,7 @@ extern const TIFFFaxTabEnt TIFFFaxBlackTable[];
 		goto eoflab;						\
 	    BitsAvail = (n);			/* pad with zeros */	\
 	} else {							\
-	    BitAcc |= ((uint32) bitmap[*cp++])<<BitsAvail;		\
+	    BitAcc |= ((uint32_t) bitmap[*cp++])<<BitsAvail;		\
 	    BitsAvail += 8;						\
 	}								\
     }									\
@@ -155,13 +155,13 @@ extern const TIFFFaxTabEnt TIFFFaxBlackTable[];
 		goto eoflab;						\
 	    BitsAvail = (n);			/* pad with zeros */	\
 	} else {							\
-	    BitAcc |= ((uint32) bitmap[*cp++])<<BitsAvail;		\
+	    BitAcc |= ((uint32_t) bitmap[*cp++])<<BitsAvail;		\
 	    if ((BitsAvail += 8) < (n)) {				\
 		if (EndOfData()) {					\
 		    /* NB: we know BitsAvail is non-zero here */	\
 		    BitsAvail = (n);		/* pad with zeros */	\
 		} else {						\
-		    BitAcc |= ((uint32) bitmap[*cp++])<<BitsAvail;	\
+		    BitAcc |= ((uint32_t) bitmap[*cp++])<<BitsAvail;	\
 		    BitsAvail += 8;					\
 		}							\
 	    }								\
@@ -240,6 +240,11 @@ static const char* StateNames[] = {
  * current row and reset decoding state.
  */
 #define SETVALUE(x) do {							\
+    if (pa >= thisrun + sp->nruns) {					\
+        TIFFErrorExt(tif->tif_clientdata, module, "Buffer overflow at line %u of %s %u",	\
+                    sp->line, isTiled(tif) ? "tile" : "strip", isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip);	\
+        return (-1);							\
+    }									\
     *pa++ = RunLength + (x);						\
     a0 += (x);								\
     RunLength = 0;							\
@@ -377,6 +382,11 @@ done1d:									\
  */
 #define CHECK_b1 do {							\
     if (pa != thisrun) while (b1 <= a0 && b1 < lastx) {			\
+	if( pb + 1 >= sp->refruns + sp->nruns) { 			\
+	    TIFFErrorExt(tif->tif_clientdata, module, "Buffer overflow at line %u of %s %u",	\
+	                sp->line, isTiled(tif) ? "tile" : "strip", isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip);	\
+	    return (-1);						\
+	}								\
 	b1 += pb[0] + pb[1];						\
 	pb += 2;							\
     }									\
@@ -387,10 +397,20 @@ done1d:									\
  */
 #define EXPAND2D(eoflab) do {						\
     while (a0 < lastx) {						\
+	if (pa >= thisrun + sp->nruns) {				\
+		TIFFErrorExt(tif->tif_clientdata, module, "Buffer overflow at line %u of %s %u",	\
+		             sp->line, isTiled(tif) ? "tile" : "strip", isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip);	\
+		return (-1);						\
+	}								\
 	LOOKUP8(7, TIFFFaxMainTable, eof2d);				\
 	switch (TabEnt->State) {					\
 	case S_Pass:							\
 	    CHECK_b1;							\
+	    if( pb + 1 >= sp->refruns + sp->nruns) { 			\
+	        TIFFErrorExt(tif->tif_clientdata, module, "Buffer overflow at line %u of %s %u",	\
+	                sp->line, isTiled(tif) ? "tile" : "strip", isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip);	\
+	        return (-1);						\
+	    }								\
 	    b1 += *pb++;						\
 	    RunLength += b1 - a0;					\
 	    a0 = b1;							\
@@ -469,20 +489,28 @@ done1d:									\
 	case S_V0:							\
 	    CHECK_b1;							\
 	    SETVALUE(b1 - a0);						\
+	    if( pb >= sp->refruns + sp->nruns) { 			\
+	        TIFFErrorExt(tif->tif_clientdata, module, "Buffer overflow at line %u of %s %u",	\
+	                sp->line, isTiled(tif) ? "tile" : "strip", isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip);	\
+	        return (-1);						\
+	    }								\
 	    b1 += *pb++;						\
 	    break;							\
 	case S_VR:							\
 	    CHECK_b1;							\
 	    SETVALUE(b1 - a0 + TabEnt->Param);				\
+	    if( pb >= sp->refruns + sp->nruns) { 			\
+	        TIFFErrorExt(tif->tif_clientdata, module, "Buffer overflow at line %u of %s %u",	\
+	                sp->line, isTiled(tif) ? "tile" : "strip", isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip);	\
+	        return (-1);						\
+	    }								\
 	    b1 += *pb++;						\
 	    break;							\
 	case S_VL:							\
 	    CHECK_b1;							\
-	    if (b1 <= (int) (a0 + TabEnt->Param)) {			\
-		if (b1 < (int) (a0 + TabEnt->Param) || pa != thisrun) {	\
-		    unexpected("VL", a0);				\
-		    goto eol2d;						\
-		}							\
+	    if (b1 < (int) (a0 + TabEnt->Param)) {			\
+		unexpected("VL", a0);				\
+		goto eol2d;						\
 	    }								\
 	    SETVALUE(b1 - a0 - TabEnt->Param);				\
 	    b1 -= *--pb;						\
@@ -529,6 +557,7 @@ eol2d:									\
     CLEANUP_RUNS();							\
 } while (0)
 #endif /* _FAX3_ */
+/* vim: set ts=8 sts=4 sw=4 noet: */
 /*
  * Local Variables:
  * mode: c
diff --git a/src/3rdparty/libtiff/libtiff/tif_fax3sm.c b/src/3rdparty/libtiff/libtiff/tif_fax3sm.c
index 822191e..ba2fc53 100644
--- a/src/3rdparty/libtiff/libtiff/tif_fax3sm.c
+++ b/src/3rdparty/libtiff/libtiff/tif_fax3sm.c
@@ -1,5 +1,6 @@
 /* WARNING, this file was automatically generated by the
     mkg3states program */
+#include <stdint.h>
 #include "tiff.h"
 #include "tif_fax3.h"
  const TIFFFaxTabEnt TIFFFaxMainTable[128] = {
diff --git a/src/3rdparty/libtiff/libtiff/tif_getimage.c b/src/3rdparty/libtiff/libtiff/tif_getimage.c
index 4da785d..a1b6570 100644
--- a/src/3rdparty/libtiff/libtiff/tif_getimage.c
+++ b/src/3rdparty/libtiff/libtiff/tif_getimage.c
@@ -29,11 +29,12 @@
  */
 #include "tiffiop.h"
 #include <stdio.h>
+#include <limits.h>
 
-static int gtTileContig(TIFFRGBAImage*, uint32*, uint32, uint32);
-static int gtTileSeparate(TIFFRGBAImage*, uint32*, uint32, uint32);
-static int gtStripContig(TIFFRGBAImage*, uint32*, uint32, uint32);
-static int gtStripSeparate(TIFFRGBAImage*, uint32*, uint32, uint32);
+static int gtTileContig(TIFFRGBAImage*, uint32_t*, uint32_t, uint32_t);
+static int gtTileSeparate(TIFFRGBAImage*, uint32_t*, uint32_t, uint32_t);
+static int gtStripContig(TIFFRGBAImage*, uint32_t*, uint32_t, uint32_t);
+static int gtStripSeparate(TIFFRGBAImage*, uint32_t*, uint32_t, uint32_t);
 static int PickContigCase(TIFFRGBAImage*);
 static int PickSeparateCase(TIFFRGBAImage*);
 
@@ -74,7 +75,7 @@ int
 TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 {
 	TIFFDirectory* td = &tif->tif_dir;
-	uint16 photometric;
+	uint16_t photometric;
 	int colorchannels;
 
 	if (!tif->tif_decodestatus) {
@@ -89,7 +90,7 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 		case 16:
 			break;
 		default:
-			sprintf(emsg, "Sorry, can not handle images with %d-bit samples",
+			sprintf(emsg, "Sorry, can not handle images with %"PRIu16"-bit samples",
 			    td->td_bitspersample);
 			return (0);
 	}
@@ -119,8 +120,8 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 			    && td->td_samplesperpixel != 1
 			    && td->td_bitspersample < 8 ) {
 				sprintf(emsg,
-				    "Sorry, can not handle contiguous data with %s=%d, "
-				    "and %s=%d and Bits/Sample=%d",
+				    "Sorry, can not handle contiguous data with %s=%"PRIu16", "
+				    "and %s=%"PRIu16" and Bits/Sample=%"PRIu16"",
 				    photoTag, photometric,
 				    "Samples/pixel", td->td_samplesperpixel,
 				    td->td_bitspersample);
@@ -149,7 +150,7 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 			break;
 		case PHOTOMETRIC_SEPARATED:
 			{
-				uint16 inkset;
+				uint16_t inkset;
 				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
 				if (inkset != INKSET_CMYK) {
 					sprintf(emsg,
@@ -159,7 +160,7 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 				}
 				if (td->td_samplesperpixel < 4) {
 					sprintf(emsg,
-					    "Sorry, can not handle separated image with %s=%d",
+					    "Sorry, can not handle separated image with %s=%"PRIu16,
 					    "Samples/pixel", td->td_samplesperpixel);
 					return 0;
 				}
@@ -180,13 +181,13 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 				return (0);
 			}
 			if (td->td_planarconfig != PLANARCONFIG_CONTIG) {
-				sprintf(emsg, "Sorry, can not handle LogLuv images with %s=%d",
+				sprintf(emsg, "Sorry, can not handle LogLuv images with %s=%"PRIu16,
 				    "Planarconfiguration", td->td_planarconfig);
 				return (0);
 			}
 			if ( td->td_samplesperpixel != 3 || colorchannels != 3 ) {
                                 sprintf(emsg,
-                                        "Sorry, can not handle image with %s=%d, %s=%d",
+                                        "Sorry, can not handle image with %s=%"PRIu16", %s=%d",
                                         "Samples/pixel", td->td_samplesperpixel,
                                         "colorchannels", colorchannels);
                                 return 0;
@@ -195,7 +196,7 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 		case PHOTOMETRIC_CIELAB:
                         if ( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 ) {
                                 sprintf(emsg,
-                                        "Sorry, can not handle image with %s=%d, %s=%d and %s=%d",
+                                        "Sorry, can not handle image with %s=%"PRIu16", %s=%d and %s=%"PRIu16,
                                         "Samples/pixel", td->td_samplesperpixel,
                                         "colorchannels", colorchannels,
                                         "Bits/sample", td->td_bitspersample);
@@ -203,7 +204,7 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
                         }
 			break;
                 default:
-			sprintf(emsg, "Sorry, can not handle image with %s=%d",
+			sprintf(emsg, "Sorry, can not handle image with %s=%"PRIu16,
 			    photoTag, photometric);
 			return (0);
 	}
@@ -253,7 +254,7 @@ TIFFRGBAImageEnd(TIFFRGBAImage* img)
 static int
 isCCITTCompression(TIFF* tif)
 {
-    uint16 compress;
+    uint16_t compress;
     TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);
     return (compress == COMPRESSION_CCITTFAX3 ||
 	    compress == COMPRESSION_CCITTFAX4 ||
@@ -264,12 +265,12 @@ isCCITTCompression(TIFF* tif)
 int
 TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
 {
-	uint16* sampleinfo;
-	uint16 extrasamples;
-	uint16 planarconfig;
-	uint16 compress;
+	uint16_t* sampleinfo;
+	uint16_t extrasamples;
+	uint16_t planarconfig;
+	uint16_t compress;
 	int colorchannels;
-	uint16 *red_orig, *green_orig, *blue_orig;
+	uint16_t *red_orig, *green_orig, *blue_orig;
 	int n_color;
 	
 	if( !TIFFRGBAImageOK(tif, emsg) )
@@ -301,7 +302,7 @@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
 		case 16:
 			break;
 		default:
-			sprintf(emsg, "Sorry, can not handle images with %d-bit samples",
+			sprintf(emsg, "Sorry, can not handle images with %"PRIu16"-bit samples",
 			    img->bitspersample);
 			goto fail_return;
 	}
@@ -365,9 +366,9 @@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
 
 			/* copy the colormaps so we can modify them */
 			n_color = (1U << img->bitspersample);
-			img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
-			img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
-			img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
+			img->redcmap = (uint16_t *) _TIFFmalloc(sizeof(uint16_t) * n_color);
+			img->greencmap = (uint16_t *) _TIFFmalloc(sizeof(uint16_t) * n_color);
+			img->bluecmap = (uint16_t *) _TIFFmalloc(sizeof(uint16_t) * n_color);
 			if( !img->redcmap || !img->greencmap || !img->bluecmap ) {
 				sprintf(emsg, "Out of memory for colormap copy");
                                 goto fail_return;
@@ -384,8 +385,8 @@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
 			    && img->samplesperpixel != 1
 			    && img->bitspersample < 8 ) {
 				sprintf(emsg,
-				    "Sorry, can not handle contiguous data with %s=%d, "
-				    "and %s=%d and Bits/Sample=%d",
+				    "Sorry, can not handle contiguous data with %s=%"PRIu16", "
+				    "and %s=%"PRIu16" and Bits/Sample=%"PRIu16,
 				    photoTag, img->photometric,
 				    "Samples/pixel", img->samplesperpixel,
 				    img->bitspersample);
@@ -427,15 +428,15 @@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
 			break;
 		case PHOTOMETRIC_SEPARATED:
 			{
-				uint16 inkset;
+				uint16_t inkset;
 				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
 				if (inkset != INKSET_CMYK) {
-					sprintf(emsg, "Sorry, can not handle separated image with %s=%d",
+					sprintf(emsg, "Sorry, can not handle separated image with %s=%"PRIu16,
 					    "InkSet", inkset);
                                         goto fail_return;
 				}
 				if (img->samplesperpixel < 4) {
-					sprintf(emsg, "Sorry, can not handle separated image with %s=%d",
+					sprintf(emsg, "Sorry, can not handle separated image with %s=%"PRIu16,
 					    "Samples/pixel", img->samplesperpixel);
                                         goto fail_return;
 				}
@@ -458,7 +459,7 @@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
                                 goto fail_return;
 			}
 			if (planarconfig != PLANARCONFIG_CONTIG) {
-				sprintf(emsg, "Sorry, can not handle LogLuv images with %s=%d",
+				sprintf(emsg, "Sorry, can not handle LogLuv images with %s=%"PRIu16,
 				    "Planarconfiguration", planarconfig);
 				return (0);
 			}
@@ -469,7 +470,7 @@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
 		case PHOTOMETRIC_CIELAB:
 			break;
 		default:
-			sprintf(emsg, "Sorry, can not handle image with %s=%d",
+			sprintf(emsg, "Sorry, can not handle image with %s=%"PRIu16,
 			    photoTag, img->photometric);
                         goto fail_return;
 	}
@@ -497,7 +498,7 @@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
 }
 
 int
-TIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
+TIFFRGBAImageGet(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 {
     if (img->get == NULL) {
 		TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), "No \"get\" routine setup");
@@ -517,15 +518,15 @@ TIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
  */
 int
 TIFFReadRGBAImageOriented(TIFF* tif,
-			  uint32 rwidth, uint32 rheight, uint32* raster,
-			  int orientation, int stop)
+                          uint32_t rwidth, uint32_t rheight, uint32_t* raster,
+                          int orientation, int stop)
 {
     char emsg[1024] = "";
     TIFFRGBAImage img;
     int ok;
 
 	if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop, emsg)) {
-		img.req_orientation = (uint16)orientation;
+		img.req_orientation = (uint16_t)orientation;
 		/* XXX verify rwidth and rheight against width and height */
 		ok = TIFFRGBAImageGet(&img, raster+(rheight-img.height)*rwidth,
 			rwidth, img.height);
@@ -543,7 +544,7 @@ TIFFReadRGBAImageOriented(TIFF* tif,
  */
 int
 TIFFReadRGBAImage(TIFF* tif,
-		  uint32 rwidth, uint32 rheight, uint32* raster, int stop)
+                  uint32_t rwidth, uint32_t rheight, uint32_t* raster, int stop)
 {
 	return TIFFReadRGBAImageOriented(tif, rwidth, rheight, raster,
 					 ORIENTATION_BOTLEFT, stop);
@@ -617,21 +618,21 @@ setorientation(TIFFRGBAImage* img)
  *	SamplesPerPixel == 1
  */	
 static int
-gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
+gtTileContig(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 {
     TIFF* tif = img->tif;
     tileContigRoutine put = img->put.contig;
-    uint32 col, row, y, rowstoread;
+    uint32_t col, row, y, rowstoread;
     tmsize_t pos;
-    uint32 tw, th;
+    uint32_t tw, th;
     unsigned char* buf = NULL;
-    int32 fromskew, toskew;
-    uint32 nrow;
+    int32_t fromskew, toskew;
+    uint32_t nrow;
     int ret = 1, flip;
-    uint32 this_tw, tocol;
-    int32 this_toskew, leftmost_toskew;
-    int32 leftmost_fromskew;
-    uint32 leftmost_tw;
+    uint32_t this_tw, tocol;
+    int32_t this_toskew, leftmost_toskew;
+    int32_t leftmost_fromskew;
+    uint32_t leftmost_tw;
     tmsize_t bufsize;
 
     bufsize = TIFFTileSize(tif);
@@ -645,12 +646,20 @@ gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 
     flip = setorientation(img);
     if (flip & FLIP_VERTICALLY) {
-	    y = h - 1;
-	    toskew = -(int32)(tw + w);
+        if ((tw + w) > INT_MAX) {
+            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "%s", "unsupported tile size (too wide)");
+            return (0);
+        }
+        y = h - 1;
+        toskew = -(int32_t)(tw + w);
     }
     else {
-	    y = 0;
-	    toskew = -(int32)(tw - w);
+        if (tw > (INT_MAX + w)) {
+            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "%s", "unsupported tile size (too wide)");
+            return (0);
+        }
+        y = 0;
+        toskew = -(int32_t)(tw - w);
     }
      
     /*
@@ -699,19 +708,19 @@ gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 	    this_toskew = toskew;
 	}
 
-        y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);
+        y += ((flip & FLIP_VERTICALLY) ? -(int32_t) nrow : (int32_t) nrow);
     }
     _TIFFfree(buf);
 
     if (flip & FLIP_HORIZONTALLY) {
-	    uint32 line;
+	    uint32_t line;
 
 	    for (line = 0; line < h; line++) {
-		    uint32 *left = raster + (line * w);
-		    uint32 *right = left + w - 1;
+		    uint32_t *left = raster + (line * w);
+		    uint32_t *right = left + w - 1;
 		    
 		    while ( left < right ) {
-			    uint32 temp = *left;
+			    uint32_t temp = *left;
 			    *left = *right;
 			    *right = temp;
 			    left++;
@@ -730,13 +739,13 @@ gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
  * We assume that all such images are RGB.
  */	
 static int
-gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
+gtTileSeparate(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 {
 	TIFF* tif = img->tif;
 	tileSeparateRoutine put = img->put.separate;
-	uint32 col, row, y, rowstoread;
+	uint32_t col, row, y, rowstoread;
 	tmsize_t pos;
-	uint32 tw, th;
+	uint32_t tw, th;
 	unsigned char* buf = NULL;
 	unsigned char* p0 = NULL;
 	unsigned char* p1 = NULL;
@@ -744,15 +753,15 @@ gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 	unsigned char* pa = NULL;
 	tmsize_t tilesize;
 	tmsize_t bufsize;
-	int32 fromskew, toskew;
+	int32_t fromskew, toskew;
 	int alpha = img->alpha;
-	uint32 nrow;
+	uint32_t nrow;
 	int ret = 1, flip;
-        uint16 colorchannels;
-	uint32 this_tw, tocol;
-	int32 this_toskew, leftmost_toskew;
-	int32 leftmost_fromskew;
-	uint32 leftmost_tw;
+        uint16_t colorchannels;
+	uint32_t this_tw, tocol;
+	int32_t this_toskew, leftmost_toskew;
+	int32_t leftmost_fromskew;
+	uint32_t leftmost_tw;
 
 	tilesize = TIFFTileSize(tif);  
 	bufsize = _TIFFMultiplySSize(tif, alpha?4:3,tilesize, "gtTileSeparate");
@@ -765,12 +774,20 @@ gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 
 	flip = setorientation(img);
 	if (flip & FLIP_VERTICALLY) {
+		if ((tw + w) > INT_MAX) {
+            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "%s", "unsupported tile size (too wide)");
+            return (0);
+        }
 		y = h - 1;
-		toskew = -(int32)(tw + w);
+		toskew = -(int32_t)(tw + w);
 	}
 	else {
+		if (tw > (INT_MAX + w)) {
+            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "%s", "unsupported tile size (too wide)");
+            return (0);
+        }
 		y = 0;
-		toskew = -(int32)(tw - w);
+		toskew = -(int32_t)(tw - w);
 	}
 
         switch( img->photometric )
@@ -880,18 +897,18 @@ gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 			this_toskew = toskew;
 		}
 
-		y += ((flip & FLIP_VERTICALLY) ?-(int32) nrow : (int32) nrow);
+		y += ((flip & FLIP_VERTICALLY) ? -(int32_t) nrow : (int32_t) nrow);
 	}
 
 	if (flip & FLIP_HORIZONTALLY) {
-		uint32 line;
+		uint32_t line;
 
 		for (line = 0; line < h; line++) {
-			uint32 *left = raster + (line * w);
-			uint32 *right = left + w - 1;
+			uint32_t *left = raster + (line * w);
+			uint32_t *right = left + w - 1;
 
 			while ( left < right ) {
-				uint32 temp = *left;
+				uint32_t temp = *left;
 				*left = *right;
 				*right = temp;
 				left++;
@@ -911,18 +928,18 @@ gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
  *	SamplesPerPixel == 1
  */	
 static int
-gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
+gtStripContig(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 {
 	TIFF* tif = img->tif;
 	tileContigRoutine put = img->put.contig;
-	uint32 row, y, nrow, nrowsub, rowstoread;
+	uint32_t row, y, nrow, nrowsub, rowstoread;
 	tmsize_t pos;
 	unsigned char* buf = NULL;
-	uint32 rowsperstrip;
-	uint16 subsamplinghor,subsamplingver;
-	uint32 imagewidth = img->width;
+	uint32_t rowsperstrip;
+	uint16_t subsamplinghor,subsamplingver;
+	uint32_t imagewidth = img->width;
 	tmsize_t scanline;
-	int32 fromskew, toskew;
+	int32_t fromskew, toskew;
 	int ret = 1, flip;
         tmsize_t maxstripsize;
 
@@ -936,11 +953,15 @@ gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 
 	flip = setorientation(img);
 	if (flip & FLIP_VERTICALLY) {
+		if ( w > INT_MAX ) {
+        	TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "Width overflow");
+			return (0);
+		}
 		y = h - 1;
-		toskew = -(int32)(w + w);
+		toskew = -(int32_t)(w + w);
 	} else {
 		y = 0;
-		toskew = -(int32)(w - w);
+		toskew = -(int32_t)(w - w);
 	}
 
 	TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
@@ -949,7 +970,7 @@ gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 	fromskew = (w < imagewidth ? imagewidth - w : 0);
 	for (row = 0; row < h; row += nrow)
 	{
-		uint32 temp;
+		uint32_t temp;
 		rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;
 		nrow = (row + rowstoread > h ? h - row : rowstoread);
 		nrowsub = nrow;
@@ -975,18 +996,18 @@ gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 		pos = ((row + img->row_offset) % rowsperstrip) * scanline + \
 			((tmsize_t) img->col_offset * img->samplesperpixel);
 		(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);
-		y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);
+		y += ((flip & FLIP_VERTICALLY) ? -(int32_t) nrow : (int32_t) nrow);
 	}
 
 	if (flip & FLIP_HORIZONTALLY) {
-		uint32 line;
+		uint32_t line;
 
 		for (line = 0; line < h; line++) {
-			uint32 *left = raster + (line * w);
-			uint32 *right = left + w - 1;
+			uint32_t *left = raster + (line * w);
+			uint32_t *right = left + w - 1;
 
 			while ( left < right ) {
-				uint32 temp = *left;
+				uint32_t temp = *left;
 				*left = *right;
 				*right = temp;
 				left++;
@@ -1006,23 +1027,23 @@ gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
  * We assume that all such images are RGB.
  */
 static int
-gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
+gtStripSeparate(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)
 {
 	TIFF* tif = img->tif;
 	tileSeparateRoutine put = img->put.separate;
 	unsigned char *buf = NULL;
 	unsigned char *p0 = NULL, *p1 = NULL, *p2 = NULL, *pa = NULL;
-	uint32 row, y, nrow, rowstoread;
+	uint32_t row, y, nrow, rowstoread;
 	tmsize_t pos;
 	tmsize_t scanline;
-	uint32 rowsperstrip, offset_row;
-	uint32 imagewidth = img->width;
+	uint32_t rowsperstrip, offset_row;
+	uint32_t imagewidth = img->width;
 	tmsize_t stripsize;
 	tmsize_t bufsize;
-	int32 fromskew, toskew;
+	int32_t fromskew, toskew;
 	int alpha = img->alpha;
 	int ret = 1, flip;
-        uint16 colorchannels;
+        uint16_t colorchannels;
 
 	stripsize = TIFFStripSize(tif);  
 	bufsize = _TIFFMultiplySSize(tif,alpha?4:3,stripsize, "gtStripSeparate");
@@ -1032,12 +1053,16 @@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 
 	flip = setorientation(img);
 	if (flip & FLIP_VERTICALLY) {
+		if ( w > INT_MAX ) {
+        	TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "Width overflow");
+			return (0);
+		}
 		y = h - 1;
-		toskew = -(int32)(w + w);
+		toskew = -(int32_t)(w + w);
 	}
 	else {
 		y = 0;
-		toskew = -(int32)(w - w);
+		toskew = -(int32_t)(w - w);
 	}
 
         switch( img->photometric )
@@ -1058,7 +1083,7 @@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 	fromskew = (w < imagewidth ? imagewidth - w : 0);
 	for (row = 0; row < h; row += nrow)
 	{
-                uint32 temp;
+                uint32_t temp;
 		rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;
 		nrow = (row + rowstoread > h ? h - row : rowstoread);
 		offset_row = row + img->row_offset;
@@ -1130,18 +1155,18 @@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 			((tmsize_t) img->col_offset * img->samplesperpixel);
 		(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,
 		    p2 + pos, (alpha?(pa+pos):NULL));
-		y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);
+		y += ((flip & FLIP_VERTICALLY) ? -(int32_t) nrow : (int32_t) nrow);
 	}
 
 	if (flip & FLIP_HORIZONTALLY) {
-		uint32 line;
+		uint32_t line;
 
 		for (line = 0; line < h; line++) {
-			uint32 *left = raster + (line * w);
-			uint32 *right = left + w - 1;
+			uint32_t *left = raster + (line * w);
+			uint32_t *right = left + w - 1;
 
 			while ( left < right ) {
-				uint32 temp = *left;
+				uint32_t temp = *left;
 				*left = *right;
 				*right = temp;
 				left++;
@@ -1181,7 +1206,7 @@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 #define	NOP
 
 #define	UNROLL8(w, op1, op2) {		\
-    uint32 _x;				\
+    uint32_t _x;				\
     for (_x = w; _x >= 8; _x -= 8) {	\
 	op1;				\
 	REPEAT8(op2);			\
@@ -1192,7 +1217,7 @@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
     }					\
 }
 #define	UNROLL4(w, op1, op2) {		\
-    uint32 _x;				\
+    uint32_t _x;				\
     for (_x = w; _x >= 4; _x -= 4) {	\
 	op1;				\
 	REPEAT4(op2);			\
@@ -1203,7 +1228,7 @@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
     }					\
 }
 #define	UNROLL2(w, op1, op2) {		\
-    uint32 _x;				\
+    uint32_t _x;				\
     for (_x = w; _x >= 2; _x -= 2) {	\
 	op1;				\
 	REPEAT2(op2);			\
@@ -1217,25 +1242,25 @@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 #define	SKEW(r,g,b,skew)	{ r += skew; g += skew; b += skew; }
 #define	SKEW4(r,g,b,a,skew)	{ r += skew; g += skew; b += skew; a+= skew; }
 
-#define A1 (((uint32)0xffL)<<24)
+#define A1 (((uint32_t)0xffL)<<24)
 #define	PACK(r,g,b)	\
-	((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|A1)
+	((uint32_t)(r)|((uint32_t)(g)<<8)|((uint32_t)(b)<<16)|A1)
 #define	PACK4(r,g,b,a)	\
-	((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|((uint32)(a)<<24))
+	((uint32_t)(r)|((uint32_t)(g)<<8)|((uint32_t)(b)<<16)|((uint32_t)(a)<<24))
 #define W2B(v) (((v)>>8)&0xff)
 /* TODO: PACKW should have be made redundant in favor of Bitdepth16To8 LUT */
 #define	PACKW(r,g,b)	\
-	((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|A1)
+	((uint32_t)W2B(r)|((uint32_t)W2B(g)<<8)|((uint32_t)W2B(b)<<16)|A1)
 #define	PACKW4(r,g,b,a)	\
-	((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|((uint32)W2B(a)<<24))
+	((uint32_t)W2B(r)|((uint32_t)W2B(g)<<8)|((uint32_t)W2B(b)<<16)|((uint32_t)W2B(a)<<24))
 
 #define	DECLAREContigPutFunc(name) \
 static void name(\
     TIFFRGBAImage* img, \
-    uint32* cp, \
-    uint32 x, uint32 y, \
-    uint32 w, uint32 h, \
-    int32 fromskew, int32 toskew, \
+    uint32_t* cp, \
+    uint32_t x, uint32_t y, \
+    uint32_t w, uint32_t h, \
+    int32_t fromskew, int32_t toskew, \
     unsigned char* pp \
 )
 
@@ -1244,7 +1269,7 @@ static void name(\
  */
 DECLAREContigPutFunc(put8bitcmaptile)
 {
-    uint32** PALmap = img->PALmap;
+    uint32_t** PALmap = img->PALmap;
     int samplesperpixel = img->samplesperpixel;
 
     (void) y;
@@ -1264,12 +1289,12 @@ DECLAREContigPutFunc(put8bitcmaptile)
  */
 DECLAREContigPutFunc(put4bitcmaptile)
 {
-    uint32** PALmap = img->PALmap;
+    uint32_t** PALmap = img->PALmap;
 
     (void) x; (void) y;
     fromskew /= 2;
     for( ; h > 0; --h) {
-	uint32* bw;
+	uint32_t* bw;
 	UNROLL2(w, bw = PALmap[*pp++], *cp++ = *bw++);
 	cp += toskew;
 	pp += fromskew;
@@ -1281,12 +1306,12 @@ DECLAREContigPutFunc(put4bitcmaptile)
  */
 DECLAREContigPutFunc(put2bitcmaptile)
 {
-    uint32** PALmap = img->PALmap;
+    uint32_t** PALmap = img->PALmap;
 
     (void) x; (void) y;
     fromskew /= 4;
     for( ; h > 0; --h) {
-	uint32* bw;
+	uint32_t* bw;
 	UNROLL4(w, bw = PALmap[*pp++], *cp++ = *bw++);
 	cp += toskew;
 	pp += fromskew;
@@ -1298,12 +1323,12 @@ DECLAREContigPutFunc(put2bitcmaptile)
  */
 DECLAREContigPutFunc(put1bitcmaptile)
 {
-    uint32** PALmap = img->PALmap;
+    uint32_t** PALmap = img->PALmap;
 
     (void) x; (void) y;
     fromskew /= 8;
     for( ; h > 0; --h) {
-	uint32* bw;
+	uint32_t* bw;
 	UNROLL8(w, bw = PALmap[*pp++], *cp++ = *bw++);
 	cp += toskew;
 	pp += fromskew;
@@ -1316,7 +1341,7 @@ DECLAREContigPutFunc(put1bitcmaptile)
 DECLAREContigPutFunc(putgreytile)
 {
     int samplesperpixel = img->samplesperpixel;
-    uint32** BWmap = img->BWmap;
+    uint32_t** BWmap = img->BWmap;
 
     (void) y;
     for( ; h > 0; --h) {
@@ -1336,13 +1361,13 @@ DECLAREContigPutFunc(putgreytile)
 DECLAREContigPutFunc(putagreytile)
 {
     int samplesperpixel = img->samplesperpixel;
-    uint32** BWmap = img->BWmap;
+    uint32_t** BWmap = img->BWmap;
 
     (void) y;
     for( ; h > 0; --h) {
 	for (x = w; x > 0; --x)
         {
-            *cp++ = BWmap[*pp][0] & ((uint32)*(pp+1) << 24 | ~A1);
+            *cp++ = BWmap[*pp][0] & ((uint32_t)*(pp + 1) << 24 | ~A1);
             pp += samplesperpixel;
         }
 	cp += toskew;
@@ -1356,11 +1381,11 @@ DECLAREContigPutFunc(putagreytile)
 DECLAREContigPutFunc(put16bitbwtile)
 {
     int samplesperpixel = img->samplesperpixel;
-    uint32** BWmap = img->BWmap;
+    uint32_t** BWmap = img->BWmap;
 
     (void) y;
     for( ; h > 0; --h) {
-        uint16 *wp = (uint16 *) pp;
+        uint16_t *wp = (uint16_t *) pp;
 
 	for (x = w; x > 0; --x)
         {
@@ -1380,12 +1405,12 @@ DECLAREContigPutFunc(put16bitbwtile)
  */
 DECLAREContigPutFunc(put1bitbwtile)
 {
-    uint32** BWmap = img->BWmap;
+    uint32_t** BWmap = img->BWmap;
 
     (void) x; (void) y;
     fromskew /= 8;
     for( ; h > 0; --h) {
-	uint32* bw;
+	uint32_t* bw;
 	UNROLL8(w, bw = BWmap[*pp++], *cp++ = *bw++);
 	cp += toskew;
 	pp += fromskew;
@@ -1397,12 +1422,12 @@ DECLAREContigPutFunc(put1bitbwtile)
  */
 DECLAREContigPutFunc(put2bitbwtile)
 {
-    uint32** BWmap = img->BWmap;
+    uint32_t** BWmap = img->BWmap;
 
     (void) x; (void) y;
     fromskew /= 4;
     for( ; h > 0; --h) {
-	uint32* bw;
+	uint32_t* bw;
 	UNROLL4(w, bw = BWmap[*pp++], *cp++ = *bw++);
 	cp += toskew;
 	pp += fromskew;
@@ -1414,12 +1439,12 @@ DECLAREContigPutFunc(put2bitbwtile)
  */
 DECLAREContigPutFunc(put4bitbwtile)
 {
-    uint32** BWmap = img->BWmap;
+    uint32_t** BWmap = img->BWmap;
 
     (void) x; (void) y;
     fromskew /= 2;
     for( ; h > 0; --h) {
-	uint32* bw;
+	uint32_t* bw;
 	UNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);
 	cp += toskew;
 	pp += fromskew;
@@ -1473,8 +1498,8 @@ DECLAREContigPutFunc(putRGBUAcontig8bittile)
 	(void) y;
 	fromskew *= samplesperpixel;
 	for( ; h > 0; --h) {
-		uint32 r, g, b, a;
-		uint8* m;
+		uint32_t r, g, b, a;
+		uint8_t* m;
 		for (x = w; x > 0; --x) {
 			a = pp[3];
 			m = img->UaToAa+((size_t) a<<8);
@@ -1495,7 +1520,7 @@ DECLAREContigPutFunc(putRGBUAcontig8bittile)
 DECLAREContigPutFunc(putRGBcontig16bittile)
 {
 	int samplesperpixel = img->samplesperpixel;
-	uint16 *wp = (uint16 *)pp;
+	uint16_t *wp = (uint16_t *)pp;
 	(void) y;
 	fromskew *= samplesperpixel;
 	for( ; h > 0; --h) {
@@ -1517,7 +1542,7 @@ DECLAREContigPutFunc(putRGBcontig16bittile)
 DECLAREContigPutFunc(putRGBAAcontig16bittile)
 {
 	int samplesperpixel = img->samplesperpixel;
-	uint16 *wp = (uint16 *)pp;
+	uint16_t *wp = (uint16_t *)pp;
 	(void) y;
 	fromskew *= samplesperpixel;
 	for( ; h > 0; --h) {
@@ -1540,12 +1565,12 @@ DECLAREContigPutFunc(putRGBAAcontig16bittile)
 DECLAREContigPutFunc(putRGBUAcontig16bittile)
 {
 	int samplesperpixel = img->samplesperpixel;
-	uint16 *wp = (uint16 *)pp;
+	uint16_t *wp = (uint16_t *)pp;
 	(void) y;
 	fromskew *= samplesperpixel;
 	for( ; h > 0; --h) {
-		uint32 r,g,b,a;
-		uint8* m;
+		uint32_t r,g,b,a;
+		uint8_t* m;
 		for (x = w; x > 0; --x) {
 			a = img->Bitdepth16To8[wp[3]];
 			m = img->UaToAa+((size_t) a<<8);
@@ -1568,7 +1593,7 @@ DECLAREContigPutFunc(putRGBUAcontig16bittile)
 DECLAREContigPutFunc(putRGBcontig8bitCMYKtile)
 {
     int samplesperpixel = img->samplesperpixel;
-    uint16 r, g, b, k;
+    uint16_t r, g, b, k;
 
     (void) x; (void) y;
     fromskew *= samplesperpixel;
@@ -1594,7 +1619,7 @@ DECLAREContigPutFunc(putRGBcontig8bitCMYKMaptile)
 {
     int samplesperpixel = img->samplesperpixel;
     TIFFRGBValue* Map = img->Map;
-    uint16 r, g, b, k;
+    uint16_t r, g, b, k;
 
     (void) y;
     fromskew *= samplesperpixel;
@@ -1615,10 +1640,10 @@ DECLAREContigPutFunc(putRGBcontig8bitCMYKMaptile)
 #define	DECLARESepPutFunc(name) \
 static void name(\
     TIFFRGBAImage* img,\
-    uint32* cp,\
-    uint32 x, uint32 y, \
-    uint32 w, uint32 h,\
-    int32 fromskew, int32 toskew,\
+    uint32_t* cp,\
+    uint32_t x, uint32_t y, \
+    uint32_t w, uint32_t h,\
+    int32_t fromskew, int32_t toskew,\
     unsigned char* r, unsigned char* g, unsigned char* b, unsigned char* a\
 )
 
@@ -1655,7 +1680,7 @@ DECLARESepPutFunc(putCMYKseparate8bittile)
 {
 	(void) img; (void) y;
 	for( ; h > 0; --h) {
-		uint32 rv, gv, bv, kv;
+		uint32_t rv, gv, bv, kv;
 		for (x = w; x > 0; --x) {
 			kv = 255 - *a++;
 			rv = (kv*(255-*r++))/255;
@@ -1675,8 +1700,8 @@ DECLARESepPutFunc(putRGBUAseparate8bittile)
 {
 	(void) img; (void) y;
 	for( ; h > 0; --h) {
-		uint32 rv, gv, bv, av;
-		uint8* m;
+		uint32_t rv, gv, bv, av;
+		uint8_t* m;
 		for (x = w; x > 0; --x) {
 			av = *a++;
 			m = img->UaToAa+((size_t) av<<8);
@@ -1695,9 +1720,9 @@ DECLARESepPutFunc(putRGBUAseparate8bittile)
  */
 DECLARESepPutFunc(putRGBseparate16bittile)
 {
-	uint16 *wr = (uint16*) r;
-	uint16 *wg = (uint16*) g;
-	uint16 *wb = (uint16*) b;
+	uint16_t *wr = (uint16_t*) r;
+	uint16_t *wg = (uint16_t*) g;
+	uint16_t *wb = (uint16_t*) b;
 	(void) img; (void) y; (void) a;
 	for( ; h > 0; --h) {
 		for (x = 0; x < w; x++)
@@ -1714,10 +1739,10 @@ DECLARESepPutFunc(putRGBseparate16bittile)
  */
 DECLARESepPutFunc(putRGBAAseparate16bittile)
 {
-	uint16 *wr = (uint16*) r;
-	uint16 *wg = (uint16*) g;
-	uint16 *wb = (uint16*) b;
-	uint16 *wa = (uint16*) a;
+	uint16_t *wr = (uint16_t*) r;
+	uint16_t *wg = (uint16_t*) g;
+	uint16_t *wb = (uint16_t*) b;
+	uint16_t *wa = (uint16_t*) a;
 	(void) img; (void) y;
 	for( ; h > 0; --h) {
 		for (x = 0; x < w; x++)
@@ -1735,14 +1760,14 @@ DECLARESepPutFunc(putRGBAAseparate16bittile)
  */
 DECLARESepPutFunc(putRGBUAseparate16bittile)
 {
-	uint16 *wr = (uint16*) r;
-	uint16 *wg = (uint16*) g;
-	uint16 *wb = (uint16*) b;
-	uint16 *wa = (uint16*) a;
+	uint16_t *wr = (uint16_t*) r;
+	uint16_t *wg = (uint16_t*) g;
+	uint16_t *wb = (uint16_t*) b;
+	uint16_t *wa = (uint16_t*) a;
 	(void) img; (void) y;
 	for( ; h > 0; --h) {
-		uint32 r2,g2,b2,a2;
-		uint8* m;
+		uint32_t r2,g2,b2,a2;
+		uint8_t* m;
 		for (x = w; x > 0; --x) {
 			a2 = img->Bitdepth16To8[*wa++];
 			m = img->UaToAa+((size_t) a2<<8);
@@ -1762,7 +1787,7 @@ DECLARESepPutFunc(putRGBUAseparate16bittile)
 DECLAREContigPutFunc(putcontig8bitCIELab)
 {
 	float X, Y, Z;
-	uint32 r, g, b;
+	uint32_t r, g, b;
 	(void) y;
 	fromskew *= 3;
 	for( ; h > 0; --h) {
@@ -1786,7 +1811,7 @@ DECLAREContigPutFunc(putcontig8bitCIELab)
  */
 
 #define	YCbCrtoRGB(dst, Y) {						\
-	uint32 r, g, b;							\
+	uint32_t r, g, b;							\
 	TIFFYCbCrtoRGB(img->ycbcr, (Y), Cb, Cr, &r, &g, &b);		\
 	dst = PACK(r, g, b);						\
 }
@@ -1802,20 +1827,20 @@ DECLAREContigPutFunc(putcontig8bitCIELab)
 #ifdef notdef
 static void putcontig8bitYCbCrGenericTile( 
     TIFFRGBAImage* img, 
-    uint32* cp, 
-    uint32 x, uint32 y, 
-    uint32 w, uint32 h, 
-    int32 fromskew, int32 toskew, 
+    uint32_t* cp,
+    uint32_t x, uint32_t y,
+    uint32_t w, uint32_t h,
+    int32_t fromskew, int32_t toskew,
     unsigned char* pp,
     int h_group, 
     int v_group )
 
 {
-    uint32* cp1 = cp+w+toskew;
-    uint32* cp2 = cp1+w+toskew;
-    uint32* cp3 = cp2+w+toskew;
-    int32 incr = 3*w+4*toskew;
-    int32   Cb, Cr;
+    uint32_t* cp1 = cp+w+toskew;
+    uint32_t* cp2 = cp1+w+toskew;
+    uint32_t* cp3 = cp2+w+toskew;
+    int32_t incr = 3*w+4*toskew;
+    int32_t   Cb, Cr;
     int     group_size = v_group * h_group + 2;
 
     (void) y;
@@ -1872,10 +1897,10 @@ static void putcontig8bitYCbCrGenericTile(
  */
 DECLAREContigPutFunc(putcontig8bitYCbCr44tile)
 {
-    uint32* cp1 = cp+w+toskew;
-    uint32* cp2 = cp1+w+toskew;
-    uint32* cp3 = cp2+w+toskew;
-    int32 incr = 3*w+4*toskew;
+    uint32_t* cp1 = cp + w + toskew;
+    uint32_t* cp2 = cp1 + w + toskew;
+    uint32_t* cp3 = cp2 + w + toskew;
+    int32_t incr = 3 * w + 4 * toskew;
 
     (void) y;
     /* adjust fromskew */
@@ -1884,8 +1909,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr44tile)
         for (; h >= 4; h -= 4) {
             x = w>>2;
             do {
-                int32 Cb = pp[16];
-                int32 Cr = pp[17];
+                int32_t Cb = pp[16];
+                int32_t Cr = pp[17];
 
                 YCbCrtoRGB(cp [0], pp[ 0]);
                 YCbCrtoRGB(cp [1], pp[ 1]);
@@ -1919,8 +1944,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr44tile)
     } else {
         while (h > 0) {
             for (x = w; x > 0;) {
-                int32 Cb = pp[16];
-                int32 Cr = pp[17];
+                int32_t Cb = pp[16];
+                int32_t Cr = pp[17];
                 switch (x) {
                 default:
                     switch (h) {
@@ -1978,8 +2003,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr44tile)
  */
 DECLAREContigPutFunc(putcontig8bitYCbCr42tile)
 {
-    uint32* cp1 = cp+w+toskew;
-    int32 incr = 2*toskew+w;
+    uint32_t* cp1 = cp + w + toskew;
+    int32_t incr = 2 * toskew + w;
 
     (void) y;
     fromskew = (fromskew / 4) * (4*2+2);
@@ -1987,8 +2012,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr42tile)
         for (; h >= 2; h -= 2) {
             x = w>>2;
             do {
-                int32 Cb = pp[8];
-                int32 Cr = pp[9];
+                int32_t Cb = pp[8];
+                int32_t Cr = pp[9];
                 
                 YCbCrtoRGB(cp [0], pp[0]);
                 YCbCrtoRGB(cp [1], pp[1]);
@@ -2010,8 +2035,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr42tile)
     } else {
         while (h > 0) {
             for (x = w; x > 0;) {
-                int32 Cb = pp[8];
-                int32 Cr = pp[9];
+                int32_t Cb = pp[8];
+                int32_t Cr = pp[9];
                 switch (x) {
                 default:
                     switch (h) {
@@ -2064,8 +2089,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr41tile)
     do {
 	x = w>>2;
 	while(x>0) {
-	    int32 Cb = pp[4];
-	    int32 Cr = pp[5];
+	    int32_t Cb = pp[4];
+	    int32_t Cr = pp[5];
 
 	    YCbCrtoRGB(cp [0], pp[0]);
 	    YCbCrtoRGB(cp [1], pp[1]);
@@ -2079,8 +2104,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr41tile)
 
         if( (w&3) != 0 )
         {
-	    int32 Cb = pp[4];
-	    int32 Cr = pp[5];
+	    int32_t Cb = pp[4];
+	    int32_t Cr = pp[5];
 
             switch( (w&3) ) {
               case 3: YCbCrtoRGB(cp [2], pp[2]); /*-fallthrough*/
@@ -2104,16 +2129,16 @@ DECLAREContigPutFunc(putcontig8bitYCbCr41tile)
  */
 DECLAREContigPutFunc(putcontig8bitYCbCr22tile)
 {
-	uint32* cp2;
-	int32 incr = 2*toskew+w;
+	uint32_t* cp2;
+	int32_t incr = 2 * toskew + w;
 	(void) y;
 	fromskew = (fromskew / 2) * (2*2+2);
 	cp2 = cp+w+toskew;
 	while (h>=2) {
 		x = w;
 		while (x>=2) {
-			uint32 Cb = pp[4];
-			uint32 Cr = pp[5];
+			uint32_t Cb = pp[4];
+			uint32_t Cr = pp[5];
 			YCbCrtoRGB(cp[0], pp[0]);
 			YCbCrtoRGB(cp[1], pp[1]);
 			YCbCrtoRGB(cp2[0], pp[2]);
@@ -2124,8 +2149,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr22tile)
 			x -= 2;
 		}
 		if (x==1) {
-			uint32 Cb = pp[4];
-			uint32 Cr = pp[5];
+			uint32_t Cb = pp[4];
+			uint32_t Cr = pp[5];
 			YCbCrtoRGB(cp[0], pp[0]);
 			YCbCrtoRGB(cp2[0], pp[2]);
 			cp ++ ;
@@ -2140,8 +2165,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr22tile)
 	if (h==1) {
 		x = w;
 		while (x>=2) {
-			uint32 Cb = pp[4];
-			uint32 Cr = pp[5];
+			uint32_t Cb = pp[4];
+			uint32_t Cr = pp[5];
 			YCbCrtoRGB(cp[0], pp[0]);
 			YCbCrtoRGB(cp[1], pp[1]);
 			cp += 2;
@@ -2150,8 +2175,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr22tile)
 			x -= 2;
 		}
 		if (x==1) {
-			uint32 Cb = pp[4];
-			uint32 Cr = pp[5];
+			uint32_t Cb = pp[4];
+			uint32_t Cr = pp[5];
 			YCbCrtoRGB(cp[0], pp[0]);
 		}
 	}
@@ -2167,8 +2192,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr21tile)
 	do {
 		x = w>>1;
 		while(x>0) {
-			int32 Cb = pp[2];
-			int32 Cr = pp[3];
+			int32_t Cb = pp[2];
+			int32_t Cr = pp[3];
 
 			YCbCrtoRGB(cp[0], pp[0]);
 			YCbCrtoRGB(cp[1], pp[1]);
@@ -2180,8 +2205,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr21tile)
 
 		if( (w&1) != 0 )
 		{
-			int32 Cb = pp[2];
-			int32 Cr = pp[3];
+			int32_t Cb = pp[2];
+			int32_t Cr = pp[3];
 
 			YCbCrtoRGB(cp[0], pp[0]);
 
@@ -2199,16 +2224,16 @@ DECLAREContigPutFunc(putcontig8bitYCbCr21tile)
  */
 DECLAREContigPutFunc(putcontig8bitYCbCr12tile)
 {
-	uint32* cp2;
-	int32 incr = 2*toskew+w;
+	uint32_t* cp2;
+	int32_t incr = 2 * toskew + w;
 	(void) y;
 	fromskew = (fromskew / 1) * (1 * 2 + 2);
 	cp2 = cp+w+toskew;
 	while (h>=2) {
 		x = w;
 		do {
-			uint32 Cb = pp[2];
-			uint32 Cr = pp[3];
+			uint32_t Cb = pp[2];
+			uint32_t Cr = pp[3];
 			YCbCrtoRGB(cp[0], pp[0]);
 			YCbCrtoRGB(cp2[0], pp[1]);
 			cp ++;
@@ -2223,8 +2248,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr12tile)
 	if (h==1) {
 		x = w;
 		do {
-			uint32 Cb = pp[2];
-			uint32 Cr = pp[3];
+			uint32_t Cb = pp[2];
+			uint32_t Cr = pp[3];
 			YCbCrtoRGB(cp[0], pp[0]);
 			cp ++;
 			pp += 4;
@@ -2242,8 +2267,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr11tile)
 	do {
 		x = w; /* was x = w>>1; patched 2000/09/25 warmerda@home.com */
 		do {
-			int32 Cb = pp[1];
-			int32 Cr = pp[2];
+			int32_t Cb = pp[1];
+			int32_t Cr = pp[2];
 
 			YCbCrtoRGB(*cp++, pp[0]);
 
@@ -2265,7 +2290,7 @@ DECLARESepPutFunc(putseparate8bitYCbCr11tile)
 	for( ; h > 0; --h) {
 		x = w;
 		do {
-			uint32 dr, dg, db;
+			uint32_t dr, dg, db;
 			TIFFYCbCrtoRGB(img->ycbcr,*r++,*g++,*b++,&dr,&dg,&db);
 			*cp++ = PACK(dr,dg,db);
 		} while (--x);
@@ -2292,7 +2317,7 @@ initYCbCrConversion(TIFFRGBAImage* img)
 		    TIFFroundup_32(sizeof (TIFFYCbCrToRGB), sizeof (long))  
 		    + 4*256*sizeof (TIFFRGBValue)
 		    + 2*256*sizeof (int)
-		    + 3*256*sizeof (int32)
+		    + 3*256*sizeof (int32_t)
 		    );
 		if (img->ycbcr == NULL) {
 			TIFFErrorExt(img->tif->tif_clientdata, module,
@@ -2387,18 +2412,18 @@ makebwmap(TIFFRGBAImage* img)
     int bitspersample = img->bitspersample;
     int nsamples = 8 / bitspersample;
     int i;
-    uint32* p;
+    uint32_t* p;
 
     if( nsamples == 0 )
         nsamples = 1;
 
-    img->BWmap = (uint32**) _TIFFmalloc(
-	256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));
+    img->BWmap = (uint32_t**) _TIFFmalloc(
+	256*sizeof (uint32_t *) + (256 * nsamples * sizeof(uint32_t)));
     if (img->BWmap == NULL) {
 		TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), "No space for B&W mapping table");
 		return (0);
     }
-    p = (uint32*)(img->BWmap + 256);
+    p = (uint32_t*)(img->BWmap + 256);
     for (i = 0; i < 256; i++) {
 	TIFFRGBValue c;
 	img->BWmap[i] = p;
@@ -2442,13 +2467,13 @@ makebwmap(TIFFRGBAImage* img)
 static int
 setupMap(TIFFRGBAImage* img)
 {
-    int32 x, range;
+    int32_t x, range;
 
-    range = (int32)((1L<<img->bitspersample)-1);
+    range = (int32_t)((1L << img->bitspersample) - 1);
     
     /* treat 16 bit the same as eight bit */
     if( img->bitspersample == 16 )
-        range = (int32) 255;
+        range = (int32_t) 255;
 
     img->Map = (TIFFRGBValue*) _TIFFmalloc((range+1) * sizeof (TIFFRGBValue));
     if (img->Map == NULL) {
@@ -2482,9 +2507,9 @@ setupMap(TIFFRGBAImage* img)
 static int
 checkcmap(TIFFRGBAImage* img)
 {
-    uint16* r = img->redcmap;
-    uint16* g = img->greencmap;
-    uint16* b = img->bluecmap;
+    uint16_t* r = img->redcmap;
+    uint16_t* g = img->greencmap;
+    uint16_t* b = img->bluecmap;
     long n = 1L<<img->bitspersample;
 
     while (n-- > 0)
@@ -2496,13 +2521,13 @@ checkcmap(TIFFRGBAImage* img)
 static void
 cvtcmap(TIFFRGBAImage* img)
 {
-    uint16* r = img->redcmap;
-    uint16* g = img->greencmap;
-    uint16* b = img->bluecmap;
+    uint16_t* r = img->redcmap;
+    uint16_t* g = img->greencmap;
+    uint16_t* b = img->bluecmap;
     long i;
 
     for (i = (1L<<img->bitspersample)-1; i >= 0; i--) {
-#define	CVT(x)		((uint16)((x)>>8))
+#define	CVT(x)		((uint16_t)((x)>>8))
 	r[i] = CVT(r[i]);
 	g[i] = CVT(g[i]);
 	b[i] = CVT(b[i]);
@@ -2522,19 +2547,19 @@ makecmap(TIFFRGBAImage* img)
 {
     int bitspersample = img->bitspersample;
     int nsamples = 8 / bitspersample;
-    uint16* r = img->redcmap;
-    uint16* g = img->greencmap;
-    uint16* b = img->bluecmap;
-    uint32 *p;
+    uint16_t* r = img->redcmap;
+    uint16_t* g = img->greencmap;
+    uint16_t* b = img->bluecmap;
+    uint32_t *p;
     int i;
 
-    img->PALmap = (uint32**) _TIFFmalloc(
-	256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));
+    img->PALmap = (uint32_t**) _TIFFmalloc(
+	256*sizeof (uint32_t *) + (256 * nsamples * sizeof(uint32_t)));
     if (img->PALmap == NULL) {
 		TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), "No space for Palette mapping table");
 		return (0);
 	}
-    p = (uint32*)(img->PALmap + 256);
+    p = (uint32_t*)(img->PALmap + 256);
     for (i = 0; i < 256; i++) {
 	TIFFRGBValue c;
 	img->PALmap[i] = p;
@@ -2721,8 +2746,8 @@ PickContigCase(TIFFRGBAImage* img)
 					 * Joris: added support for the [1,2] case, nonetheless, to accommodate
 					 * some OJPEG files
 					 */
-					uint16 SubsamplingHor;
-					uint16 SubsamplingVer;
+					uint16_t SubsamplingHor;
+					uint16_t SubsamplingVer;
 					TIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &SubsamplingHor, &SubsamplingVer);
 					switch ((SubsamplingHor<<4)|SubsamplingVer) {
 						case 0x44:
@@ -2820,7 +2845,7 @@ PickSeparateCase(TIFFRGBAImage* img)
 		{
 			if (initYCbCrConversion(img)!=0)
 			{
-				uint16 hs, vs;
+				uint16_t hs, vs;
 				TIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &hs, &vs);
 				switch ((hs<<4)|vs) {
 				case 0x11:
@@ -2839,8 +2864,8 @@ static int
 BuildMapUaToAa(TIFFRGBAImage* img)
 {
 	static const char module[]="BuildMapUaToAa";
-	uint8* m;
-	uint16 na,nv;
+	uint8_t* m;
+	uint16_t na,nv;
 	assert(img->UaToAa==NULL);
 	img->UaToAa=_TIFFmalloc(65536);
 	if (img->UaToAa==NULL)
@@ -2852,7 +2877,7 @@ BuildMapUaToAa(TIFFRGBAImage* img)
 	for (na=0; na<256; na++)
 	{
 		for (nv=0; nv<256; nv++)
-			*m++=(uint8)((nv*na+127)/255);
+			*m++=(uint8_t)((nv * na + 127) / 255);
 	}
 	return(1);
 }
@@ -2861,8 +2886,8 @@ static int
 BuildMapBitdepth16To8(TIFFRGBAImage* img)
 {
 	static const char module[]="BuildMapBitdepth16To8";
-	uint8* m;
-	uint32 n;
+	uint8_t* m;
+	uint32_t n;
 	assert(img->Bitdepth16To8==NULL);
 	img->Bitdepth16To8=_TIFFmalloc(65536);
 	if (img->Bitdepth16To8==NULL)
@@ -2872,7 +2897,7 @@ BuildMapBitdepth16To8(TIFFRGBAImage* img)
 	}
 	m=img->Bitdepth16To8;
 	for (n=0; n<65536; n++)
-		*m++=(uint8)((n+128)/257);
+		*m++=(uint8_t)((n + 128) / 257);
 	return(1);
 }
 
@@ -2886,20 +2911,20 @@ BuildMapBitdepth16To8(TIFFRGBAImage* img)
 
 
 int
-TIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )
+TIFFReadRGBAStrip(TIFF* tif, uint32_t row, uint32_t * raster )
 
 {
     return TIFFReadRGBAStripExt(tif, row, raster, 0 );
 }
 
 int
-TIFFReadRGBAStripExt(TIFF* tif, uint32 row, uint32 * raster, int stop_on_error)
+TIFFReadRGBAStripExt(TIFF* tif, uint32_t row, uint32_t * raster, int stop_on_error)
 
 {
     char 	emsg[1024] = "";
     TIFFRGBAImage img;
     int 	ok;
-    uint32	rowsperstrip, rows_to_read;
+    uint32_t	rowsperstrip, rows_to_read;
 
     if( TIFFIsTiled( tif ) )
     {
@@ -2944,7 +2969,7 @@ TIFFReadRGBAStripExt(TIFF* tif, uint32 row, uint32 * raster, int stop_on_error)
  */
 
 int
-TIFFReadRGBATile(TIFF* tif, uint32 col, uint32 row, uint32 * raster)
+TIFFReadRGBATile(TIFF* tif, uint32_t col, uint32_t row, uint32_t * raster)
 
 {
     return TIFFReadRGBATileExt(tif, col, row, raster, 0 );
@@ -2952,14 +2977,14 @@ TIFFReadRGBATile(TIFF* tif, uint32 col, uint32 row, uint32 * raster)
 
 
 int
-TIFFReadRGBATileExt(TIFF* tif, uint32 col, uint32 row, uint32 * raster, int stop_on_error )
+TIFFReadRGBATileExt(TIFF* tif, uint32_t col, uint32_t row, uint32_t * raster, int stop_on_error )
 {
     char 	emsg[1024] = "";
     TIFFRGBAImage img;
     int 	ok;
-    uint32	tile_xsize, tile_ysize;
-    uint32	read_xsize, read_ysize;
-    uint32	i_row;
+    uint32_t	tile_xsize, tile_ysize;
+    uint32_t	read_xsize, read_ysize;
+    uint32_t	i_row;
 
     /*
      * Verify that our request is legal - on a tile file, and on a
@@ -3035,14 +3060,14 @@ TIFFReadRGBATileExt(TIFF* tif, uint32 col, uint32 row, uint32 * raster, int stop
     for( i_row = 0; i_row < read_ysize; i_row++ ) {
         memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,
                  raster + (read_ysize - i_row - 1) * read_xsize,
-                 read_xsize * sizeof(uint32) );
+                 read_xsize * sizeof(uint32_t) );
         _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize+read_xsize,
-                     0, sizeof(uint32) * (tile_xsize - read_xsize) );
+                     0, sizeof(uint32_t) * (tile_xsize - read_xsize) );
     }
 
     for( i_row = read_ysize; i_row < tile_ysize; i_row++ ) {
         _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize,
-                     0, sizeof(uint32) * tile_xsize );
+                     0, sizeof(uint32_t) * tile_xsize );
     }
 
     return (ok);
diff --git a/src/3rdparty/libtiff/libtiff/tif_jbig.c b/src/3rdparty/libtiff/libtiff/tif_jbig.c
index 7ffe885..7408633 100644
--- a/src/3rdparty/libtiff/libtiff/tif_jbig.c
+++ b/src/3rdparty/libtiff/libtiff/tif_jbig.c
@@ -46,7 +46,7 @@ static int JBIGSetupDecode(TIFF* tif)
 	return 1;
 }
 
-static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)
+static int JBIGDecode(TIFF* tif, uint8_t* buffer, tmsize_t size, uint16_t s)
 {
 	struct jbg_dec_state decoder;
 	int decodeStatus = 0;
@@ -101,14 +101,14 @@ static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)
 	if( (tmsize_t)decodedSize < size )
 	{
 	    TIFFWarningExt(tif->tif_clientdata, "JBIG",
-	                   "Only decoded %lu bytes, whereas %lu requested",
-	                   decodedSize, (unsigned long)size);
+	                   "Only decoded %lu bytes, whereas %"TIFF_SSIZE_FORMAT" requested",
+	                   decodedSize, size);
 	}
 	else if( (tmsize_t)decodedSize > size )
 	{
 	    TIFFErrorExt(tif->tif_clientdata, "JBIG",
-	                 "Decoded %lu bytes, whereas %lu were requested",
-	                 decodedSize, (unsigned long)size);
+	                 "Decoded %lu bytes, whereas %"TIFF_SSIZE_FORMAT" were requested",
+	                 decodedSize, size);
 	    jbg_dec_free(&decoder);
 	    return 0;
 	}
@@ -133,7 +133,7 @@ static int JBIGSetupEncode(TIFF* tif)
 	return 1;
 }
 
-static int JBIGCopyEncodedData(TIFF* tif, unsigned char* pp, size_t cc, uint16 s)
+static int JBIGCopyEncodedData(TIFF* tif, unsigned char* pp, size_t cc, uint16_t s)
 {
 	(void) s;
 	while (cc > 0)
@@ -173,7 +173,7 @@ static void JBIGOutputBie(unsigned char* buffer, size_t len, void* userData)
 	JBIGCopyEncodedData(tif, buffer, len, 0);
 }
 
-static int JBIGEncode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)
+static int JBIGEncode(TIFF* tif, uint8_t* buffer, tmsize_t size, uint16_t s)
 {
 	TIFFDirectory* dir = &tif->tif_dir;
 	struct jbg_enc_state encoder;
@@ -199,6 +199,7 @@ static int JBIGEncode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)
 
 int TIFFInitJBIG(TIFF* tif, int scheme)
 {
+        (void)scheme;
 	assert(scheme == COMPRESSION_JBIG);
 
 	/*
diff --git a/src/3rdparty/libtiff/libtiff/tif_jpeg.c b/src/3rdparty/libtiff/libtiff/tif_jpeg.c
index 93ae2ea..6076c11 100644
--- a/src/3rdparty/libtiff/libtiff/tif_jpeg.c
+++ b/src/3rdparty/libtiff/libtiff/tif_jpeg.c
@@ -44,8 +44,8 @@
  */
 #include <setjmp.h>
 
-int TIFFFillStrip(TIFF* tif, uint32 strip);
-int TIFFFillTile(TIFF* tif, uint32 tile);
+int TIFFFillStrip(TIFF* tif, uint32_t strip);
+int TIFFFillTile(TIFF* tif, uint32_t tile);
 int TIFFReInitJPEG_12( TIFF *tif, int scheme, int is_encode );
 int TIFFJPEGIsFullStripRequired_12(TIFF* tif);
 
@@ -156,9 +156,9 @@ typedef struct {
 	jpeg_source_mgr	src;		/* data source for decompression */
 					/* private state */
 	TIFF*		tif;		/* back link needed by some code */
-	uint16		photometric;	/* copy of PhotometricInterpretation */
-	uint16		h_sampling;	/* luminance sampling factors */
-	uint16		v_sampling;
+	uint16_t	photometric;	/* copy of PhotometricInterpretation */
+	uint16_t	h_sampling;	/* luminance sampling factors */
+	uint16_t	v_sampling;
 	tmsize_t   	bytesperline;	/* decompressed bytes per scanline */
 	/* pointers to intermediate buffers when processing downsampled data */
 	JSAMPARRAY	ds_buffer[MAX_COMPONENTS];
@@ -172,7 +172,7 @@ typedef struct {
 	TIFFTileMethod	deftparent;	/* super-class method */
 					/* pseudo-tag fields */
 	void*		jpegtables;	/* JPEGTables tag value, or NULL */
-	uint32		jpegtables_length; /* number of bytes in same */
+	uint32_t	jpegtables_length; /* number of bytes in same */
 	int		jpegquality;	/* Compression quality level */
 	int		jpegcolormode;	/* Auto RGB<=>YCbCr convert? */
 	int		jpegtablesmode;	/* What to put in JPEGTables */
@@ -183,12 +183,12 @@ typedef struct {
 
 #define	JState(tif)	((JPEGState*)(tif)->tif_data)
 
-static int JPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s);
-static int JPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s);
-static int JPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s);
-static int JPEGEncodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s);
+static int JPEGDecode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s);
+static int JPEGDecodeRaw(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s);
+static int JPEGEncode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s);
+static int JPEGEncodeRaw(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s);
 static int JPEGInitializeLibJPEG(TIFF * tif, int decode );
-static int DecodeRowError(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s);
+static int DecodeRowError(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s);
 
 #define	FIELD_JPEGTABLES	(FIELD_CODEC+0)
 
@@ -466,7 +466,8 @@ std_empty_output_buffer(j_compress_ptr cinfo)
        }
 #endif
 
-	TIFFFlushData1(tif);
+	if( !TIFFFlushData1(tif) )
+            return FALSE;
 	sp->dest.next_output_byte = (JOCTET*) tif->tif_rawdata;
 	sp->dest.free_in_buffer = (size_t) tif->tif_rawdatasize;
 
@@ -479,7 +480,7 @@ std_term_destination(j_compress_ptr cinfo)
 	JPEGState* sp = (JPEGState*) cinfo;
 	TIFF* tif = sp->tif;
 
-	tif->tif_rawcp = (uint8*) sp->dest.next_output_byte;
+	tif->tif_rawcp = (uint8_t*) sp->dest.next_output_byte;
 	tif->tif_rawcc =
 	    tif->tif_rawdatasize - (tmsize_t) sp->dest.free_in_buffer;
 	/* NB: libtiff does the final buffer flush */
@@ -533,7 +534,7 @@ tables_term_destination(j_compress_ptr cinfo)
 	JPEGState* sp = (JPEGState*) cinfo;
 
 	/* set tables length to number of bytes actually emitted */
-	sp->jpegtables_length -= (uint32) sp->dest.free_in_buffer;
+	sp->jpegtables_length -= (uint32_t) sp->dest.free_in_buffer;
 }
 
 static int
@@ -723,18 +724,18 @@ struct JPEGFixupTagsSubsamplingData
 {
 	TIFF* tif;
 	void* buffer;
-	uint32 buffersize;
-	uint8* buffercurrentbyte;
-	uint32 bufferbytesleft;
-	uint64 fileoffset;
-	uint64 filebytesleft;
-	uint8 filepositioned;
+	uint32_t buffersize;
+	uint8_t* buffercurrentbyte;
+	uint32_t bufferbytesleft;
+	uint64_t fileoffset;
+	uint64_t filebytesleft;
+	uint8_t filepositioned;
 };
 static void JPEGFixupTagsSubsampling(TIFF* tif);
 static int JPEGFixupTagsSubsamplingSec(struct JPEGFixupTagsSubsamplingData* data);
-static int JPEGFixupTagsSubsamplingReadByte(struct JPEGFixupTagsSubsamplingData* data, uint8* result);
-static int JPEGFixupTagsSubsamplingReadWord(struct JPEGFixupTagsSubsamplingData* data, uint16* result);
-static void JPEGFixupTagsSubsamplingSkip(struct JPEGFixupTagsSubsamplingData* data, uint16 skiplength);
+static int JPEGFixupTagsSubsamplingReadByte(struct JPEGFixupTagsSubsamplingData* data, uint8_t* result);
+static int JPEGFixupTagsSubsamplingReadWord(struct JPEGFixupTagsSubsamplingData* data, uint16_t* result);
+static void JPEGFixupTagsSubsamplingSkip(struct JPEGFixupTagsSubsamplingData* data, uint16_t skiplength);
 
 #endif
 
@@ -780,7 +781,7 @@ JPEGFixupTagsSubsampling(TIFF* tif)
 	 */
 	static const char module[] = "JPEGFixupTagsSubsampling";
 	struct JPEGFixupTagsSubsamplingData m;
-        uint64 fileoffset = TIFFGetStrileOffset(tif, 0);
+        uint64_t fileoffset = TIFFGetStrileOffset(tif, 0);
 
         if( fileoffset == 0 )
         {
@@ -814,7 +815,7 @@ static int
 JPEGFixupTagsSubsamplingSec(struct JPEGFixupTagsSubsamplingData* data)
 {
 	static const char module[] = "JPEGFixupTagsSubsamplingSec";
-	uint8 m;
+	uint8_t m;
 	while (1)
 	{
 		while (1)
@@ -859,7 +860,7 @@ JPEGFixupTagsSubsamplingSec(struct JPEGFixupTagsSubsamplingData* data)
 			case JPEG_MARKER_DRI:
 				/* this type of marker has data, but it has no use to us and should be skipped */
 				{
-					uint16 n;
+					uint16_t n;
 					if (!JPEGFixupTagsSubsamplingReadWord(data,&n))
 						return(0);
 					if (n<2)
@@ -876,10 +877,10 @@ JPEGFixupTagsSubsamplingSec(struct JPEGFixupTagsSubsamplingData* data)
 			case JPEG_MARKER_SOF10: /* Progressive arithmetic: normally not allowed by TechNote, but that doesn't hurt supporting it */
 				/* this marker contains the subsampling factors we're scanning for */
 				{
-					uint16 n;
-					uint16 o;
-					uint8 p;
-					uint8 ph,pv;
+					uint16_t n;
+					uint16_t o;
+					uint8_t p;
+					uint8_t ph,pv;
 					if (!JPEGFixupTagsSubsamplingReadWord(data,&n))
 						return(0);
 					if (n!=8+data->tif->tif_dir.td_samplesperpixel*3)
@@ -912,10 +913,10 @@ JPEGFixupTagsSubsamplingSec(struct JPEGFixupTagsSubsamplingData* data)
 					if ((ph!=data->tif->tif_dir.td_ycbcrsubsampling[0])||(pv!=data->tif->tif_dir.td_ycbcrsubsampling[1]))
 					{
 						TIFFWarningExt(data->tif->tif_clientdata,module,
-						    "Auto-corrected former TIFF subsampling values [%d,%d] to match subsampling values inside JPEG compressed data [%d,%d]",
-						    (int)data->tif->tif_dir.td_ycbcrsubsampling[0],
-						    (int)data->tif->tif_dir.td_ycbcrsubsampling[1],
-						    (int)ph,(int)pv);
+						    "Auto-corrected former TIFF subsampling values [%"PRIu16",%"PRIu16"] to match subsampling values inside JPEG compressed data [%"PRIu8",%"PRIu8"]",
+						    data->tif->tif_dir.td_ycbcrsubsampling[0],
+						    data->tif->tif_dir.td_ycbcrsubsampling[1],
+						    ph, pv);
 						data->tif->tif_dir.td_ycbcrsubsampling[0]=ph;
 						data->tif->tif_dir.td_ycbcrsubsampling[1]=pv;
 					}
@@ -928,21 +929,24 @@ JPEGFixupTagsSubsamplingSec(struct JPEGFixupTagsSubsamplingData* data)
 }
 
 static int
-JPEGFixupTagsSubsamplingReadByte(struct JPEGFixupTagsSubsamplingData* data, uint8* result)
+JPEGFixupTagsSubsamplingReadByte(struct JPEGFixupTagsSubsamplingData* data, uint8_t* result)
 {
 	if (data->bufferbytesleft==0)
 	{
-		uint32 m;
+		uint32_t m;
 		if (data->filebytesleft==0)
 			return(0);
 		if (!data->filepositioned)
 		{
-			TIFFSeekFile(data->tif,data->fileoffset,SEEK_SET);
+			if (TIFFSeekFile(data->tif,data->fileoffset,SEEK_SET) == (toff_t)-1)
+			{
+			    return 0;
+			}
 			data->filepositioned=1;
 		}
 		m=data->buffersize;
-		if ((uint64)m>data->filebytesleft)
-			m=(uint32)data->filebytesleft;
+		if ((uint64_t)m > data->filebytesleft)
+			m=(uint32_t)data->filebytesleft;
 		assert(m<0x80000000UL);
 		if (TIFFReadFile(data->tif,data->buffer,(tmsize_t)m)!=(tmsize_t)m)
 			return(0);
@@ -958,10 +962,10 @@ JPEGFixupTagsSubsamplingReadByte(struct JPEGFixupTagsSubsamplingData* data, uint
 }
 
 static int
-JPEGFixupTagsSubsamplingReadWord(struct JPEGFixupTagsSubsamplingData* data, uint16* result)
+JPEGFixupTagsSubsamplingReadWord(struct JPEGFixupTagsSubsamplingData* data, uint16_t* result)
 {
-	uint8 ma;
-	uint8 mb;
+	uint8_t ma;
+	uint8_t mb;
 	if (!JPEGFixupTagsSubsamplingReadByte(data,&ma))
 		return(0);
 	if (!JPEGFixupTagsSubsamplingReadByte(data,&mb))
@@ -971,17 +975,17 @@ JPEGFixupTagsSubsamplingReadWord(struct JPEGFixupTagsSubsamplingData* data, uint
 }
 
 static void
-JPEGFixupTagsSubsamplingSkip(struct JPEGFixupTagsSubsamplingData* data, uint16 skiplength)
+JPEGFixupTagsSubsamplingSkip(struct JPEGFixupTagsSubsamplingData* data, uint16_t skiplength)
 {
-	if ((uint32)skiplength<=data->bufferbytesleft)
+	if ((uint32_t)skiplength <= data->bufferbytesleft)
 	{
 		data->buffercurrentbyte+=skiplength;
 		data->bufferbytesleft-=skiplength;
 	}
 	else
 	{
-		uint16 m;
-		m=(uint16)(skiplength-data->bufferbytesleft);
+		uint16_t m;
+		m=(uint16_t)(skiplength - data->bufferbytesleft);
 		if (m<=data->filebytesleft)
 		{
 			data->bufferbytesleft=0;
@@ -1085,12 +1089,12 @@ int TIFFJPEGIsFullStripRequired(TIFF* tif)
  * Set up for decoding a strip or tile.
  */
 /*ARGSUSED*/ static int
-JPEGPreDecode(TIFF* tif, uint16 s)
+JPEGPreDecode(TIFF* tif, uint16_t s)
 {
 	JPEGState *sp = JState(tif);
 	TIFFDirectory *td = &tif->tif_dir;
 	static const char module[] = "JPEGPreDecode";
-	uint32 segment_width, segment_height;
+	uint32_t segment_width, segment_height;
 	int downsampled_output;
 	int ci;
 
@@ -1115,7 +1119,7 @@ JPEGPreDecode(TIFF* tif, uint16 s)
 	if (TIFFjpeg_read_header(sp, TRUE) != JPEG_HEADER_OK)
 		return (0);
 
-        tif->tif_rawcp = (uint8*) sp->src.next_input_byte;
+        tif->tif_rawcp = (uint8_t*) sp->src.next_input_byte;
         tif->tif_rawcc = sp->src.bytes_in_buffer;
 
 	/*
@@ -1144,7 +1148,7 @@ JPEGPreDecode(TIFF* tif, uint16 s)
 	    sp->cinfo.d.image_height < segment_height) {
 		TIFFWarningExt(tif->tif_clientdata, module,
 			       "Improper JPEG strip/tile size, "
-			       "expected %dx%d, got %dx%d",
+			       "expected %"PRIu32"x%"PRIu32", got %ux%u",
 			       segment_width, segment_height,
 			       sp->cinfo.d.image_width,
 			       sp->cinfo.d.image_height);
@@ -1159,7 +1163,7 @@ JPEGPreDecode(TIFF* tif, uint16 s)
 		/* we can safely recover from that. */
 		TIFFWarningExt(tif->tif_clientdata, module,
 			     "JPEG strip size exceeds expected dimensions,"
-			     " expected %dx%d, got %dx%d",
+			     " expected %"PRIu32"x%"PRIu32", got %ux%u",
 			     segment_width, segment_height,
 			     sp->cinfo.d.image_width, sp->cinfo.d.image_height);
 	}
@@ -1173,7 +1177,7 @@ JPEGPreDecode(TIFF* tif, uint16 s)
 		 */
 		TIFFErrorExt(tif->tif_clientdata, module,
 			     "JPEG strip/tile size exceeds expected dimensions,"
-			     " expected %dx%d, got %dx%d",
+			     " expected %"PRIu32"x%"PRIu32", got %ux%u",
 			     segment_width, segment_height,
 			     sp->cinfo.d.image_width, sp->cinfo.d.image_height);
 		return (0);
@@ -1206,35 +1210,37 @@ JPEGPreDecode(TIFF* tif, uint16 s)
             /* store for all coefficients */
             /* See call to jinit_d_coef_controller() from master_selection() */
             /* in libjpeg */
-            toff_t nRequiredMemory = (toff_t)sp->cinfo.d.image_width *
-                                     sp->cinfo.d.image_height *
-                                     sp->cinfo.d.num_components *
-                                     ((td->td_bitspersample+7)/8);
-            /* BLOCK_SMOOTHING_SUPPORTED is generally defined, so we need */
-            /* to replicate the logic of jinit_d_coef_controller() */
-            if( sp->cinfo.d.progressive_mode )
-                nRequiredMemory *= 3;
-
-#ifndef TIFF_LIBJPEG_LARGEST_MEM_ALLOC
-#define TIFF_LIBJPEG_LARGEST_MEM_ALLOC (100 * 1024 * 1024)
-#endif
 
-            if( nRequiredMemory > TIFF_LIBJPEG_LARGEST_MEM_ALLOC &&
+            /* 1 MB for regular libjpeg usage */
+            toff_t nRequiredMemory = 1024 * 1024;
+
+            for (ci = 0; ci < sp->cinfo.d.num_components; ci++) {
+                const jpeg_component_info *compptr = &(sp->cinfo.d.comp_info[ci]);
+                if( compptr->h_samp_factor > 0 && compptr->v_samp_factor > 0 )
+                {
+                    nRequiredMemory += (toff_t)(
+                        ((compptr->width_in_blocks + compptr->h_samp_factor - 1) / compptr->h_samp_factor)) *
+                        ((compptr->height_in_blocks + compptr->v_samp_factor - 1) / compptr->v_samp_factor) *
+                        sizeof(JBLOCK);
+                }
+            }
+
+            if( sp->cinfo.d.mem->max_memory_to_use > 0 &&
+                nRequiredMemory > (toff_t)(sp->cinfo.d.mem->max_memory_to_use) &&
                 getenv("LIBTIFF_ALLOW_LARGE_LIBJPEG_MEM_ALLOC") == NULL )
             {
-                    TIFFErrorExt(tif->tif_clientdata, module,
-                        "Reading this strip would require libjpeg to allocate "
-                        "at least %u bytes. "
-                        "This is disabled since above the %u threshold. "
-                        "You may override this restriction by defining the "
-                        "LIBTIFF_ALLOW_LARGE_LIBJPEG_MEM_ALLOC environment variable, "
-                        "or recompile libtiff by defining the "
-                        "TIFF_LIBJPEG_LARGEST_MEM_ALLOC macro to a value greater "
-                        "than %u",
-                        (unsigned)nRequiredMemory,
-                        (unsigned)TIFF_LIBJPEG_LARGEST_MEM_ALLOC,
-                        (unsigned)TIFF_LIBJPEG_LARGEST_MEM_ALLOC);
-                    return (0);
+                TIFFErrorExt(tif->tif_clientdata, module,
+                    "Reading this image would require libjpeg to allocate "
+                    "at least %"PRIu64" bytes. "
+                    "This is disabled since above the %ld threshold. "
+                    "You may override this restriction by defining the "
+                    "LIBTIFF_ALLOW_LARGE_LIBJPEG_MEM_ALLOC environment variable, "
+                    "or setting the JPEGMEM environment variable to a value greater "
+                    "or equal to '%"PRIu64"M'",
+                    nRequiredMemory,
+                    sp->cinfo.d.mem->max_memory_to_use,
+                    (nRequiredMemory + 1000000u - 1u) / 1000000u);
+                return 0;
             }
         }
 
@@ -1244,7 +1250,7 @@ JPEGPreDecode(TIFF* tif, uint16 s)
 		    sp->cinfo.d.comp_info[0].v_samp_factor != sp->v_sampling) {
 			TIFFErrorExt(tif->tif_clientdata, module,
 				       "Improper JPEG sampling factors %d,%d\n"
-				       "Apparently should be %d,%d.",
+				       "Apparently should be %"PRIu16",%"PRIu16".",
 				       sp->cinfo.d.comp_info[0].h_samp_factor,
 				       sp->cinfo.d.comp_info[0].v_samp_factor,
 				       sp->h_sampling, sp->v_sampling);
@@ -1317,7 +1323,7 @@ JPEGPreDecode(TIFF* tif, uint16 s)
  */
 #if !JPEG_LIB_MK1_OR_12BIT
 static int
-JPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+JPEGDecode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
 	JPEGState *sp = JState(tif);
 	tmsize_t nrows;
@@ -1362,7 +1368,7 @@ JPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
         }
 
         /* Update information on consumed data */
-        tif->tif_rawcp = (uint8*) sp->src.next_input_byte;
+        tif->tif_rawcp = (uint8_t*) sp->src.next_input_byte;
         tif->tif_rawcc = sp->src.bytes_in_buffer;
                 
 	/* Close down the decompressor if we've finished the strip or tile. */
@@ -1373,7 +1379,7 @@ JPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 
 #if JPEG_LIB_MK1_OR_12BIT
 /*ARGSUSED*/ static int
-JPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+JPEGDecode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
 	JPEGState *sp = JState(tif);
 	tmsize_t nrows;
@@ -1468,7 +1474,7 @@ JPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
         }
 
         /* Update information on consumed data */
-        tif->tif_rawcp = (uint8*) sp->src.next_input_byte;
+        tif->tif_rawcp = (uint8_t*) sp->src.next_input_byte;
         tif->tif_rawcc = sp->src.bytes_in_buffer;
                 
 	/* Close down the decompressor if we've finished the strip or tile. */
@@ -1478,7 +1484,7 @@ JPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 #endif /* JPEG_LIB_MK1_OR_12BIT */
 
 /*ARGSUSED*/ static int
-DecodeRowError(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+DecodeRowError(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 
 {
     (void) buf;
@@ -1495,7 +1501,7 @@ DecodeRowError(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
  * Returned data is downsampled per sampling factors.
  */
 /*ARGSUSED*/ static int
-JPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+JPEGDecodeRaw(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
 	JPEGState *sp = JState(tif);
 	tmsize_t nrows;
@@ -1506,7 +1512,7 @@ JPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
         /* For last strip, limit number of rows to its truncated height */
         /* even if the codestream height is larger (which is not compliant, */
         /* but that we tolerate) */
-        if( (uint32)nrows > td->td_imagelength - tif->tif_row && !isTiled(tif) )
+        if((uint32_t)nrows > td->td_imagelength - tif->tif_row && !isTiled(tif) )
             nrows = td->td_imagelength - tif->tif_row;
 
 	/* data is expected to be read in multiples of a scanline */
@@ -1778,7 +1784,7 @@ JPEGSetupEncode(TIFF* tif)
                 if( td->td_bitspersample > 16 )
                 {
                     TIFFErrorExt(tif->tif_clientdata, module,
-                                 "BitsPerSample %d not allowed for JPEG",
+                                 "BitsPerSample %"PRIu16" not allowed for JPEG",
                                  td->td_bitspersample);
                     return (0);
                 }
@@ -1808,8 +1814,8 @@ JPEGSetupEncode(TIFF* tif)
 	case PHOTOMETRIC_PALETTE:		/* disallowed by Tech Note */
 	case PHOTOMETRIC_MASK:
 		TIFFErrorExt(tif->tif_clientdata, module,
-			  "PhotometricInterpretation %d not allowed for JPEG",
-			  (int) sp->photometric);
+			  "PhotometricInterpretation %"PRIu16" not allowed for JPEG",
+			  sp->photometric);
 		return (0);
 	default:
 		/* TIFF 6.0 forbids subsampling of all other color spaces */
@@ -1832,8 +1838,8 @@ JPEGSetupEncode(TIFF* tif)
 	if (td->td_bitspersample != BITS_IN_JSAMPLE )
 #endif
 	{
-		TIFFErrorExt(tif->tif_clientdata, module, "BitsPerSample %d not allowed for JPEG",
-			  (int) td->td_bitspersample);
+		TIFFErrorExt(tif->tif_clientdata, module, "BitsPerSample %"PRIu16" not allowed for JPEG",
+			  td->td_bitspersample);
 		return (0);
 	}
 	sp->cinfo.c.data_precision = td->td_bitspersample;
@@ -1843,22 +1849,22 @@ JPEGSetupEncode(TIFF* tif)
 	if (isTiled(tif)) {
 		if ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-				  "JPEG tile height must be multiple of %d",
-				  sp->v_sampling * DCTSIZE);
+				  "JPEG tile height must be multiple of %"PRIu32,
+				  (uint32_t)(sp->v_sampling * DCTSIZE));
 			return (0);
 		}
 		if ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-				  "JPEG tile width must be multiple of %d",
-				  sp->h_sampling * DCTSIZE);
+				  "JPEG tile width must be multiple of %"PRIu32,
+				  (uint32_t)(sp->h_sampling * DCTSIZE));
 			return (0);
 		}
 	} else {
 		if (td->td_rowsperstrip < td->td_imagelength &&
 		    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-				  "RowsPerStrip must be multiple of %d for JPEG",
-				  sp->v_sampling * DCTSIZE);
+				  "RowsPerStrip must be multiple of %"PRIu32" for JPEG",
+				  (uint32_t)(sp->v_sampling * DCTSIZE));
 			return (0);
 		}
 	}
@@ -1891,12 +1897,12 @@ JPEGSetupEncode(TIFF* tif)
  * Set encoding state at the start of a strip or tile.
  */
 static int
-JPEGPreEncode(TIFF* tif, uint16 s)
+JPEGPreEncode(TIFF* tif, uint16_t s)
 {
 	JPEGState *sp = JState(tif);
 	TIFFDirectory *td = &tif->tif_dir;
 	static const char module[] = "JPEGPreEncode";
-	uint32 segment_width, segment_height;
+	uint32_t segment_width, segment_height;
 	int downsampled_input;
 
 	assert(sp != NULL);
@@ -2028,7 +2034,7 @@ JPEGPreEncode(TIFF* tif, uint16 s)
  * "Standard" case: incoming data is not downsampled.
  */
 static int
-JPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+JPEGEncode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
 	JPEGState *sp = JState(tif);
 	tmsize_t nrows;
@@ -2106,7 +2112,7 @@ JPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
  * Incoming data is expected to be downsampled per sampling factors.
  */
 static int
-JPEGEncodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+JPEGEncodeRaw(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
 	JPEGState *sp = JState(tif);
 	JSAMPLE* inptr;
@@ -2280,17 +2286,17 @@ JPEGResetUpsampled( TIFF* tif )
 }
 
 static int
-JPEGVSetField(TIFF* tif, uint32 tag, va_list ap)
+JPEGVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	JPEGState* sp = JState(tif);
 	const TIFFField* fip;
-	uint32 v32;
+	uint32_t v32;
 
 	assert(sp != NULL);
 
 	switch (tag) {
 	case TIFFTAG_JPEGTABLES:
-		v32 = (uint32) va_arg(ap, uint32);
+		v32 = (uint32_t) va_arg(ap, uint32_t);
 		if (v32 == 0) {
 			/* XXX */
 			return (0);
@@ -2335,7 +2341,7 @@ JPEGVSetField(TIFF* tif, uint32 tag, va_list ap)
 }
 
 static int
-JPEGVGetField(TIFF* tif, uint32 tag, va_list ap)
+JPEGVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	JPEGState* sp = JState(tif);
 
@@ -2343,8 +2349,8 @@ JPEGVGetField(TIFF* tif, uint32 tag, va_list ap)
 
 	switch (tag) {
 		case TIFFTAG_JPEGTABLES:
-			*va_arg(ap, uint32*) = sp->jpegtables_length;
-			*va_arg(ap, void**) = sp->jpegtables;
+			*va_arg(ap, uint32_t*) = sp->jpegtables_length;
+			*va_arg(ap, const void**) = sp->jpegtables;
 			break;
 		case TIFFTAG_JPEGQUALITY:
 			*va_arg(ap, int*) = sp->jpegquality;
@@ -2371,15 +2377,15 @@ JPEGPrintDir(TIFF* tif, FILE* fd, long flags)
 
         if( sp != NULL ) {
 		if (TIFFFieldSet(tif,FIELD_JPEGTABLES))
-			fprintf(fd, "  JPEG Tables: (%lu bytes)\n",
-				(unsigned long) sp->jpegtables_length);
+			fprintf(fd, "  JPEG Tables: (%"PRIu32" bytes)\n",
+				sp->jpegtables_length);
 		if (sp->printdir)
 			(*sp->printdir)(tif, fd, flags);
 	}
 }
 
-static uint32
-JPEGDefaultStripSize(TIFF* tif, uint32 s)
+static uint32_t
+JPEGDefaultStripSize(TIFF* tif, uint32_t s)
 {
 	JPEGState* sp = JState(tif);
 	TIFFDirectory *td = &tif->tif_dir;
@@ -2391,7 +2397,7 @@ JPEGDefaultStripSize(TIFF* tif, uint32 s)
 }
 
 static void
-JPEGDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)
+JPEGDefaultTileSize(TIFF* tif, uint32_t* tw, uint32_t* th)
 {
 	JPEGState* sp = JState(tif);
 	TIFFDirectory *td = &tif->tif_dir;
@@ -2479,6 +2485,7 @@ TIFFInitJPEG(TIFF* tif, int scheme)
 {
 	JPEGState* sp;
 
+        (void)scheme;
 	assert(scheme == COMPRESSION_JPEG);
 
 	/*
@@ -2494,7 +2501,7 @@ TIFFInitJPEG(TIFF* tif, int scheme)
 	/*
 	 * Allocate state block so tag methods have storage to record values.
 	 */
-	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (JPEGState));
+	tif->tif_data = (uint8_t*) _TIFFmalloc(sizeof (JPEGState));
 
 	if (tif->tif_data == NULL) {
 		TIFFErrorExt(tif->tif_clientdata,
diff --git a/src/3rdparty/libtiff/libtiff/tif_lerc.c b/src/3rdparty/libtiff/libtiff/tif_lerc.c
new file mode 100644
index 0000000..a4aeb4a
--- /dev/null
+++ b/src/3rdparty/libtiff/libtiff/tif_lerc.c
@@ -0,0 +1,1277 @@
+/*
+* Copyright (c) 2018, Even Rouault
+* Author: <even.rouault at spatialys.com>
+*
+* Permission to use, copy, modify, distribute, and sell this software and
+* its documentation for any purpose is hereby granted without fee, provided
+* that (i) the above copyright notices and this permission notice appear in
+* all copies of the software and related documentation, and (ii) the names of
+* Sam Leffler and Silicon Graphics may not be used in any advertising or
+* publicity relating to the software without the specific, prior written
+* permission of Sam Leffler and Silicon Graphics.
+*
+* THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
+* WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+*
+* IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+* ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+* OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+* WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
+* LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+* OF THIS SOFTWARE.
+*/
+
+#include "tiffiop.h"
+#ifdef LERC_SUPPORT
+/*
+* TIFF Library.
+*
+* LERC Compression Support
+*
+*/
+
+#include "Lerc_c_api.h"
+#include "zlib.h"
+#ifdef ZSTD_SUPPORT
+#include "zstd.h"
+#endif
+
+#if LIBDEFLATE_SUPPORT
+#include "libdeflate.h"
+#endif
+#define LIBDEFLATE_MAX_COMPRESSION_LEVEL 12
+
+#include <assert.h>
+
+#define LSTATE_INIT_DECODE 0x01
+#define LSTATE_INIT_ENCODE 0x02
+
+#ifndef LERC_AT_LEAST_VERSION
+#define LERC_AT_LEAST_VERSION(maj,min,patch) 0
+#endif
+
+/*
+* State block for each open TIFF file using LERC compression/decompression.
+*/
+typedef struct {
+        double          maxzerror;              /* max z error */
+        int             lerc_version;
+        int             additional_compression;
+        int             zstd_compress_level;      /* zstd */
+        int             zipquality;             /* deflate */
+        int             state;                  /* state flags */
+
+        uint32_t        segment_width;
+        uint32_t        segment_height;
+
+        unsigned int    uncompressed_size;
+        unsigned int    uncompressed_alloc;
+        uint8_t        *uncompressed_buffer;
+        unsigned int    uncompressed_offset;
+
+        unsigned int    mask_size;
+        uint8_t        *mask_buffer;
+
+        unsigned int    compressed_size;
+        void           *compressed_buffer;
+
+#if LIBDEFLATE_SUPPORT
+        struct libdeflate_decompressor* libdeflate_dec;
+        struct libdeflate_compressor*   libdeflate_enc;
+#endif
+
+        TIFFVGetMethod  vgetparent;            /* super-class method */
+        TIFFVSetMethod  vsetparent;            /* super-class method */
+} LERCState;
+
+#define LState(tif)             ((LERCState*) (tif)->tif_data)
+#define DecoderState(tif)       LState(tif)
+#define EncoderState(tif)       LState(tif)
+
+static int LERCEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s);
+static int LERCDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s);
+
+static int
+LERCFixupTags(TIFF* tif)
+{
+        (void) tif;
+        return 1;
+}
+
+static int
+LERCSetupDecode(TIFF* tif)
+{
+        LERCState* sp = DecoderState(tif);
+
+        assert(sp != NULL);
+
+        /* if we were last encoding, terminate this mode */
+        if (sp->state & LSTATE_INIT_ENCODE) {
+            sp->state = 0;
+        }
+
+        sp->state |= LSTATE_INIT_DECODE;
+        return 1;
+}
+
+static int GetLercDataType(TIFF* tif)
+{
+    TIFFDirectory *td = &tif->tif_dir;
+    static const char module[] = "GetLercDataType";
+
+    if( td->td_sampleformat == SAMPLEFORMAT_INT &&
+            td->td_bitspersample == 8 )
+    {
+        return 0;
+    }
+
+    if( td->td_sampleformat == SAMPLEFORMAT_UINT &&
+            td->td_bitspersample == 8 )
+    {
+        return 1;
+    }
+
+    if( td->td_sampleformat == SAMPLEFORMAT_INT &&
+            td->td_bitspersample == 16 )
+    {
+        return 2;
+    }
+
+    if( td->td_sampleformat == SAMPLEFORMAT_UINT &&
+            td->td_bitspersample == 16 )
+    {
+        return 3;
+    }
+
+    if( td->td_sampleformat == SAMPLEFORMAT_INT &&
+            td->td_bitspersample == 32 )
+    {
+        return 4;
+    }
+
+    if( td->td_sampleformat == SAMPLEFORMAT_UINT &&
+            td->td_bitspersample == 32 )
+    {
+        return 5;
+    }
+
+    if( td->td_sampleformat == SAMPLEFORMAT_IEEEFP &&
+            td->td_bitspersample == 32 )
+    {
+        return 6;
+    }
+
+    if( td->td_sampleformat == SAMPLEFORMAT_IEEEFP &&
+            td->td_bitspersample == 64 )
+    {
+        return 7;
+    }
+
+    TIFFErrorExt(tif->tif_clientdata, module,
+        "Unsupported combination of SampleFormat and td_bitspersample");
+    return -1;
+}
+
+static int SetupUncompressedBuffer(TIFF* tif, LERCState* sp,
+                                   const char* module)
+{
+    TIFFDirectory *td = &tif->tif_dir;
+    uint64_t new_size_64;
+    uint64_t new_alloc_64;
+    unsigned int new_size;
+    unsigned int new_alloc;
+
+    sp->uncompressed_offset = 0;
+
+    if (isTiled(tif)) {
+            sp->segment_width = td->td_tilewidth;
+            sp->segment_height = td->td_tilelength;
+    } else {
+            sp->segment_width = td->td_imagewidth;
+            sp->segment_height = td->td_imagelength - tif->tif_row;
+            if (sp->segment_height > td->td_rowsperstrip)
+                sp->segment_height = td->td_rowsperstrip;
+    }
+
+    new_size_64 = (uint64_t)sp->segment_width * sp->segment_height *
+                                        (td->td_bitspersample / 8);
+    if( td->td_planarconfig == PLANARCONFIG_CONTIG )
+    {
+        new_size_64 *= td->td_samplesperpixel;
+    }
+
+    new_size = (unsigned int)new_size_64;
+    sp->uncompressed_size = new_size;
+
+    /* add some margin as we are going to use it also to store deflate/zstd compressed data */
+    new_alloc_64 = 100 + new_size_64 + new_size_64 / 3;
+#ifdef ZSTD_SUPPORT
+    {
+        size_t zstd_max = ZSTD_compressBound((size_t)new_size_64);
+        if( new_alloc_64 < zstd_max )
+        {
+            new_alloc_64 = zstd_max;
+        }
+    }
+#endif
+    new_alloc = (unsigned int)new_alloc_64;
+    if( new_alloc != new_alloc_64 )
+    {
+        TIFFErrorExt(tif->tif_clientdata, module,
+                        "Too large uncompressed strip/tile");
+        _TIFFfree(sp->uncompressed_buffer);
+        sp->uncompressed_buffer = 0;
+        sp->uncompressed_alloc = 0;
+        return 0;
+    }
+
+    if( sp->uncompressed_alloc < new_alloc )
+    {
+        _TIFFfree(sp->uncompressed_buffer);
+        sp->uncompressed_buffer = _TIFFmalloc(new_alloc);
+        if( !sp->uncompressed_buffer )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                            "Cannot allocate buffer");
+            _TIFFfree(sp->uncompressed_buffer);
+            sp->uncompressed_buffer = 0;
+            sp->uncompressed_alloc = 0;
+            return 0;
+        }
+        sp->uncompressed_alloc = new_alloc;
+    }
+
+    if( (td->td_planarconfig == PLANARCONFIG_CONTIG &&
+         td->td_extrasamples > 0 &&
+         td->td_sampleinfo[td->td_extrasamples-1] == EXTRASAMPLE_UNASSALPHA &&
+         GetLercDataType(tif) == 1 ) ||
+        (td->td_sampleformat == SAMPLEFORMAT_IEEEFP &&
+         (td->td_planarconfig == PLANARCONFIG_SEPARATE ||
+         td->td_samplesperpixel == 1) &&
+         (td->td_bitspersample == 32 || td->td_bitspersample == 64 )) )
+    {
+        unsigned int mask_size = sp->segment_width * sp->segment_height;
+        if( sp->mask_size < mask_size )
+        {
+            void* mask_buffer = _TIFFrealloc(sp->mask_buffer, mask_size);
+            if( mask_buffer == NULL )
+            {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                                "Cannot allocate buffer");
+                sp->mask_size = 0;
+                _TIFFfree(sp->uncompressed_buffer);
+                sp->uncompressed_buffer = 0;
+                sp->uncompressed_alloc = 0;
+                return 0;
+            }
+            sp->mask_buffer = (uint8_t*)mask_buffer;
+            sp->mask_size = mask_size;
+        }
+    }
+
+    return 1;
+}
+
+/*
+* Setup state for decoding a strip.
+*/
+static int
+LERCPreDecode(TIFF* tif, uint16_t s)
+{
+        static const char module[] = "LERCPreDecode";
+        lerc_status lerc_ret;
+        TIFFDirectory *td = &tif->tif_dir;
+        LERCState* sp = DecoderState(tif);
+        int lerc_data_type;
+        unsigned int infoArray[8];
+        unsigned nomask_bands = td->td_samplesperpixel;
+        int ndims;
+        int use_mask = 0;
+        uint8_t* lerc_data = tif->tif_rawcp;
+        unsigned int lerc_data_size = (unsigned int)tif->tif_rawcc;
+
+        (void) s;
+        assert(sp != NULL);
+        if( sp->state != LSTATE_INIT_DECODE )
+            tif->tif_setupdecode(tif);
+
+        lerc_data_type = GetLercDataType(tif);
+        if( lerc_data_type < 0 )
+            return 0;
+
+        if( !SetupUncompressedBuffer(tif, sp, module) )
+            return 0;
+
+        if( sp->additional_compression != LERC_ADD_COMPRESSION_NONE )
+        {
+            if( sp->compressed_size < sp->uncompressed_alloc )
+            {
+                _TIFFfree(sp->compressed_buffer);
+                sp->compressed_buffer = _TIFFmalloc(sp->uncompressed_alloc);
+                if( !sp->compressed_buffer )
+                {
+                    sp->compressed_size = 0;
+                    return 0;
+                }
+                sp->compressed_size = sp->uncompressed_alloc;
+            }
+        }
+
+        if( sp->additional_compression == LERC_ADD_COMPRESSION_DEFLATE )
+        {
+#if LIBDEFLATE_SUPPORT
+            enum libdeflate_result res;
+            size_t lerc_data_sizet = 0;
+            if( sp->libdeflate_dec == NULL )
+            {
+                sp->libdeflate_dec = libdeflate_alloc_decompressor();
+                if( sp->libdeflate_dec == NULL )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "Cannot allocate decompressor");
+                    return 0;
+                }
+            }
+
+            res = libdeflate_zlib_decompress(
+                sp->libdeflate_dec, tif->tif_rawcp, (size_t)tif->tif_rawcc,
+                sp->compressed_buffer, sp->compressed_size,
+                &lerc_data_sizet);
+            if( res != LIBDEFLATE_SUCCESS )
+            {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                                "Decoding error at scanline %lu",
+                                (unsigned long) tif->tif_row);
+                return 0;
+            }
+            assert( lerc_data_sizet == (unsigned int)lerc_data_sizet );
+            lerc_data = sp->compressed_buffer;
+            lerc_data_size = (unsigned int)lerc_data_sizet;
+#else
+            z_stream strm;
+            int zlib_ret;
+
+            memset(&strm, 0, sizeof(strm));
+            strm.zalloc = NULL;
+            strm.zfree = NULL;
+            strm.opaque = NULL;
+            zlib_ret = inflateInit(&strm);
+            if( zlib_ret != Z_OK )
+            {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                         "inflateInit() failed");
+                inflateEnd(&strm);
+                return 0;
+            }
+
+            strm.avail_in = (uInt)tif->tif_rawcc;
+            strm.next_in = tif->tif_rawcp;
+            strm.avail_out = sp->compressed_size;
+            strm.next_out = sp->compressed_buffer;
+            zlib_ret = inflate(&strm, Z_FINISH);
+            if( zlib_ret != Z_STREAM_END && zlib_ret != Z_OK )
+            {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                         "inflate() failed");
+                inflateEnd(&strm);
+                return 0;
+            }
+            lerc_data = sp->compressed_buffer;
+            lerc_data_size = sp->compressed_size - strm.avail_out;
+            inflateEnd(&strm);
+#endif
+        }
+        else if( sp->additional_compression == LERC_ADD_COMPRESSION_ZSTD )
+        {
+#ifdef ZSTD_SUPPORT
+            size_t zstd_ret;
+
+            zstd_ret = ZSTD_decompress(sp->compressed_buffer,
+                                       sp->compressed_size,
+                                       tif->tif_rawcp,
+                                       tif->tif_rawcc);
+            if( ZSTD_isError(zstd_ret) ) {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                            "Error in ZSTD_decompress(): %s",
+                            ZSTD_getErrorName(zstd_ret));
+                return 0;
+            }
+
+            lerc_data = sp->compressed_buffer;
+            lerc_data_size = (unsigned int)zstd_ret;
+#else
+            TIFFErrorExt(tif->tif_clientdata, module, "ZSTD support missing");
+            return 0;
+#endif
+        }
+        else if( sp->additional_compression != LERC_ADD_COMPRESSION_NONE )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unhandled additional compression");
+            return 0;
+        }
+
+        lerc_ret = lerc_getBlobInfo(
+            lerc_data,
+            lerc_data_size,
+            infoArray,
+            NULL,
+            8,
+            0);
+        if( lerc_ret != 0 )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "lerc_getBlobInfo() failed");
+            return 0;
+        }
+
+        /* If the configuration is compatible of a LERC mask, and that the */
+        /* LERC info has dim == samplesperpixel - 1, then there is a LERC */
+        /* mask. */
+        if( td->td_planarconfig == PLANARCONFIG_CONTIG &&
+            td->td_extrasamples > 0 &&
+            td->td_sampleinfo[td->td_extrasamples-1] == EXTRASAMPLE_UNASSALPHA &&
+            GetLercDataType(tif) == 1 &&
+            infoArray[2] == td->td_samplesperpixel - 1U )
+        {
+            use_mask = 1;
+            nomask_bands --;
+        }
+        else if( td->td_sampleformat == SAMPLEFORMAT_IEEEFP &&
+                 (td->td_planarconfig == PLANARCONFIG_SEPARATE ||
+                  td->td_samplesperpixel == 1) &&
+                 (td->td_bitspersample == 32 || td->td_bitspersample == 64) )
+        {
+            use_mask = 1;
+        }
+
+        ndims = td->td_planarconfig == PLANARCONFIG_CONTIG ?
+                                                nomask_bands : 1;
+
+        /* Info returned in infoArray is { version, dataType, nDim, nCols,
+            nRows, nBands, nValidPixels, blobSize } */
+        if( infoArray[0] != (unsigned)sp->lerc_version )
+        {
+            TIFFWarningExt(tif->tif_clientdata, module,
+                         "Unexpected version number: %d. Expected: %d",
+                         infoArray[0], sp->lerc_version);
+        }
+        if( infoArray[1] != (unsigned)lerc_data_type )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unexpected dataType: %d. Expected: %d",
+                         infoArray[1], lerc_data_type);
+            return 0;
+        }
+        if( infoArray[2] != (unsigned)ndims )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unexpected nDim: %d. Expected: %d",
+                         infoArray[2], ndims);
+            return 0;
+        }
+        if( infoArray[3] != sp->segment_width )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unexpected nCols: %d. Expected: %du",
+                         infoArray[3], sp->segment_width);
+            return 0;
+        }
+        if( infoArray[4] != sp->segment_height )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unexpected nRows: %d. Expected: %u",
+                         infoArray[4], sp->segment_height);
+            return 0;
+        }
+        if( infoArray[5] != 1 )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unexpected nBands: %d. Expected: %d",
+                         infoArray[5], 1);
+            return 0;
+        }
+        if( infoArray[7] != lerc_data_size )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unexpected blobSize: %d. Expected: %u",
+                         infoArray[7],
+                         lerc_data_size);
+            return 0;
+        }
+
+        lerc_ret = lerc_decode(
+            lerc_data,
+            lerc_data_size,
+#if LERC_AT_LEAST_VERSION(3,0,0)
+            use_mask ? 1 : 0,
+#endif
+            use_mask ? sp->mask_buffer : NULL,
+            ndims,
+            sp->segment_width,
+            sp->segment_height,
+            1,
+            lerc_data_type,
+            sp->uncompressed_buffer);
+        if( lerc_ret != 0 )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "lerc_decode() failed");
+            return 0;
+        }
+
+        /* Interleave alpha mask with other samples. */
+        if( use_mask && GetLercDataType(tif) == 1 )
+        {
+            unsigned src_stride =
+                (td->td_samplesperpixel - 1) * (td->td_bitspersample / 8);
+            unsigned dst_stride =
+                td->td_samplesperpixel * (td->td_bitspersample / 8);
+            unsigned i = sp->segment_width * sp->segment_height;
+            /* Operate from end to begin to be able to move in place */
+            while( i > 0 && i > nomask_bands )
+            {
+                i --;
+                sp->uncompressed_buffer[
+                    i * dst_stride + td->td_samplesperpixel - 1] =
+                        255 * sp->mask_buffer[i];
+                memcpy( sp->uncompressed_buffer + i * dst_stride,
+                        sp->uncompressed_buffer + i * src_stride,
+                        src_stride );
+            }
+            /* First pixels must use memmove due to overlapping areas */
+            while( i > 0  )
+            {
+                i --;
+                sp->uncompressed_buffer[
+                    i * dst_stride + td->td_samplesperpixel - 1] =
+                        255 * sp->mask_buffer[i];
+                memmove( sp->uncompressed_buffer + i * dst_stride,
+                        sp->uncompressed_buffer + i * src_stride,
+                        src_stride );
+            }
+        }
+        else if( use_mask && td->td_sampleformat == SAMPLEFORMAT_IEEEFP )
+        {
+            const unsigned nb_pixels = sp->segment_width * sp->segment_height;
+            unsigned i;
+#if HOST_BIGENDIAN
+            const unsigned char nan_bytes[] = {  0x7f, 0xc0, 0, 0 };
+#else
+            const unsigned char nan_bytes[] = {  0, 0, 0xc0, 0x7f };
+#endif
+            float nan_float32;
+            memcpy(&nan_float32, nan_bytes, 4);
+
+            if( td->td_bitspersample == 32 )
+            {
+                for( i = 0; i < nb_pixels; i++ )
+                {
+                    if( sp->mask_buffer[i] == 0 )
+                        ((float*)sp->uncompressed_buffer)[i] = nan_float32;
+                }
+            }
+            else
+            {
+                const double nan_float64 = nan_float32;
+                for( i = 0; i < nb_pixels; i++ )
+                {
+                    if( sp->mask_buffer[i] == 0 )
+                        ((double*)sp->uncompressed_buffer)[i] = nan_float64;
+                }
+            }
+        }
+
+        return 1;
+}
+
+/*
+* Decode a strip, tile or scanline.
+*/
+static int
+LERCDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
+{
+        static const char module[] = "LERCDecode";
+        LERCState* sp = DecoderState(tif);
+
+        (void) s;
+        assert(sp != NULL);
+        assert(sp->state == LSTATE_INIT_DECODE);
+
+        if( sp->uncompressed_buffer == 0 )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Uncompressed buffer not allocated");
+            return 0;
+        }
+
+        if( (uint64_t)sp->uncompressed_offset +
+                                        (uint64_t)occ > sp->uncompressed_size )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Too many bytes read");
+            return 0;
+        }
+
+        memcpy(op,
+               sp->uncompressed_buffer + sp->uncompressed_offset,
+               occ);
+        sp->uncompressed_offset += (unsigned)occ;
+
+        return 1;
+}
+
+static int
+LERCSetupEncode(TIFF* tif)
+{
+        LERCState* sp = EncoderState(tif);
+
+        assert(sp != NULL);
+        if (sp->state & LSTATE_INIT_DECODE) {
+            sp->state = 0;
+        }
+
+        sp->state |= LSTATE_INIT_ENCODE;
+
+        return 1;
+}
+
+/*
+* Reset encoding state at the start of a strip.
+*/
+static int
+LERCPreEncode(TIFF* tif, uint16_t s)
+{
+        static const char module[] = "LERCPreEncode";
+        LERCState *sp = EncoderState(tif);
+        int lerc_data_type;
+
+        (void) s;
+        assert(sp != NULL);
+        if( sp->state != LSTATE_INIT_ENCODE )
+            tif->tif_setupencode(tif);
+
+        lerc_data_type = GetLercDataType(tif);
+        if( lerc_data_type < 0 )
+            return 0;
+
+        if( !SetupUncompressedBuffer(tif, sp, module) )
+            return 0;
+
+        return 1;
+}
+
+/*
+* Encode a chunk of pixels.
+*/
+static int
+LERCEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
+{
+        static const char module[] = "LERCEncode";
+        LERCState *sp = EncoderState(tif);
+
+        (void)s;
+        assert(sp != NULL);
+        assert(sp->state == LSTATE_INIT_ENCODE);
+
+        if( (uint64_t)sp->uncompressed_offset +
+                                    (uint64_t)cc > sp->uncompressed_size )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Too many bytes written");
+            return 0;
+        }
+
+        memcpy(sp->uncompressed_buffer + sp->uncompressed_offset,
+               bp, cc);
+        sp->uncompressed_offset += (unsigned)cc;
+
+        return 1;
+}
+
+/*
+* Finish off an encoded strip by flushing it.
+*/
+static int
+LERCPostEncode(TIFF* tif)
+{
+        lerc_status lerc_ret;
+        static const char module[] = "LERCPostEncode";
+        LERCState *sp = EncoderState(tif);
+        unsigned int numBytes = 0;
+        unsigned int numBytesWritten = 0;
+        TIFFDirectory *td = &tif->tif_dir;
+        int use_mask = 0;
+        unsigned dst_nbands = td->td_samplesperpixel;
+
+        if( sp->uncompressed_offset != sp->uncompressed_size )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unexpected number of bytes in the buffer");
+            return 0;
+        }
+
+        /* Extract alpha mask (if containing only 0 and 255 values, */
+        /* and compact array of regular bands */
+        if( td->td_planarconfig == PLANARCONFIG_CONTIG &&
+            td->td_extrasamples > 0 &&
+            td->td_sampleinfo[td->td_extrasamples-1] == EXTRASAMPLE_UNASSALPHA &&
+            GetLercDataType(tif) == 1 )
+        {
+            const unsigned dst_stride = (td->td_samplesperpixel - 1) *
+                                            (td->td_bitspersample / 8);
+            const unsigned src_stride = td->td_samplesperpixel *
+                                            (td->td_bitspersample / 8);
+            unsigned i = 0;
+            const unsigned nb_pixels = sp->segment_width * sp->segment_height;
+
+            use_mask = 1;
+            for( i = 0 ; i < nb_pixels; i++)
+            {
+                int v = sp->uncompressed_buffer[
+                            i * src_stride + td->td_samplesperpixel - 1];
+                if( v != 0 && v != 255 )
+                {
+                    use_mask = 0;
+                    break;
+                }
+            }
+
+            if( use_mask )
+            {
+                dst_nbands --;
+                /* First pixels must use memmove due to overlapping areas */
+                for( i = 0 ;i < dst_nbands && i < nb_pixels; i++)
+                {
+                    memmove( sp->uncompressed_buffer + i * dst_stride,
+                            sp->uncompressed_buffer + i * src_stride,
+                            dst_stride );
+                    sp->mask_buffer[i] = sp->uncompressed_buffer[
+                        i * src_stride + td->td_samplesperpixel - 1];
+                }
+                for(; i < nb_pixels; i++)
+                {
+                    memcpy( sp->uncompressed_buffer + i * dst_stride,
+                            sp->uncompressed_buffer + i * src_stride,
+                            dst_stride );
+                    sp->mask_buffer[i] = sp->uncompressed_buffer[
+                        i * src_stride + td->td_samplesperpixel - 1];
+                }
+            }
+        }
+        else if( td->td_sampleformat == SAMPLEFORMAT_IEEEFP &&
+                 (td->td_planarconfig == PLANARCONFIG_SEPARATE ||
+                  dst_nbands == 1) &&
+                 (td->td_bitspersample == 32 || td->td_bitspersample == 64 ) )
+        {
+            /* Check for NaN values */
+            unsigned i;
+            const unsigned nb_pixels = sp->segment_width * sp->segment_height;
+            if( td->td_bitspersample == 32 )
+            {
+                for( i = 0; i < nb_pixels; i++ )
+                {
+                    const float val = ((float*)sp->uncompressed_buffer)[i];
+                    if( val != val )
+                    {
+                        use_mask = 1;
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                for( i = 0; i < nb_pixels; i++ )
+                {
+                    const double val = ((double*)sp->uncompressed_buffer)[i];
+                    if( val != val )
+                    {
+                        use_mask = 1;
+                        break;
+                    }
+                }
+            }
+
+            if( use_mask )
+            {
+                if( td->td_bitspersample == 32 )
+                {
+                    for( i = 0; i < nb_pixels; i++ )
+                    {
+                        const float val = ((float*)sp->uncompressed_buffer)[i];
+                        sp->mask_buffer[i] = ( val == val ) ? 255 : 0;
+                    }
+                }
+                else
+                {
+                    for( i = 0; i < nb_pixels; i++ )
+                    {
+                        const double val = ((double*)sp->uncompressed_buffer)[i];
+                        sp->mask_buffer[i] = ( val == val ) ? 255 : 0;
+                    }
+                }
+            }
+        }
+
+
+#if 0
+        lerc_ret = lerc_computeCompressedSize(
+            sp->uncompressed_buffer,
+            sp->lerc_version,
+            GetLercDataType(tif),
+            td->td_planarconfig == PLANARCONFIG_CONTIG ?
+                dst_nbands : 1,
+            sp->segment_width,
+            sp->segment_height,
+            1,
+            use_mask ? sp->mask_buffer : NULL,
+            sp->maxzerror,
+            &numBytes);
+        if( lerc_ret != 0 )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "lerc_computeCompressedSize() failed");
+            return 0;
+        }
+#else
+        numBytes = sp->uncompressed_alloc;
+#endif
+
+        if( sp->compressed_size < numBytes )
+        {
+            _TIFFfree(sp->compressed_buffer);
+            sp->compressed_buffer = _TIFFmalloc(numBytes);
+            if( !sp->compressed_buffer )
+            {
+                sp->compressed_size = 0;
+                return 0;
+            }
+            sp->compressed_size = numBytes;
+        }
+
+        lerc_ret = lerc_encodeForVersion(
+            sp->uncompressed_buffer,
+            sp->lerc_version,
+            GetLercDataType(tif),
+            td->td_planarconfig == PLANARCONFIG_CONTIG ?
+                dst_nbands : 1,
+            sp->segment_width,
+            sp->segment_height,
+            1,
+#if LERC_AT_LEAST_VERSION(3,0,0)
+            use_mask ? 1 : 0,
+#endif
+            use_mask ? sp->mask_buffer : NULL,
+            sp->maxzerror,
+            sp->compressed_buffer,
+            sp->compressed_size,
+            &numBytesWritten);
+        if( lerc_ret != 0 )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "lerc_encode() failed");
+            return 0;
+        }
+        assert( numBytesWritten < numBytes );
+
+        if( sp->additional_compression == LERC_ADD_COMPRESSION_DEFLATE )
+        {
+#if LIBDEFLATE_SUPPORT
+            if( sp->libdeflate_enc == NULL )
+            {
+                /* To get results as good as zlib, we ask for an extra */
+                /* level of compression */
+                sp->libdeflate_enc = libdeflate_alloc_compressor(
+                    sp->zipquality == Z_DEFAULT_COMPRESSION ? 7 :
+                    sp->zipquality >= 6 && sp->zipquality <= 9 ? sp->zipquality + 1 :
+                    sp->zipquality);
+                if( sp->libdeflate_enc == NULL )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "Cannot allocate compressor");
+                    return 0;
+                }
+            }
+
+            /* Should not happen normally */
+            if( libdeflate_zlib_compress_bound(sp->libdeflate_enc, numBytesWritten) >
+                     sp->uncompressed_alloc )
+            {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                             "Output buffer for libdeflate too small");
+                return 0;
+            }
+
+            tif->tif_rawcc = libdeflate_zlib_compress(
+                sp->libdeflate_enc,
+                sp->compressed_buffer, numBytesWritten,
+                sp->uncompressed_buffer, sp->uncompressed_alloc);
+
+            if( tif->tif_rawcc == 0 )
+            {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                                "Encoder error at scanline %lu",
+                                (unsigned long) tif->tif_row);
+                return 0;
+            }
+#else
+            z_stream strm;
+            int zlib_ret;
+            int cappedQuality = sp->zipquality;
+            if( cappedQuality > Z_BEST_COMPRESSION )
+                cappedQuality = Z_BEST_COMPRESSION;
+
+            memset(&strm, 0, sizeof(strm));
+            strm.zalloc = NULL;
+            strm.zfree = NULL;
+            strm.opaque = NULL;
+            zlib_ret = deflateInit(&strm, cappedQuality);
+            if( zlib_ret != Z_OK )
+            {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                         "deflateInit() failed");
+                return 0;
+            }
+
+            strm.avail_in = numBytesWritten;
+            strm.next_in = sp->compressed_buffer;
+            strm.avail_out = sp->uncompressed_alloc;
+            strm.next_out = sp->uncompressed_buffer;
+            zlib_ret = deflate(&strm, Z_FINISH);
+            if( zlib_ret == Z_STREAM_END )
+            {
+                tif->tif_rawcc = sp->uncompressed_alloc - strm.avail_out;
+            }
+            deflateEnd(&strm);
+            if( zlib_ret != Z_STREAM_END )
+            {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                         "deflate() failed");
+                return 0;
+            }
+#endif
+            {
+                int ret;
+                uint8_t* tif_rawdata_backup = tif->tif_rawdata;
+                tif->tif_rawdata = sp->uncompressed_buffer;
+                ret = TIFFFlushData1(tif);
+                tif->tif_rawdata = tif_rawdata_backup;
+                if( !ret )
+                {
+                    return 0;
+                }
+            }
+        }
+        else if( sp->additional_compression == LERC_ADD_COMPRESSION_ZSTD )
+        {
+#ifdef ZSTD_SUPPORT
+            size_t zstd_ret = ZSTD_compress( sp->uncompressed_buffer,
+                                             sp->uncompressed_alloc,
+                                             sp->compressed_buffer,
+                                             numBytesWritten,
+                                             sp->zstd_compress_level );
+            if( ZSTD_isError(zstd_ret) ) {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                            "Error in ZSTD_compress(): %s",
+                            ZSTD_getErrorName(zstd_ret));
+                return 0;
+            }
+
+            {
+                int ret;
+                uint8_t* tif_rawdata_backup = tif->tif_rawdata;
+                tif->tif_rawdata = sp->uncompressed_buffer;
+                tif->tif_rawcc = zstd_ret;
+                ret = TIFFFlushData1(tif);
+                tif->tif_rawdata = tif_rawdata_backup;
+                if( !ret )
+                {
+                    return 0;
+                }
+            }
+#else
+            TIFFErrorExt(tif->tif_clientdata, module, "ZSTD support missing");
+            return 0;
+#endif
+        }
+        else if( sp->additional_compression != LERC_ADD_COMPRESSION_NONE )
+        {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Unhandled additional compression");
+            return 0;
+        }
+        else
+        {
+            int ret;
+            uint8_t* tif_rawdata_backup = tif->tif_rawdata;
+            tif->tif_rawdata = sp->compressed_buffer;
+            tif->tif_rawcc = numBytesWritten;
+            ret = TIFFFlushData1(tif);
+            tif->tif_rawdata = tif_rawdata_backup;
+            if( !ret )
+                return 0;
+        }
+
+        return 1;
+}
+
+static void
+LERCCleanup(TIFF* tif)
+{
+        LERCState* sp = LState(tif);
+
+        assert(sp != 0);
+
+        tif->tif_tagmethods.vgetfield = sp->vgetparent;
+        tif->tif_tagmethods.vsetfield = sp->vsetparent;
+
+        _TIFFfree(sp->uncompressed_buffer);
+        _TIFFfree(sp->compressed_buffer);
+        _TIFFfree(sp->mask_buffer);
+
+#if LIBDEFLATE_SUPPORT
+        if( sp->libdeflate_dec )
+            libdeflate_free_decompressor(sp->libdeflate_dec);
+        if( sp->libdeflate_enc )
+            libdeflate_free_compressor(sp->libdeflate_enc);
+#endif
+
+        _TIFFfree(sp);
+        tif->tif_data = NULL;
+
+        _TIFFSetDefaultCompressionState(tif);
+}
+
+static const TIFFField LERCFields[] = {
+        { TIFFTAG_LERC_PARAMETERS, TIFF_VARIABLE2, TIFF_VARIABLE2,
+          TIFF_LONG, 0, TIFF_SETGET_C32_UINT32, TIFF_SETGET_UNDEFINED,
+          FIELD_CUSTOM, FALSE, TRUE, "LercParameters", NULL },
+        { TIFFTAG_LERC_MAXZERROR, 0, 0, TIFF_ANY, 0, TIFF_SETGET_DOUBLE,
+          TIFF_SETGET_UNDEFINED,
+          FIELD_PSEUDO, TRUE, FALSE, "LercMaximumError", NULL },
+        { TIFFTAG_LERC_VERSION, 0, 0, TIFF_ANY, 0, TIFF_SETGET_UINT32,
+          TIFF_SETGET_UNDEFINED,
+          FIELD_PSEUDO, FALSE, FALSE, "LercVersion", NULL },
+        { TIFFTAG_LERC_ADD_COMPRESSION, 0, 0, TIFF_ANY, 0, TIFF_SETGET_UINT32,
+          TIFF_SETGET_UNDEFINED,
+          FIELD_PSEUDO, FALSE, FALSE, "LercAdditionalCompression", NULL },
+        { TIFFTAG_ZSTD_LEVEL, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT,
+          TIFF_SETGET_UNDEFINED,
+          FIELD_PSEUDO, TRUE, FALSE, "ZSTD zstd_compress_level", NULL },
+        { TIFFTAG_ZIPQUALITY, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT,
+          TIFF_SETGET_UNDEFINED, FIELD_PSEUDO, TRUE, FALSE, "", NULL },
+};
+
+static int LERCVSetFieldBase(TIFF* tif, uint32_t tag, ...)
+{
+    LERCState* sp = LState(tif);
+    int ret;
+    va_list ap;
+    va_start(ap, tag);
+    ret = (*sp->vsetparent)(tif, tag, ap);
+    va_end(ap);
+    return ret;
+}
+
+static int
+LERCVSetField(TIFF* tif, uint32_t tag, va_list ap)
+{
+	static const char module[] = "LERCVSetField";
+        LERCState* sp = LState(tif);
+
+        switch (tag) {
+        case TIFFTAG_LERC_PARAMETERS:
+        {
+                uint32_t count = va_arg(ap, int);
+                int* params = va_arg(ap, int*);
+                if( count < 2 )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                            "Invalid count for LercParameters: %u", count);
+                    return 0;
+                }
+                sp->lerc_version = params[0];
+                sp->additional_compression = params[1];
+                return LERCVSetFieldBase(tif, TIFFTAG_LERC_PARAMETERS,
+                                         count, params);
+        }
+        case TIFFTAG_LERC_MAXZERROR:
+                sp->maxzerror = va_arg(ap, double);
+                return 1;
+        case TIFFTAG_LERC_VERSION:
+        {
+                int params[2] = {0, 0};
+                int version = va_arg(ap, int);
+                if( version != LERC_VERSION_2_4 )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                            "Invalid value for LercVersion: %d", version);
+                    return 0;
+                }
+                sp->lerc_version = version;
+                params[0] = sp->lerc_version;
+                params[1] = sp->additional_compression;
+                return LERCVSetFieldBase(tif, TIFFTAG_LERC_PARAMETERS,
+                                         2, params);
+        }
+        case TIFFTAG_LERC_ADD_COMPRESSION:
+        {
+                int params[2] = {0, 0};
+                int additional_compression = va_arg(ap, int);
+#ifndef ZSTD_SUPPORT
+                if( additional_compression == LERC_ADD_COMPRESSION_ZSTD )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "LERC_ZSTD requested, but ZSTD not available");
+                    return 0;
+                }
+#endif
+                if( additional_compression != LERC_ADD_COMPRESSION_NONE &&
+                    additional_compression != LERC_ADD_COMPRESSION_DEFLATE &&
+                    additional_compression != LERC_ADD_COMPRESSION_ZSTD )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                            "Invalid value for LercAdditionalCompression: %d",
+                            additional_compression);
+                    return 0;
+                }
+                sp->additional_compression = additional_compression;
+                params[0] = sp->lerc_version;
+                params[1] = sp->additional_compression;
+                return LERCVSetFieldBase(tif, TIFFTAG_LERC_PARAMETERS,
+                                         2, params);
+        }
+#ifdef ZSTD_SUPPORT
+        case TIFFTAG_ZSTD_LEVEL:
+        {
+            sp->zstd_compress_level = (int) va_arg(ap, int);
+            if( sp->zstd_compress_level <= 0 ||
+                sp->zstd_compress_level > ZSTD_maxCLevel() )
+            {
+                TIFFWarningExt(tif->tif_clientdata, module,
+                                "ZSTD_LEVEL should be between 1 and %d",
+                                ZSTD_maxCLevel());
+            }
+            return 1;
+        }
+#endif
+	case TIFFTAG_ZIPQUALITY:
+        {
+                sp->zipquality = (int) va_arg(ap, int);
+                if( sp->zipquality < Z_DEFAULT_COMPRESSION ||
+                    sp->zipquality > LIBDEFLATE_MAX_COMPRESSION_LEVEL ) {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "Invalid ZipQuality value. Should be in [-1,%d] range",
+                                 LIBDEFLATE_MAX_COMPRESSION_LEVEL);
+                    return 0;
+                }
+
+#if LIBDEFLATE_SUPPORT
+                if( sp->libdeflate_enc )
+                {
+                    libdeflate_free_compressor(sp->libdeflate_enc);
+                    sp->libdeflate_enc = NULL;
+                }
+#endif
+
+                return (1);
+        }
+        default:
+                return (*sp->vsetparent)(tif, tag, ap);
+        }
+        /*NOTREACHED*/
+}
+
+static int
+LERCVGetField(TIFF* tif, uint32_t tag, va_list ap)
+{
+        LERCState* sp = LState(tif);
+
+        switch (tag) {
+        case TIFFTAG_LERC_MAXZERROR:
+                *va_arg(ap, double*) = sp->maxzerror;
+                break;
+        case TIFFTAG_LERC_VERSION:
+                *va_arg(ap, int*) = sp->lerc_version;
+                break;
+        case TIFFTAG_LERC_ADD_COMPRESSION:
+                *va_arg(ap, int*) = sp->additional_compression;
+                break;
+        case TIFFTAG_ZSTD_LEVEL:
+                *va_arg(ap, int*) = sp->zstd_compress_level;
+                break;
+        case TIFFTAG_ZIPQUALITY:
+                *va_arg(ap, int*) = sp->zipquality;
+                break;
+        default:
+                return (*sp->vgetparent)(tif, tag, ap);
+        }
+        return 1;
+}
+
+int TIFFInitLERC(TIFF* tif, int scheme)
+{
+        static const char module[] = "TIFFInitLERC";
+        LERCState* sp;
+
+        (void) scheme;
+        assert( scheme == COMPRESSION_LERC );
+
+        /*
+        * Merge codec-specific tag information.
+        */
+        if (!_TIFFMergeFields(tif, LERCFields, TIFFArrayCount(LERCFields))) {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                            "Merging LERC codec-specific tags failed");
+                return 0;
+        }
+
+        /*
+        * Allocate state block so tag methods have storage to record values.
+        */
+        tif->tif_data = (uint8_t*) _TIFFcalloc(1, sizeof(LERCState));
+        if (tif->tif_data == NULL)
+                goto bad;
+        sp = LState(tif);
+
+        /*
+        * Override parent get/set field methods.
+        */
+        sp->vgetparent = tif->tif_tagmethods.vgetfield;
+        tif->tif_tagmethods.vgetfield = LERCVGetField;	/* hook for codec tags */
+        sp->vsetparent = tif->tif_tagmethods.vsetfield;
+        tif->tif_tagmethods.vsetfield = LERCVSetField;	/* hook for codec tags */
+
+        /*
+        * Install codec methods.
+        */
+        tif->tif_fixuptags = LERCFixupTags;
+        tif->tif_setupdecode = LERCSetupDecode;
+        tif->tif_predecode = LERCPreDecode;
+        tif->tif_decoderow = LERCDecode;
+        tif->tif_decodestrip = LERCDecode;
+        tif->tif_decodetile = LERCDecode;
+        tif->tif_setupencode = LERCSetupEncode;
+        tif->tif_preencode = LERCPreEncode;
+        tif->tif_postencode = LERCPostEncode;
+        tif->tif_encoderow = LERCEncode;
+        tif->tif_encodestrip = LERCEncode;
+        tif->tif_encodetile = LERCEncode;
+        tif->tif_cleanup = LERCCleanup;
+
+        /* Default values for codec-specific fields */
+        TIFFSetField(tif, TIFFTAG_LERC_VERSION, LERC_VERSION_2_4);
+        TIFFSetField(tif, TIFFTAG_LERC_ADD_COMPRESSION, LERC_ADD_COMPRESSION_NONE);
+        sp->maxzerror = 0.0;
+        sp->zstd_compress_level = 9;		/* default comp. level */
+        sp->zipquality = Z_DEFAULT_COMPRESSION;	/* default comp. level */
+        sp->state = 0;
+
+        return 1;
+bad:
+        TIFFErrorExt(tif->tif_clientdata, module,
+                    "No space for LERC state block");
+        return 0;
+}
+#endif /* LERC_SUPPORT */
diff --git a/src/3rdparty/libtiff/libtiff/tif_luv.c b/src/3rdparty/libtiff/libtiff/tif_luv.c
index 6fe4858..13765ea 100644
--- a/src/3rdparty/libtiff/libtiff/tif_luv.c
+++ b/src/3rdparty/libtiff/libtiff/tif_luv.c
@@ -161,9 +161,9 @@ struct logLuvState {
 	int                     encode_meth;    /* encoding method */
 	int                     pixel_size;     /* bytes per pixel */
 
-	uint8*                  tbuf;           /* translation buffer */
+	uint8_t*                tbuf;           /* translation buffer */
 	tmsize_t                tbuflen;        /* buffer length */
-	void (*tfunc)(LogLuvState*, uint8*, tmsize_t);
+	void (*tfunc)(LogLuvState*, uint8_t*, tmsize_t);
 
 	TIFFVSetMethod          vgetparent;     /* super-class method */
 	TIFFVSetMethod          vsetparent;     /* super-class method */
@@ -180,7 +180,7 @@ struct logLuvState {
  * Decode a string of 16-bit gray pixels.
  */
 static int
-LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
+LogL16Decode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "LogL16Decode";
 	LogLuvState* sp = DecoderState(tif);
@@ -188,25 +188,26 @@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	tmsize_t i;
 	tmsize_t npixels;
 	unsigned char* bp;
-	int16* tp;
-	int16 b;
+	int16_t* tp;
+	int16_t b;
 	tmsize_t cc;
 	int rc;
 
+        (void)s;
 	assert(s == 0);
 	assert(sp != NULL);
 
 	npixels = occ / sp->pixel_size;
 
 	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
-		tp = (int16*) op;
+		tp = (int16_t*) op;
 	else {
 		if(sp->tbuflen < npixels) {
 			TIFFErrorExt(tif->tif_clientdata, module,
 						 "Translation buffer too short");
 			return (0);
 		}
-		tp = (int16*) sp->tbuf;
+		tp = (int16_t*) sp->tbuf;
 	}
 	_TIFFmemset((void*) tp, 0, npixels*sizeof (tp[0]));
 
@@ -219,35 +220,28 @@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 				if( cc < 2 )
 					break;
 				rc = *bp++ + (2-128);
-				b = (int16)(*bp++ << shft);
+				b = (int16_t)(*bp++ << shft);
 				cc -= 2;
 				while (rc-- && i < npixels)
 					tp[i++] |= b;
 			} else {			/* non-run */
 				rc = *bp++;		/* nul is noop */
 				while (--cc && rc-- && i < npixels)
-					tp[i++] |= (int16)*bp++ << shft;
+					tp[i++] |= (int16_t)*bp++ << shft;
 			}
 		}
 		if (i != npixels) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Not enough data at row %lu (short %I64d pixels)",
-				     (unsigned long) tif->tif_row,
-				     (unsigned __int64) (npixels - i));
-#else
-			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Not enough data at row %lu (short %llu pixels)",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long long) (npixels - i));
-#endif
-			tif->tif_rawcp = (uint8*) bp;
+			    "Not enough data at row %"PRIu32" (short %"TIFF_SSIZE_FORMAT" pixels)",
+				     tif->tif_row,
+				     npixels - i);
+			tif->tif_rawcp = (uint8_t*) bp;
 			tif->tif_rawcc = cc;
 			return (0);
 		}
 	}
 	(*sp->tfunc)(sp, op, npixels);
-	tif->tif_rawcp = (uint8*) bp;
+	tif->tif_rawcp = (uint8_t*) bp;
 	tif->tif_rawcc = cc;
 	return (1);
 }
@@ -256,7 +250,7 @@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
  * Decode a string of 24-bit pixels.
  */
 static int
-LogLuvDecode24(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
+LogLuvDecode24(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "LogLuvDecode24";
 	LogLuvState* sp = DecoderState(tif);
@@ -264,24 +258,25 @@ LogLuvDecode24(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	tmsize_t i;
 	tmsize_t npixels;
 	unsigned char* bp;
-	uint32* tp;
+	uint32_t* tp;
 
+        (void)s;
 	assert(s == 0);
 	assert(sp != NULL);
 
 	npixels = occ / sp->pixel_size;
 
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
-		tp = (uint32 *)op;
+		tp = (uint32_t *)op;
 	else {
 		if(sp->tbuflen < npixels) {
 			TIFFErrorExt(tif->tif_clientdata, module,
 						 "Translation buffer too short");
 			return (0);
 		}
-		tp = (uint32 *) sp->tbuf;
+		tp = (uint32_t *) sp->tbuf;
 	}
-	/* copy to array of uint32 */
+	/* copy to array of uint32_t */
 	bp = (unsigned char*) tif->tif_rawcp;
 	cc = tif->tif_rawcc;
 	for (i = 0; i < npixels && cc >= 3; i++) {
@@ -289,20 +284,13 @@ LogLuvDecode24(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 		bp += 3;
 		cc -= 3;
 	}
-	tif->tif_rawcp = (uint8*) bp;
+	tif->tif_rawcp = (uint8_t*) bp;
 	tif->tif_rawcc = cc;
 	if (i != npixels) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-		TIFFErrorExt(tif->tif_clientdata, module,
-			"Not enough data at row %lu (short %I64d pixels)",
-			     (unsigned long) tif->tif_row,
-			     (unsigned __int64) (npixels - i));
-#else
 		TIFFErrorExt(tif->tif_clientdata, module,
-			"Not enough data at row %lu (short %llu pixels)",
-			     (unsigned long) tif->tif_row,
-			     (unsigned long long) (npixels - i));
-#endif
+			"Not enough data at row %"PRIu32" (short %"TIFF_SSIZE_FORMAT" pixels)",
+			     tif->tif_row,
+			     npixels - i);
 		return (0);
 	}
 	(*sp->tfunc)(sp, op, npixels);
@@ -313,7 +301,7 @@ LogLuvDecode24(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
  * Decode a string of 32-bit pixels.
  */
 static int
-LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
+LogLuvDecode32(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "LogLuvDecode32";
 	LogLuvState* sp;
@@ -321,11 +309,12 @@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	tmsize_t i;
 	tmsize_t npixels;
 	unsigned char* bp;
-	uint32* tp;
-	uint32 b;
+	uint32_t* tp;
+	uint32_t b;
 	tmsize_t cc;
 	int rc;
 
+        (void)s;
 	assert(s == 0);
 	sp = DecoderState(tif);
 	assert(sp != NULL);
@@ -333,14 +322,14 @@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	npixels = occ / sp->pixel_size;
 
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
-		tp = (uint32*) op;
+		tp = (uint32_t*) op;
 	else {
 		if(sp->tbuflen < npixels) {
 			TIFFErrorExt(tif->tif_clientdata, module,
 						 "Translation buffer too short");
 			return (0);
 		}
-		tp = (uint32*) sp->tbuf;
+		tp = (uint32_t*) sp->tbuf;
 	}
 	_TIFFmemset((void*) tp, 0, npixels*sizeof (tp[0]));
 
@@ -353,35 +342,28 @@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 				if( cc < 2 )
 					break;
 				rc = *bp++ + (2-128);
-				b = (uint32)*bp++ << shft;
+				b = (uint32_t)*bp++ << shft;
 				cc -= 2;
 				while (rc-- && i < npixels)
 					tp[i++] |= b;
 			} else {			/* non-run */
 				rc = *bp++;		/* nul is noop */
 				while (--cc && rc-- && i < npixels)
-					tp[i++] |= (uint32)*bp++ << shft;
+					tp[i++] |= (uint32_t)*bp++ << shft;
 			}
 		}
 		if (i != npixels) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-			TIFFErrorExt(tif->tif_clientdata, module,
-			"Not enough data at row %lu (short %I64d pixels)",
-				     (unsigned long) tif->tif_row,
-				     (unsigned __int64) (npixels - i));
-#else
 			TIFFErrorExt(tif->tif_clientdata, module,
-			"Not enough data at row %lu (short %llu pixels)",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long long) (npixels - i));
-#endif
-			tif->tif_rawcp = (uint8*) bp;
+			"Not enough data at row %"PRIu32" (short %"TIFF_SSIZE_FORMAT" pixels)",
+				     tif->tif_row,
+				     npixels - i);
+			tif->tif_rawcp = (uint8_t*) bp;
 			tif->tif_rawcc = cc;
 			return (0);
 		}
 	}
 	(*sp->tfunc)(sp, op, npixels);
-	tif->tif_rawcp = (uint8*) bp;
+	tif->tif_rawcp = (uint8_t*) bp;
 	tif->tif_rawcc = cc;
 	return (1);
 }
@@ -392,7 +374,7 @@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
  * is row by row.
  */
 static int
-LogLuvDecodeStrip(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LogLuvDecodeStrip(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	tmsize_t rowlen = TIFFScanlineSize(tif);
 
@@ -413,7 +395,7 @@ LogLuvDecodeStrip(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
  * is row by row.
  */
 static int
-LogLuvDecodeTile(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LogLuvDecodeTile(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	tmsize_t rowlen = TIFFTileRowSize(tif);
 
@@ -432,7 +414,7 @@ LogLuvDecodeTile(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
  * Encode a row of 16-bit pixels.
  */
 static int
-LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LogL16Encode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "LogL16Encode";
 	LogLuvState* sp = EncoderState(tif);
@@ -440,21 +422,22 @@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 	tmsize_t i;
 	tmsize_t j;
 	tmsize_t npixels;
-	uint8* op;
-	int16* tp;
-	int16 b;
+	uint8_t* op;
+	int16_t* tp;
+	int16_t b;
 	tmsize_t occ;
 	int rc=0, mask;
 	tmsize_t beg;
 
+        (void)s;
 	assert(s == 0);
 	assert(sp != NULL);
 	npixels = cc / sp->pixel_size;
 
 	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
-		tp = (int16*) bp;
+		tp = (int16_t*) bp;
 	else {
-		tp = (int16*) sp->tbuf;
+		tp = (int16_t*) sp->tbuf;
 		if(sp->tbuflen < npixels) {
 			TIFFErrorExt(tif->tif_clientdata, module,
 						 "Translation buffer too short");
@@ -477,7 +460,7 @@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 			}
 			mask = 0xff << shft;		/* find next run */
 			for (beg = i; beg < npixels; beg += rc) {
-				b = (int16) (tp[beg] & mask);
+				b = (int16_t) (tp[beg] & mask);
 				rc = 1;
 				while (rc < 127+2 && beg+rc < npixels &&
 				    (tp[beg+rc] & mask) == b)
@@ -486,12 +469,12 @@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 					break;		/* long enough */
 			}
 			if (beg-i > 1 && beg-i < MINRUN) {
-				b = (int16) (tp[i] & mask);/*check short run */
+				b = (int16_t) (tp[i] & mask);/*check short run */
 				j = i+1;
 				while ((tp[j++] & mask) == b)
 					if (j == beg) {
-						*op++ = (uint8)(128-2+j-i);
-						*op++ = (uint8)(b >> shft);
+						*op++ = (uint8_t)(128 - 2 + j - i);
+						*op++ = (uint8_t)(b >> shft);
 						occ -= 2;
 						i = beg;
 						break;
@@ -507,15 +490,15 @@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 					op = tif->tif_rawcp;
 					occ = tif->tif_rawdatasize - tif->tif_rawcc;
 				}
-				*op++ = (uint8) j; occ--;
+				*op++ = (uint8_t) j; occ--;
 				while (j--) {
-					*op++ = (uint8) (tp[i++] >> shft & 0xff);
+					*op++ = (uint8_t) (tp[i++] >> shft & 0xff);
 					occ--;
 				}
 			}
 			if (rc >= MINRUN) {		/* write out run */
-				*op++ = (uint8) (128-2+rc);
-				*op++ = (uint8) (tp[beg] >> shft & 0xff);
+				*op++ = (uint8_t) (128 - 2 + rc);
+				*op++ = (uint8_t) (tp[beg] >> shft & 0xff);
 				occ -= 2;
 			} else
 				rc = 0;
@@ -531,24 +514,25 @@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
  * Encode a row of 24-bit pixels.
  */
 static int
-LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LogLuvEncode24(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "LogLuvEncode24";
 	LogLuvState* sp = EncoderState(tif);
 	tmsize_t i;
 	tmsize_t npixels;
 	tmsize_t occ;
-	uint8* op;
-	uint32* tp;
+	uint8_t* op;
+	uint32_t* tp;
 
+        (void)s;
 	assert(s == 0);
 	assert(sp != NULL);
 	npixels = cc / sp->pixel_size;
 
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
-		tp = (uint32*) bp;
+		tp = (uint32_t*) bp;
 	else {
-		tp = (uint32*) sp->tbuf;
+		tp = (uint32_t*) sp->tbuf;
 		if(sp->tbuflen < npixels) {
 			TIFFErrorExt(tif->tif_clientdata, module,
 						 "Translation buffer too short");
@@ -568,9 +552,9 @@ LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 			op = tif->tif_rawcp;
 			occ = tif->tif_rawdatasize - tif->tif_rawcc;
 		}
-		*op++ = (uint8)(*tp >> 16);
-		*op++ = (uint8)(*tp >> 8 & 0xff);
-		*op++ = (uint8)(*tp++ & 0xff);
+		*op++ = (uint8_t)(*tp >> 16);
+		*op++ = (uint8_t)(*tp >> 8 & 0xff);
+		*op++ = (uint8_t)(*tp++ & 0xff);
 		occ -= 3;
 	}
 	tif->tif_rawcp = op;
@@ -583,7 +567,7 @@ LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
  * Encode a row of 32-bit pixels.
  */
 static int
-LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LogLuvEncode32(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "LogLuvEncode32";
 	LogLuvState* sp = EncoderState(tif);
@@ -591,22 +575,23 @@ LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 	tmsize_t i;
 	tmsize_t j;
 	tmsize_t npixels;
-	uint8* op;
-	uint32* tp;
-	uint32 b;
+	uint8_t* op;
+	uint32_t* tp;
+	uint32_t b;
 	tmsize_t occ;
 	int rc=0, mask;
 	tmsize_t beg;
 
+        (void)s;
 	assert(s == 0);
 	assert(sp != NULL);
 
 	npixels = cc / sp->pixel_size;
 
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
-		tp = (uint32*) bp;
+		tp = (uint32_t*) bp;
 	else {
-		tp = (uint32*) sp->tbuf;
+		tp = (uint32_t*) sp->tbuf;
 		if(sp->tbuflen < npixels) {
 			TIFFErrorExt(tif->tif_clientdata, module,
 						 "Translation buffer too short");
@@ -642,8 +627,8 @@ LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 				j = i+1;
 				while ((tp[j++] & mask) == b)
 					if (j == beg) {
-						*op++ = (uint8)(128-2+j-i);
-						*op++ = (uint8)(b >> shft);
+						*op++ = (uint8_t)(128 - 2 + j - i);
+						*op++ = (uint8_t)(b >> shft);
 						occ -= 2;
 						i = beg;
 						break;
@@ -659,15 +644,15 @@ LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 					op = tif->tif_rawcp;
 					occ = tif->tif_rawdatasize - tif->tif_rawcc;
 				}
-				*op++ = (uint8) j; occ--;
+				*op++ = (uint8_t) j; occ--;
 				while (j--) {
-					*op++ = (uint8)(tp[i++] >> shft & 0xff);
+					*op++ = (uint8_t)(tp[i++] >> shft & 0xff);
 					occ--;
 				}
 			}
 			if (rc >= MINRUN) {		/* write out run */
-				*op++ = (uint8) (128-2+rc);
-				*op++ = (uint8)(tp[beg] >> shft & 0xff);
+				*op++ = (uint8_t) (128 - 2 + rc);
+				*op++ = (uint8_t)(tp[beg] >> shft & 0xff);
 				occ -= 2;
 			} else
 				rc = 0;
@@ -684,7 +669,7 @@ LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
  * avoid encoding runs across row boundaries.
  */
 static int
-LogLuvEncodeStrip(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LogLuvEncodeStrip(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	tmsize_t rowlen = TIFFScanlineSize(tif);
 
@@ -704,7 +689,7 @@ LogLuvEncodeStrip(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
  * avoid encoding runs across row boundaries.
  */
 static int
-LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LogLuvEncodeTile(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	tmsize_t rowlen = TIFFTileRowSize(tif);
 
@@ -742,7 +727,7 @@ LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 #undef exp2  /* Conflict with C'99 function */
 #define exp2(x)		exp(M_LN2*(x))
 
-static int itrunc(double x, int m)
+static int tiff_itrunc(double x, int m)
 {
     if( m == SGILOGENCODE_NODITHER )
         return (int)x;
@@ -777,16 +762,16 @@ LogL16fromY(double Y, int em)	/* get 16-bit LogL from Y */
 	if (Y <= -1.8371976e19)
 		return (0xffff);
 	if (Y > 5.4136769e-20)
-		return itrunc(256.*(log2(Y) + 64.), em);
+		return tiff_itrunc(256.*(log2(Y) + 64.), em);
 	if (Y < -5.4136769e-20)
-		return (~0x7fff | itrunc(256.*(log2(-Y) + 64.), em));
+		return (~0x7fff | tiff_itrunc(256.*(log2(-Y) + 64.), em));
 	return (0);
 }
 
 static void
-L16toY(LogLuvState* sp, uint8* op, tmsize_t n)
+L16toY(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	int16* l16 = (int16*) sp->tbuf;
+	int16_t* l16 = (int16_t*) sp->tbuf;
 	float* yp = (float*) op;
 
 	while (n-- > 0)
@@ -794,32 +779,32 @@ L16toY(LogLuvState* sp, uint8* op, tmsize_t n)
 }
 
 static void
-L16toGry(LogLuvState* sp, uint8* op, tmsize_t n)
+L16toGry(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	int16* l16 = (int16*) sp->tbuf;
-	uint8* gp = (uint8*) op;
+	int16_t* l16 = (int16_t*) sp->tbuf;
+	uint8_t* gp = (uint8_t*) op;
 
 	while (n-- > 0) {
 		double Y = LogL16toY(*l16++);
-		*gp++ = (uint8) ((Y <= 0.) ? 0 : (Y >= 1.) ? 255 : (int)(256.*sqrt(Y)));
+		*gp++ = (uint8_t) ((Y <= 0.) ? 0 : (Y >= 1.) ? 255 : (int)(256. * sqrt(Y)));
 	}
 }
 
 static void
-L16fromY(LogLuvState* sp, uint8* op, tmsize_t n)
+L16fromY(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	int16* l16 = (int16*) sp->tbuf;
+	int16_t* l16 = (int16_t*) sp->tbuf;
 	float* yp = (float*) op;
 
 	while (n-- > 0)
-		*l16++ = (int16) (LogL16fromY(*yp++, sp->encode_meth));
+		*l16++ = (int16_t) (LogL16fromY(*yp++, sp->encode_meth));
 }
 
 #if !LOGLUV_PUBLIC
 static
 #endif
 void
-XYZtoRGB24(float xyz[3], uint8 rgb[3])
+XYZtoRGB24(float xyz[3], uint8_t rgb[3])
 {
 	double	r, g, b;
 					/* assume CCIR-709 primaries */
@@ -828,9 +813,9 @@ XYZtoRGB24(float xyz[3], uint8 rgb[3])
 	b =  0.061*xyz[0] + -0.224*xyz[1] +  1.163*xyz[2];
 					/* assume 2.0 gamma for speed */
 	/* could use integer sqrt approx., but this is probably faster */
-	rgb[0] = (uint8)((r<=0.) ? 0 : (r >= 1.) ? 255 : (int)(256.*sqrt(r)));
-	rgb[1] = (uint8)((g<=0.) ? 0 : (g >= 1.) ? 255 : (int)(256.*sqrt(g)));
-	rgb[2] = (uint8)((b<=0.) ? 0 : (b >= 1.) ? 255 : (int)(256.*sqrt(b)));
+	rgb[0] = (uint8_t)((r <= 0.) ? 0 : (r >= 1.) ? 255 : (int)(256. * sqrt(r)));
+	rgb[1] = (uint8_t)((g <= 0.) ? 0 : (g >= 1.) ? 255 : (int)(256. * sqrt(g)));
+	rgb[2] = (uint8_t)((b <= 0.) ? 0 : (b >= 1.) ? 255 : (int)(256. * sqrt(b)));
 }
 
 #if !LOGLUV_PUBLIC
@@ -855,7 +840,7 @@ LogL10fromY(double Y, int em)	/* get 10-bit LogL from Y */
 	else if (Y <= .00024283)
 		return (0);
 	else
-		return itrunc(64.*(log2(Y) + 12.), em);
+		return tiff_itrunc(64.*(log2(Y) + 12.), em);
 }
 
 #define NANGLES		100
@@ -925,12 +910,12 @@ uv_encode(double u, double v, int em)	/* encode (u',v') coordinates */
 
 	if (v < UV_VSTART)
 		return oog_encode(u, v);
-	vi = itrunc((v - UV_VSTART)*(1./UV_SQSIZ), em);
+	vi = tiff_itrunc((v - UV_VSTART)*(1./UV_SQSIZ), em);
 	if (vi >= UV_NVS)
 		return oog_encode(u, v);
 	if (u < uv_row[vi].ustart)
 		return oog_encode(u, v);
-	ui = itrunc((u - uv_row[vi].ustart)*(1./UV_SQSIZ), em);
+	ui = tiff_itrunc((u - uv_row[vi].ustart)*(1./UV_SQSIZ), em);
 	if (ui >= uv_row[vi].nus)
 		return oog_encode(u, v);
 
@@ -973,7 +958,7 @@ uv_decode(double *up, double *vp, int c)	/* decode (u',v') index */
 static
 #endif
 void
-LogLuv24toXYZ(uint32 p, float XYZ[3])
+LogLuv24toXYZ(uint32_t p, float XYZ[3])
 {
 	int	Ce;
 	double	L, u, v, s, x, y;
@@ -1000,7 +985,7 @@ LogLuv24toXYZ(uint32 p, float XYZ[3])
 #if !LOGLUV_PUBLIC
 static
 #endif
-uint32
+uint32_t
 LogLuv24fromXYZ(float XYZ[3], int em)
 {
 	int	Le, Ce;
@@ -1024,9 +1009,9 @@ LogLuv24fromXYZ(float XYZ[3], int em)
 }
 
 static void
-Luv24toXYZ(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv24toXYZ(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
+	uint32_t* luv = (uint32_t*) sp->tbuf;
 	float* xyz = (float*) op;
 
 	while (n-- > 0) {
@@ -1037,30 +1022,30 @@ Luv24toXYZ(LogLuvState* sp, uint8* op, tmsize_t n)
 }
 
 static void
-Luv24toLuv48(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv24toLuv48(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
-	int16* luv3 = (int16*) op;
+	uint32_t* luv = (uint32_t*) sp->tbuf;
+	int16_t* luv3 = (int16_t*) op;
 
 	while (n-- > 0) {
 		double u, v;
 
-		*luv3++ = (int16)((*luv >> 12 & 0xffd) + 13314);
+		*luv3++ = (int16_t)((*luv >> 12 & 0xffd) + 13314);
 		if (uv_decode(&u, &v, *luv&0x3fff) < 0) {
 			u = U_NEU;
 			v = V_NEU;
 		}
-		*luv3++ = (int16)(u * (1L<<15));
-		*luv3++ = (int16)(v * (1L<<15));
+		*luv3++ = (int16_t)(u * (1L << 15));
+		*luv3++ = (int16_t)(v * (1L << 15));
 		luv++;
 	}
 }
 
 static void
-Luv24toRGB(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv24toRGB(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
-	uint8* rgb = (uint8*) op;
+	uint32_t* luv = (uint32_t*) sp->tbuf;
+	uint8_t* rgb = (uint8_t*) op;
 
 	while (n-- > 0) {
 		float xyz[3];
@@ -1072,9 +1057,9 @@ Luv24toRGB(LogLuvState* sp, uint8* op, tmsize_t n)
 }
 
 static void
-Luv24fromXYZ(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv24fromXYZ(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
+	uint32_t* luv = (uint32_t*) sp->tbuf;
 	float* xyz = (float*) op;
 
 	while (n-- > 0) {
@@ -1084,10 +1069,10 @@ Luv24fromXYZ(LogLuvState* sp, uint8* op, tmsize_t n)
 }
 
 static void
-Luv24fromLuv48(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv24fromLuv48(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
-	int16* luv3 = (int16*) op;
+	uint32_t* luv = (uint32_t*) sp->tbuf;
+	int16_t* luv3 = (int16_t*) op;
 
 	while (n-- > 0) {
 		int Le, Ce;
@@ -1099,13 +1084,13 @@ Luv24fromLuv48(LogLuvState* sp, uint8* op, tmsize_t n)
 		else if (sp->encode_meth == SGILOGENCODE_NODITHER)
 			Le = (luv3[0]-3314) >> 2;
 		else
-			Le = itrunc(.25*(luv3[0]-3314.), sp->encode_meth);
+			Le = tiff_itrunc(.25*(luv3[0]-3314.), sp->encode_meth);
 
 		Ce = uv_encode((luv3[1]+.5)/(1<<15), (luv3[2]+.5)/(1<<15),
 					sp->encode_meth);
 		if (Ce < 0)	/* never happens */
 			Ce = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);
-		*luv++ = (uint32)Le << 14 | Ce;
+		*luv++ = (uint32_t)Le << 14 | Ce;
 		luv3 += 3;
 	}
 }
@@ -1114,7 +1099,7 @@ Luv24fromLuv48(LogLuvState* sp, uint8* op, tmsize_t n)
 static
 #endif
 void
-LogLuv32toXYZ(uint32 p, float XYZ[3])
+LogLuv32toXYZ(uint32_t p, float XYZ[3])
 {
 	double	L, u, v, s, x, y;
 					/* decode luminance */
@@ -1138,7 +1123,7 @@ LogLuv32toXYZ(uint32 p, float XYZ[3])
 #if !LOGLUV_PUBLIC
 static
 #endif
-uint32
+uint32_t
 LogLuv32fromXYZ(float XYZ[3], int em)
 {
 	unsigned int	Le, ue, ve;
@@ -1155,19 +1140,19 @@ LogLuv32fromXYZ(float XYZ[3], int em)
 		v = 9.*XYZ[1] / s;
 	}
 	if (u <= 0.) ue = 0;
-	else ue = itrunc(UVSCALE*u, em);
+	else ue = tiff_itrunc(UVSCALE*u, em);
 	if (ue > 255) ue = 255;
 	if (v <= 0.) ve = 0;
-	else ve = itrunc(UVSCALE*v, em);
+	else ve = tiff_itrunc(UVSCALE*v, em);
 	if (ve > 255) ve = 255;
 					/* combine encodings */
 	return (Le << 16 | ue << 8 | ve);
 }
 
 static void
-Luv32toXYZ(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv32toXYZ(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
+	uint32_t* luv = (uint32_t*) sp->tbuf;
 	float* xyz = (float*) op;
 
 	while (n-- > 0) {
@@ -1177,28 +1162,28 @@ Luv32toXYZ(LogLuvState* sp, uint8* op, tmsize_t n)
 }
 
 static void
-Luv32toLuv48(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv32toLuv48(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
-	int16* luv3 = (int16*) op;
+	uint32_t* luv = (uint32_t*) sp->tbuf;
+	int16_t* luv3 = (int16_t*) op;
 
 	while (n-- > 0) {
 		double u, v;
 
-		*luv3++ = (int16)(*luv >> 16);
+		*luv3++ = (int16_t)(*luv >> 16);
 		u = 1./UVSCALE * ((*luv>>8 & 0xff) + .5);
 		v = 1./UVSCALE * ((*luv & 0xff) + .5);
-		*luv3++ = (int16)(u * (1L<<15));
-		*luv3++ = (int16)(v * (1L<<15));
+		*luv3++ = (int16_t)(u * (1L << 15));
+		*luv3++ = (int16_t)(v * (1L << 15));
 		luv++;
 	}
 }
 
 static void
-Luv32toRGB(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv32toRGB(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
-	uint8* rgb = (uint8*) op;
+	uint32_t* luv = (uint32_t*) sp->tbuf;
+	uint8_t* rgb = (uint8_t*) op;
 
 	while (n-- > 0) {
 		float xyz[3];
@@ -1210,9 +1195,9 @@ Luv32toRGB(LogLuvState* sp, uint8* op, tmsize_t n)
 }
 
 static void
-Luv32fromXYZ(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv32fromXYZ(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;  
+	uint32_t* luv = (uint32_t*) sp->tbuf;
 	float* xyz = (float*) op;
 
 	while (n-- > 0) {
@@ -1222,30 +1207,30 @@ Luv32fromXYZ(LogLuvState* sp, uint8* op, tmsize_t n)
 }
 
 static void
-Luv32fromLuv48(LogLuvState* sp, uint8* op, tmsize_t n)
+Luv32fromLuv48(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
-	uint32* luv = (uint32*) sp->tbuf;
-	int16* luv3 = (int16*) op;
+	uint32_t* luv = (uint32_t*) sp->tbuf;
+	int16_t* luv3 = (int16_t*) op;
 
 	if (sp->encode_meth == SGILOGENCODE_NODITHER) {
 		while (n-- > 0) {
-			*luv++ = (uint32)luv3[0] << 16 |
-				(luv3[1]*(uint32)(UVSCALE+.5) >> 7 & 0xff00) |
-				(luv3[2]*(uint32)(UVSCALE+.5) >> 15 & 0xff);
+			*luv++ = (uint32_t)luv3[0] << 16 |
+                     (luv3[1]*(uint32_t)(UVSCALE + .5) >> 7 & 0xff00) |
+                     (luv3[2]*(uint32_t)(UVSCALE + .5) >> 15 & 0xff);
 			luv3 += 3;
 		}
 		return;
 	}
 	while (n-- > 0) {
-		*luv++ = (uint32)luv3[0] << 16 |
-	(itrunc(luv3[1]*(UVSCALE/(1<<15)), sp->encode_meth) << 8 & 0xff00) |
-		(itrunc(luv3[2]*(UVSCALE/(1<<15)), sp->encode_meth) & 0xff);
+		*luv++ = (uint32_t)luv3[0] << 16 |
+                 (tiff_itrunc(luv3[1]*(UVSCALE/(1<<15)), sp->encode_meth) << 8 & 0xff00) |
+                 (tiff_itrunc(luv3[2]*(UVSCALE/(1<<15)), sp->encode_meth) & 0xff);
 		luv3 += 3;
 	}
 }
 
 static void
-_logLuvNop(LogLuvState* sp, uint8* op, tmsize_t n)
+_logLuvNop(LogLuvState* sp, uint8_t* op, tmsize_t n)
 {
 	(void) sp; (void) op; (void) n;
 }
@@ -1288,7 +1273,7 @@ LogL16InitState(TIFF* tif)
 	if( td->td_samplesperpixel != 1 )
 	{
 		TIFFErrorExt(tif->tif_clientdata, module,
-		             "Sorry, can not handle LogL image with %s=%d",
+		             "Sorry, can not handle LogL image with %s=%"PRIu16,
 			     "Samples/pixel", td->td_samplesperpixel);
 		return 0;
 	}
@@ -1301,10 +1286,10 @@ LogL16InitState(TIFF* tif)
 		sp->pixel_size = sizeof (float);
 		break;
 	case SGILOGDATAFMT_16BIT:
-		sp->pixel_size = sizeof (int16);
+		sp->pixel_size = sizeof (int16_t);
 		break;
 	case SGILOGDATAFMT_8BIT:
-		sp->pixel_size = sizeof (uint8);
+		sp->pixel_size = sizeof (uint8_t);
 		break;
 	default:
 		TIFFErrorExt(tif->tif_clientdata, module,
@@ -1317,8 +1302,8 @@ LogL16InitState(TIFF* tif)
             sp->tbuflen = multiply_ms(td->td_imagewidth, td->td_rowsperstrip);
         else
             sp->tbuflen = multiply_ms(td->td_imagewidth, td->td_imagelength);
-	if (multiply_ms(sp->tbuflen, sizeof (int16)) == 0 ||
-	    (sp->tbuf = (uint8*) _TIFFmalloc(sp->tbuflen * sizeof (int16))) == NULL) {
+	if (multiply_ms(sp->tbuflen, sizeof (int16_t)) == 0 ||
+        (sp->tbuf = (uint8_t*) _TIFFmalloc(sp->tbuflen * sizeof (int16_t))) == NULL) {
 		TIFFErrorExt(tif->tif_clientdata, module, "No space for SGILog translation buffer");
 		return (0);
 	}
@@ -1400,13 +1385,13 @@ LogLuvInitState(TIFF* tif)
 		sp->pixel_size = 3*sizeof (float);
 		break;
 	case SGILOGDATAFMT_16BIT:
-		sp->pixel_size = 3*sizeof (int16);
+		sp->pixel_size = 3*sizeof (int16_t);
 		break;
 	case SGILOGDATAFMT_RAW:
-		sp->pixel_size = sizeof (uint32);
+		sp->pixel_size = sizeof (uint32_t);
 		break;
 	case SGILOGDATAFMT_8BIT:
-		sp->pixel_size = 3*sizeof (uint8);
+		sp->pixel_size = 3*sizeof (uint8_t);
 		break;
 	default:
 		TIFFErrorExt(tif->tif_clientdata, module,
@@ -1419,8 +1404,8 @@ LogLuvInitState(TIFF* tif)
             sp->tbuflen = multiply_ms(td->td_imagewidth, td->td_rowsperstrip);
         else
             sp->tbuflen = multiply_ms(td->td_imagewidth, td->td_imagelength);
-	if (multiply_ms(sp->tbuflen, sizeof (uint32)) == 0 ||
-	    (sp->tbuf = (uint8*) _TIFFmalloc(sp->tbuflen * sizeof (uint32))) == NULL) {
+	if (multiply_ms(sp->tbuflen, sizeof (uint32_t)) == 0 ||
+        (sp->tbuf = (uint8_t*) _TIFFmalloc(sp->tbuflen * sizeof (uint32_t))) == NULL) {
 		TIFFErrorExt(tif->tif_clientdata, module, "No space for SGILog translation buffer");
 		return (0);
 	}
@@ -1489,7 +1474,7 @@ LogLuvSetupDecode(TIFF* tif)
 		return (1);
 	default:
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "Inappropriate photometric interpretation %d for SGILog compression; %s",
+		    "Inappropriate photometric interpretation %"PRIu16" for SGILog compression; %s",
 		    td->td_photometric, "must be either LogLUV or LogL");
 		break;
 	}
@@ -1553,7 +1538,7 @@ LogLuvSetupEncode(TIFF* tif)
 		break;
 	default:
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "Inappropriate photometric interpretation %d for SGILog compression; %s",
+		    "Inappropriate photometric interpretation %"PRIu16" for SGILog compression; %s",
 		    td->td_photometric, "must be either LogLUV or LogL");
 		return (0);
 	}
@@ -1611,7 +1596,7 @@ LogLuvCleanup(TIFF* tif)
 }
 
 static int
-LogLuvVSetField(TIFF* tif, uint32 tag, va_list ap)
+LogLuvVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	static const char module[] = "LogLuvVSetField";
 	LogLuvState* sp = DecoderState(tif);
@@ -1674,7 +1659,7 @@ LogLuvVSetField(TIFF* tif, uint32 tag, va_list ap)
 }
 
 static int
-LogLuvVGetField(TIFF* tif, uint32 tag, va_list ap)
+LogLuvVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	LogLuvState *sp = (LogLuvState *)tif->tif_data;
 
@@ -1713,7 +1698,7 @@ TIFFInitSGILog(TIFF* tif, int scheme)
 	/*
 	 * Allocate state block so tag methods have storage to record values.
 	 */
-	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (LogLuvState));
+	tif->tif_data = (uint8_t*) _TIFFmalloc(sizeof (LogLuvState));
 	if (tif->tif_data == NULL)
 		goto bad;
 	sp = (LogLuvState*) tif->tif_data;
diff --git a/src/3rdparty/libtiff/libtiff/tif_lzma.c b/src/3rdparty/libtiff/libtiff/tif_lzma.c
index 3f6096b..fc04647 100644
--- a/src/3rdparty/libtiff/libtiff/tif_lzma.c
+++ b/src/3rdparty/libtiff/libtiff/tif_lzma.c
@@ -61,8 +61,8 @@ typedef struct {
 #define DecoderState(tif)       LState(tif)
 #define EncoderState(tif)       LState(tif)
 
-static int LZMAEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s);
-static int LZMADecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s);
+static int LZMAEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s);
+static int LZMADecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s);
 
 static const char *
 LZMAStrerror(lzma_ret ret)
@@ -125,7 +125,7 @@ LZMASetupDecode(TIFF* tif)
  * Setup state for decoding a strip.
  */
 static int
-LZMAPreDecode(TIFF* tif, uint16 s)
+LZMAPreDecode(TIFF* tif, uint16_t s)
 {
 	static const char module[] = "LZMAPreDecode";
 	LZMAState* sp = DecoderState(tif);
@@ -160,7 +160,7 @@ LZMAPreDecode(TIFF* tif, uint16 s)
 }
 
 static int
-LZMADecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
+LZMADecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "LZMADecode";
 	LZMAState* sp = DecoderState(tif);
@@ -206,19 +206,19 @@ LZMADecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 		}
 		if (ret != LZMA_OK) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Decoding error at scanline %lu, %s",
-			    (unsigned long) tif->tif_row, LZMAStrerror(ret));
+			    "Decoding error at scanline %"PRIu32", %s",
+			    tif->tif_row, LZMAStrerror(ret));
 			break;
 		}
 	} while (sp->stream.avail_out > 0);
 	if (sp->stream.avail_out != 0) {
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "Not enough data at scanline %lu (short %lu bytes)",
-		    (unsigned long) tif->tif_row, (unsigned long) sp->stream.avail_out);
+		    "Not enough data at scanline %"PRIu32" (short %"TIFF_SIZE_FORMAT" bytes)",
+		    tif->tif_row, sp->stream.avail_out);
 		return 0;
 	}
 
-        tif->tif_rawcp = (uint8 *)sp->stream.next_in; /* cast away const */
+        tif->tif_rawcp = (uint8_t *)sp->stream.next_in; /* cast away const */
         tif->tif_rawcc = sp->stream.avail_in;
         
 	return 1;
@@ -243,7 +243,7 @@ LZMASetupEncode(TIFF* tif)
  * Reset encoding state at the start of a strip.
  */
 static int
-LZMAPreEncode(TIFF* tif, uint16 s)
+LZMAPreEncode(TIFF* tif, uint16_t s)
 {
 	static const char module[] = "LZMAPreEncode";
 	LZMAState *sp = EncoderState(tif);
@@ -274,7 +274,7 @@ LZMAPreEncode(TIFF* tif, uint16 s)
  * Encode a chunk of pixels.
  */
 static int
-LZMAEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LZMAEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "LZMAEncode";
 	LZMAState *sp = EncoderState(tif);
@@ -294,13 +294,14 @@ LZMAEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 		lzma_ret ret = lzma_code(&sp->stream, LZMA_RUN);
 		if (ret != LZMA_OK) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-				"Encoding error at scanline %lu, %s",
-				(unsigned long) tif->tif_row, LZMAStrerror(ret));
+				"Encoding error at scanline %"PRIu32", %s",
+				tif->tif_row, LZMAStrerror(ret));
 			return 0;
 		}
 		if (sp->stream.avail_out == 0) {
 			tif->tif_rawcc = tif->tif_rawdatasize;
-			TIFFFlushData1(tif);
+			if (!TIFFFlushData1(tif))
+				return 0;
 			sp->stream.next_out = tif->tif_rawdata;
 			sp->stream.avail_out = (size_t)tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in LZMAPreEncode */
 		}
@@ -328,7 +329,8 @@ LZMAPostEncode(TIFF* tif)
 			if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) {
 				tif->tif_rawcc =
 					tif->tif_rawdatasize - sp->stream.avail_out;
-				TIFFFlushData1(tif);
+				if (!TIFFFlushData1(tif))
+					return 0;
 				sp->stream.next_out = tif->tif_rawdata;
 				sp->stream.avail_out = (size_t)tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in ZIPPreEncode */
 			}
@@ -365,7 +367,7 @@ LZMACleanup(TIFF* tif)
 }
 
 static int
-LZMAVSetField(TIFF* tif, uint32 tag, va_list ap)
+LZMAVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	static const char module[] = "LZMAVSetField";
 	LZMAState* sp = LState(tif);
@@ -392,7 +394,7 @@ LZMAVSetField(TIFF* tif, uint32 tag, va_list ap)
 }
 
 static int
-LZMAVGetField(TIFF* tif, uint32 tag, va_list ap)
+LZMAVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	LZMAState* sp = LState(tif);
 
@@ -418,6 +420,7 @@ TIFFInitLZMA(TIFF* tif, int scheme)
 	LZMAState* sp;
 	lzma_stream tmp_stream = LZMA_STREAM_INIT;
 
+        (void)scheme;
 	assert( scheme == COMPRESSION_LZMA );
 
 	/*
@@ -432,7 +435,7 @@ TIFFInitLZMA(TIFF* tif, int scheme)
 	/*
 	 * Allocate state block so tag methods have storage to record values.
 	 */
-	tif->tif_data = (uint8*) _TIFFmalloc(sizeof(LZMAState));
+	tif->tif_data = (uint8_t*) _TIFFmalloc(sizeof(LZMAState));
 	if (tif->tif_data == NULL)
 		goto bad;
 	sp = LState(tif);
diff --git a/src/3rdparty/libtiff/libtiff/tif_lzw.c b/src/3rdparty/libtiff/libtiff/tif_lzw.c
index 21064f2..c06aec4 100644
--- a/src/3rdparty/libtiff/libtiff/tif_lzw.c
+++ b/src/3rdparty/libtiff/libtiff/tif_lzw.c
@@ -107,7 +107,7 @@ typedef struct {
 /*
  * Encoding-specific state.
  */
-typedef uint16 hcode_t;			/* codes fit in 16 bits */
+typedef uint16_t hcode_t;			/* codes fit in 16 bits */
 typedef struct {
 	long	hash;
 	hcode_t	code;
@@ -123,7 +123,7 @@ typedef struct code_ent {
 	unsigned char	firstchar;	/* first token of string */
 } code_t;
 
-typedef int (*decodeFunc)(TIFF*, uint8*, tmsize_t, uint16);
+typedef int (*decodeFunc)(TIFF*, uint8_t*, tmsize_t, uint16_t);
 
 typedef struct {
 	LZWBaseState base;
@@ -132,7 +132,7 @@ typedef struct {
 	long    dec_nbitsmask;		/* lzw_nbits 1 bits, right adjusted */
 	long    dec_restart;		/* restart count */
 #ifdef LZW_CHECKEOS
-	uint64  dec_bitsleft;		/* available bits in raw data */
+	uint64_t  dec_bitsleft;		/* available bits in raw data */
 	tmsize_t old_tif_rawcc;         /* value of tif_rawcc at the end of the previous TIFLZWDecode() call */
 #endif
 	decodeFunc dec_decode;		/* regular or backwards compatible */
@@ -149,7 +149,7 @@ typedef struct {
 	long    enc_ratio;		/* current compression ratio */
 	long    enc_incount;		/* (input) data bytes encoded */
 	long    enc_outcount;		/* encoded (output) bytes */
-	uint8*  enc_rawlimit;		/* bound on tif_rawdata buffer */
+	uint8_t*  enc_rawlimit;		/* bound on tif_rawdata buffer */
 	hash_t* enc_hashtab;		/* kept separate for small machines */
 } LZWCodecState;
 
@@ -157,9 +157,9 @@ typedef struct {
 #define DecoderState(tif)	((LZWCodecState*) LZWState(tif))
 #define EncoderState(tif)	((LZWCodecState*) LZWState(tif))
 
-static int LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s);
+static int LZWDecode(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s);
 #ifdef LZW_COMPAT
-static int LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s);
+static int LZWDecodeCompat(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s);
 #endif
 static void cl_hash(LZWCodecState*);
 
@@ -173,9 +173,9 @@ static void cl_hash(LZWCodecState*);
  * strip is suppose to be terminated with CODE_EOI.
  */
 #define	NextCode(_tif, _sp, _bp, _code, _get) {				\
-	if ((_sp)->dec_bitsleft < (uint64)nbits) {			\
+	if ((_sp)->dec_bitsleft < (uint64_t)nbits) {			\
 		TIFFWarningExt(_tif->tif_clientdata, module,		\
-		    "LZWDecode: Strip %d not terminated with EOI code", \
+		    "LZWDecode: Strip %"PRIu32" not terminated with EOI code", \
 		    _tif->tif_curstrip);				\
 		_code = CODE_EOI;					\
 	} else {							\
@@ -207,26 +207,23 @@ LZWSetupDecode(TIFF* tif)
 		 * Allocate state block so tag methods have storage to record
 		 * values.
 		*/
-		tif->tif_data = (uint8*) _TIFFmalloc(sizeof(LZWCodecState));
+		tif->tif_data = (uint8_t*) _TIFFmalloc(sizeof(LZWCodecState));
 		if (tif->tif_data == NULL)
 		{
 			TIFFErrorExt(tif->tif_clientdata, module, "No space for LZW state block");
 			return (0);
 		}
 
-		DecoderState(tif)->dec_codetab = NULL;
-		DecoderState(tif)->dec_decode = NULL;
+		sp = DecoderState(tif);
+		sp->dec_codetab = NULL;
+		sp->dec_decode = NULL;
 
 		/*
 		 * Setup predictor setup.
 		 */
 		(void) TIFFPredictorInit(tif);
-
-		sp = DecoderState(tif);
 	}
 
-	assert(sp != NULL);
-
 	if (sp->dec_codetab == NULL) {
 		sp->dec_codetab = (code_t*)_TIFFmalloc(CSIZE*sizeof (code_t));
 		if (sp->dec_codetab == NULL) {
@@ -259,7 +256,7 @@ LZWSetupDecode(TIFF* tif)
  * Setup state for decoding a strip.
  */
 static int
-LZWPreDecode(TIFF* tif, uint16 s)
+LZWPreDecode(TIFF* tif, uint16_t s)
 {
 	static const char module[] = "LZWPreDecode";
 	LZWCodecState *sp = DecoderState(tif);
@@ -355,12 +352,12 @@ static void
 codeLoop(TIFF* tif, const char* module)
 {
 	TIFFErrorExt(tif->tif_clientdata, module,
-	    "Bogus encoding, loop in the code table; scanline %d",
+	    "Bogus encoding, loop in the code table; scanline %"PRIu32,
 	    tif->tif_row);
 }
 
 static int
-LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
+LZWDecode(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s)
 {
 	static const char module[] = "LZWDecode";
 	LZWCodecState *sp = DecoderState(tif);
@@ -429,7 +426,7 @@ LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 
 	bp = (unsigned char *)tif->tif_rawcp;
 #ifdef LZW_CHECKEOS
-	sp->dec_bitsleft += (((uint64)tif->tif_rawcc - sp->old_tif_rawcc) << 3);
+	sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);
 #endif
 	nbits = sp->lzw_nbits;
 	nextdata = sp->lzw_nextdata;
@@ -457,7 +454,7 @@ LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 				break;
 			if (code > CODE_CLEAR) {
 				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				"LZWDecode: Corrupted LZW table at scanline %d",
+				"LZWDecode: Corrupted LZW table at scanline %"PRIu32,
 					     tif->tif_row);
 				return (0);
 			}
@@ -474,7 +471,7 @@ LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 		if (free_entp < &sp->dec_codetab[0] ||
 		    free_entp >= &sp->dec_codetab[CSIZE]) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Corrupted LZW table at scanline %d",
+			    "Corrupted LZW table at scanline %"PRIu32,
 			    tif->tif_row);
 			return (0);
 		}
@@ -483,7 +480,7 @@ LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 		if (free_entp->next < &sp->dec_codetab[0] ||
 		    free_entp->next >= &sp->dec_codetab[CSIZE]) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Corrupted LZW table at scanline %d",
+			    "Corrupted LZW table at scanline %"PRIu32,
 			    tif->tif_row);
 			return (0);
 		}
@@ -506,7 +503,7 @@ LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 			if(codep->length == 0) {
 				TIFFErrorExt(tif->tif_clientdata, module,
 				    "Wrong length of decoded string: "
-				    "data probably corrupted at scanline %d",
+				    "data probably corrupted at scanline %"PRIu32,
 				    tif->tif_row);
 				return (0);
 			}
@@ -555,8 +552,8 @@ LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 		}
 	}
 
-	tif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp );
-	tif->tif_rawcp = (uint8*) bp;
+	tif->tif_rawcc -= (tmsize_t)((uint8_t*) bp - tif->tif_rawcp );
+	tif->tif_rawcp = (uint8_t*) bp;
 #ifdef LZW_CHECKEOS
 	sp->old_tif_rawcc = tif->tif_rawcc;
 #endif
@@ -569,15 +566,9 @@ LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 	sp->dec_maxcodep = maxcodep;
 
 	if (occ > 0) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
-			"Not enough data at scanline %d (short %I64d bytes)",
-			     tif->tif_row, (unsigned __int64) occ);
-#else
-		TIFFErrorExt(tif->tif_clientdata, module,
-			"Not enough data at scanline %d (short %llu bytes)",
-			     tif->tif_row, (unsigned long long) occ);
-#endif
+			"Not enough data at scanline %"PRIu32" (short %ld bytes)",
+			     tif->tif_row, occ);
 		return (0);
 	}
 	return (1);
@@ -600,7 +591,7 @@ LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 }
 
 static int
-LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
+LZWDecodeCompat(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s)
 {
 	static const char module[] = "LZWDecodeCompat";
 	LZWCodecState *sp = DecoderState(tif);
@@ -663,7 +654,7 @@ LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 
 	bp = (unsigned char *)tif->tif_rawcp;
 #ifdef LZW_CHECKEOS
-	sp->dec_bitsleft += (((uint64)tif->tif_rawcc - sp->old_tif_rawcc) << 3);
+	sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);
 #endif
 	nbits = sp->lzw_nbits;
 	nextdata = sp->lzw_nextdata;
@@ -691,7 +682,7 @@ LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 				break;
 			if (code > CODE_CLEAR) {
 				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				"LZWDecode: Corrupted LZW table at scanline %d",
+				"LZWDecode: Corrupted LZW table at scanline %"PRIu32,
 					     tif->tif_row);
 				return (0);
 			}
@@ -708,7 +699,7 @@ LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 		if (free_entp < &sp->dec_codetab[0] ||
 		    free_entp >= &sp->dec_codetab[CSIZE]) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Corrupted LZW table at scanline %d", tif->tif_row);
+			    "Corrupted LZW table at scanline %"PRIu32, tif->tif_row);
 			return (0);
 		}
 
@@ -716,7 +707,7 @@ LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 		if (free_entp->next < &sp->dec_codetab[0] ||
 		    free_entp->next >= &sp->dec_codetab[CSIZE]) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Corrupted LZW table at scanline %d", tif->tif_row);
+			    "Corrupted LZW table at scanline %"PRIu32, tif->tif_row);
 			return (0);
 		}
 		free_entp->firstchar = free_entp->next->firstchar;
@@ -738,7 +729,7 @@ LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 			if(codep->length == 0) {
 				TIFFErrorExt(tif->tif_clientdata, module,
 				    "Wrong length of decoded "
-				    "string: data probably corrupted at scanline %d",
+				    "string: data probably corrupted at scanline %"PRIu32,
 				    tif->tif_row);
 				return (0);
 			}
@@ -779,8 +770,8 @@ LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 		}
 	}
 
-	tif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp );
-	tif->tif_rawcp = (uint8*) bp;
+	tif->tif_rawcc -= (tmsize_t)((uint8_t*) bp - tif->tif_rawcp );
+	tif->tif_rawcp = (uint8_t*) bp;
 #ifdef LZW_CHECKEOS
 	sp->old_tif_rawcc = tif->tif_rawcc;
 #endif
@@ -793,15 +784,9 @@ LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 	sp->dec_maxcodep = maxcodep;
 
 	if (occ > 0) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
-			"Not enough data at scanline %d (short %I64d bytes)",
-			     tif->tif_row, (unsigned __int64) occ);
-#else
-		TIFFErrorExt(tif->tif_clientdata, module,
-			"Not enough data at scanline %d (short %llu bytes)",
-			     tif->tif_row, (unsigned long long) occ);
-#endif
+			"Not enough data at scanline %"PRIu32" (short %ld bytes)",
+			     tif->tif_row, occ);
 		return (0);
 	}
 	return (1);
@@ -832,7 +817,7 @@ LZWSetupEncode(TIFF* tif)
  * Reset encoding state at the start of a strip.
  */
 static int
-LZWPreEncode(TIFF* tif, uint16 s)
+LZWPreEncode(TIFF* tif, uint16_t s)
 {
 	LZWCodecState *sp = EncoderState(tif);
 
@@ -899,7 +884,7 @@ LZWPreEncode(TIFF* tif, uint16 s)
  * for the decoder. 
  */
 static int
-LZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+LZWEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	register LZWCodecState *sp = EncoderState(tif);
 	register long fcode;
@@ -911,8 +896,8 @@ LZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 	unsigned long nextdata;
         long nextbits;
 	int free_ent, maxcode, nbits;
-	uint8* op;
-	uint8* limit;
+	uint8_t* op;
+	uint8_t* limit;
 
 	(void) s;
 	if (sp == NULL)
@@ -1070,7 +1055,7 @@ static int
 LZWPostEncode(TIFF* tif)
 {
 	register LZWCodecState *sp = EncoderState(tif);
-	uint8* op = tif->tif_rawcp;
+	uint8_t* op = tif->tif_rawcp;
 	long nextbits = sp->lzw_nextbits;
 	unsigned long nextdata = sp->lzw_nextdata;
 	long outcount = sp->enc_outcount;
@@ -1161,11 +1146,12 @@ int
 TIFFInitLZW(TIFF* tif, int scheme)
 {
 	static const char module[] = "TIFFInitLZW";
+        (void)scheme;
 	assert(scheme == COMPRESSION_LZW);
 	/*
 	 * Allocate state block so tag methods have storage to record values.
 	 */
-	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (LZWCodecState));
+	tif->tif_data = (uint8_t*) _TIFFmalloc(sizeof (LZWCodecState));
 	if (tif->tif_data == NULL)
 		goto bad;
 	DecoderState(tif)->dec_codetab = NULL;
@@ -1218,7 +1204,7 @@ bad:
  * from this software without specific prior written permission.
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 #endif /* LZW_SUPPORT */
 
diff --git a/src/3rdparty/libtiff/libtiff/tif_next.c b/src/3rdparty/libtiff/libtiff/tif_next.c
index 0ba61ae..695fc5d 100644
--- a/src/3rdparty/libtiff/libtiff/tif_next.c
+++ b/src/3rdparty/libtiff/libtiff/tif_next.c
@@ -44,12 +44,12 @@
 #define WHITE   	((1<<2)-1)
 
 static int
-NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
+NeXTDecode(TIFF* tif, uint8_t* buf, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "NeXTDecode";
 	unsigned char *bp, *op;
 	tmsize_t cc;
-	uint8* row;
+	uint8_t* row;
 	tmsize_t scanline, n;
 
 	(void) s;
@@ -101,9 +101,9 @@ NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 			break;
 		}
 		default: {
-			uint32 npixels = 0, grey;
+			uint32_t npixels = 0, grey;
 			tmsize_t op_offset = 0;
-			uint32 imagewidth = tif->tif_dir.td_imagewidth;
+			uint32_t imagewidth = tif->tif_dir.td_imagewidth;
             if( isTiled(tif) )
                 imagewidth = tif->tif_dir.td_tilewidth;
 
@@ -115,7 +115,7 @@ NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 			 */
 			op = row;
 			for (;;) {
-				grey = (uint32)((n>>6) & 0x3);
+				grey = (uint32_t)((n >> 6) & 0x3);
 				n &= 0x3f;
 				/*
 				 * Ensure the run does not exceed the scanline
@@ -127,8 +127,8 @@ NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 				if (npixels >= imagewidth)
 					break;
                 if (op_offset >= scanline ) {
-                    TIFFErrorExt(tif->tif_clientdata, module, "Invalid data for scanline %ld",
-                        (long) tif->tif_row);
+                    TIFFErrorExt(tif->tif_clientdata, module, "Invalid data for scanline %"PRIu32,
+                        tif->tif_row);
                     return (0);
                 }
 				if (cc == 0)
@@ -140,17 +140,17 @@ NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		}
 		}
 	}
-	tif->tif_rawcp = (uint8*) bp;
+	tif->tif_rawcp = (uint8_t*) bp;
 	tif->tif_rawcc = cc;
 	return (1);
 bad:
-	TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",
-	    (long) tif->tif_row);
+	TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %"PRIu32,
+	    tif->tif_row);
 	return (0);
 }
 
 static int
-NeXTPreDecode(TIFF* tif, uint16 s)
+NeXTPreDecode(TIFF* tif, uint16_t s)
 {
 	static const char module[] = "NeXTPreDecode";
 	TIFFDirectory *td = &tif->tif_dir;
@@ -158,7 +158,7 @@ NeXTPreDecode(TIFF* tif, uint16 s)
 
 	if( td->td_bitspersample != 2 )
 	{
-		TIFFErrorExt(tif->tif_clientdata, module, "Unsupported BitsPerSample = %d",
+		TIFFErrorExt(tif->tif_clientdata, module, "Unsupported BitsPerSample = %"PRIu16,
 					 td->td_bitspersample);
 		return (0);
 	}
diff --git a/src/3rdparty/libtiff/libtiff/tif_ojpeg.c b/src/3rdparty/libtiff/libtiff/tif_ojpeg.c
index bf0d1a2..66cd275 100644
--- a/src/3rdparty/libtiff/libtiff/tif_ojpeg.c
+++ b/src/3rdparty/libtiff/libtiff/tif_ojpeg.c
@@ -74,7 +74,7 @@
    or errors, up to the point where either these values are read, or it's clear they
    aren't there. This means that some of the data is read twice, but we feel speed
    in correcting these values is important enough to warrant this sacrifice. Although
-   there is currently no define or other configuration mechanism to disable this behaviour,
+   there is currently no define or other configuration mechanism to disable this behavior,
    the actual header scanning is build to robustly respond with error report if it
    should encounter an uncorrected mismatch of subsampling values. See
    OJPEGReadHeaderInfoSecStreamSof.
@@ -141,7 +141,7 @@
  * 	enough so as to not result in significant call overhead. It should be at least a few
  * 	bytes to accommodate some structures (this is verified in asserts), but it would not be
  * 	sensible to make it this small anyway, and it should be at most 64K since it is indexed
- * 	with uint16. We recommend 2K.
+ * 	with uint16_t. We recommend 2K.
  * EGYPTIANWALK: You could also define EGYPTIANWALK here, but it is not used anywhere and has
  * 	absolutely no effect. That is why most people insist the EGYPTIANWALK is a bit silly.
  */
@@ -250,114 +250,114 @@ typedef struct {
 	TIFFVGetMethod vgetparent;
 	TIFFVSetMethod vsetparent;
 	TIFFPrintMethod printdir;
-	uint64 file_size;
-	uint32 image_width;
-	uint32 image_length;
-	uint32 strile_width;
-	uint32 strile_length;
-	uint32 strile_length_total;
-	uint8 samples_per_pixel;
-	uint8 plane_sample_offset;
-	uint8 samples_per_pixel_per_plane;
-	uint64 jpeg_interchange_format;
-	uint64 jpeg_interchange_format_length;
-	uint8 jpeg_proc;
-	uint8 subsamplingcorrect;
-	uint8 subsamplingcorrect_done;
-	uint8 subsampling_tag;
-	uint8 subsampling_hor;
-	uint8 subsampling_ver;
-	uint8 subsampling_force_desubsampling_inside_decompression;
-	uint8 qtable_offset_count;
-	uint8 dctable_offset_count;
-	uint8 actable_offset_count;
-	uint64 qtable_offset[3];
-	uint64 dctable_offset[3];
-	uint64 actable_offset[3];
-	uint8* qtable[4];
-	uint8* dctable[4];
-	uint8* actable[4];
-	uint16 restart_interval;
-	uint8 restart_index;
-	uint8 sof_log;
-	uint8 sof_marker_id;
-	uint32 sof_x;
-	uint32 sof_y;
-	uint8 sof_c[3];
-	uint8 sof_hv[3];
-	uint8 sof_tq[3];
-	uint8 sos_cs[3];
-	uint8 sos_tda[3];
+	uint64_t file_size;
+	uint32_t image_width;
+	uint32_t image_length;
+	uint32_t strile_width;
+	uint32_t strile_length;
+	uint32_t strile_length_total;
+	uint8_t samples_per_pixel;
+	uint8_t plane_sample_offset;
+	uint8_t samples_per_pixel_per_plane;
+	uint64_t jpeg_interchange_format;
+	uint64_t jpeg_interchange_format_length;
+	uint8_t jpeg_proc;
+	uint8_t subsamplingcorrect;
+	uint8_t subsamplingcorrect_done;
+	uint8_t subsampling_tag;
+	uint8_t subsampling_hor;
+	uint8_t subsampling_ver;
+	uint8_t subsampling_force_desubsampling_inside_decompression;
+	uint8_t qtable_offset_count;
+	uint8_t dctable_offset_count;
+	uint8_t actable_offset_count;
+	uint64_t qtable_offset[3];
+	uint64_t dctable_offset[3];
+	uint64_t actable_offset[3];
+	uint8_t* qtable[4];
+	uint8_t* dctable[4];
+	uint8_t* actable[4];
+	uint16_t restart_interval;
+	uint8_t restart_index;
+	uint8_t sof_log;
+	uint8_t sof_marker_id;
+	uint32_t sof_x;
+	uint32_t sof_y;
+	uint8_t sof_c[3];
+	uint8_t sof_hv[3];
+	uint8_t sof_tq[3];
+	uint8_t sos_cs[3];
+	uint8_t sos_tda[3];
 	struct {
-		uint8 log;
+		uint8_t log;
 		OJPEGStateInBufferSource in_buffer_source;
-		uint32 in_buffer_next_strile;
-		uint64 in_buffer_file_pos;
-		uint64 in_buffer_file_togo;
+		uint32_t in_buffer_next_strile;
+		uint64_t in_buffer_file_pos;
+		uint64_t in_buffer_file_togo;
 	} sos_end[3];
-	uint8 readheader_done;
-	uint8 writeheader_done;
-	uint16 write_cursample;
-	uint32 write_curstrile;
-	uint8 libjpeg_session_active;
-	uint8 libjpeg_jpeg_query_style;
+	uint8_t readheader_done;
+	uint8_t writeheader_done;
+	uint16_t write_cursample;
+	uint32_t write_curstrile;
+	uint8_t libjpeg_session_active;
+	uint8_t libjpeg_jpeg_query_style;
 	jpeg_error_mgr libjpeg_jpeg_error_mgr;
 	jpeg_decompress_struct libjpeg_jpeg_decompress_struct;
 	jpeg_source_mgr libjpeg_jpeg_source_mgr;
-	uint8 subsampling_convert_log;
-	uint32 subsampling_convert_ylinelen;
-	uint32 subsampling_convert_ylines;
-	uint32 subsampling_convert_clinelen;
-	uint32 subsampling_convert_clines;
-	uint32 subsampling_convert_ybuflen;
-	uint32 subsampling_convert_cbuflen;
-	uint32 subsampling_convert_ycbcrbuflen;
-	uint8* subsampling_convert_ycbcrbuf;
-	uint8* subsampling_convert_ybuf;
-	uint8* subsampling_convert_cbbuf;
-	uint8* subsampling_convert_crbuf;
-	uint32 subsampling_convert_ycbcrimagelen;
-	uint8** subsampling_convert_ycbcrimage;
-	uint32 subsampling_convert_clinelenout;
-	uint32 subsampling_convert_state;
-	uint32 bytes_per_line;   /* if the codec outputs subsampled data, a 'line' in bytes_per_line */
-	uint32 lines_per_strile; /* and lines_per_strile means subsampling_ver desubsampled rows     */
+	uint8_t subsampling_convert_log;
+	uint32_t subsampling_convert_ylinelen;
+	uint32_t subsampling_convert_ylines;
+	uint32_t subsampling_convert_clinelen;
+	uint32_t subsampling_convert_clines;
+	uint32_t subsampling_convert_ybuflen;
+	uint32_t subsampling_convert_cbuflen;
+	uint32_t subsampling_convert_ycbcrbuflen;
+	uint8_t* subsampling_convert_ycbcrbuf;
+	uint8_t* subsampling_convert_ybuf;
+	uint8_t* subsampling_convert_cbbuf;
+	uint8_t* subsampling_convert_crbuf;
+	uint32_t subsampling_convert_ycbcrimagelen;
+	uint8_t** subsampling_convert_ycbcrimage;
+	uint32_t subsampling_convert_clinelenout;
+	uint32_t subsampling_convert_state;
+	uint32_t bytes_per_line;   /* if the codec outputs subsampled data, a 'line' in bytes_per_line */
+	uint32_t lines_per_strile; /* and lines_per_strile means subsampling_ver desubsampled rows     */
 	OJPEGStateInBufferSource in_buffer_source;
-	uint32 in_buffer_next_strile;
-	uint32 in_buffer_strile_count;
-	uint64 in_buffer_file_pos;
-	uint8 in_buffer_file_pos_log;
-	uint64 in_buffer_file_togo;
-	uint16 in_buffer_togo;
-	uint8* in_buffer_cur;
-	uint8 in_buffer[OJPEG_BUFFER];
+	uint32_t in_buffer_next_strile;
+	uint32_t in_buffer_strile_count;
+	uint64_t in_buffer_file_pos;
+	uint8_t in_buffer_file_pos_log;
+	uint64_t in_buffer_file_togo;
+	uint16_t in_buffer_togo;
+	uint8_t* in_buffer_cur;
+	uint8_t in_buffer[OJPEG_BUFFER];
 	OJPEGStateOutState out_state;
-	uint8 out_buffer[OJPEG_BUFFER];
-	uint8* skip_buffer;
+	uint8_t out_buffer[OJPEG_BUFFER];
+	uint8_t* skip_buffer;
 } OJPEGState;
 
-static int OJPEGVGetField(TIFF* tif, uint32 tag, va_list ap);
-static int OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap);
+static int OJPEGVGetField(TIFF* tif, uint32_t tag, va_list ap);
+static int OJPEGVSetField(TIFF* tif, uint32_t tag, va_list ap);
 static void OJPEGPrintDir(TIFF* tif, FILE* fd, long flags);
 
 static int OJPEGFixupTags(TIFF* tif);
 static int OJPEGSetupDecode(TIFF* tif);
-static int OJPEGPreDecode(TIFF* tif, uint16 s);
+static int OJPEGPreDecode(TIFF* tif, uint16_t s);
 static int OJPEGPreDecodeSkipRaw(TIFF* tif);
 static int OJPEGPreDecodeSkipScanlines(TIFF* tif);
-static int OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s);
-static int OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc);
-static int OJPEGDecodeScanlines(TIFF* tif, uint8* buf, tmsize_t cc);
-static void OJPEGPostDecode(TIFF* tif, uint8* buf, tmsize_t cc);
+static int OJPEGDecode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s);
+static int OJPEGDecodeRaw(TIFF* tif, uint8_t* buf, tmsize_t cc);
+static int OJPEGDecodeScanlines(TIFF* tif, uint8_t* buf, tmsize_t cc);
+static void OJPEGPostDecode(TIFF* tif, uint8_t* buf, tmsize_t cc);
 static int OJPEGSetupEncode(TIFF* tif);
-static int OJPEGPreEncode(TIFF* tif, uint16 s);
-static int OJPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s);
+static int OJPEGPreEncode(TIFF* tif, uint16_t s);
+static int OJPEGEncode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s);
 static int OJPEGPostEncode(TIFF* tif);
 static void OJPEGCleanup(TIFF* tif);
 
 static void OJPEGSubsamplingCorrect(TIFF* tif);
 static int OJPEGReadHeaderInfo(TIFF* tif);
-static int OJPEGReadSecondarySos(TIFF* tif, uint16 s);
+static int OJPEGReadSecondarySos(TIFF* tif, uint16_t s);
 static int OJPEGWriteHeaderInfo(TIFF* tif);
 static void OJPEGLibjpegSessionAbort(TIFF* tif);
 
@@ -365,45 +365,45 @@ static int OJPEGReadHeaderInfoSec(TIFF* tif);
 static int OJPEGReadHeaderInfoSecStreamDri(TIFF* tif);
 static int OJPEGReadHeaderInfoSecStreamDqt(TIFF* tif);
 static int OJPEGReadHeaderInfoSecStreamDht(TIFF* tif);
-static int OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id);
+static int OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8_t marker_id);
 static int OJPEGReadHeaderInfoSecStreamSos(TIFF* tif);
 static int OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif);
 static int OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif);
 static int OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif);
 
 static int OJPEGReadBufferFill(OJPEGState* sp);
-static int OJPEGReadByte(OJPEGState* sp, uint8* byte);
-static int OJPEGReadBytePeek(OJPEGState* sp, uint8* byte);
+static int OJPEGReadByte(OJPEGState* sp, uint8_t* byte);
+static int OJPEGReadBytePeek(OJPEGState* sp, uint8_t* byte);
 static void OJPEGReadByteAdvance(OJPEGState* sp);
-static int OJPEGReadWord(OJPEGState* sp, uint16* word);
-static int OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem);
-static void OJPEGReadSkip(OJPEGState* sp, uint16 len);
-
-static int OJPEGWriteStream(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);
-static void OJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);
-static void OJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);
-static void OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len);
-static int OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len);
+static int OJPEGReadWord(OJPEGState* sp, uint16_t* word);
+static int OJPEGReadBlock(OJPEGState* sp, uint16_t len, void* mem);
+static void OJPEGReadSkip(OJPEGState* sp, uint16_t len);
+
+static int OJPEGWriteStream(TIFF* tif, void** mem, uint32_t* len);
+static void OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32_t* len);
+static void OJPEGWriteStreamQTable(TIFF* tif, uint8_t table_index, void** mem, uint32_t* len);
+static void OJPEGWriteStreamDcTable(TIFF* tif, uint8_t table_index, void** mem, uint32_t* len);
+static void OJPEGWriteStreamAcTable(TIFF* tif, uint8_t table_index, void** mem, uint32_t* len);
+static void OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32_t* len);
+static void OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32_t* len);
+static void OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32_t* len);
+static int OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32_t* len);
+static void OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32_t* len);
+static void OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32_t* len);
 
 #ifdef LIBJPEG_ENCAP_EXTERNAL
 extern int jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);
-extern int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image);
+extern int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8_t require_image);
 extern int jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);
-extern int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines);
-extern int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines);
+extern int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32_t max_lines);
+extern int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32_t max_lines);
 extern void jpeg_encap_unwind(TIFF* tif);
 #else
 static int jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* j);
-static int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image);
+static int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8_t require_image);
 static int jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);
-static int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines);
-static int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines);
+static int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32_t max_lines);
+static int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32_t max_lines);
 static void jpeg_encap_unwind(TIFF* tif);
 #endif
 
@@ -421,6 +421,7 @@ TIFFInitOJPEG(TIFF* tif, int scheme)
 	static const char module[]="TIFFInitOJPEG";
 	OJPEGState* sp;
 
+        (void)scheme;
 	assert(scheme==COMPRESSION_OJPEG);
 
         /*
@@ -460,7 +461,7 @@ TIFFInitOJPEG(TIFF* tif, int scheme)
 	tif->tif_encodestrip=OJPEGEncode;  
 	tif->tif_encodetile=OJPEGEncode;  
 	tif->tif_cleanup=OJPEGCleanup;
-	tif->tif_data=(uint8*)sp;
+	tif->tif_data=(uint8_t*)sp;
 	/* tif tag methods */
 	sp->vgetparent=tif->tif_tagmethods.vgetfield;
 	tif->tif_tagmethods.vgetfield=OJPEGVGetField;
@@ -479,40 +480,40 @@ TIFFInitOJPEG(TIFF* tif, int scheme)
 }
 
 static int
-OJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)
+OJPEGVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	switch(tag)
 	{
 		case TIFFTAG_JPEGIFOFFSET:
-			*va_arg(ap,uint64*)=(uint64)sp->jpeg_interchange_format;
+			*va_arg(ap, uint64_t*)=(uint64_t)sp->jpeg_interchange_format;
 			break;
 		case TIFFTAG_JPEGIFBYTECOUNT:
-			*va_arg(ap,uint64*)=(uint64)sp->jpeg_interchange_format_length;
+			*va_arg(ap, uint64_t*)=(uint64_t)sp->jpeg_interchange_format_length;
 			break;
 		case TIFFTAG_YCBCRSUBSAMPLING:
 			if (sp->subsamplingcorrect_done==0)
 				OJPEGSubsamplingCorrect(tif);
-			*va_arg(ap,uint16*)=(uint16)sp->subsampling_hor;
-			*va_arg(ap,uint16*)=(uint16)sp->subsampling_ver;
+			*va_arg(ap, uint16_t*)=(uint16_t)sp->subsampling_hor;
+			*va_arg(ap, uint16_t*)=(uint16_t)sp->subsampling_ver;
 			break;
 		case TIFFTAG_JPEGQTABLES:
-			*va_arg(ap,uint32*)=(uint32)sp->qtable_offset_count;
-			*va_arg(ap,void**)=(void*)sp->qtable_offset; 
+			*va_arg(ap, uint32_t*)=(uint32_t)sp->qtable_offset_count;
+			*va_arg(ap,const void**)=(const void*)sp->qtable_offset;
 			break;
 		case TIFFTAG_JPEGDCTABLES:
-			*va_arg(ap,uint32*)=(uint32)sp->dctable_offset_count;
-			*va_arg(ap,void**)=(void*)sp->dctable_offset;  
+			*va_arg(ap, uint32_t*)=(uint32_t)sp->dctable_offset_count;
+			*va_arg(ap,const void**)=(const void*)sp->dctable_offset;
 			break;
 		case TIFFTAG_JPEGACTABLES:
-			*va_arg(ap,uint32*)=(uint32)sp->actable_offset_count;
-			*va_arg(ap,void**)=(void*)sp->actable_offset;
+			*va_arg(ap, uint32_t*)=(uint32_t)sp->actable_offset_count;
+			*va_arg(ap,const void**)=(const void*)sp->actable_offset;
 			break;
 		case TIFFTAG_JPEGPROC:
-			*va_arg(ap,uint16*)=(uint16)sp->jpeg_proc;
+			*va_arg(ap, uint16_t*)=(uint16_t)sp->jpeg_proc;
 			break;
 		case TIFFTAG_JPEGRESTARTINTERVAL:
-			*va_arg(ap,uint16*)=sp->restart_interval;
+			*va_arg(ap, uint16_t*)=sp->restart_interval;
 			break;
 		default:
 			return (*sp->vgetparent)(tif,tag,ap);
@@ -521,32 +522,32 @@ OJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)
 }
 
 static int
-OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)
+OJPEGVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	static const char module[]="OJPEGVSetField";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint32 ma;
-	uint64* mb;
-	uint32 n;
+	uint32_t ma;
+	uint64_t* mb;
+	uint32_t n;
 	const TIFFField* fip;
 
 	switch(tag)
 	{
 		case TIFFTAG_JPEGIFOFFSET:
-			sp->jpeg_interchange_format=(uint64)va_arg(ap,uint64);
+			sp->jpeg_interchange_format=(uint64_t)va_arg(ap, uint64_t);
 			break;
 		case TIFFTAG_JPEGIFBYTECOUNT:
-			sp->jpeg_interchange_format_length=(uint64)va_arg(ap,uint64);
+			sp->jpeg_interchange_format_length=(uint64_t)va_arg(ap, uint64_t);
 			break;
 		case TIFFTAG_YCBCRSUBSAMPLING:
 			sp->subsampling_tag=1;
-			sp->subsampling_hor=(uint8)va_arg(ap,uint16_vap);
-			sp->subsampling_ver=(uint8)va_arg(ap,uint16_vap);
+			sp->subsampling_hor=(uint8_t)va_arg(ap, uint16_vap);
+			sp->subsampling_ver=(uint8_t)va_arg(ap, uint16_vap);
 			tif->tif_dir.td_ycbcrsubsampling[0]=sp->subsampling_hor;
 			tif->tif_dir.td_ycbcrsubsampling[1]=sp->subsampling_ver;
 			break;
 		case TIFFTAG_JPEGQTABLES:
-			ma=(uint32)va_arg(ap,uint32);
+			ma=(uint32_t)va_arg(ap, uint32_t);
 			if (ma!=0)
 			{
 				if (ma>3)
@@ -554,14 +555,14 @@ OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)
 					TIFFErrorExt(tif->tif_clientdata,module,"JpegQTables tag has incorrect count");
 					return(0);
 				}
-				sp->qtable_offset_count=(uint8)ma;
-				mb=(uint64*)va_arg(ap,uint64*);
+				sp->qtable_offset_count=(uint8_t)ma;
+				mb=(uint64_t*)va_arg(ap, uint64_t*);
 				for (n=0; n<ma; n++)
 					sp->qtable_offset[n]=mb[n];
 			}
 			break;
 		case TIFFTAG_JPEGDCTABLES:
-			ma=(uint32)va_arg(ap,uint32);
+			ma=(uint32_t)va_arg(ap, uint32_t);
 			if (ma!=0)
 			{
 				if (ma>3)
@@ -569,14 +570,14 @@ OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)
 					TIFFErrorExt(tif->tif_clientdata,module,"JpegDcTables tag has incorrect count");
 					return(0);
 				}
-				sp->dctable_offset_count=(uint8)ma;
-				mb=(uint64*)va_arg(ap,uint64*);
+				sp->dctable_offset_count=(uint8_t)ma;
+				mb=(uint64_t*)va_arg(ap, uint64_t*);
 				for (n=0; n<ma; n++)
 					sp->dctable_offset[n]=mb[n];
 			}
 			break;
 		case TIFFTAG_JPEGACTABLES:
-			ma=(uint32)va_arg(ap,uint32);
+			ma=(uint32_t)va_arg(ap, uint32_t);
 			if (ma!=0)
 			{
 				if (ma>3)
@@ -584,17 +585,17 @@ OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)
 					TIFFErrorExt(tif->tif_clientdata,module,"JpegAcTables tag has incorrect count");
 					return(0);
 				}
-				sp->actable_offset_count=(uint8)ma;
-				mb=(uint64*)va_arg(ap,uint64*);
+				sp->actable_offset_count=(uint8_t)ma;
+				mb=(uint64_t*)va_arg(ap, uint64_t*);
 				for (n=0; n<ma; n++)
 					sp->actable_offset[n]=mb[n];
 			}
 			break;
 		case TIFFTAG_JPEGPROC:
-			sp->jpeg_proc=(uint8)va_arg(ap,uint16_vap);
+			sp->jpeg_proc=(uint8_t)va_arg(ap, uint16_vap);
 			break;
 		case TIFFTAG_JPEGRESTARTINTERVAL:
-			sp->restart_interval=(uint16)va_arg(ap,uint16_vap);
+			sp->restart_interval=(uint16_t)va_arg(ap, uint16_vap);
 			break;
 		default:
 			return (*sp->vsetparent)(tif,tag,ap);
@@ -611,38 +612,38 @@ static void
 OJPEGPrintDir(TIFF* tif, FILE* fd, long flags)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
+	uint8_t m;
 	(void)flags;
 	assert(sp!=NULL);
 	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMAT))
-		fprintf(fd,"  JpegInterchangeFormat: " TIFF_UINT64_FORMAT "\n",(TIFF_UINT64_T)sp->jpeg_interchange_format);  
+		fprintf(fd,"  JpegInterchangeFormat: %" PRIu64 "\n",(uint64_t)sp->jpeg_interchange_format);
 	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH))
-		fprintf(fd,"  JpegInterchangeFormatLength: " TIFF_UINT64_FORMAT "\n",(TIFF_UINT64_T)sp->jpeg_interchange_format_length);  
+		fprintf(fd,"  JpegInterchangeFormatLength: %" PRIu64 "\n",(uint64_t)sp->jpeg_interchange_format_length);
 	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGQTABLES))
 	{
 		fprintf(fd,"  JpegQTables:");
 		for (m=0; m<sp->qtable_offset_count; m++)
-			fprintf(fd," " TIFF_UINT64_FORMAT,(TIFF_UINT64_T)sp->qtable_offset[m]);
+			fprintf(fd," %" PRIu64,(uint64_t)sp->qtable_offset[m]);
 		fprintf(fd,"\n");
 	}
 	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGDCTABLES))
 	{
 		fprintf(fd,"  JpegDcTables:");
 		for (m=0; m<sp->dctable_offset_count; m++)
-			fprintf(fd," " TIFF_UINT64_FORMAT,(TIFF_UINT64_T)sp->dctable_offset[m]);
+			fprintf(fd," %" PRIu64,(uint64_t)sp->dctable_offset[m]);
 		fprintf(fd,"\n");
 	}
 	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGACTABLES))
 	{
 		fprintf(fd,"  JpegAcTables:");
 		for (m=0; m<sp->actable_offset_count; m++)
-			fprintf(fd," " TIFF_UINT64_FORMAT,(TIFF_UINT64_T)sp->actable_offset[m]);
+			fprintf(fd," %" PRIu64,(uint64_t)sp->actable_offset[m]);
 		fprintf(fd,"\n");
 	}
 	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGPROC))
-		fprintf(fd,"  JpegProc: %u\n",(unsigned int)sp->jpeg_proc);
+		fprintf(fd,"  JpegProc: %"PRIu8"\n", sp->jpeg_proc);
 	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGRESTARTINTERVAL))
-		fprintf(fd,"  JpegRestartInterval: %u\n",(unsigned int)sp->restart_interval);
+		fprintf(fd,"  JpegRestartInterval: %"PRIu16"\n", sp->restart_interval);
 	if (sp->printdir)
 		(*sp->printdir)(tif, fd, flags);
 }
@@ -658,15 +659,15 @@ static int
 OJPEGSetupDecode(TIFF* tif)
 {
 	static const char module[]="OJPEGSetupDecode";
-	TIFFWarningExt(tif->tif_clientdata,module,"Depreciated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software");
+	TIFFWarningExt(tif->tif_clientdata,module,"Deprecated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software");
 	return(1);
 }
 
 static int
-OJPEGPreDecode(TIFF* tif, uint16 s)
+OJPEGPreDecode(TIFF* tif, uint16_t s)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint32 m;
+	uint32_t m;
 	if (sp->subsamplingcorrect_done==0)
 		OJPEGSubsamplingCorrect(tif);
 	if (sp->readheader_done==0)
@@ -691,7 +692,7 @@ OJPEGPreDecode(TIFF* tif, uint16 s)
 	}
 	if (sp->writeheader_done==0)
 	{
-		sp->plane_sample_offset=(uint8)s;
+		sp->plane_sample_offset=(uint8_t)s;
 		sp->write_cursample=s;
 		sp->write_curstrile=s*tif->tif_dir.td_stripsperimage;
 		if ((sp->in_buffer_file_pos_log==0) ||
@@ -730,7 +731,7 @@ static int
 OJPEGPreDecodeSkipRaw(TIFF* tif)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint32 m;
+	uint32_t m;
 	m=sp->lines_per_strile;
 	if (sp->subsampling_convert_state!=0)
 	{
@@ -765,7 +766,7 @@ OJPEGPreDecodeSkipScanlines(TIFF* tif)
 {
 	static const char module[]="OJPEGPreDecodeSkipScanlines";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint32 m;
+	uint32_t m;
 	if (sp->skip_buffer==NULL)
 	{
 		sp->skip_buffer=_TIFFmalloc(sp->bytes_per_line);
@@ -784,7 +785,7 @@ OJPEGPreDecodeSkipScanlines(TIFF* tif)
 }
 
 static int
-OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+OJPEGDecode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
         static const char module[]="OJPEGDecode";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
@@ -812,19 +813,19 @@ OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 }
 
 static int
-OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)
+OJPEGDecodeRaw(TIFF* tif, uint8_t* buf, tmsize_t cc)
 {
 	static const char module[]="OJPEGDecodeRaw";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8* m;
+	uint8_t* m;
 	tmsize_t n;
-	uint8* oy;
-	uint8* ocb;
-	uint8* ocr;
-	uint8* p;
-	uint32 q;
-	uint8* r;
-	uint8 sx,sy;
+	uint8_t* oy;
+	uint8_t* ocb;
+	uint8_t* ocr;
+	uint8_t* p;
+	uint32_t q;
+	uint8_t* r;
+	uint8_t sx,sy;
 	if (cc%sp->bytes_per_line!=0)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Fractional scanline not read");
@@ -837,36 +838,6 @@ OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)
 	{
 		if (sp->subsampling_convert_state==0)
 		{
-			const jpeg_decompress_struct* cinfo = &sp->libjpeg_jpeg_decompress_struct;
-			int width = 0;
-			int last_col_width = 0;
-			int jpeg_bytes;
-			int expected_bytes;
-			int i;
-			if (cinfo->MCUs_per_row == 0)
-			{
-				sp->error_in_raw_data_decoding = 1;
-				return 0;
-			}
-			for (i = 0; i < cinfo->comps_in_scan; ++i)
-			{
-				const jpeg_component_info* info = cinfo->cur_comp_info[i];
-#if JPEG_LIB_VERSION >= 70
-				width += info->MCU_width * info->DCT_h_scaled_size;
-				last_col_width += info->last_col_width * info->DCT_h_scaled_size;
-#else
-				width += info->MCU_width * info->DCT_scaled_size;
-				last_col_width += info->last_col_width * info->DCT_scaled_size;
-#endif
-			}
-			jpeg_bytes = (cinfo->MCUs_per_row - 1) * width + last_col_width;
-			expected_bytes = sp->subsampling_convert_clinelenout * sp->subsampling_ver * sp->subsampling_hor;
-			if (jpeg_bytes != expected_bytes)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Inconsistent number of MCU in codestream");
-				sp->error_in_raw_data_decoding = 1;
-				return(0);
-			}
 			if (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)
 			{
 				sp->error_in_raw_data_decoding = 1;
@@ -900,11 +871,11 @@ OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)
 }
 
 static int
-OJPEGDecodeScanlines(TIFF* tif, uint8* buf, tmsize_t cc)
+OJPEGDecodeScanlines(TIFF* tif, uint8_t* buf, tmsize_t cc)
 {
 	static const char module[]="OJPEGDecodeScanlines";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8* m;
+	uint8_t* m;
 	tmsize_t n;
 	if (cc%sp->bytes_per_line!=0)
 	{
@@ -925,7 +896,7 @@ OJPEGDecodeScanlines(TIFF* tif, uint8* buf, tmsize_t cc)
 }
 
 static void
-OJPEGPostDecode(TIFF* tif, uint8* buf, tmsize_t cc)
+OJPEGPostDecode(TIFF* tif, uint8_t* buf, tmsize_t cc)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	(void)buf;
@@ -948,7 +919,7 @@ OJPEGSetupEncode(TIFF* tif)
 }
 
 static int
-OJPEGPreEncode(TIFF* tif, uint16 s)
+OJPEGPreEncode(TIFF* tif, uint16_t s)
 {
 	static const char module[]="OJPEGPreEncode";
 	(void)s;
@@ -957,7 +928,7 @@ OJPEGPreEncode(TIFF* tif, uint16 s)
 }
 
 static int
-OJPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+OJPEGEncode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
 	static const char module[]="OJPEGEncode";
 	(void)buf;
@@ -1027,8 +998,8 @@ OJPEGSubsamplingCorrect(TIFF* tif)
 {
 	static const char module[]="OJPEGSubsamplingCorrect";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 mh;
-	uint8 mv;
+	uint8_t mh;
+	uint8_t mv;
         
 	assert(sp->subsamplingcorrect_done==0);
 	if ((tif->tif_dir.td_samplesperpixel!=3) || ((tif->tif_dir.td_photometric!=PHOTOMETRIC_YCBCR) &&
@@ -1056,21 +1027,21 @@ OJPEGSubsamplingCorrect(TIFF* tif)
 		if (((sp->subsampling_hor!=mh) || (sp->subsampling_ver!=mv)) && (sp->subsampling_force_desubsampling_inside_decompression==0))
 		{
 			if (sp->subsampling_tag==0)
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling tag is not set, yet subsampling inside JPEG data [%d,%d] does not match default values [2,2]; assuming subsampling inside JPEG data is correct",sp->subsampling_hor,sp->subsampling_ver);
+				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling tag is not set, yet subsampling inside JPEG data [%"PRIu8",%"PRIu8"] does not match default values [2,2]; assuming subsampling inside JPEG data is correct",sp->subsampling_hor,sp->subsampling_ver);
 			else
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling inside JPEG data [%d,%d] does not match subsampling tag values [%d,%d]; assuming subsampling inside JPEG data is correct",sp->subsampling_hor,sp->subsampling_ver,mh,mv);
+				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling inside JPEG data [%"PRIu8",%"PRIu8"] does not match subsampling tag values [%"PRIu8",%"PRIu8"]; assuming subsampling inside JPEG data is correct",sp->subsampling_hor,sp->subsampling_ver,mh,mv);
 		}
 		if (sp->subsampling_force_desubsampling_inside_decompression!=0)
 		{
 			if (sp->subsampling_tag==0)
 				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling tag is not set, yet subsampling inside JPEG data does not match default values [2,2] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression");
 			else
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling inside JPEG data does not match subsampling tag values [%d,%d] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression",mh,mv);
+				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling inside JPEG data does not match subsampling tag values [%"PRIu8",%"PRIu8"] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression",mh,mv);
 		}
 		if (sp->subsampling_force_desubsampling_inside_decompression==0)
 		{
 			if (sp->subsampling_hor<sp->subsampling_ver)
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling values [%d,%d] are not allowed in TIFF",sp->subsampling_hor,sp->subsampling_ver);
+				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling values [%"PRIu8",%"PRIu8"] are not allowed in TIFF",sp->subsampling_hor,sp->subsampling_ver);
 		}
 	}
 	sp->subsamplingcorrect_done=1;
@@ -1094,6 +1065,8 @@ OJPEGReadHeaderInfo(TIFF* tif)
 	{
 		sp->strile_width=sp->image_width;
 		sp->strile_length=tif->tif_dir.td_rowsperstrip;
+                if( sp->strile_length == (uint32_t)-1 )
+                    sp->strile_length = sp->image_length;
 		sp->strile_length_total=sp->image_length;
 	}
 	if (tif->tif_dir.td_samplesperpixel==1)
@@ -1108,7 +1081,7 @@ OJPEGReadHeaderInfo(TIFF* tif)
 	{
 		if (tif->tif_dir.td_samplesperpixel!=3)
 		{
-			TIFFErrorExt(tif->tif_clientdata,module,"SamplesPerPixel %d not supported for this compression scheme",sp->samples_per_pixel);
+			TIFFErrorExt(tif->tif_clientdata,module,"SamplesPerPixel %"PRIu8" not supported for this compression scheme",sp->samples_per_pixel);
 			return(0);
 		}
 		sp->samples_per_pixel=3;
@@ -1131,7 +1104,7 @@ OJPEGReadHeaderInfo(TIFF* tif)
 			TIFFErrorExt(tif->tif_clientdata,module,"Incompatible vertical subsampling and image strip/tile length");
 			return(0);
 		}
-		sp->restart_interval=(uint16)(((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8))*(sp->strile_length/(sp->subsampling_ver*8)));
+		sp->restart_interval=(uint16_t)(((sp->strile_width + sp->subsampling_hor * 8 - 1) / (sp->subsampling_hor * 8)) * (sp->strile_length / (sp->subsampling_ver * 8)));
 	}
 	if (OJPEGReadHeaderInfoSec(tif)==0)
 		return(0);
@@ -1145,15 +1118,15 @@ OJPEGReadHeaderInfo(TIFF* tif)
 }
 
 static int
-OJPEGReadSecondarySos(TIFF* tif, uint16 s)
+OJPEGReadSecondarySos(TIFF* tif, uint16_t s)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
+	uint8_t m;
 	assert(s>0);
 	assert(s<3);
 	assert(sp->sos_end[0].log!=0);
 	assert(sp->sos_end[s].log==0);
-	sp->plane_sample_offset=(uint8)(s-1);
+	sp->plane_sample_offset=(uint8_t)(s - 1);
 	while(sp->sos_end[sp->plane_sample_offset].log==0)
 		sp->plane_sample_offset--;
 	sp->in_buffer_source=sp->sos_end[sp->plane_sample_offset].in_buffer_source;
@@ -1199,8 +1172,8 @@ OJPEGWriteHeaderInfo(TIFF* tif)
 {
 	static const char module[]="OJPEGWriteHeaderInfo";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8** m;
-	uint32 n;
+	uint8_t** m;
+	uint32_t n;
 	/* if a previous attempt failed, don't try again */
 	if (sp->libjpeg_session_active != 0) 
 		return 0;
@@ -1257,16 +1230,16 @@ OJPEGWriteHeaderInfo(TIFF* tif)
 			sp->subsampling_convert_cbbuf=sp->subsampling_convert_ybuf+sp->subsampling_convert_ybuflen;
 			sp->subsampling_convert_crbuf=sp->subsampling_convert_cbbuf+sp->subsampling_convert_cbuflen;
 			sp->subsampling_convert_ycbcrimagelen=3+sp->subsampling_convert_ylines+2*sp->subsampling_convert_clines;
-			sp->subsampling_convert_ycbcrimage=_TIFFmalloc(sp->subsampling_convert_ycbcrimagelen*sizeof(uint8*));
+			sp->subsampling_convert_ycbcrimage=_TIFFmalloc(sp->subsampling_convert_ycbcrimagelen*sizeof(uint8_t*));
 			if (sp->subsampling_convert_ycbcrimage==0)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 				return(0);
 			}
 			m=sp->subsampling_convert_ycbcrimage;
-			*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3);
-			*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines);
-			*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines+sp->subsampling_convert_clines);
+			*m++=(uint8_t*)(sp->subsampling_convert_ycbcrimage + 3);
+			*m++=(uint8_t*)(sp->subsampling_convert_ycbcrimage + 3 + sp->subsampling_convert_ylines);
+			*m++=(uint8_t*)(sp->subsampling_convert_ycbcrimage + 3 + sp->subsampling_convert_ylines + sp->subsampling_convert_clines);
 			for (n=0; n<sp->subsampling_convert_ylines; n++)
 				*m++=sp->subsampling_convert_ybuf+n*sp->subsampling_convert_ylinelen;
 			for (n=0; n<sp->subsampling_convert_clines; n++)
@@ -1291,6 +1264,26 @@ OJPEGWriteHeaderInfo(TIFF* tif)
 	}
 	if (jpeg_start_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)
 		return(0);
+        if(sp->libjpeg_jpeg_decompress_struct.image_width != sp->strile_width ) {
+            TIFFErrorExt(tif->tif_clientdata,module,
+                         "jpeg_start_decompress() returned image_width = %u, "
+                         "expected %"PRIu32,
+                         sp->libjpeg_jpeg_decompress_struct.image_width,
+                         sp->strile_width);
+            return 0;
+        }
+        if(sp->libjpeg_jpeg_decompress_struct.max_h_samp_factor != sp->subsampling_hor ||
+           sp->libjpeg_jpeg_decompress_struct.max_v_samp_factor != sp->subsampling_ver) {
+            TIFFErrorExt(tif->tif_clientdata,module,
+                         "jpeg_start_decompress() returned max_h_samp_factor = %d "
+                         "and max_v_samp_factor = %d, expected %"PRIu8" and %"PRIu8,
+                         sp->libjpeg_jpeg_decompress_struct.max_h_samp_factor,
+                         sp->libjpeg_jpeg_decompress_struct.max_v_samp_factor,
+                         sp->subsampling_hor,
+                         sp->subsampling_ver);
+            return 0;
+        }
+
 	sp->writeheader_done=1;
 	return(1);
 }
@@ -1309,9 +1302,9 @@ OJPEGReadHeaderInfoSec(TIFF* tif)
 {
 	static const char module[]="OJPEGReadHeaderInfoSec";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	uint16 n;
-	uint8 o;
+	uint8_t m;
+	uint16_t n;
+	uint8_t o;
 	if (sp->file_size==0)
 		sp->file_size=TIFFGetFileSize(tif);
 	if (sp->jpeg_interchange_format!=0)
@@ -1324,7 +1317,7 @@ OJPEGReadHeaderInfoSec(TIFF* tif)
 		else
 		{
 			if ((sp->jpeg_interchange_format_length==0) ||
-                            (sp->jpeg_interchange_format > TIFF_UINT64_MAX - sp->jpeg_interchange_format_length) ||
+                            (sp->jpeg_interchange_format > UINT64_MAX - sp->jpeg_interchange_format_length) ||
                             (sp->jpeg_interchange_format+sp->jpeg_interchange_format_length>sp->file_size))
 				sp->jpeg_interchange_format_length=sp->file_size-sp->jpeg_interchange_format;
 		}
@@ -1408,7 +1401,7 @@ OJPEGReadHeaderInfoSec(TIFF* tif)
 					return(0);
 				break;
 			default:
-				TIFFErrorExt(tif->tif_clientdata,module,"Unknown marker type %d in JPEG data",m);
+				TIFFErrorExt(tif->tif_clientdata,module,"Unknown marker type %"PRIu8" in JPEG data", m);
 				return(0);
 		}
 	} while(m!=JPEG_MARKER_SOS);
@@ -1444,7 +1437,7 @@ OJPEGReadHeaderInfoSecStreamDri(TIFF* tif)
            occurred so far */
 	static const char module[]="OJPEGReadHeaderInfoSecStreamDri";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
+	uint16_t m;
 	if (OJPEGReadWord(sp,&m)==0)
 		return(0);
 	if (m!=4)
@@ -1464,10 +1457,10 @@ OJPEGReadHeaderInfoSecStreamDqt(TIFF* tif)
 	/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */
 	static const char module[]="OJPEGReadHeaderInfoSecStreamDqt";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	uint32 na;
-	uint8* nb;
-	uint8 o;
+	uint16_t m;
+	uint32_t na;
+	uint8_t* nb;
+	uint8_t o;
 	if (OJPEGReadWord(sp,&m)==0)
 		return(0);
 	if (m<=2)
@@ -1488,23 +1481,23 @@ OJPEGReadHeaderInfoSecStreamDqt(TIFF* tif)
 				TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DQT marker in JPEG data");
 				return(0);
 			}
-			na=sizeof(uint32)+69;
+			na= sizeof(uint32_t) + 69;
 			nb=_TIFFmalloc(na);
 			if (nb==0)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 				return(0);
 			}
-			*(uint32*)nb=na;
-			nb[sizeof(uint32)]=255;
-			nb[sizeof(uint32)+1]=JPEG_MARKER_DQT;
-			nb[sizeof(uint32)+2]=0;
-			nb[sizeof(uint32)+3]=67;
-			if (OJPEGReadBlock(sp,65,&nb[sizeof(uint32)+4])==0) {
+			*(uint32_t*)nb=na;
+			nb[sizeof(uint32_t)]=255;
+			nb[sizeof(uint32_t) + 1]=JPEG_MARKER_DQT;
+			nb[sizeof(uint32_t) + 2]=0;
+			nb[sizeof(uint32_t) + 3]=67;
+			if (OJPEGReadBlock(sp,65,&nb[sizeof(uint32_t) + 4]) == 0) {
 				_TIFFfree(nb);
 				return(0);
 			}
-			o=nb[sizeof(uint32)+4]&15;
+			o= nb[sizeof(uint32_t) + 4] & 15;
 			if (3<o)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DQT marker in JPEG data");
@@ -1527,10 +1520,10 @@ OJPEGReadHeaderInfoSecStreamDht(TIFF* tif)
 	/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */
 	static const char module[]="OJPEGReadHeaderInfoSecStreamDht";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	uint32 na;
-	uint8* nb;
-	uint8 o;
+	uint16_t m;
+	uint32_t na;
+	uint8_t* nb;
+	uint8_t o;
 	if (OJPEGReadWord(sp,&m)==0)
 		return(0);
 	if (m<=2)
@@ -1545,23 +1538,23 @@ OJPEGReadHeaderInfoSecStreamDht(TIFF* tif)
 	}
 	else
 	{
-		na=sizeof(uint32)+2+m;
+		na= sizeof(uint32_t) + 2 + m;
 		nb=_TIFFmalloc(na);
 		if (nb==0)
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 			return(0);
 		}
-		*(uint32*)nb=na;
-		nb[sizeof(uint32)]=255;
-		nb[sizeof(uint32)+1]=JPEG_MARKER_DHT;
-		nb[sizeof(uint32)+2]=(m>>8);
-		nb[sizeof(uint32)+3]=(m&255);
-		if (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0) {
+		*(uint32_t*)nb=na;
+		nb[sizeof(uint32_t)]=255;
+		nb[sizeof(uint32_t) + 1]=JPEG_MARKER_DHT;
+		nb[sizeof(uint32_t) + 2]=(m >> 8);
+		nb[sizeof(uint32_t) + 3]=(m & 255);
+		if (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32_t) + 4]) == 0) {
                         _TIFFfree(nb);
 			return(0);
                 }
-		o=nb[sizeof(uint32)+4];
+		o=nb[sizeof(uint32_t) + 4];
 		if ((o&240)==0)
 		{
 			if (3<o)
@@ -1598,16 +1591,16 @@ OJPEGReadHeaderInfoSecStreamDht(TIFF* tif)
 }
 
 static int
-OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id)
+OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8_t marker_id)
 {
 	/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */
 	static const char module[]="OJPEGReadHeaderInfoSecStreamSof";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	uint16 n;
-	uint8 o;
-	uint16 p;
-	uint16 q;
+	uint16_t m;
+	uint16_t n;
+	uint8_t o;
+	uint16_t p;
+	uint16_t q;
 	if (sp->sof_log!=0)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Corrupt JPEG data");
@@ -1657,7 +1650,7 @@ OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id)
 		/* Y: Number of lines */
 		if (OJPEGReadWord(sp,&p)==0)
 			return(0);
-		if (((uint32)p<sp->image_length) && ((uint32)p<sp->strile_length_total))
+		if (((uint32_t)p < sp->image_length) && ((uint32_t)p < sp->strile_length_total))
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data indicates unexpected height");
 			return(0);
@@ -1666,12 +1659,12 @@ OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id)
 		/* X: Number of samples per line */
 		if (OJPEGReadWord(sp,&p)==0)
 			return(0);
-		if (((uint32)p<sp->image_width) && ((uint32)p<sp->strile_width))
+		if (((uint32_t)p < sp->image_width) && ((uint32_t)p < sp->strile_width))
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data indicates unexpected width");
 			return(0);
 		}
-		if ((uint32)p>sp->strile_width)
+		if ((uint32_t)p > sp->strile_width)
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data image width exceeds expected image width");
 			return(0);
@@ -1755,9 +1748,9 @@ OJPEGReadHeaderInfoSecStreamSos(TIFF* tif)
 	/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */
 	static const char module[]="OJPEGReadHeaderInfoSecStreamSos";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	uint8 n;
-	uint8 o;
+	uint16_t m;
+	uint8_t n;
+	uint8_t o;
 	assert(sp->subsamplingcorrect==0);
 	if (sp->sof_log==0)
 	{
@@ -1802,11 +1795,11 @@ OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif)
 {
 	static const char module[]="OJPEGReadHeaderInfoSecTablesQTable";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	uint8 n;
-	uint32 oa;
-	uint8* ob;
-	uint32 p;
+	uint8_t m;
+	uint8_t n;
+	uint32_t oa;
+	uint8_t* ob;
+	uint32_t p;
 	if (sp->qtable_offset[0]==0)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Missing JPEG tables");
@@ -1825,21 +1818,21 @@ OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif)
 					return(0);
 				}
 			}
-			oa=sizeof(uint32)+69;
+			oa= sizeof(uint32_t) + 69;
 			ob=_TIFFmalloc(oa);
 			if (ob==0)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 				return(0);
 			}
-			*(uint32*)ob=oa;
-			ob[sizeof(uint32)]=255;
-			ob[sizeof(uint32)+1]=JPEG_MARKER_DQT;
-			ob[sizeof(uint32)+2]=0;
-			ob[sizeof(uint32)+3]=67;
-			ob[sizeof(uint32)+4]=m;
+			*(uint32_t*)ob=oa;
+			ob[sizeof(uint32_t)]=255;
+			ob[sizeof(uint32_t) + 1]=JPEG_MARKER_DQT;
+			ob[sizeof(uint32_t) + 2]=0;
+			ob[sizeof(uint32_t) + 3]=67;
+			ob[sizeof(uint32_t) + 4]=m;
 			TIFFSeekFile(tif,sp->qtable_offset[m],SEEK_SET); 
-			p=(uint32)TIFFReadFile(tif,&ob[sizeof(uint32)+5],64);
+			p=(uint32_t)TIFFReadFile(tif, &ob[sizeof(uint32_t) + 5], 64);
 			if (p!=64)
                         {
                                 _TIFFfree(ob);
@@ -1861,13 +1854,13 @@ OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif)
 {
 	static const char module[]="OJPEGReadHeaderInfoSecTablesDcTable";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	uint8 n;
-	uint8 o[16];
-	uint32 p;
-	uint32 q;
-	uint32 ra;
-	uint8* rb;
+	uint8_t m;
+	uint8_t n;
+	uint8_t o[16];
+	uint32_t p;
+	uint32_t q;
+	uint32_t ra;
+	uint8_t* rb;
 	if (sp->dctable_offset[0]==0)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Missing JPEG tables");
@@ -1887,28 +1880,28 @@ OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif)
 				}
 			}
 			TIFFSeekFile(tif,sp->dctable_offset[m],SEEK_SET);
-			p=(uint32)TIFFReadFile(tif,o,16);
+			p=(uint32_t)TIFFReadFile(tif, o, 16);
 			if (p!=16)
 				return(0);
 			q=0;
 			for (n=0; n<16; n++)
 				q+=o[n];
-			ra=sizeof(uint32)+21+q;
+			ra= sizeof(uint32_t) + 21 + q;
 			rb=_TIFFmalloc(ra);
 			if (rb==0)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 				return(0);
 			}
-			*(uint32*)rb=ra;
-			rb[sizeof(uint32)]=255;
-			rb[sizeof(uint32)+1]=JPEG_MARKER_DHT;
-			rb[sizeof(uint32)+2]=(uint8)((19+q)>>8);
-			rb[sizeof(uint32)+3]=((19+q)&255);
-			rb[sizeof(uint32)+4]=m;
+			*(uint32_t*)rb=ra;
+			rb[sizeof(uint32_t)]=255;
+			rb[sizeof(uint32_t) + 1]=JPEG_MARKER_DHT;
+			rb[sizeof(uint32_t) + 2]=(uint8_t)((19 + q) >> 8);
+			rb[sizeof(uint32_t) + 3]=((19 + q) & 255);
+			rb[sizeof(uint32_t) + 4]=m;
 			for (n=0; n<16; n++)
-				rb[sizeof(uint32)+5+n]=o[n];
-			p=(uint32)TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);
+				rb[sizeof(uint32_t) + 5 + n]=o[n];
+			p=(uint32_t)TIFFReadFile(tif, &(rb[sizeof(uint32_t) + 21]), q);
 			if (p!=q)
                         {
                                 _TIFFfree(rb);
@@ -1930,13 +1923,13 @@ OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif)
 {
 	static const char module[]="OJPEGReadHeaderInfoSecTablesAcTable";
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	uint8 n;
-	uint8 o[16];
-	uint32 p;
-	uint32 q;
-	uint32 ra;
-	uint8* rb;
+	uint8_t m;
+	uint8_t n;
+	uint8_t o[16];
+	uint32_t p;
+	uint32_t q;
+	uint32_t ra;
+	uint8_t* rb;
 	if (sp->actable_offset[0]==0)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Missing JPEG tables");
@@ -1956,28 +1949,28 @@ OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif)
 				}
 			}
 			TIFFSeekFile(tif,sp->actable_offset[m],SEEK_SET);  
-			p=(uint32)TIFFReadFile(tif,o,16);
+			p=(uint32_t)TIFFReadFile(tif, o, 16);
 			if (p!=16)
 				return(0);
 			q=0;
 			for (n=0; n<16; n++)
 				q+=o[n];
-			ra=sizeof(uint32)+21+q;
+			ra= sizeof(uint32_t) + 21 + q;
 			rb=_TIFFmalloc(ra);
 			if (rb==0)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
 				return(0);
 			}
-			*(uint32*)rb=ra;
-			rb[sizeof(uint32)]=255;
-			rb[sizeof(uint32)+1]=JPEG_MARKER_DHT;
-			rb[sizeof(uint32)+2]=(uint8)((19+q)>>8);
-			rb[sizeof(uint32)+3]=((19+q)&255);
-			rb[sizeof(uint32)+4]=(16|m);
+			*(uint32_t*)rb=ra;
+			rb[sizeof(uint32_t)]=255;
+			rb[sizeof(uint32_t) + 1]=JPEG_MARKER_DHT;
+			rb[sizeof(uint32_t) + 2]=(uint8_t)((19 + q) >> 8);
+			rb[sizeof(uint32_t) + 3]=((19 + q) & 255);
+			rb[sizeof(uint32_t) + 4]=(16 | m);
 			for (n=0; n<16; n++)
-				rb[sizeof(uint32)+5+n]=o[n];
-			p=(uint32)TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);
+				rb[sizeof(uint32_t) + 5 + n]=o[n];
+			p=(uint32_t)TIFFReadFile(tif, &(rb[sizeof(uint32_t) + 21]), q);
 			if (p!=q)
                         {
                                 _TIFFfree(rb);
@@ -1997,7 +1990,7 @@ OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif)
 static int
 OJPEGReadBufferFill(OJPEGState* sp)
 {
-	uint16 m;
+	uint16_t m;
 	tmsize_t n;
 	/* TODO: double-check: when subsamplingcorrect is set, no call to TIFFErrorExt or TIFFWarningExt should be made
 	 * in any other case, seek or read errors should be passed through */
@@ -2011,16 +2004,16 @@ OJPEGReadBufferFill(OJPEGState* sp)
 				sp->in_buffer_file_pos_log=1;
 			}
 			m=OJPEG_BUFFER;
-			if ((uint64)m>sp->in_buffer_file_togo)
-				m=(uint16)sp->in_buffer_file_togo;
+			if ((uint64_t)m > sp->in_buffer_file_togo)
+				m=(uint16_t)sp->in_buffer_file_togo;
 			n=TIFFReadFile(sp->tif,sp->in_buffer,(tmsize_t)m);
 			if (n==0)
 				return(0);
 			assert(n>0);
 			assert(n<=OJPEG_BUFFER);
 			assert(n<65536);
-			assert((uint64)n<=sp->in_buffer_file_togo);
-			m=(uint16)n;
+			assert((uint64_t)n <= sp->in_buffer_file_togo);
+			m=(uint16_t)n;
 			sp->in_buffer_togo=m;
 			sp->in_buffer_cur=sp->in_buffer;
 			sp->in_buffer_file_togo-=m;
@@ -2052,7 +2045,7 @@ OJPEGReadBufferFill(OJPEGState* sp)
 						return 0;
 					if (sp->in_buffer_file_pos!=0)
 					{
-						uint64 bytecount = TIFFGetStrileByteCountWithErr(sp->tif, sp->in_buffer_next_strile, &err);
+						uint64_t bytecount = TIFFGetStrileByteCountWithErr(sp->tif, sp->in_buffer_next_strile, &err);
 						if( err )
 							return 0;
 						if (sp->in_buffer_file_pos>=sp->file_size)
@@ -2064,7 +2057,7 @@ OJPEGReadBufferFill(OJPEGState* sp)
 							sp->in_buffer_file_togo=bytecount;
 							if (sp->in_buffer_file_togo==0)
 								sp->in_buffer_file_pos=0;
-							else if (sp->in_buffer_file_pos > TIFF_UINT64_MAX - sp->in_buffer_file_togo || 
+							else if (sp->in_buffer_file_pos > UINT64_MAX - sp->in_buffer_file_togo ||
                                                                 sp->in_buffer_file_pos+sp->in_buffer_file_togo>sp->file_size)
 								sp->in_buffer_file_togo=sp->file_size-sp->in_buffer_file_pos;
 						}
@@ -2080,7 +2073,7 @@ OJPEGReadBufferFill(OJPEGState* sp)
 }
 
 static int
-OJPEGReadByte(OJPEGState* sp, uint8* byte)
+OJPEGReadByte(OJPEGState* sp, uint8_t* byte)
 {
 	if (sp->in_buffer_togo==0)
 	{
@@ -2095,7 +2088,7 @@ OJPEGReadByte(OJPEGState* sp, uint8* byte)
 }
 
 static int
-OJPEGReadBytePeek(OJPEGState* sp, uint8* byte)
+OJPEGReadBytePeek(OJPEGState* sp, uint8_t* byte)
 {
 	if (sp->in_buffer_togo==0)
 	{
@@ -2116,9 +2109,9 @@ OJPEGReadByteAdvance(OJPEGState* sp)
 }
 
 static int
-OJPEGReadWord(OJPEGState* sp, uint16* word)
+OJPEGReadWord(OJPEGState* sp, uint16_t* word)
 {
-	uint8 m;
+	uint8_t m;
 	if (OJPEGReadByte(sp,&m)==0)
 		return(0);
 	*word=(m<<8);
@@ -2129,11 +2122,11 @@ OJPEGReadWord(OJPEGState* sp, uint16* word)
 }
 
 static int
-OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem)
+OJPEGReadBlock(OJPEGState* sp, uint16_t len, void* mem)
 {
-	uint16 mlen;
-	uint8* mmem;
-	uint16 n;
+	uint16_t mlen;
+	uint8_t* mmem;
+	uint16_t n;
 	assert(len>0);
 	mlen=len;
 	mmem=mem;
@@ -2158,10 +2151,10 @@ OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem)
 }
 
 static void
-OJPEGReadSkip(OJPEGState* sp, uint16 len)
+OJPEGReadSkip(OJPEGState* sp, uint16_t len)
 {
-	uint16 m;
-	uint16 n;
+	uint16_t m;
+	uint16_t n;
 	m=len;
 	n=m;
 	if (n>sp->in_buffer_togo)
@@ -2173,8 +2166,8 @@ OJPEGReadSkip(OJPEGState* sp, uint16 len)
 	{
 		assert(sp->in_buffer_togo==0);
 		n=m;
-		if ((uint64)n>sp->in_buffer_file_togo)
-			n=(uint16)sp->in_buffer_file_togo;
+		if ((uint64_t)n > sp->in_buffer_file_togo)
+			n=(uint16_t)sp->in_buffer_file_togo;
 		sp->in_buffer_file_pos+=n;
 		sp->in_buffer_file_togo-=n;
 		sp->in_buffer_file_pos_log=0;
@@ -2188,7 +2181,7 @@ OJPEGReadSkip(OJPEGState* sp, uint16 len)
 }
 
 static int
-OJPEGWriteStream(TIFF* tif, void** mem, uint32* len)
+OJPEGWriteStream(TIFF* tif, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	*len=0;
@@ -2261,7 +2254,7 @@ OJPEGWriteStream(TIFF* tif, void** mem, uint32* len)
 }
 
 static void
-OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len)
+OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	assert(OJPEG_BUFFER>=2);
@@ -2273,43 +2266,43 @@ OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len)
 }
 
 static void
-OJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)
+OJPEGWriteStreamQTable(TIFF* tif, uint8_t table_index, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	if (sp->qtable[table_index]!=0)
 	{
-		*mem=(void*)(sp->qtable[table_index]+sizeof(uint32));
-		*len=*((uint32*)sp->qtable[table_index])-sizeof(uint32);
+		*mem=(void*)(sp->qtable[table_index]+sizeof(uint32_t));
+		*len= *((uint32_t*)sp->qtable[table_index]) - sizeof(uint32_t);
 	}
 	sp->out_state++;
 }
 
 static void
-OJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)
+OJPEGWriteStreamDcTable(TIFF* tif, uint8_t table_index, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	if (sp->dctable[table_index]!=0)
 	{
-		*mem=(void*)(sp->dctable[table_index]+sizeof(uint32));
-		*len=*((uint32*)sp->dctable[table_index])-sizeof(uint32);
+		*mem=(void*)(sp->dctable[table_index]+sizeof(uint32_t));
+		*len= *((uint32_t*)sp->dctable[table_index]) - sizeof(uint32_t);
 	}
 	sp->out_state++;
 }
 
 static void
-OJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)
+OJPEGWriteStreamAcTable(TIFF* tif, uint8_t table_index, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	if (sp->actable[table_index]!=0)
 	{
-		*mem=(void*)(sp->actable[table_index]+sizeof(uint32));
-		*len=*((uint32*)sp->actable[table_index])-sizeof(uint32);
+		*mem=(void*)(sp->actable[table_index]+sizeof(uint32_t));
+		*len= *((uint32_t*)sp->actable[table_index]) - sizeof(uint32_t);
 	}
 	sp->out_state++;
 }
 
 static void
-OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len)
+OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	assert(OJPEG_BUFFER>=6);
@@ -2328,10 +2321,10 @@ OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len)
 }
 
 static void
-OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len)
+OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
+	uint8_t m;
 	assert(OJPEG_BUFFER>=2+8+sp->samples_per_pixel_per_plane*3);
 	assert(255>=8+sp->samples_per_pixel_per_plane*3);
 	sp->out_buffer[0]=255;
@@ -2342,10 +2335,10 @@ OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len)
 	/* P */
 	sp->out_buffer[4]=8;
 	/* Y */
-	sp->out_buffer[5]=(uint8)(sp->sof_y>>8);
+	sp->out_buffer[5]=(uint8_t)(sp->sof_y >> 8);
 	sp->out_buffer[6]=(sp->sof_y&255);
 	/* X */
-	sp->out_buffer[7]=(uint8)(sp->sof_x>>8);
+	sp->out_buffer[7]=(uint8_t)(sp->sof_x >> 8);
 	sp->out_buffer[8]=(sp->sof_x&255);
 	/* Nf */
 	sp->out_buffer[9]=sp->samples_per_pixel_per_plane;
@@ -2364,10 +2357,10 @@ OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len)
 }
 
 static void
-OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len)
+OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
+	uint8_t m;
 	assert(OJPEG_BUFFER>=2+6+sp->samples_per_pixel_per_plane*2);
 	assert(255>=6+sp->samples_per_pixel_per_plane*2);
 	sp->out_buffer[0]=255;
@@ -2396,7 +2389,7 @@ OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len)
 }
 
 static int
-OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len)
+OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	if (sp->in_buffer_togo==0)
@@ -2429,7 +2422,7 @@ OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len)
 }
 
 static void
-OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len)
+OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	assert(OJPEG_BUFFER>=2);
@@ -2444,7 +2437,7 @@ OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len)
 }
 
 static void
-OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len)
+OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32_t* len)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	assert(OJPEG_BUFFER>=2);
@@ -2469,7 +2462,7 @@ jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)
 
 #ifndef LIBJPEG_ENCAP_EXTERNAL
 static int
-jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image)
+jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8_t require_image)
 {
 	if( SETJMP(sp->exit_jmpbuf) )
 		return 0;
@@ -2495,7 +2488,7 @@ jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)
 
 #ifndef LIBJPEG_ENCAP_EXTERNAL
 static int
-jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines)
+jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32_t max_lines)
 {
 	if( SETJMP(sp->exit_jmpbuf) )
 		return 0;
@@ -2508,7 +2501,7 @@ jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* s
 
 #ifndef LIBJPEG_ENCAP_EXTERNAL
 static int
-jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines)
+jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32_t max_lines)
 {
 	if( SETJMP(sp->exit_jmpbuf) )
 		return 0;
@@ -2557,7 +2550,7 @@ OJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo)
 	TIFF* tif=(TIFF*)cinfo->client_data;
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	void* mem=0;
-	uint32 len=0U;
+	uint32_t len=0U;
 	if (OJPEGWriteStream(tif,&mem,&len)==0)
 	{
 		TIFFErrorExt(tif->tif_clientdata,"LibJpeg","Premature end of JPEG data");
diff --git a/src/3rdparty/libtiff/libtiff/tif_open.c b/src/3rdparty/libtiff/libtiff/tif_open.c
index 3cb53d4..9724162 100644
--- a/src/3rdparty/libtiff/libtiff/tif_open.c
+++ b/src/3rdparty/libtiff/libtiff/tif_open.c
@@ -88,22 +88,23 @@ TIFFClientOpen(
 	/* The following are configuration checks. They should be redundant, but should not
 	 * compile to any actual code in an optimised release build anyway. If any of them
 	 * fail, (makefile-based or other) configuration is not correct */
-	assert(sizeof(uint8)==1);
-	assert(sizeof(int8)==1);
-	assert(sizeof(uint16)==2);
-	assert(sizeof(int16)==2);
-	assert(sizeof(uint32)==4);
-	assert(sizeof(int32)==4);
-	assert(sizeof(uint64)==8);
-	assert(sizeof(int64)==8);
+	assert(sizeof(uint8_t) == 1);
+	assert(sizeof(int8_t) == 1);
+	assert(sizeof(uint16_t) == 2);
+	assert(sizeof(int16_t) == 2);
+	assert(sizeof(uint32_t) == 4);
+	assert(sizeof(int32_t) == 4);
+	assert(sizeof(uint64_t) == 8);
+	assert(sizeof(int64_t) == 8);
 	assert(sizeof(tmsize_t)==sizeof(void*));
 	{
 		union{
-			uint8 a8[2];
-			uint16 a16;
+			uint8_t a8[2];
+			uint16_t a16;
 		} n;
 		n.a8[0]=1;
 		n.a8[1]=0;
+                (void)n;
 		#ifdef WORDS_BIGENDIAN
 		assert(n.a16==256);
 		#else
@@ -123,10 +124,10 @@ TIFFClientOpen(
 	tif->tif_name = (char *)tif + sizeof (TIFF);
 	strcpy(tif->tif_name, name);
 	tif->tif_mode = m &~ (O_CREAT|O_TRUNC);
-	tif->tif_curdir = (uint16) -1;		/* non-existent directory */
+	tif->tif_curdir = (uint16_t) -1;		/* non-existent directory */
 	tif->tif_curoff = 0;
-	tif->tif_curstrip = (uint32) -1;	/* invalid strip */
-	tif->tif_row = (uint32) -1;		/* read/write pre-increment */
+	tif->tif_curstrip = (uint32_t) -1;	/* invalid strip */
+	tif->tif_row = (uint32_t) -1;		/* read/write pre-increment */
 	tif->tif_clientdata = clientdata;
 	if (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {
 		TIFFErrorExt(clientdata, module,
@@ -165,7 +166,7 @@ TIFFClientOpen(
 	/*
 	 * Process library-specific flags in the open mode string.
 	 * The following flags may be used to control intrinsic library
-	 * behaviour that may or may not be desirable (usually for
+	 * behavior that may or may not be desirable (usually for
 	 * compatibility with some application that claims to support
 	 * TIFF but only supports some brain dead idea of what the
 	 * vendor thinks TIFF is):
@@ -206,7 +207,7 @@ TIFFClientOpen(
 	 * not do right now.
 	 *
 	 * The 'M' and 'm' flags are provided because some virtual memory
-	 * systems exhibit poor behaviour when large images are mapped.
+	 * systems exhibit poor behavior when large images are mapped.
 	 * These options permit clients to control the use of memory-mapped
 	 * files on a per-file basis.
 	 *
@@ -372,11 +373,11 @@ TIFFClientOpen(
 	    #endif
 	    ) {
 		TIFFErrorExt(tif->tif_clientdata, name,
-		    "Not a TIFF or MDI file, bad magic number %d (0x%x)",
+		    "Not a TIFF or MDI file, bad magic number %"PRIu16" (0x%"PRIx16")",
 	    #else
 	    ) {
 		TIFFErrorExt(tif->tif_clientdata, name,
-		    "Not a TIFF file, bad magic number %d (0x%x)",
+		    "Not a TIFF file, bad magic number %"PRIu16" (0x%"PRIx16")",
 	    #endif
 		    tif->tif_header.common.tiff_magic,
 		    tif->tif_header.common.tiff_magic);
@@ -396,7 +397,7 @@ TIFFClientOpen(
 	if ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&
 	    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {
 		TIFFErrorExt(tif->tif_clientdata, name,
-		    "Not a TIFF file, bad version number %d (0x%x)",
+		    "Not a TIFF file, bad version number %"PRIu16" (0x%"PRIx16")",
 		    tif->tif_header.common.tiff_version,
 		    tif->tif_header.common.tiff_version);
 		goto bad;
@@ -409,7 +410,7 @@ TIFFClientOpen(
 	}
 	else
 	{
-		if (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))
+		if (!ReadOK(tif, ((uint8_t*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig) - sizeof(TIFFHeaderClassic))))
 		{
 			TIFFErrorExt(tif->tif_clientdata, name,
 			    "Cannot read TIFF header");
@@ -423,7 +424,7 @@ TIFFClientOpen(
 		if (tif->tif_header.big.tiff_offsetsize != 8)
 		{
 			TIFFErrorExt(tif->tif_clientdata, name,
-			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",
+			    "Not a TIFF file, bad BigTIFF offsetsize %"PRIu16" (0x%"PRIx16")",
 			    tif->tif_header.big.tiff_offsetsize,
 			    tif->tif_header.big.tiff_offsetsize);
 			goto bad;
@@ -431,7 +432,7 @@ TIFFClientOpen(
 		if (tif->tif_header.big.tiff_unused != 0)
 		{
 			TIFFErrorExt(tif->tif_clientdata, name,
-			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",
+			    "Not a TIFF file, bad BigTIFF unused %"PRIu16" (0x%"PRIx16")",
 			    tif->tif_header.big.tiff_unused,
 			    tif->tif_header.big.tiff_unused);
 			goto bad;
@@ -599,7 +600,7 @@ TIFFIsTiled(TIFF* tif)
 /*
  * Return current row being read/written.
  */
-uint32
+uint32_t
 TIFFCurrentRow(TIFF* tif)
 {
 	return (tif->tif_row);
@@ -608,7 +609,7 @@ TIFFCurrentRow(TIFF* tif)
 /*
  * Return index of the current directory.
  */
-uint16
+uint16_t
 TIFFCurrentDirectory(TIFF* tif)
 {
 	return (tif->tif_curdir);
@@ -617,7 +618,7 @@ TIFFCurrentDirectory(TIFF* tif)
 /*
  * Return current strip.
  */
-uint32
+uint32_t
 TIFFCurrentStrip(TIFF* tif)
 {
 	return (tif->tif_curstrip);
@@ -626,7 +627,7 @@ TIFFCurrentStrip(TIFF* tif)
 /*
  * Return current tile.
  */
-uint32
+uint32_t
 TIFFCurrentTile(TIFF* tif)
 {
 	return (tif->tif_curtile);
diff --git a/src/3rdparty/libtiff/libtiff/tif_packbits.c b/src/3rdparty/libtiff/libtiff/tif_packbits.c
index a8f29e8..76569ad 100644
--- a/src/3rdparty/libtiff/libtiff/tif_packbits.c
+++ b/src/3rdparty/libtiff/libtiff/tif_packbits.c
@@ -32,11 +32,11 @@
 #include <stdio.h>
 
 static int
-PackBitsPreEncode(TIFF* tif, uint16 s)
+PackBitsPreEncode(TIFF* tif, uint16_t s)
 {
 	(void) s;
 
-        tif->tif_data = (uint8*)_TIFFmalloc(sizeof(tmsize_t));
+        tif->tif_data = (uint8_t*)_TIFFmalloc(sizeof(tmsize_t));
 	if (tif->tif_data == NULL)
 		return (0);
 	/*
@@ -61,12 +61,12 @@ PackBitsPostEncode(TIFF* tif)
  * Encode a run of pixels.
  */
 static int
-PackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
+PackBitsEncode(TIFF* tif, uint8_t* buf, tmsize_t cc, uint16_t s)
 {
 	unsigned char* bp = (unsigned char*) buf;
-	uint8* op;
-	uint8* ep;
-	uint8* lastliteral;
+	uint8_t* op;
+	uint8_t* ep;
+	uint8_t* lastliteral;
 	long n, slop;
 	int b;
 	enum { BASE, LITERAL, RUN, LITERAL_RUN } state;
@@ -114,17 +114,17 @@ PackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 			if (n > 1) {
 				state = RUN;
 				if (n > 128) {
-					*op++ = (uint8) -127;
-					*op++ = (uint8) b;
+					*op++ = (uint8_t) -127;
+					*op++ = (uint8_t) b;
 					n -= 128;
 					goto again;
 				}
-				*op++ = (uint8)(-(n-1));
-				*op++ = (uint8) b;
+				*op++ = (uint8_t)(-(n - 1));
+				*op++ = (uint8_t) b;
 			} else {
 				lastliteral = op;
 				*op++ = 0;
-				*op++ = (uint8) b;
+				*op++ = (uint8_t) b;
 				state = LITERAL;
 			}
 			break;
@@ -132,33 +132,33 @@ PackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 			if (n > 1) {
 				state = LITERAL_RUN;
 				if (n > 128) {
-					*op++ = (uint8) -127;
-					*op++ = (uint8) b;
+					*op++ = (uint8_t) -127;
+					*op++ = (uint8_t) b;
 					n -= 128;
 					goto again;
 				}
-				*op++ = (uint8)(-(n-1));	/* encode run */
-				*op++ = (uint8) b;
+				*op++ = (uint8_t)(-(n - 1));	/* encode run */
+				*op++ = (uint8_t) b;
 			} else {			/* extend literal */
 				if (++(*lastliteral) == 127)
 					state = BASE;
-				*op++ = (uint8) b;
+				*op++ = (uint8_t) b;
 			}
 			break;
 		case RUN:		/* last object was run */
 			if (n > 1) {
 				if (n > 128) {
-					*op++ = (uint8) -127;
-					*op++ = (uint8) b;
+					*op++ = (uint8_t) -127;
+					*op++ = (uint8_t) b;
 					n -= 128;
 					goto again;
 				}
-				*op++ = (uint8)(-(n-1));
-				*op++ = (uint8) b;
+				*op++ = (uint8_t)(-(n - 1));
+				*op++ = (uint8_t) b;
 			} else {
 				lastliteral = op;
 				*op++ = 0;
-				*op++ = (uint8) b;
+				*op++ = (uint8_t) b;
 				state = LITERAL;
 			}
 			break;
@@ -169,7 +169,7 @@ PackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 			 * case we convert literal-run-literal
 			 * to a single literal.
 			 */
-			if (n == 1 && op[-2] == (uint8) -1 &&
+			if (n == 1 && op[-2] == (uint8_t) -1 &&
 			    *lastliteral < 126) {
 				state = (((*lastliteral) += 2) == 127 ?
 				    BASE : LITERAL);
@@ -192,7 +192,7 @@ PackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
  * when it was encoded by strips.
  */
 static int
-PackBitsEncodeChunk(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+PackBitsEncodeChunk(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	tmsize_t rowsize = *(tmsize_t*)tif->tif_data;
 
@@ -211,7 +211,7 @@ PackBitsEncodeChunk(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 }
 
 static int
-PackBitsDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
+PackBitsDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "PackBitsDecode";
 	char *bp;
@@ -238,8 +238,8 @@ PackBitsDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 			if( occ < (tmsize_t)n )
 			{
 				TIFFWarningExt(tif->tif_clientdata, module,
-				    "Discarding %lu bytes to avoid buffer overrun",
-				    (unsigned long) ((tmsize_t)n - occ));
+				    "Discarding %"TIFF_SSIZE_FORMAT" bytes to avoid buffer overrun",
+				    (tmsize_t)n - occ);
 				n = (long)occ;
 			}
 			if( cc == 0 )
@@ -252,13 +252,13 @@ PackBitsDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 			b = *bp++;
 			cc--;
 			while (n-- > 0)
-				*op++ = (uint8) b;
+				*op++ = (uint8_t) b;
 		} else {		/* copy next n+1 bytes literally */
 			if (occ < (tmsize_t)(n + 1))
 			{
 				TIFFWarningExt(tif->tif_clientdata, module,
-				    "Discarding %lu bytes to avoid buffer overrun",
-				    (unsigned long) ((tmsize_t)n - occ + 1));
+				    "Discarding %"TIFF_SSIZE_FORMAT" bytes to avoid buffer overrun",
+				    (tmsize_t)n - occ + 1);
 				n = (long)occ - 1;
 			}
 			if (cc < (tmsize_t) (n+1)) 
@@ -272,12 +272,12 @@ PackBitsDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 			bp += n; cc -= n;
 		}
 	}
-	tif->tif_rawcp = (uint8*) bp;
+	tif->tif_rawcp = (uint8_t*) bp;
 	tif->tif_rawcc = cc;
 	if (occ > 0) {
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "Not enough data for scanline %lu",
-		    (unsigned long) tif->tif_row);
+		    "Not enough data for scanline %"PRIu32,
+		    tif->tif_row);
 		return (0);
 	}
 	return (1);
diff --git a/src/3rdparty/libtiff/libtiff/tif_pixarlog.c b/src/3rdparty/libtiff/libtiff/tif_pixarlog.c
index 6264090..87c6709 100644
--- a/src/3rdparty/libtiff/libtiff/tif_pixarlog.c
+++ b/src/3rdparty/libtiff/libtiff/tif_pixarlog.c
@@ -109,8 +109,8 @@ static float  LogK1, LogK2;
 #define REPEAT(n, op)   { int i; i=n; do { i--; op; } while (i>0); }
 
 static void
-horizontalAccumulateF(uint16 *wp, int n, int stride, float *op,
-	float *ToLinearF)
+horizontalAccumulateF(uint16_t *wp, int n, int stride, float *op,
+                      float *ToLinearF)
 {
     register unsigned int  cr, cg, cb, ca, mask;
     register float  t0, t1, t2, t3;
@@ -172,14 +172,14 @@ horizontalAccumulateF(uint16 *wp, int n, int stride, float *op,
 }
 
 static void
-horizontalAccumulate12(uint16 *wp, int n, int stride, int16 *op,
-	float *ToLinearF)
+horizontalAccumulate12(uint16_t *wp, int n, int stride, int16_t *op,
+                       float *ToLinearF)
 {
     register unsigned int  cr, cg, cb, ca, mask;
     register float  t0, t1, t2, t3;
 
 #define SCALE12 2048.0F
-#define CLAMP12(t) (((t) < 3071) ? (uint16) (t) : 3071)
+#define CLAMP12(t) (((t) < 3071) ? (uint16_t) (t) : 3071)
 
     if (n >= stride) {
 	mask = CODE_MASK;
@@ -240,8 +240,8 @@ horizontalAccumulate12(uint16 *wp, int n, int stride, int16 *op,
 }
 
 static void
-horizontalAccumulate16(uint16 *wp, int n, int stride, uint16 *op,
-	uint16 *ToLinear16)
+horizontalAccumulate16(uint16_t *wp, int n, int stride, uint16_t *op,
+                       uint16_t *ToLinear16)
 {
     register unsigned int  cr, cg, cb, ca, mask;
 
@@ -292,7 +292,7 @@ horizontalAccumulate16(uint16 *wp, int n, int stride, uint16 *op,
  * differencing undone.
  */
 static void
-horizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op)
+horizontalAccumulate11(uint16_t *wp, int n, int stride, uint16_t *op)
 {
     register unsigned int cr, cg, cb, ca, mask;
 
@@ -306,9 +306,9 @@ horizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op)
 		wp += 3;
 		op += 3;
 		n -= 3;
-		op[0] = (uint16)((cr += wp[0]) & mask);
-		op[1] = (uint16)((cg += wp[1]) & mask);
-		op[2] = (uint16)((cb += wp[2]) & mask);
+		op[0] = (uint16_t)((cr += wp[0]) & mask);
+		op[1] = (uint16_t)((cg += wp[1]) & mask);
+		op[2] = (uint16_t)((cb += wp[2]) & mask);
 	    }
 	} else if (stride == 4) {
 	    op[0] = wp[0];  op[1] = wp[1];
@@ -319,10 +319,10 @@ horizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op)
 		wp += 4;
 		op += 4;
 		n -= 4;
-		op[0] = (uint16)((cr += wp[0]) & mask);
-		op[1] = (uint16)((cg += wp[1]) & mask);
-		op[2] = (uint16)((cb += wp[2]) & mask);
-		op[3] = (uint16)((ca += wp[3]) & mask);
+		op[0] = (uint16_t)((cr += wp[0]) & mask);
+		op[1] = (uint16_t)((cg += wp[1]) & mask);
+		op[2] = (uint16_t)((cb += wp[2]) & mask);
+		op[3] = (uint16_t)((ca += wp[3]) & mask);
 	    } 
 	} else {
 	    REPEAT(stride, *op = *wp&mask; wp++; op++)
@@ -337,8 +337,8 @@ horizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op)
 }
 
 static void
-horizontalAccumulate8(uint16 *wp, int n, int stride, unsigned char *op,
-	unsigned char *ToLinear8)
+horizontalAccumulate8(uint16_t *wp, int n, int stride, unsigned char *op,
+                      unsigned char *ToLinear8)
 {
     register unsigned int  cr, cg, cb, ca, mask;
 
@@ -386,8 +386,8 @@ horizontalAccumulate8(uint16 *wp, int n, int stride, unsigned char *op,
 
 
 static void
-horizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op,
-	unsigned char *ToLinear8)
+horizontalAccumulate8abgr(uint16_t *wp, int n, int stride, unsigned char *op,
+                          unsigned char *ToLinear8)
 {
     register unsigned int  cr, cg, cb, ca, mask;
     register unsigned char  t0, t1, t2, t3;
@@ -458,8 +458,8 @@ typedef	struct {
 	TIFFPredictorState	predict;
 	z_stream		stream;
 	tmsize_t		tbuf_size; /* only set/used on reading for now */
-	uint16			*tbuf; 
-	uint16			stride;
+	uint16_t			*tbuf;
+	uint16_t			stride;
 	int			state;
 	int			user_datafmt;
 	int			quality;
@@ -469,11 +469,11 @@ typedef	struct {
 	TIFFVSetMethod		vsetparent;	/* super-class method */
 
 	float *ToLinearF;
-	uint16 *ToLinear16;
+	uint16_t *ToLinear16;
 	unsigned char *ToLinear8;
-	uint16  *FromLT2;
-	uint16  *From14; /* Really for 16-bit data, but we shift down 2 */
-	uint16  *From8;
+	uint16_t  *FromLT2;
+	uint16_t  *From14; /* Really for 16-bit data, but we shift down 2 */
+	uint16_t  *From8;
 	
 } PixarLogState;
 
@@ -496,11 +496,11 @@ PixarLogMakeTables(PixarLogState *sp)
     int  i, j;
     double  b, c, linstep, v;
     float *ToLinearF;
-    uint16 *ToLinear16;
+    uint16_t *ToLinear16;
     unsigned char *ToLinear8;
-    uint16  *FromLT2;
-    uint16  *From14; /* Really for 16-bit data, but we shift down 2 */
-    uint16  *From8;
+    uint16_t  *FromLT2;
+    uint16_t  *From14; /* Really for 16-bit data, but we shift down 2 */
+    uint16_t  *From8;
 
     c = log(RATIO);	
     nlin = (int)(1./c);	/* nlin must be an integer */
@@ -511,11 +511,11 @@ PixarLogMakeTables(PixarLogState *sp)
     LogK1 = (float)(1./c);	/* if (v >= 2)  token = k1*log(v*k2) */
     LogK2 = (float)(1./b);
     lt2size = (int)(2./linstep) + 1;
-    FromLT2 = (uint16 *)_TIFFmalloc(lt2size*sizeof(uint16));
-    From14 = (uint16 *)_TIFFmalloc(16384*sizeof(uint16));
-    From8 = (uint16 *)_TIFFmalloc(256*sizeof(uint16));
+    FromLT2 = (uint16_t *)_TIFFmalloc(lt2size * sizeof(uint16_t));
+    From14 = (uint16_t *)_TIFFmalloc(16384 * sizeof(uint16_t));
+    From8 = (uint16_t *)_TIFFmalloc(256 * sizeof(uint16_t));
     ToLinearF = (float *)_TIFFmalloc(TSIZEP1 * sizeof(float));
-    ToLinear16 = (uint16 *)_TIFFmalloc(TSIZEP1 * sizeof(uint16));
+    ToLinear16 = (uint16_t *)_TIFFmalloc(TSIZEP1 * sizeof(uint16_t));
     ToLinear8 = (unsigned char *)_TIFFmalloc(TSIZEP1 * sizeof(unsigned char));
     if (FromLT2 == NULL || From14  == NULL || From8   == NULL ||
 	 ToLinearF == NULL || ToLinear16 == NULL || ToLinear8 == NULL) {
@@ -548,7 +548,7 @@ PixarLogMakeTables(PixarLogState *sp)
 
     for (i = 0; i < TSIZEP1; i++)  {
 	v = ToLinearF[i]*65535.0 + 0.5;
-	ToLinear16[i] = (v > 65535.0) ? 65535 : (uint16)v;
+	ToLinear16[i] = (v > 65535.0) ? 65535 : (uint16_t)v;
 	v = ToLinearF[i]*255.0  + 0.5;
 	ToLinear8[i]  = (v > 255.0) ? 255 : (unsigned char)v;
     }
@@ -557,7 +557,7 @@ PixarLogMakeTables(PixarLogState *sp)
     for (i = 0; i < lt2size; i++)  {
 	if ((i*linstep)*(i*linstep) > ToLinearF[j]*ToLinearF[j+1])
 	    j++;
-	FromLT2[i] = (uint16)j;
+	FromLT2[i] = (uint16_t)j;
     }
 
     /*
@@ -569,14 +569,14 @@ PixarLogMakeTables(PixarLogState *sp)
     for (i = 0; i < 16384; i++)  {
 	while ((i/16383.)*(i/16383.) > ToLinearF[j]*ToLinearF[j+1])
 	    j++;
-	From14[i] = (uint16)j;
+	From14[i] = (uint16_t)j;
     }
 
     j = 0;
     for (i = 0; i < 256; i++)  {
 	while ((i/255.)*(i/255.) > ToLinearF[j]*ToLinearF[j+1])
 	    j++;
-	From8[i] = (uint16)j;
+	From8[i] = (uint16_t)j;
     }
 
     Fltsize = (float)(lt2size/2);
@@ -594,8 +594,8 @@ PixarLogMakeTables(PixarLogState *sp)
 #define DecoderState(tif)	((PixarLogState*) (tif)->tif_data)
 #define EncoderState(tif)	((PixarLogState*) (tif)->tif_data)
 
-static int PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s);
-static int PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s);
+static int PixarLogEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s);
+static int PixarLogDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s);
 
 #define PIXARLOGDATAFMT_UNKNOWN	-1
 
@@ -667,7 +667,7 @@ PixarLogSetupDecode(TIFF* tif)
 	TIFFDirectory *td = &tif->tif_dir;
 	PixarLogState* sp = DecoderState(tif);
 	tmsize_t tbuf_size;
-        uint32 strip_height;
+        uint32_t strip_height;
 
 	assert(sp != NULL);
 
@@ -690,12 +690,12 @@ PixarLogSetupDecode(TIFF* tif)
 	sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?
 	    td->td_samplesperpixel : 1);
 	tbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),
-				      strip_height), sizeof(uint16));
+				      strip_height), sizeof(uint16_t));
 	/* add one more stride in case input ends mid-stride */
-	tbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride);
+	tbuf_size = add_ms(tbuf_size, sizeof(uint16_t) * sp->stride);
 	if (tbuf_size == 0)
 		return (0);   /* TODO: this is an error return without error report through TIFFErrorExt */
-	sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);
+	sp->tbuf = (uint16_t *) _TIFFmalloc(tbuf_size);
 	if (sp->tbuf == NULL)
 		return (0);
 	sp->tbuf_size = tbuf_size;
@@ -706,7 +706,7 @@ PixarLogSetupDecode(TIFF* tif)
                 sp->tbuf = NULL;
                 sp->tbuf_size = 0;
 		TIFFErrorExt(tif->tif_clientdata, module,
-			"PixarLog compression can't handle bits depth/data format combination (depth: %d)", 
+			"PixarLog compression can't handle bits depth/data format combination (depth: %"PRIu16")",
 			td->td_bitspersample);
 		return (0);
 	}
@@ -727,7 +727,7 @@ PixarLogSetupDecode(TIFF* tif)
  * Setup state for decoding a strip.
  */
 static int
-PixarLogPreDecode(TIFF* tif, uint16 s)
+PixarLogPreDecode(TIFF* tif, uint16_t s)
 {
 	static const char module[] = "PixarLogPreDecode";
 	PixarLogState* sp = DecoderState(tif);
@@ -749,7 +749,7 @@ PixarLogPreDecode(TIFF* tif, uint16 s)
 }
 
 static int
-PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
+PixarLogDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "PixarLogDecode";
 	TIFFDirectory *td = &tif->tif_dir;
@@ -757,7 +757,7 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	tmsize_t i;
 	tmsize_t nsamples;
 	int llen;
-	uint16 *up;
+	uint16_t *up;
 
 	switch (sp->user_datafmt) {
 	case PIXARLOGDATAFMT_FLOAT:
@@ -766,7 +766,7 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	case PIXARLOGDATAFMT_16BIT:
 	case PIXARLOGDATAFMT_12BITPICIO:
 	case PIXARLOGDATAFMT_11BITLOG:
-		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
+		nsamples = occ / sizeof(uint16_t); /* XXX uint16_t == 16 bits */
 		break;
 	case PIXARLOGDATAFMT_8BIT:
 	case PIXARLOGDATAFMT_8BITABGR:
@@ -774,7 +774,7 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 		break;
 	default:
 		TIFFErrorExt(tif->tif_clientdata, module,
-			"%d bit input not supported in PixarLog",
+			"%"PRIu16" bit input not supported in PixarLog",
 			td->td_bitspersample);
 		return 0;
 	}
@@ -792,8 +792,8 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	    we need to simplify this code to reflect a ZLib that is likely updated
 	    to deal with 8byte memory sizes, though this code will respond
 	    appropriately even before we simplify it */
-	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
-	if (sp->stream.avail_out != nsamples * sizeof(uint16))
+	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16_t));
+	if (sp->stream.avail_out != nsamples * sizeof(uint16_t))
 	{
 		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");
 		return (0);
@@ -811,8 +811,8 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 		}
 		if (state == Z_DATA_ERROR) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Decoding error at scanline %lu, %s",
-			    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : "(null)");
+			    "Decoding error at scanline %"PRIu32", %s",
+			    tif->tif_row, sp->stream.msg ? sp->stream.msg : "(null)");
 			return (0);
 		}
 		if (state != Z_OK) {
@@ -825,8 +825,8 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	/* hopefully, we got all the bytes we needed */
 	if (sp->stream.avail_out != 0) {
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",
-		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
+		    "Not enough data at scanline %"PRIu32" (short %u bytes)",
+		    tif->tif_row, sp->stream.avail_out);
 		return (0);
 	}
 
@@ -845,8 +845,8 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	 */
 	if (nsamples % llen) { 
 		TIFFWarningExt(tif->tif_clientdata, module,
-			"stride %lu is not a multiple of sample count, "
-			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples);
+			"stride %d is not a multiple of sample count, "
+            "%"TIFF_SSIZE_FORMAT", data truncated.", llen, nsamples);
 		nsamples -= nsamples % llen;
 	}
 
@@ -859,18 +859,18 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 			break;
 		case PIXARLOGDATAFMT_16BIT:
 			horizontalAccumulate16(up, llen, sp->stride,
-					(uint16 *)op, sp->ToLinear16);
-			op += llen * sizeof(uint16);
+                                   (uint16_t *)op, sp->ToLinear16);
+			op += llen * sizeof(uint16_t);
 			break;
 		case PIXARLOGDATAFMT_12BITPICIO:
 			horizontalAccumulate12(up, llen, sp->stride,
-					(int16 *)op, sp->ToLinearF);
-			op += llen * sizeof(int16);
+                                   (int16_t *)op, sp->ToLinearF);
+			op += llen * sizeof(int16_t);
 			break;
 		case PIXARLOGDATAFMT_11BITLOG:
 			horizontalAccumulate11(up, llen, sp->stride,
-					(uint16 *)op);
-			op += llen * sizeof(uint16);
+					(uint16_t *)op);
+			op += llen * sizeof(uint16_t);
 			break;
 		case PIXARLOGDATAFMT_8BIT:
 			horizontalAccumulate8(up, llen, sp->stride,
@@ -884,7 +884,7 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 			break;
 		default:
 			TIFFErrorExt(tif->tif_clientdata, module,
-				  "Unsupported bits/sample: %d",
+				  "Unsupported bits/sample: %"PRIu16,
 				  td->td_bitspersample);
 			return (0);
 		}
@@ -908,16 +908,16 @@ PixarLogSetupEncode(TIFF* tif)
 	sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?
 	    td->td_samplesperpixel : 1);
 	tbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),
-				      td->td_rowsperstrip), sizeof(uint16));
+				      td->td_rowsperstrip), sizeof(uint16_t));
 	if (tbuf_size == 0)
 		return (0);  /* TODO: this is an error return without error report through TIFFErrorExt */
-	sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);
+	sp->tbuf = (uint16_t *) _TIFFmalloc(tbuf_size);
 	if (sp->tbuf == NULL)
 		return (0);
 	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)
 		sp->user_datafmt = PixarLogGuessDataFmt(td);
 	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {
-		TIFFErrorExt(tif->tif_clientdata, module, "PixarLog compression can't handle %d bit linear encodings", td->td_bitspersample);
+		TIFFErrorExt(tif->tif_clientdata, module, "PixarLog compression can't handle %"PRIu16" bit linear encodings", td->td_bitspersample);
 		return (0);
 	}
 
@@ -934,7 +934,7 @@ PixarLogSetupEncode(TIFF* tif)
  * Reset encoding state at the start of a strip.
  */
 static int
-PixarLogPreEncode(TIFF* tif, uint16 s)
+PixarLogPreEncode(TIFF* tif, uint16_t s)
 {
 	static const char module[] = "PixarLogPreEncode";
 	PixarLogState *sp = EncoderState(tif);
@@ -956,9 +956,9 @@ PixarLogPreEncode(TIFF* tif, uint16 s)
 }
 
 static void
-horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)
+horizontalDifferenceF(float *ip, int n, int stride, uint16_t *wp, uint16_t *FromLT2)
 {
-    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;
+    int32_t r1, g1, b1, a1, r2, g2, b2, a2, mask;
     float fltsize = Fltsize;
 
 #define  CLAMP(v) ( (v<(float)0.)   ? 0				\
@@ -969,39 +969,39 @@ horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)
     mask = CODE_MASK;
     if (n >= stride) {
 	if (stride == 3) {
-	    r2 = wp[0] = (uint16) CLAMP(ip[0]);
-	    g2 = wp[1] = (uint16) CLAMP(ip[1]);
-	    b2 = wp[2] = (uint16) CLAMP(ip[2]);
+	    r2 = wp[0] = (uint16_t) CLAMP(ip[0]);
+	    g2 = wp[1] = (uint16_t) CLAMP(ip[1]);
+	    b2 = wp[2] = (uint16_t) CLAMP(ip[2]);
 	    n -= 3;
 	    while (n > 0) {
 		n -= 3;
 		wp += 3;
 		ip += 3;
-		r1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
-		g1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
-		b1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
+		r1 = (int32_t) CLAMP(ip[0]); wp[0] = (uint16_t)((r1 - r2) & mask); r2 = r1;
+		g1 = (int32_t) CLAMP(ip[1]); wp[1] = (uint16_t)((g1 - g2) & mask); g2 = g1;
+		b1 = (int32_t) CLAMP(ip[2]); wp[2] = (uint16_t)((b1 - b2) & mask); b2 = b1;
 	    }
 	} else if (stride == 4) {
-	    r2 = wp[0] = (uint16) CLAMP(ip[0]);
-	    g2 = wp[1] = (uint16) CLAMP(ip[1]);
-	    b2 = wp[2] = (uint16) CLAMP(ip[2]);
-	    a2 = wp[3] = (uint16) CLAMP(ip[3]);
+	    r2 = wp[0] = (uint16_t) CLAMP(ip[0]);
+	    g2 = wp[1] = (uint16_t) CLAMP(ip[1]);
+	    b2 = wp[2] = (uint16_t) CLAMP(ip[2]);
+	    a2 = wp[3] = (uint16_t) CLAMP(ip[3]);
 	    n -= 4;
 	    while (n > 0) {
 		n -= 4;
 		wp += 4;
 		ip += 4;
-		r1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
-		g1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
-		b1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
-		a1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;
+		r1 = (int32_t) CLAMP(ip[0]); wp[0] = (uint16_t)((r1 - r2) & mask); r2 = r1;
+		g1 = (int32_t) CLAMP(ip[1]); wp[1] = (uint16_t)((g1 - g2) & mask); g2 = g1;
+		b1 = (int32_t) CLAMP(ip[2]); wp[2] = (uint16_t)((b1 - b2) & mask); b2 = b1;
+		a1 = (int32_t) CLAMP(ip[3]); wp[3] = (uint16_t)((a1 - a2) & mask); a2 = a1;
 	    }
 	} else {
-        REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)
+        REPEAT(stride, wp[0] = (uint16_t) CLAMP(ip[0]); wp++; ip++)
         n -= stride;
         while (n > 0) {
             REPEAT(stride,
-                wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);
+                wp[0] = (uint16_t)(((int32_t)CLAMP(ip[0]) - (int32_t)CLAMP(ip[-stride])) & mask);
                 wp++; ip++)
             n -= stride;
         }
@@ -1010,8 +1010,8 @@ horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)
 }
 
 static void
-horizontalDifference16(unsigned short *ip, int n, int stride, 
-	unsigned short *wp, uint16 *From14)
+horizontalDifference16(unsigned short *ip, int n, int stride,
+                       unsigned short *wp, uint16_t *From14)
 {
     register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;
 
@@ -1029,9 +1029,9 @@ horizontalDifference16(unsigned short *ip, int n, int stride,
 		n -= 3;
 		wp += 3;
 		ip += 3;
-		r1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
-		g1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
-		b1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
+		r1 = CLAMP(ip[0]); wp[0] = (uint16_t)((r1 - r2) & mask); r2 = r1;
+		g1 = CLAMP(ip[1]); wp[1] = (uint16_t)((g1 - g2) & mask); g2 = g1;
+		b1 = CLAMP(ip[2]); wp[2] = (uint16_t)((b1 - b2) & mask); b2 = b1;
 	    }
 	} else if (stride == 4) {
 	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
@@ -1041,17 +1041,17 @@ horizontalDifference16(unsigned short *ip, int n, int stride,
 		n -= 4;
 		wp += 4;
 		ip += 4;
-		r1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
-		g1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
-		b1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
-		a1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;
+		r1 = CLAMP(ip[0]); wp[0] = (uint16_t)((r1 - r2) & mask); r2 = r1;
+		g1 = CLAMP(ip[1]); wp[1] = (uint16_t)((g1 - g2) & mask); g2 = g1;
+		b1 = CLAMP(ip[2]); wp[2] = (uint16_t)((b1 - b2) & mask); b2 = b1;
+		a1 = CLAMP(ip[3]); wp[3] = (uint16_t)((a1 - a2) & mask); a2 = a1;
 	    }
 	} else {
         REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)
 	    n -= stride;
 	    while (n > 0) {
             REPEAT(stride,
-                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);
+                wp[0] = (uint16_t)((CLAMP(ip[0]) - CLAMP(ip[-stride])) & mask);
                 wp++; ip++)
             n -= stride;
         }
@@ -1061,8 +1061,8 @@ horizontalDifference16(unsigned short *ip, int n, int stride,
 
 
 static void
-horizontalDifference8(unsigned char *ip, int n, int stride, 
-	unsigned short *wp, uint16 *From8)
+horizontalDifference8(unsigned char *ip, int n, int stride,
+                      unsigned short *wp, uint16_t *From8)
 {
     register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;
 
@@ -1077,9 +1077,9 @@ horizontalDifference8(unsigned char *ip, int n, int stride,
 	    n -= 3;
 	    while (n > 0) {
 		n -= 3;
-		r1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;
-		g1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;
-		b1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;
+		r1 = CLAMP(ip[3]); wp[3] = (uint16_t)((r1 - r2) & mask); r2 = r1;
+		g1 = CLAMP(ip[4]); wp[4] = (uint16_t)((g1 - g2) & mask); g2 = g1;
+		b1 = CLAMP(ip[5]); wp[5] = (uint16_t)((b1 - b2) & mask); b2 = b1;
 		wp += 3;
 		ip += 3;
 	    }
@@ -1089,10 +1089,10 @@ horizontalDifference8(unsigned char *ip, int n, int stride,
 	    n -= 4;
 	    while (n > 0) {
 		n -= 4;
-		r1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;
-		g1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;
-		b1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;
-		a1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;
+		r1 = CLAMP(ip[4]); wp[4] = (uint16_t)((r1 - r2) & mask); r2 = r1;
+		g1 = CLAMP(ip[5]); wp[5] = (uint16_t)((g1 - g2) & mask); g2 = g1;
+		b1 = CLAMP(ip[6]); wp[6] = (uint16_t)((b1 - b2) & mask); b2 = b1;
+		a1 = CLAMP(ip[7]); wp[7] = (uint16_t)((a1 - a2) & mask); a2 = a1;
 		wp += 4;
 		ip += 4;
 	    }
@@ -1101,7 +1101,7 @@ horizontalDifference8(unsigned char *ip, int n, int stride,
         n -= stride;
         while (n > 0) {
             REPEAT(stride,
-                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);
+                wp[0] = (uint16_t)((CLAMP(ip[0]) - CLAMP(ip[-stride])) & mask);
                 wp++; ip++)
             n -= stride;
         }
@@ -1113,7 +1113,7 @@ horizontalDifference8(unsigned char *ip, int n, int stride,
  * Encode a chunk of pixels.
  */
 static int
-PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+PixarLogEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "PixarLogEncode";
 	TIFFDirectory *td = &tif->tif_dir;
@@ -1132,7 +1132,7 @@ PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 	case PIXARLOGDATAFMT_16BIT:
 	case PIXARLOGDATAFMT_12BITPICIO:
 	case PIXARLOGDATAFMT_11BITLOG:
-		n = cc / sizeof(uint16);	/* XXX uint16 == 16 bits */
+		n = cc / sizeof(uint16_t);	/* XXX uint16_t == 16 bits */
 		break;
 	case PIXARLOGDATAFMT_8BIT:
 	case PIXARLOGDATAFMT_8BITABGR:
@@ -1140,13 +1140,13 @@ PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 		break;
 	default:
 		TIFFErrorExt(tif->tif_clientdata, module,
-			"%d bit input not supported in PixarLog",
+			"%"PRIu16" bit input not supported in PixarLog",
 			td->td_bitspersample);
 		return 0;
 	}
 
 	llen = sp->stride * td->td_imagewidth;
-    /* Check against the number of elements (of size uint16) of sp->tbuf */
+    /* Check against the number of elements (of size uint16_t) of sp->tbuf */
     if( n > ((tmsize_t)td->td_rowsperstrip * llen) )
     {
         TIFFErrorExt(tif->tif_clientdata, module,
@@ -1162,9 +1162,9 @@ PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 			bp += llen * sizeof(float);
 			break;
 		case PIXARLOGDATAFMT_16BIT:
-			horizontalDifference16((uint16 *)bp, llen, 
-				sp->stride, up, sp->From14);
-			bp += llen * sizeof(uint16);
+			horizontalDifference16((uint16_t *)bp, llen,
+                                   sp->stride, up, sp->From14);
+			bp += llen * sizeof(uint16_t);
 			break;
 		case PIXARLOGDATAFMT_8BIT:
 			horizontalDifference8((unsigned char *)bp, llen, 
@@ -1173,7 +1173,7 @@ PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 			break;
 		default:
 			TIFFErrorExt(tif->tif_clientdata, module,
-				"%d bit input not supported in PixarLog",
+				"%"PRIu16" bit input not supported in PixarLog",
 				td->td_bitspersample);
 			return 0;
 		}
@@ -1184,8 +1184,8 @@ PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 	    we need to simplify this code to reflect a ZLib that is likely updated
 	    to deal with 8byte memory sizes, though this code will respond
 	    appropriately even before we simplify it */
-	sp->stream.avail_in = (uInt) (n * sizeof(uint16));
-	if ((sp->stream.avail_in / sizeof(uint16)) != (uInt) n)
+	sp->stream.avail_in = (uInt) (n * sizeof(uint16_t));
+	if ((sp->stream.avail_in / sizeof(uint16_t)) != (uInt) n)
 	{
 		TIFFErrorExt(tif->tif_clientdata, module,
 			     "ZLib cannot deal with buffers this size");
@@ -1200,7 +1200,8 @@ PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 		}
 		if (sp->stream.avail_out == 0) {
 			tif->tif_rawcc = tif->tif_rawdatasize;
-			TIFFFlushData1(tif);
+			if (!TIFFFlushData1(tif))
+				return 0;
 			sp->stream.next_out = tif->tif_rawdata;
 			sp->stream.avail_out = (uInt) tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in PixarLogPreEncode */
 		}
@@ -1230,7 +1231,8 @@ PixarLogPostEncode(TIFF* tif)
 		    if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) {
 			    tif->tif_rawcc =
 				tif->tif_rawdatasize - sp->stream.avail_out;
-			    TIFFFlushData1(tif);
+			    if (!TIFFFlushData1(tif))
+                                return 0;
 			    sp->stream.next_out = tif->tif_rawdata;
 			    sp->stream.avail_out = (uInt) tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in PixarLogPreEncode */
 		    }
@@ -1307,7 +1309,7 @@ PixarLogCleanup(TIFF* tif)
 }
 
 static int
-PixarLogVSetField(TIFF* tif, uint32 tag, va_list ap)
+PixarLogVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
     static const char module[] = "PixarLogVSetField";
     PixarLogState *sp = (PixarLogState *)tif->tif_data;
@@ -1369,7 +1371,7 @@ PixarLogVSetField(TIFF* tif, uint32 tag, va_list ap)
 }
 
 static int
-PixarLogVGetField(TIFF* tif, uint32 tag, va_list ap)
+PixarLogVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
     PixarLogState *sp = (PixarLogState *)tif->tif_data;
 
@@ -1398,6 +1400,7 @@ TIFFInitPixarLog(TIFF* tif, int scheme)
 
 	PixarLogState* sp;
 
+        (void)scheme;
 	assert(scheme == COMPRESSION_PIXARLOG);
 
 	/*
@@ -1413,7 +1416,7 @@ TIFFInitPixarLog(TIFF* tif, int scheme)
 	/*
 	 * Allocate state block so tag methods have storage to record values.
 	 */
-	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (PixarLogState));
+	tif->tif_data = (uint8_t*) _TIFFmalloc(sizeof (PixarLogState));
 	if (tif->tif_data == NULL)
 		goto bad;
 	sp = (PixarLogState*) tif->tif_data;
diff --git a/src/3rdparty/libtiff/libtiff/tif_predict.c b/src/3rdparty/libtiff/libtiff/tif_predict.c
index b775663..4aa4af6 100644
--- a/src/3rdparty/libtiff/libtiff/tif_predict.c
+++ b/src/3rdparty/libtiff/libtiff/tif_predict.c
@@ -32,22 +32,22 @@
 
 #define	PredictorState(tif)	((TIFFPredictorState*) (tif)->tif_data)
 
-static int horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc);
-static int PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s);
-static int PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s);
-static int PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s);
-static int PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s);
+static int horAcc8(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int horAcc16(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int horAcc32(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int swabHorAcc16(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int swabHorAcc32(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int horDiff8(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int horDiff16(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int horDiff32(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int swabHorDiff16(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int swabHorDiff32(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int fpAcc(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int fpDiff(TIFF* tif, uint8_t* cp0, tmsize_t cc);
+static int PredictorDecodeRow(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s);
+static int PredictorDecodeTile(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s);
+static int PredictorEncodeRow(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s);
+static int PredictorEncodeTile(TIFF* tif, uint8_t* bp0, tmsize_t cc0, uint16_t s);
 
 static int
 PredictorSetup(TIFF* tif)
@@ -66,7 +66,7 @@ PredictorSetup(TIFF* tif)
 			    && td->td_bitspersample != 16
 			    && td->td_bitspersample != 32) {
 				TIFFErrorExt(tif->tif_clientdata, module,
-				    "Horizontal differencing \"Predictor\" not supported with %d-bit samples",
+				    "Horizontal differencing \"Predictor\" not supported with %"PRIu16"-bit samples",
 				    td->td_bitspersample);
 				return 0;
 			}
@@ -74,7 +74,7 @@ PredictorSetup(TIFF* tif)
 		case PREDICTOR_FLOATINGPOINT:
 			if (td->td_sampleformat != SAMPLEFORMAT_IEEEFP) {
 				TIFFErrorExt(tif->tif_clientdata, module,
-				    "Floating point \"Predictor\" not supported with %d data format",
+				    "Floating point \"Predictor\" not supported with %"PRIu16" data format",
 				    td->td_sampleformat);
 				return 0;
 			}
@@ -83,7 +83,7 @@ PredictorSetup(TIFF* tif)
                             && td->td_bitspersample != 32
                             && td->td_bitspersample != 64) { /* Should 64 be allowed? */
                                 TIFFErrorExt(tif->tif_clientdata, module,
-                                             "Floating point \"Predictor\" not supported with %d-bit samples",
+                                             "Floating point \"Predictor\" not supported with %"PRIu16"-bit samples",
                                              td->td_bitspersample);
 				return 0;
                             }
@@ -116,7 +116,7 @@ PredictorSetupDecode(TIFF* tif)
 	TIFFDirectory* td = &tif->tif_dir;
 
 	/* Note: when PredictorSetup() fails, the effets of setupdecode() */
-	/* will not be "cancelled" so setupdecode() might be robust to */
+	/* will not be "canceled" so setupdecode() might be robust to */
 	/* be called several times. */
 	if (!(*sp->setupdecode)(tif) || !PredictorSetup(tif))
 		return 0;
@@ -270,14 +270,14 @@ PredictorSetupEncode(TIFF* tif)
     }
 
 /* Remarks related to C standard compliance in all below functions : */
-/* - to avoid any undefined behaviour, we only operate on unsigned types */
-/*   since the behaviour of "overflows" is defined (wrap over) */
+/* - to avoid any undefined behavior, we only operate on unsigned types */
+/*   since the behavior of "overflows" is defined (wrap over) */
 /* - when storing into the byte stream, we explicitly mask with 0xff so */
 /*   as to make icc -check=conversions happy (not necessary by the standard) */
 
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
 static int
-horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)
+horAcc8(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
 	tmsize_t stride = PredictorState(tif)->stride;
 
@@ -334,9 +334,9 @@ horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)
 }
 
 static int
-swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)
+swabHorAcc16(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
-	uint16* wp = (uint16*) cp0;
+	uint16_t* wp = (uint16_t*) cp0;
 	tmsize_t wc = cc / 2;
 
         TIFFSwabArrayOfShort(wp, wc);
@@ -345,10 +345,10 @@ swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)
 
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
 static int
-horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)
+horAcc16(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
 	tmsize_t stride = PredictorState(tif)->stride;
-	uint16* wp = (uint16*) cp0;
+	uint16_t* wp = (uint16_t*) cp0;
 	tmsize_t wc = cc / 2;
 
     if((cc%(2*stride))!=0)
@@ -361,7 +361,7 @@ horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)
 	if (wc > stride) {
 		wc -= stride;
 		do {
-			REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)
+			REPEAT4(stride, wp[stride] = (uint16_t)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)
 			wc -= stride;
 		} while (wc > 0);
 	}
@@ -369,9 +369,9 @@ horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)
 }
 
 static int
-swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)
+swabHorAcc32(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
-	uint32* wp = (uint32*) cp0;
+	uint32_t* wp = (uint32_t*) cp0;
 	tmsize_t wc = cc / 4;
 
         TIFFSwabArrayOfLong(wp, wc);
@@ -380,10 +380,10 @@ swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)
 
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
 static int
-horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)
+horAcc32(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
 	tmsize_t stride = PredictorState(tif)->stride;
-	uint32* wp = (uint32*) cp0;
+	uint32_t* wp = (uint32_t*) cp0;
 	tmsize_t wc = cc / 4;
 
     if((cc%(4*stride))!=0)
@@ -407,14 +407,14 @@ horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)
  * Floating point predictor accumulation routine.
  */
 static int
-fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)
+fpAcc(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
 	tmsize_t stride = PredictorState(tif)->stride;
-	uint32 bps = tif->tif_dir.td_bitspersample / 8;
+	uint32_t bps = tif->tif_dir.td_bitspersample / 8;
 	tmsize_t wc = cc / bps;
 	tmsize_t count = cc;
-	uint8 *cp = (uint8 *) cp0;
-	uint8 *tmp;
+	uint8_t *cp = (uint8_t *) cp0;
+	uint8_t *tmp;
 
     if(cc%(bps*stride)!=0)
     {
@@ -423,7 +423,7 @@ fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)
         return 0;
     }
 
-    tmp = (uint8 *)_TIFFmalloc(cc);
+    tmp = (uint8_t *)_TIFFmalloc(cc);
 	if (!tmp)
 		return 0;
 
@@ -434,9 +434,9 @@ fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)
 	}
 
 	_TIFFmemcpy(tmp, cp0, cc);
-	cp = (uint8 *) cp0;
+	cp = (uint8_t *) cp0;
 	for (count = 0; count < wc; count++) {
-		uint32 byte;
+		uint32_t byte;
 		for (byte = 0; byte < bps; byte++) {
 			#if WORDS_BIGENDIAN
 			cp[bps * count + byte] = tmp[byte * wc + count];
@@ -454,7 +454,7 @@ fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)
  * Decode a scanline and apply the predictor routine.
  */
 static int
-PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
+PredictorDecodeRow(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s)
 {
 	TIFFPredictorState *sp = PredictorState(tif);
 
@@ -476,7 +476,7 @@ PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
  * strip/tile dimensions.
  */
 static int
-PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
+PredictorDecodeTile(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s)
 {
 	TIFFPredictorState *sp = PredictorState(tif);
 
@@ -506,7 +506,7 @@ PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
 static int
-horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)
+horDiff8(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
 	TIFFPredictorState* sp = PredictorState(tif);
 	tmsize_t stride = sp->stride;
@@ -560,11 +560,11 @@ horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)
 
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
 static int
-horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)
+horDiff16(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
 	TIFFPredictorState* sp = PredictorState(tif);
 	tmsize_t stride = sp->stride;
-	uint16 *wp = (uint16*) cp0;
+	uint16_t *wp = (uint16_t*) cp0;
 	tmsize_t wc = cc/2;
 
     if((cc%(2*stride))!=0)
@@ -578,7 +578,7 @@ horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)
 		wc -= stride;
 		wp += wc - 1;
 		do {
-			REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)
+			REPEAT4(stride, wp[stride] = (uint16_t)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)
 			wc -= stride;
 		} while (wc > 0);
 	}
@@ -586,9 +586,9 @@ horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)
 }
 
 static int
-swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)
+swabHorDiff16(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
-    uint16* wp = (uint16*) cp0;
+    uint16_t* wp = (uint16_t*) cp0;
     tmsize_t wc = cc / 2;
 
     if( !horDiff16(tif, cp0, cc) )
@@ -600,11 +600,11 @@ swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)
 
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
 static int
-horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)
+horDiff32(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
 	TIFFPredictorState* sp = PredictorState(tif);
 	tmsize_t stride = sp->stride;
-	uint32 *wp = (uint32*) cp0;
+	uint32_t *wp = (uint32_t*) cp0;
 	tmsize_t wc = cc/4;
 
     if((cc%(4*stride))!=0)
@@ -626,9 +626,9 @@ horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)
 }
 
 static int
-swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)
+swabHorDiff32(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
-    uint32* wp = (uint32*) cp0;
+    uint32_t* wp = (uint32_t*) cp0;
     tmsize_t wc = cc / 4;
 
     if( !horDiff32(tif, cp0, cc) )
@@ -643,14 +643,14 @@ swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)
  */
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
 static int
-fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)
+fpDiff(TIFF* tif, uint8_t* cp0, tmsize_t cc)
 {
 	tmsize_t stride = PredictorState(tif)->stride;
-	uint32 bps = tif->tif_dir.td_bitspersample / 8;
+	uint32_t bps = tif->tif_dir.td_bitspersample / 8;
 	tmsize_t wc = cc / bps;
 	tmsize_t count;
-	uint8 *cp = (uint8 *) cp0;
-	uint8 *tmp;
+	uint8_t *cp = (uint8_t *) cp0;
+	uint8_t *tmp;
 
     if((cc%(bps*stride))!=0)
     {
@@ -659,13 +659,13 @@ fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)
         return 0;
     }
 
-    tmp = (uint8 *)_TIFFmalloc(cc);
+    tmp = (uint8_t *)_TIFFmalloc(cc);
 	if (!tmp)
 		return 0;
 
 	_TIFFmemcpy(tmp, cp0, cc);
 	for (count = 0; count < wc; count++) {
-		uint32 byte;
+		uint32_t byte;
 		for (byte = 0; byte < bps; byte++) {
 			#if WORDS_BIGENDIAN
 			cp[byte * wc + count] = tmp[bps * count + byte];
@@ -677,7 +677,7 @@ fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)
 	}
 	_TIFFfree(tmp);
 
-	cp = (uint8 *) cp0;
+	cp = (uint8_t *) cp0;
 	cp += cc - stride - 1;
 	for (count = cc; count > stride; count -= stride)
 		REPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)
@@ -685,7 +685,7 @@ fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)
 }
 
 static int
-PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+PredictorEncodeRow(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	TIFFPredictorState *sp = PredictorState(tif);
 
@@ -700,11 +700,11 @@ PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 }
 
 static int
-PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)
+PredictorEncodeTile(TIFF* tif, uint8_t* bp0, tmsize_t cc0, uint16_t s)
 {
 	static const char module[] = "PredictorEncodeTile";
 	TIFFPredictorState *sp = PredictorState(tif);
-        uint8 *working_copy;
+        uint8_t *working_copy;
 	tmsize_t cc = cc0, rowsize;
 	unsigned char* bp;
         int result_code;
@@ -717,12 +717,12 @@ PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)
          * Do predictor manipulation in a working buffer to avoid altering
          * the callers buffer. http://trac.osgeo.org/gdal/ticket/1965
          */
-        working_copy = (uint8*) _TIFFmalloc(cc0);
+        working_copy = (uint8_t*) _TIFFmalloc(cc0);
         if( working_copy == NULL )
         {
             TIFFErrorExt(tif->tif_clientdata, module, 
-                         "Out of memory allocating " TIFF_SSIZE_FORMAT " byte temp buffer.",
-                         cc0 );
+                         "Out of memory allocating %" PRId64 " byte temp buffer.",
+                         (int64_t) cc0 );
             return 0;
         }
         memcpy( working_copy, bp0, cc0 );
@@ -756,7 +756,7 @@ static const TIFFField predictFields[] = {
 };
 
 static int
-PredictorVSetField(TIFF* tif, uint32 tag, va_list ap)
+PredictorVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	TIFFPredictorState *sp = PredictorState(tif);
 
@@ -765,7 +765,7 @@ PredictorVSetField(TIFF* tif, uint32 tag, va_list ap)
 
 	switch (tag) {
 	case TIFFTAG_PREDICTOR:
-		sp->predictor = (uint16) va_arg(ap, uint16_vap);
+		sp->predictor = (uint16_t) va_arg(ap, uint16_vap);
 		TIFFSetFieldBit(tif, FIELD_PREDICTOR);
 		break;
 	default:
@@ -776,7 +776,7 @@ PredictorVSetField(TIFF* tif, uint32 tag, va_list ap)
 }
 
 static int
-PredictorVGetField(TIFF* tif, uint32 tag, va_list ap)
+PredictorVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	TIFFPredictorState *sp = PredictorState(tif);
 
@@ -785,7 +785,7 @@ PredictorVGetField(TIFF* tif, uint32 tag, va_list ap)
 
 	switch (tag) {
 	case TIFFTAG_PREDICTOR:
-		*va_arg(ap, uint16*) = (uint16)sp->predictor;
+		*va_arg(ap, uint16_t*) = (uint16_t)sp->predictor;
 		break;
 	default:
 		return (*sp->vgetparent)(tif, tag, ap);
diff --git a/src/3rdparty/libtiff/libtiff/tif_predict.h b/src/3rdparty/libtiff/libtiff/tif_predict.h
index a326b9b..597faa1 100644
--- a/src/3rdparty/libtiff/libtiff/tif_predict.h
+++ b/src/3rdparty/libtiff/libtiff/tif_predict.h
@@ -32,7 +32,7 @@
  * ``Library-private'' Support for the Predictor Tag
  */
 
-typedef int (*TIFFEncodeDecodeMethod)(TIFF* tif, uint8* buf, tmsize_t size);
+typedef int (*TIFFEncodeDecodeMethod)(TIFF* tif, uint8_t* buf, tmsize_t size);
 
 /*
  * Codecs that want to support the Predictor tag must place
diff --git a/src/3rdparty/libtiff/libtiff/tif_print.c b/src/3rdparty/libtiff/libtiff/tif_print.c
index a073794..347dbda 100644
--- a/src/3rdparty/libtiff/libtiff/tif_print.c
+++ b/src/3rdparty/libtiff/libtiff/tif_print.c
@@ -65,62 +65,43 @@ static const char * const orientNames[] = {
 
 static void
 _TIFFPrintField(FILE* fd, const TIFFField *fip,
-		uint32 value_count, void *raw_data)
+                uint32_t value_count, void *raw_data)
 {
-	uint32 j;
+	uint32_t j;
 		
 	fprintf(fd, "  %s: ", fip->field_name);
 
 	for(j = 0; j < value_count; j++) {
 		if(fip->field_type == TIFF_BYTE)
-			fprintf(fd, "%u", ((uint8 *) raw_data)[j]);
+			fprintf(fd, "%"PRIu8, ((uint8_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_UNDEFINED)
-			fprintf(fd, "0x%x",
-			    (unsigned int) ((unsigned char *) raw_data)[j]);
+			fprintf(fd, "0x%"PRIx8, ((uint8_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_SBYTE)
-			fprintf(fd, "%d", ((int8 *) raw_data)[j]);
+			fprintf(fd, "%"PRId8, ((int8_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_SHORT)
-			fprintf(fd, "%u", ((uint16 *) raw_data)[j]);
+			fprintf(fd, "%"PRIu16, ((uint16_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_SSHORT)
-			fprintf(fd, "%d", ((int16 *) raw_data)[j]);
+			fprintf(fd, "%"PRId16, ((int16_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_LONG)
-			fprintf(fd, "%lu",
-			    (unsigned long)((uint32 *) raw_data)[j]);
+			fprintf(fd, "%"PRIu32, ((uint32_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_SLONG)
-			fprintf(fd, "%ld", (long)((int32 *) raw_data)[j]);
+			fprintf(fd, "%"PRId32, ((int32_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_IFD)
-			fprintf(fd, "0x%lx",
-				(unsigned long)((uint32 *) raw_data)[j]);
+			fprintf(fd, "0x%"PRIx32, ((uint32_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_RATIONAL
 			|| fip->field_type == TIFF_SRATIONAL
 			|| fip->field_type == TIFF_FLOAT)
 			fprintf(fd, "%f", ((float *) raw_data)[j]);
 		else if(fip->field_type == TIFF_LONG8)
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-			fprintf(fd, "%I64u",
-			    (unsigned __int64)((uint64 *) raw_data)[j]);
-#else
-			fprintf(fd, "%llu",
-			    (unsigned long long)((uint64 *) raw_data)[j]);
-#endif
+			fprintf(fd, "%"PRIu64, ((uint64_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_SLONG8)
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-			fprintf(fd, "%I64d", (__int64)((int64 *) raw_data)[j]);
-#else
-			fprintf(fd, "%lld", (long long)((int64 *) raw_data)[j]);
-#endif
+			fprintf(fd, "%"PRId64, ((int64_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_IFD8)
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-			fprintf(fd, "0x%I64x",
-				(unsigned __int64)((uint64 *) raw_data)[j]);
-#else
-			fprintf(fd, "0x%llx",
-				(unsigned long long)((uint64 *) raw_data)[j]);
-#endif
+			fprintf(fd, "0x%"PRIx64, ((uint64_t *) raw_data)[j]);
 		else if(fip->field_type == TIFF_FLOAT)
 			fprintf(fd, "%f", ((float *)raw_data)[j]);
 		else if(fip->field_type == TIFF_DOUBLE)
-			fprintf(fd, "%f", ((double *) raw_data)[j]);
+			fprintf(fd, "%lf", ((double *) raw_data)[j]);
 		else if(fip->field_type == TIFF_ASCII) {
 			fprintf(fd, "%s", (char *) raw_data);
 			break;
@@ -138,8 +119,8 @@ _TIFFPrintField(FILE* fd, const TIFFField *fip,
 }
 
 static int
-_TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag,
-		      uint32 value_count, void *raw_data)
+_TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32_t tag,
+                      uint32_t value_count, void *raw_data)
 {
         (void) tif;
 
@@ -153,14 +134,14 @@ _TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag,
 		case TIFFTAG_INKSET:
 			if (value_count == 2 && fip->field_type == TIFF_SHORT) {
 				fprintf(fd, "  Ink Set: ");
-				switch (*((uint16*)raw_data)) {
+				switch (*((uint16_t*)raw_data)) {
 				case INKSET_CMYK:
 					fprintf(fd, "CMYK\n");
 					break;
 				default:
-					fprintf(fd, "%u (0x%x)\n",
-						*((uint16*)raw_data),
-						*((uint16*)raw_data));
+					fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
+						*((uint16_t*)raw_data),
+						*((uint16_t*)raw_data));
 					break;
 				}
 				return 1;
@@ -169,8 +150,8 @@ _TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag,
 
 		case TIFFTAG_DOTRANGE:
 			if (value_count == 2 && fip->field_type == TIFF_SHORT) {
-				fprintf(fd, "  Dot Range: %u-%u\n",
-					((uint16*)raw_data)[0], ((uint16*)raw_data)[1]);
+				fprintf(fd, "  Dot Range: %"PRIu16"-%"PRIu16"\n",
+                        ((uint16_t*)raw_data)[0], ((uint16_t*)raw_data)[1]);
 				return 1;
 			}
 			return 0;
@@ -185,7 +166,7 @@ _TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag,
 
 		case TIFFTAG_XMLPACKET:
 		{
-			uint32 i;
+			uint32_t i;
 
 			fprintf(fd, "  XMLPacket (XMP Metadata):\n" );
 			for(i = 0; i < value_count; i++)
@@ -199,18 +180,18 @@ _TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag,
 			 * defined as array of LONG values.
 			 */
 			fprintf(fd,
-			    "  RichTIFFIPTC Data: <present>, %lu bytes\n",
-			    (unsigned long) value_count * 4);
+			    "  RichTIFFIPTC Data: <present>, %"PRIu32" bytes\n",
+			    value_count * 4u);
 			return 1;
 
 		case TIFFTAG_PHOTOSHOP:
-			fprintf(fd, "  Photoshop Data: <present>, %lu bytes\n",
-			    (unsigned long) value_count);
+			fprintf(fd, "  Photoshop Data: <present>, %"PRIu32" bytes\n",
+			    value_count);
 			return 1;
 
 		case TIFFTAG_ICCPROFILE:
-			fprintf(fd, "  ICC Profile: <present>, %lu bytes\n",
-			    (unsigned long) value_count);
+			fprintf(fd, "  ICC Profile: <present>, %"PRIu32" bytes\n",
+			    value_count);
 			return 1;
 
 		case TIFFTAG_STONITS:
@@ -237,15 +218,9 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 	char *sep;
 	long l, n;
 
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-	fprintf(fd, "TIFF Directory at offset 0x%I64x (%I64u)\n",
-		(unsigned __int64) tif->tif_diroff,
-		(unsigned __int64) tif->tif_diroff);
-#else
-	fprintf(fd, "TIFF Directory at offset 0x%llx (%llu)\n",
-		(unsigned long long) tif->tif_diroff,
-		(unsigned long long) tif->tif_diroff);
-#endif
+	fprintf(fd, "TIFF Directory at offset 0x%"PRIu64" (%"PRIx64")\n",
+		tif->tif_diroff,
+		tif->tif_diroff);
 	if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {
 		fprintf(fd, "  Subfile Type:");
 		sep = " ";
@@ -259,23 +234,23 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 		}
 		if (td->td_subfiletype & FILETYPE_MASK)
 			fprintf(fd, "%stransparency mask", sep);
-		fprintf(fd, " (%lu = 0x%lx)\n",
-		    (unsigned long) td->td_subfiletype, (long) td->td_subfiletype);
+		fprintf(fd, " (%"PRIu32" = 0x%"PRIx32")\n",
+		    td->td_subfiletype, td->td_subfiletype);
 	}
 	if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {
-		fprintf(fd, "  Image Width: %lu Image Length: %lu",
-		    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);
+		fprintf(fd, "  Image Width: %"PRIu32" Image Length: %"PRIu32,
+		    td->td_imagewidth, td->td_imagelength);
 		if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))
-			fprintf(fd, " Image Depth: %lu",
-			    (unsigned long) td->td_imagedepth);
+			fprintf(fd, " Image Depth: %"PRIu32,
+			    td->td_imagedepth);
 		fprintf(fd, "\n");
 	}
 	if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {
-		fprintf(fd, "  Tile Width: %lu Tile Length: %lu",
-		    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);
+		fprintf(fd, "  Tile Width: %"PRIu32" Tile Length: %"PRIu32,
+		    td->td_tilewidth, td->td_tilelength);
 		if (TIFFFieldSet(tif,FIELD_TILEDEPTH))
-			fprintf(fd, " Tile Depth: %lu",
-			    (unsigned long) td->td_tiledepth);
+			fprintf(fd, " Tile Depth: %"PRIu32,
+			    td->td_tiledepth);
 		fprintf(fd, "\n");
 	}
 	if (TIFFFieldSet(tif,FIELD_RESOLUTION)) {
@@ -293,7 +268,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 				fprintf(fd, " pixels/cm");
 				break;
 			default:
-				fprintf(fd, " (unit %u = 0x%x)",
+				fprintf(fd, " (unit %"PRIu16" = 0x%"PRIx16")",
 				    td->td_resolutionunit,
 				    td->td_resolutionunit);
 				break;
@@ -305,7 +280,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 		fprintf(fd, "  Position: %g, %g\n",
 		    td->td_xposition, td->td_yposition);
 	if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
-		fprintf(fd, "  Bits/Sample: %u\n", td->td_bitspersample);
+		fprintf(fd, "  Bits/Sample: %"PRIu16"\n", td->td_bitspersample);
 	if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {
 		fprintf(fd, "  Sample Format: ");
 		switch (td->td_sampleformat) {
@@ -328,7 +303,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, "complex IEEE floating point\n");
 			break;
 		default:
-			fprintf(fd, "%u (0x%x)\n",
+			fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
 			    td->td_sampleformat, td->td_sampleformat);
 			break;
 		}
@@ -339,7 +314,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 		if (c)
 			fprintf(fd, "%s\n", c->name);
 		else
-			fprintf(fd, "%u (0x%x)\n",
+			fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
 			    td->td_compression, td->td_compression);
 	}
 	if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {
@@ -355,15 +330,15 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 				fprintf(fd, "CIE Log2(L) (u',v')\n");
 				break;
 			default:
-				fprintf(fd, "%u (0x%x)\n",
+				fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
 				    td->td_photometric, td->td_photometric);
 				break;
 			}
 		}
 	}
 	if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {
-		uint16 i;
-		fprintf(fd, "  Extra Samples: %u<", td->td_extrasamples);
+		uint16_t i;
+		fprintf(fd, "  Extra Samples: %"PRIu16"<", td->td_extrasamples);
 		sep = "";
 		for (i = 0; i < td->td_extrasamples; i++) {
 			switch (td->td_sampleinfo[i]) {
@@ -377,7 +352,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 				fprintf(fd, "%sunassoc-alpha", sep);
 				break;
 			default:
-				fprintf(fd, "%s%u (0x%x)", sep,
+				fprintf(fd, "%s%"PRIu16" (0x%"PRIx16")", sep,
 				    td->td_sampleinfo[i], td->td_sampleinfo[i]);
 				break;
 			}
@@ -387,7 +362,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 	}
 	if (TIFFFieldSet(tif,FIELD_INKNAMES)) {
 		char* cp;
-		uint16 i;
+		uint16_t i;
 		fprintf(fd, "  Ink Names: ");
 		i = td->td_samplesperpixel;
 		sep = "";
@@ -415,7 +390,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, "error diffused\n");
 			break;
 		default:
-			fprintf(fd, "%u (0x%x)\n",
+			fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
 			    td->td_threshholding, td->td_threshholding);
 			break;
 		}
@@ -430,14 +405,14 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, "lsb-to-msb\n");
 			break;
 		default:
-			fprintf(fd, "%u (0x%x)\n",
+			fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
 			    td->td_fillorder, td->td_fillorder);
 			break;
 		}
 	}
 	if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))
         {
-		fprintf(fd, "  YCbCr Subsampling: %u, %u\n",
+		fprintf(fd, "  YCbCr Subsampling: %"PRIu16", %"PRIu16"\n",
 			td->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] );
 	}
 	if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {
@@ -450,35 +425,35 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, "cosited\n");
 			break;
 		default:
-			fprintf(fd, "%u (0x%x)\n",
+			fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
 			    td->td_ycbcrpositioning, td->td_ycbcrpositioning);
 			break;
 		}
 	}
 	if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))
-		fprintf(fd, "  Halftone Hints: light %u dark %u\n",
+		fprintf(fd, "  Halftone Hints: light %"PRIu16" dark %"PRIu16"\n",
 		    td->td_halftonehints[0], td->td_halftonehints[1]);
 	if (TIFFFieldSet(tif,FIELD_ORIENTATION)) {
 		fprintf(fd, "  Orientation: ");
 		if (td->td_orientation < NORIENTNAMES)
 			fprintf(fd, "%s\n", orientNames[td->td_orientation]);
 		else
-			fprintf(fd, "%u (0x%x)\n",
+			fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
 			    td->td_orientation, td->td_orientation);
 	}
 	if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
-		fprintf(fd, "  Samples/Pixel: %u\n", td->td_samplesperpixel);
+		fprintf(fd, "  Samples/Pixel: %"PRIx16"\n", td->td_samplesperpixel);
 	if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {
 		fprintf(fd, "  Rows/Strip: ");
-		if (td->td_rowsperstrip == (uint32) -1)
+		if (td->td_rowsperstrip == (uint32_t) -1)
 			fprintf(fd, "(infinite)\n");
 		else
-			fprintf(fd, "%lu\n", (unsigned long) td->td_rowsperstrip);
+			fprintf(fd, "%"PRIu32"\n", td->td_rowsperstrip);
 	}
 	if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))
-		fprintf(fd, "  Min Sample Value: %u\n", td->td_minsamplevalue);
+		fprintf(fd, "  Min Sample Value: %"PRIu16"\n", td->td_minsamplevalue);
 	if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))
-		fprintf(fd, "  Max Sample Value: %u\n", td->td_maxsamplevalue);
+		fprintf(fd, "  Max Sample Value: %"PRIu16"\n", td->td_maxsamplevalue);
 	if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) {
 		int i;
 		int count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;
@@ -505,13 +480,13 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, "separate image planes\n");
 			break;
 		default:
-			fprintf(fd, "%u (0x%x)\n",
+			fprintf(fd, "%"PRIu16" (0x%"PRIx16")\n",
 			    td->td_planarconfig, td->td_planarconfig);
 			break;
 		}
 	}
 	if (TIFFFieldSet(tif,FIELD_PAGENUMBER))
-		fprintf(fd, "  Page Number: %u-%u\n",
+		fprintf(fd, "  Page Number: %"PRIu16"-%"PRIu16"\n",
 		    td->td_pagenumber[0], td->td_pagenumber[1]);
 	if (TIFFFieldSet(tif,FIELD_COLORMAP)) {
 		fprintf(fd, "  Color Map: ");
@@ -519,7 +494,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, "\n");
 			n = 1L<<td->td_bitspersample;
 			for (l = 0; l < n; l++)
-				fprintf(fd, "   %5ld: %5u %5u %5u\n",
+				fprintf(fd, "   %5ld: %5"PRIu16" %5"PRIu16" %5"PRIu16"\n",
 				    l,
 				    td->td_colormap[0][l],
 				    td->td_colormap[1][l],
@@ -541,11 +516,11 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, "\n");
 			n = 1L<<td->td_bitspersample;
 			for (l = 0; l < n; l++) {
-				uint16 i;
-				fprintf(fd, "    %2ld: %5u",
+				uint16_t i;
+				fprintf(fd, "    %2ld: %5"PRIu16,
 				    l, td->td_transferfunction[0][l]);
 				for (i = 1; i < td->td_samplesperpixel - td->td_extrasamples && i < 3; i++)
-					fprintf(fd, " %5u",
+					fprintf(fd, " %5"PRIu16,
 					    td->td_transferfunction[i][l]);
 				fputc('\n', fd);
 			}
@@ -553,16 +528,11 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 			fprintf(fd, "(present)\n");
 	}
 	if (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {
-		uint16 i;
+		uint16_t i;
 		fprintf(fd, "  SubIFD Offsets:");
 		for (i = 0; i < td->td_nsubifd; i++)
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-			fprintf(fd, " %5I64u",
-				(unsigned __int64) td->td_subifd[i]);
-#else
-			fprintf(fd, " %5llu",
-				(unsigned long long) td->td_subifd[i]);
-#endif
+			fprintf(fd, " %5"PRIu64,
+				td->td_subifd[i]);
 		fputc('\n', fd);
 	}
 
@@ -575,9 +545,9 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 
 		count = (short) TIFFGetTagListCount(tif);
 		for(i = 0; i < count; i++) {
-			uint32 tag = TIFFGetTagListEntry(tif, i);
+			uint32_t tag = TIFFGetTagListEntry(tif, i);
 			const TIFFField *fip;
-			uint32 value_count;
+			uint32_t value_count;
 			int mem_alloc = 0;
 			void *raw_data;
 
@@ -590,7 +560,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 					if(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)
 						continue;
 				} else if (fip->field_readcount == TIFF_VARIABLE ) {
-					uint16 small_value_count;
+					uint16_t small_value_count;
 					if(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)
 						continue;
 					value_count = small_value_count;
@@ -613,7 +583,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 					   handled this way ... likely best if we move it into
 					   the directory structure with an explicit field in 
 					   libtiff 4.1 and assign it a FIELD_ value */
-					static uint16 dotrange[2];
+					static uint16_t dotrange[2];
 					raw_data = dotrange;
 					TIFFGetField(tif, tag, dotrange+0, dotrange+1);
 				} else if (fip->field_type == TIFF_ASCII
@@ -654,23 +624,16 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 
 	if ((flags & TIFFPRINT_STRIPS) &&
 	    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {
-		uint32 s;
+		uint32_t s;
 
-		fprintf(fd, "  %lu %s:\n",
-		    (unsigned long) td->td_nstrips,
+		fprintf(fd, "  %"PRIu32" %s:\n",
+		    td->td_nstrips,
 		    isTiled(tif) ? "Tiles" : "Strips");
 		for (s = 0; s < td->td_nstrips; s++)
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-			fprintf(fd, "    %3lu: [%8I64u, %8I64u]\n",
-			    (unsigned long) s,
-			    (unsigned __int64) TIFFGetStrileOffset(tif, s),
-			    (unsigned __int64) TIFFGetStrileByteCount(tif, s));
-#else
-			fprintf(fd, "    %3lu: [%8llu, %8llu]\n",
-			    (unsigned long) s,
-			    (unsigned long long) TIFFGetStrileOffset(tif, s),
-			    (unsigned long long) TIFFGetStrileByteCount(tif, s));
-#endif
+			fprintf(fd, "    %3"PRIu32": [%8"PRIu64", %8"PRIu64"]\n",
+			    s,
+			    TIFFGetStrileOffset(tif, s),
+			    TIFFGetStrileByteCount(tif, s));
 	}
 }
 
diff --git a/src/3rdparty/libtiff/libtiff/tif_read.c b/src/3rdparty/libtiff/libtiff/tif_read.c
index 527fadd..a4c60b4 100644
--- a/src/3rdparty/libtiff/libtiff/tif_read.c
+++ b/src/3rdparty/libtiff/libtiff/tif_read.c
@@ -29,31 +29,31 @@
 #include "tiffiop.h"
 #include <stdio.h>
 
-int TIFFFillStrip(TIFF* tif, uint32 strip);
-int TIFFFillTile(TIFF* tif, uint32 tile);
-static int TIFFStartStrip(TIFF* tif, uint32 strip);
-static int TIFFStartTile(TIFF* tif, uint32 tile);
+int TIFFFillStrip(TIFF* tif, uint32_t strip);
+int TIFFFillTile(TIFF* tif, uint32_t tile);
+static int TIFFStartStrip(TIFF* tif, uint32_t strip);
+static int TIFFStartTile(TIFF* tif, uint32_t tile);
 static int TIFFCheckRead(TIFF*, int);
 static tmsize_t
-TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,const char* module);
+TIFFReadRawStrip1(TIFF* tif, uint32_t strip, void* buf, tmsize_t size, const char* module);
 static tmsize_t
-TIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* module);
+TIFFReadRawTile1(TIFF* tif, uint32_t tile, void* buf, tmsize_t size, const char* module);
 
-#define NOSTRIP ((uint32)(-1))       /* undefined state */
-#define NOTILE ((uint32)(-1))         /* undefined state */
+#define NOSTRIP ((uint32_t)(-1))       /* undefined state */
+#define NOTILE ((uint32_t)(-1))         /* undefined state */
 
 #define INITIAL_THRESHOLD (1024 * 1024)
 #define THRESHOLD_MULTIPLIER 10
 #define MAX_THRESHOLD (THRESHOLD_MULTIPLIER * THRESHOLD_MULTIPLIER * THRESHOLD_MULTIPLIER * INITIAL_THRESHOLD)
 
-#define TIFF_INT64_MAX ((((int64)0x7FFFFFFF) << 32) | 0xFFFFFFFF)
+#define TIFF_INT64_MAX ((((int64_t)0x7FFFFFFF) << 32) | 0xFFFFFFFF)
 
 /* Read 'size' bytes in tif_rawdata buffer starting at offset 'rawdata_offset'
  * Returns 1 in case of success, 0 otherwise. */
-static int TIFFReadAndRealloc( TIFF* tif, tmsize_t size,
-                               tmsize_t rawdata_offset,
-                               int is_strip, uint32 strip_or_tile,
-                               const char* module )
+static int TIFFReadAndRealloc(TIFF* tif, tmsize_t size,
+                              tmsize_t rawdata_offset,
+                              int is_strip, uint32_t strip_or_tile,
+                              const char* module )
 {
 #if SIZEOF_SIZE_T == 8
         tmsize_t threshold = INITIAL_THRESHOLD;
@@ -66,8 +66,8 @@ static int TIFFReadAndRealloc( TIFF* tif, tmsize_t size,
         /* file size */
         if( size > 1000 * 1000 * 1000 )
         {
-            uint64 filesize = TIFFGetFileSize(tif);
-            if( (uint64)size >= filesize )
+            uint64_t filesize = TIFFGetFileSize(tif);
+            if((uint64_t)size >= filesize )
             {
                 TIFFErrorExt(tif->tif_clientdata, module,
                              "Chunk size requested is larger than file size.");
@@ -95,22 +95,22 @@ static int TIFFReadAndRealloc( TIFF* tif, tmsize_t size,
             }
 #endif
             if (already_read + to_read + rawdata_offset > tif->tif_rawdatasize) {
-                uint8* new_rawdata;
+                uint8_t* new_rawdata;
                 assert((tif->tif_flags & TIFF_MYBUFFER) != 0);
                 tif->tif_rawdatasize = (tmsize_t)TIFFroundup_64(
-                        (uint64)already_read + to_read + rawdata_offset, 1024);
+                        (uint64_t)already_read + to_read + rawdata_offset, 1024);
                 if (tif->tif_rawdatasize==0) {
                     TIFFErrorExt(tif->tif_clientdata, module,
                                 "Invalid buffer size");
                     return 0;
                 }
-                new_rawdata = (uint8*) _TIFFrealloc(
+                new_rawdata = (uint8_t*) _TIFFrealloc(
                                 tif->tif_rawdata, tif->tif_rawdatasize);
                 if( new_rawdata == 0 )
                 {
                     TIFFErrorExt(tif->tif_clientdata, module,
-                        "No space for data buffer at scanline %lu",
-                        (unsigned long) tif->tif_row);
+                        "No space for data buffer at scanline %"PRIu32,
+                        tif->tif_row);
                     _TIFFfree(tif->tif_rawdata);
                     tif->tif_rawdata = 0;
                     tif->tif_rawdatasize = 0;
@@ -130,49 +130,26 @@ static int TIFFReadAndRealloc( TIFF* tif, tmsize_t size,
             if (bytes_read != to_read) {
                 memset( tif->tif_rawdata + rawdata_offset + already_read, 0,
                         tif->tif_rawdatasize - rawdata_offset - already_read );
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
                 if( is_strip )
                 {
                     TIFFErrorExt(tif->tif_clientdata, module,
-                        "Read error at scanline %lu; got %I64u bytes, "
-                        "expected %I64u",
-                                        (unsigned long) tif->tif_row,
-                                        (unsigned __int64) already_read,
-                                        (unsigned __int64) size);
+                        "Read error at scanline %"PRIu32"; got %"TIFF_SSIZE_FORMAT" bytes, "
+                        "expected %"TIFF_SSIZE_FORMAT,
+                                        tif->tif_row,
+                                        already_read,
+                                        size);
                 }
                 else
                 {
                     TIFFErrorExt(tif->tif_clientdata, module,
-                        "Read error at row %lu, col %lu, tile %lu; "
-                        "got %I64u bytes, expected %I64u",
-                                        (unsigned long) tif->tif_row,
-                                        (unsigned long) tif->tif_col,
-                                        (unsigned long) strip_or_tile,
-                                        (unsigned __int64) already_read,
-                                        (unsigned __int64) size);
+                        "Read error at row %"PRIu32", col %"PRIu32", tile %"PRIu32"; "
+                        "got %"TIFF_SSIZE_FORMAT" bytes, expected %"TIFF_SSIZE_FORMAT"",
+                                        tif->tif_row,
+                                        tif->tif_col,
+                                        strip_or_tile,
+                                        already_read,
+                                        size);
                 }
-#else
-                if( is_strip )
-                {
-                    TIFFErrorExt(tif->tif_clientdata, module,
-                        "Read error at scanline %lu; got %llu bytes, "
-                        "expected %llu",
-                                        (unsigned long) tif->tif_row,
-                                        (unsigned long long) already_read,
-                                        (unsigned long long) size);
-                }
-                else
-                {
-                    TIFFErrorExt(tif->tif_clientdata, module,
-                        "Read error at row %lu, col %lu, tile %lu; "
-                        "got %llu bytes, expected %llu",
-                                        (unsigned long) tif->tif_row,
-                                        (unsigned long) tif->tif_col,
-                                        (unsigned long) strip_or_tile,
-                                        (unsigned long long) already_read,
-                                        (unsigned long long) size);
-                }
-#endif
                 return 0;
             }
         }
@@ -186,7 +163,7 @@ TIFFFillStripPartial( TIFF *tif, int strip, tmsize_t read_ahead, int restart )
 	static const char module[] = "TIFFFillStripPartial";
 	register TIFFDirectory *td = &tif->tif_dir;
         tmsize_t unused_data;
-        uint64 read_offset;
+        uint64_t read_offset;
         tmsize_t to_read;
         tmsize_t read_ahead_mod;
         /* tmsize_t bytecountm; */
@@ -211,8 +188,8 @@ TIFFFillStripPartial( TIFF *tif, int strip, tmsize_t read_ahead, int restart )
                 tif->tif_curstrip = NOSTRIP;
                 if ((tif->tif_flags & TIFF_MYBUFFER) == 0) {
                         TIFFErrorExt(tif->tif_clientdata, module,
-                                     "Data buffer too small to hold part of strip %lu",
-                                     (unsigned long) strip);
+                                     "Data buffer too small to hold part of strip %d",
+                                     strip);
                         return (0);
                 }
         }
@@ -246,8 +223,8 @@ TIFFFillStripPartial( TIFF *tif, int strip, tmsize_t read_ahead, int restart )
 
         if (!SeekOK(tif, read_offset)) {
                 TIFFErrorExt(tif->tif_clientdata, module,
-                             "Seek error at scanline %lu, strip %lu",
-                             (unsigned long) tif->tif_row, (unsigned long) strip);
+                             "Seek error at scanline %"PRIu32", strip %d",
+                             tif->tif_row, strip);
                 return 0;
         }
 
@@ -258,8 +235,8 @@ TIFFFillStripPartial( TIFF *tif, int strip, tmsize_t read_ahead, int restart )
                 to_read = read_ahead_mod - unused_data;
         else
                 to_read = tif->tif_rawdatasize - unused_data;
-        if( (uint64) to_read > TIFFGetStrileByteCount(tif, strip)
-            - tif->tif_rawdataoff - tif->tif_rawdataloaded )
+        if((uint64_t) to_read > TIFFGetStrileByteCount(tif, strip)
+                                - tif->tif_rawdataoff - tif->tif_rawdataloaded )
         {
                 to_read = (tmsize_t) TIFFGetStrileByteCount(tif, strip)
                         - tif->tif_rawdataoff - tif->tif_rawdataloaded;
@@ -300,7 +277,7 @@ TIFFFillStripPartial( TIFF *tif, int strip, tmsize_t read_ahead, int restart )
             /* For JPEG, if there are multiple scans (can generally be known */
             /* with the  read_ahead used), we need to read the whole strip */
             if( tif->tif_dir.td_compression==COMPRESSION_JPEG &&
-                (uint64)tif->tif_rawcc < TIFFGetStrileByteCount(tif, strip) )
+                (uint64_t)tif->tif_rawcc < TIFFGetStrileByteCount(tif, strip) )
             {
                 if( TIFFJPEGIsFullStripRequired(tif) )
                 {
@@ -326,10 +303,10 @@ TIFFFillStripPartial( TIFF *tif, int strip, tmsize_t read_ahead, int restart )
  * strips.
  */
 static int
-TIFFSeek(TIFF* tif, uint32 row, uint16 sample )
+TIFFSeek(TIFF* tif, uint32_t row, uint16_t sample )
 {
 	register TIFFDirectory *td = &tif->tif_dir;
-	uint32 strip;
+	uint32_t strip;
         int    whole_strip;
 	tmsize_t read_ahead = 0;
 
@@ -338,19 +315,19 @@ TIFFSeek(TIFF* tif, uint32 row, uint16 sample )
         */
 	if (row >= td->td_imagelength) {	/* out of range */
 		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "%lu: Row out of range, max %lu",
-		    (unsigned long) row,
-		    (unsigned long) td->td_imagelength);
+		    "%"PRIu32": Row out of range, max %"PRIu32"",
+		    row,
+		    td->td_imagelength);
 		return (0);
 	}
 	if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
 		if (sample >= td->td_samplesperpixel) {
 			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "%lu: Sample out of range, max %lu",
-			    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);
+			    "%"PRIu16": Sample out of range, max %"PRIu16"",
+			    sample, td->td_samplesperpixel);
 			return (0);
 		}
-		strip = (uint32)sample*td->td_stripsperimage + row/td->td_rowsperstrip;
+		strip = (uint32_t)sample * td->td_stripsperimage + row / td->td_rowsperstrip;
 	} else
 		strip = row / td->td_rowsperstrip;
 
@@ -412,7 +389,7 @@ TIFFSeek(TIFF* tif, uint32 row, uint16 sample )
         else if( !whole_strip )
         {
                 if( ((tif->tif_rawdata + tif->tif_rawdataloaded) - tif->tif_rawcp) < read_ahead 
-                    && (uint64) tif->tif_rawdataoff+tif->tif_rawdataloaded < TIFFGetStrileByteCount(tif, strip) )
+                    && (uint64_t) tif->tif_rawdataoff + tif->tif_rawdataloaded < TIFFGetStrileByteCount(tif, strip) )
                 {
                         if( !TIFFFillStripPartial(tif,strip,read_ahead,0) )
                                 return 0;
@@ -457,7 +434,7 @@ TIFFSeek(TIFF* tif, uint32 row, uint16 sample )
 }
 
 int
-TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)
+TIFFReadScanline(TIFF* tif, void* buf, uint32_t row, uint16_t sample)
 {
 	int e;
 
@@ -468,13 +445,13 @@ TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)
 		 * Decompress desired row into user buffer.
 		 */
 		e = (*tif->tif_decoderow)
-		    (tif, (uint8*) buf, tif->tif_scanlinesize, sample);  
+		    (tif, (uint8_t*) buf, tif->tif_scanlinesize, sample);
 
 		/* we are now poised at the beginning of the next row */
 		tif->tif_row = row + 1;
 
 		if (e)
-			(*tif->tif_postdecode)(tif, (uint8*) buf,
+			(*tif->tif_postdecode)(tif, (uint8_t*) buf,
 			    tif->tif_scanlinesize);  
 	}
 	return (e > 0 ? 1 : -1);
@@ -485,22 +462,22 @@ TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)
  * rows in the strip (check for truncated last strip on any
  * of the separations).
  */
-static tmsize_t TIFFReadEncodedStripGetStripSize(TIFF* tif, uint32 strip, uint16* pplane)
+static tmsize_t TIFFReadEncodedStripGetStripSize(TIFF* tif, uint32_t strip, uint16_t* pplane)
 {
 	static const char module[] = "TIFFReadEncodedStrip";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint32 rowsperstrip;
-	uint32 stripsperplane;
-	uint32 stripinplane;
-	uint32 rows;
+	uint32_t rowsperstrip;
+	uint32_t stripsperplane;
+	uint32_t stripinplane;
+	uint32_t rows;
 	tmsize_t stripsize;
 	if (!TIFFCheckRead(tif,0))
 		return((tmsize_t)(-1));
 	if (strip>=td->td_nstrips)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,
-		    "%lu: Strip out of range, max %lu",(unsigned long)strip,
-		    (unsigned long)td->td_nstrips);
+		    "%"PRIu32": Strip out of range, max %"PRIu32, strip,
+		    td->td_nstrips);
 		return((tmsize_t)(-1));
 	}
 
@@ -509,7 +486,7 @@ static tmsize_t TIFFReadEncodedStripGetStripSize(TIFF* tif, uint32 strip, uint16
 		rowsperstrip=td->td_imagelength;
 	stripsperplane= TIFFhowmany_32_maxuint_compat(td->td_imagelength, rowsperstrip);
 	stripinplane=(strip%stripsperplane);
-	if( pplane ) *pplane=(uint16)(strip/stripsperplane);
+	if( pplane ) *pplane=(uint16_t)(strip / stripsperplane);
 	rows=td->td_imagelength-stripinplane*rowsperstrip;
 	if (rows>rowsperstrip)
 		rows=rowsperstrip;
@@ -524,12 +501,12 @@ static tmsize_t TIFFReadEncodedStripGetStripSize(TIFF* tif, uint32 strip, uint16
  * amount into the user-supplied buffer.
  */
 tmsize_t
-TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
+TIFFReadEncodedStrip(TIFF* tif, uint32_t strip, void* buf, tmsize_t size)
 {
 	static const char module[] = "TIFFReadEncodedStrip";
 	TIFFDirectory *td = &tif->tif_dir;
 	tmsize_t stripsize;
-	uint16 plane;
+	uint16_t plane;
 
 	stripsize=TIFFReadEncodedStripGetStripSize(tif, strip, &plane);
 	if (stripsize==((tmsize_t)(-1)))
@@ -569,12 +546,12 @@ TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
  * * calls regular TIFFReadEncodedStrip() if *buf != NULL
  */
 tmsize_t
-_TIFFReadEncodedStripAndAllocBuffer(TIFF* tif, uint32 strip,
+_TIFFReadEncodedStripAndAllocBuffer(TIFF* tif, uint32_t strip,
                                     void **buf, tmsize_t bufsizetoalloc,
                                     tmsize_t size_to_read)
 {
     tmsize_t this_stripsize;
-    uint16 plane;
+    uint16_t plane;
 
     if( *buf != NULL )
     {
@@ -606,8 +583,8 @@ _TIFFReadEncodedStripAndAllocBuffer(TIFF* tif, uint32 strip,
 }
 
 static tmsize_t
-TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,
-    const char* module)
+TIFFReadRawStrip1(TIFF* tif, uint32_t strip, void* buf, tmsize_t size,
+                  const char* module)
 {
 	assert((tif->tif_flags&TIFF_NOREADRAW)==0);
 	if (!isMapped(tif)) {
@@ -615,32 +592,24 @@ TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,
 
 		if (!SeekOK(tif, TIFFGetStrileOffset(tif, strip))) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Seek error at scanline %lu, strip %lu",
-			    (unsigned long) tif->tif_row, (unsigned long) strip);
+			    "Seek error at scanline %"PRIu32", strip %"PRIu32,
+			    tif->tif_row, strip);
 			return ((tmsize_t)(-1));
 		}
 		cc = TIFFReadFile(tif, buf, size);
 		if (cc != size) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 			TIFFErrorExt(tif->tif_clientdata, module,
-		"Read error at scanline %lu; got %I64u bytes, expected %I64u",
-				     (unsigned long) tif->tif_row,
-				     (unsigned __int64) cc,
-				     (unsigned __int64) size);
-#else
-			TIFFErrorExt(tif->tif_clientdata, module,
-		"Read error at scanline %lu; got %llu bytes, expected %llu",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long long) cc,
-				     (unsigned long long) size);
-#endif
+		"Read error at scanline %"PRIu32"; got %"TIFF_SSIZE_FORMAT" bytes, expected %"TIFF_SSIZE_FORMAT,
+				     tif->tif_row,
+				     cc,
+				     size);
 			return ((tmsize_t)(-1));
 		}
 	} else {
 		tmsize_t ma = 0;
 		tmsize_t n;
-		if ((TIFFGetStrileOffset(tif, strip) > (uint64)TIFF_TMSIZE_T_MAX)||
-                    ((ma=(tmsize_t)TIFFGetStrileOffset(tif, strip))>tif->tif_size))
+		if ((TIFFGetStrileOffset(tif, strip) > (uint64_t)TIFF_TMSIZE_T_MAX) ||
+            ((ma=(tmsize_t)TIFFGetStrileOffset(tif, strip))>tif->tif_size))
                 {
                     n=0;
                 }
@@ -657,21 +626,12 @@ TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,
                             n=size;
                 }
 		if (n!=size) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 			TIFFErrorExt(tif->tif_clientdata, module,
-	"Read error at scanline %lu, strip %lu; got %I64u bytes, expected %I64u",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long) strip,
-				     (unsigned __int64) n,
-				     (unsigned __int64) size);
-#else
-			TIFFErrorExt(tif->tif_clientdata, module,
-	"Read error at scanline %lu, strip %lu; got %llu bytes, expected %llu",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long) strip,
-				     (unsigned long long) n,
-				     (unsigned long long) size);
-#endif
+	"Read error at scanline %"PRIu32", strip %"PRIu32"; got %"TIFF_SSIZE_FORMAT" bytes, expected %"TIFF_SSIZE_FORMAT,
+				     tif->tif_row,
+				     strip,
+				     n,
+				     size);
 			return ((tmsize_t)(-1));
 		}
 		_TIFFmemcpy(buf, tif->tif_base + ma,
@@ -681,7 +641,7 @@ TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,
 }
 
 static tmsize_t
-TIFFReadRawStripOrTile2(TIFF* tif, uint32 strip_or_tile, int is_strip,
+TIFFReadRawStripOrTile2(TIFF* tif, uint32_t strip_or_tile, int is_strip,
                         tmsize_t size, const char* module)
 {
         assert( !isMapped(tif) );
@@ -691,17 +651,17 @@ TIFFReadRawStripOrTile2(TIFF* tif, uint32 strip_or_tile, int is_strip,
             if( is_strip )
             {
                 TIFFErrorExt(tif->tif_clientdata, module,
-                    "Seek error at scanline %lu, strip %lu",
-                    (unsigned long) tif->tif_row,
-                    (unsigned long) strip_or_tile);
+                    "Seek error at scanline %"PRIu32", strip %"PRIu32,
+                    tif->tif_row,
+                    strip_or_tile);
             }
             else
             {
                 TIFFErrorExt(tif->tif_clientdata, module,
-                    "Seek error at row %lu, col %lu, tile %lu",
-                    (unsigned long) tif->tif_row,
-                    (unsigned long) tif->tif_col,
-                    (unsigned long) strip_or_tile);
+                    "Seek error at row %"PRIu32", col %"PRIu32", tile %"PRIu32,
+                    tif->tif_row,
+                    tif->tif_col,
+                    strip_or_tile);
             }
             return ((tmsize_t)(-1));
         }
@@ -719,20 +679,20 @@ TIFFReadRawStripOrTile2(TIFF* tif, uint32 strip_or_tile, int is_strip,
  * Read a strip of data from the file.
  */
 tmsize_t
-TIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
+TIFFReadRawStrip(TIFF* tif, uint32_t strip, void* buf, tmsize_t size)
 {
 	static const char module[] = "TIFFReadRawStrip";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint64 bytecount64;
+	uint64_t bytecount64;
 	tmsize_t bytecountm;
 
 	if (!TIFFCheckRead(tif, 0))
 		return ((tmsize_t)(-1));
 	if (strip >= td->td_nstrips) {
 		TIFFErrorExt(tif->tif_clientdata, module,
-		     "%lu: Strip out of range, max %lu",
-		     (unsigned long) strip,
-		     (unsigned long) td->td_nstrips);
+		     "%"PRIu32": Strip out of range, max %"PRIu32,
+		     strip,
+		     td->td_nstrips);
 		return ((tmsize_t)(-1));
 	}
 	if (tif->tif_flags&TIFF_NOREADRAW)
@@ -742,7 +702,7 @@ TIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
 		return ((tmsize_t)(-1));
 	}
 	bytecount64 = TIFFGetStrileByteCount(tif, strip);
-	if (size != (tmsize_t)(-1) && (uint64)size <= bytecount64)
+	if (size != (tmsize_t)(-1) && (uint64_t)size <= bytecount64)
 		bytecountm = size;
 	else
 		bytecountm = _TIFFCastUInt64ToSSize(tif, bytecount64, module);
@@ -753,7 +713,7 @@ TIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
 }
 
 TIFF_NOSANITIZE_UNSIGNED_INT_OVERFLOW
-static uint64 NoSantizeSubUInt64(uint64 a, uint64 b)
+static uint64_t NoSanitizeSubUInt64(uint64_t a, uint64_t b)
 {
     return a - b;
 }
@@ -763,26 +723,19 @@ static uint64 NoSantizeSubUInt64(uint64 a, uint64 b)
  * expanded, as necessary, to hold the strip's data.
  */
 int
-TIFFFillStrip(TIFF* tif, uint32 strip)
+TIFFFillStrip(TIFF* tif, uint32_t strip)
 {
 	static const char module[] = "TIFFFillStrip";
 	TIFFDirectory *td = &tif->tif_dir;
 
 	if ((tif->tif_flags&TIFF_NOREADRAW)==0)
 	{
-		uint64 bytecount = TIFFGetStrileByteCount(tif, strip);
-		if( bytecount == 0 || bytecount > (uint64)TIFF_INT64_MAX ) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
+		uint64_t bytecount = TIFFGetStrileByteCount(tif, strip);
+		if( bytecount == 0 || bytecount > (uint64_t)TIFF_INT64_MAX ) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-				"Invalid strip byte count %I64u, strip %lu",
-				     (unsigned __int64) bytecount,
-				     (unsigned long) strip);
-#else
-			TIFFErrorExt(tif->tif_clientdata, module,
-				"Invalid strip byte count %llu, strip %lu",
-				     (unsigned long long) bytecount,
-				     (unsigned long) strip);
-#endif
+				"Invalid strip byte count %"PRIu64", strip %"PRIu32,
+				     bytecount,
+				     strip);
 			return (0);
 		}
 
@@ -795,24 +748,16 @@ TIFFFillStrip(TIFF* tif, uint32 strip)
 			/* Hopefully they are safe enough for all codecs */
 			tmsize_t stripsize = TIFFStripSize(tif);
 			if( stripsize != 0 &&
-			    (bytecount - 4096) / 10 > (uint64)stripsize  )
+			    (bytecount - 4096) / 10 > (uint64_t)stripsize  )
 			{
-				uint64 newbytecount = (uint64)stripsize * 10 + 4096;
-				if( newbytecount == 0 || newbytecount > (uint64)TIFF_INT64_MAX )
+				uint64_t newbytecount = (uint64_t)stripsize * 10 + 4096;
+				if( newbytecount == 0 || newbytecount > (uint64_t)TIFF_INT64_MAX )
 				{
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-					TIFFWarningExt(tif->tif_clientdata, module,
-					  "Too large strip byte count %I64u, strip %lu. Limiting to %I64u",
-					     (unsigned __int64) bytecount,
-					     (unsigned long) strip,
-					     (unsigned __int64) newbytecount);
-#else
 					TIFFErrorExt(tif->tif_clientdata, module,
-					  "Too large strip byte count %llu, strip %lu. Limiting to %llu",
-					     (unsigned long long) bytecount,
-					     (unsigned long) strip,
-					     (unsigned long long) newbytecount);
-#endif
+					  "Too large strip byte count %"PRIu64", strip %"PRIu32". Limiting to %"PRIu64,
+					     bytecount,
+					     strip,
+					     newbytecount);
 					bytecount = newbytecount;
 				}
 			}
@@ -828,30 +773,20 @@ TIFFFillStrip(TIFF* tif, uint32 strip)
 			 * comparison (which can overflow) we do the following
 			 * two comparisons:
 			 */
-			if (bytecount > (uint64)tif->tif_size ||
-			    TIFFGetStrileOffset(tif, strip) > (uint64)tif->tif_size - bytecount) {
+			if (bytecount > (uint64_t)tif->tif_size ||
+			    TIFFGetStrileOffset(tif, strip) > (uint64_t)tif->tif_size - bytecount) {
 				/*
 				 * This error message might seem strange, but
 				 * it's what would happen if a read were done
 				 * instead.
 				 */
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 				TIFFErrorExt(tif->tif_clientdata, module,
 
-					"Read error on strip %lu; "
-					"got %I64u bytes, expected %I64u",
-					(unsigned long) strip,
-					(unsigned __int64) NoSantizeSubUInt64(tif->tif_size, TIFFGetStrileOffset(tif, strip)),
-					(unsigned __int64) bytecount);
-#else
-				TIFFErrorExt(tif->tif_clientdata, module,
-
-					"Read error on strip %lu; "
-					"got %llu bytes, expected %llu",
-					(unsigned long) strip,
-					(unsigned long long) NoSantizeSubUInt64(tif->tif_size, TIFFGetStrileOffset(tif, strip)),
-					(unsigned long long) bytecount);
-#endif
+					"Read error on strip %"PRIu32"; "
+                    "got %"PRIu64" bytes, expected %"PRIu64,
+					strip,
+					NoSanitizeSubUInt64(tif->tif_size, TIFFGetStrileOffset(tif, strip)),
+					bytecount);
 				tif->tif_curstrip = NOSTRIP;
 				return (0);
 			}
@@ -897,7 +832,7 @@ TIFFFillStrip(TIFF* tif, uint32 strip)
 			 */
 			tmsize_t bytecountm;
 			bytecountm=(tmsize_t)bytecount;
-			if ((uint64)bytecountm!=bytecount)
+			if ((uint64_t)bytecountm != bytecount)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Integer overflow");
 				return(0);
@@ -906,8 +841,8 @@ TIFFFillStrip(TIFF* tif, uint32 strip)
 				tif->tif_curstrip = NOSTRIP;
 				if ((tif->tif_flags & TIFF_MYBUFFER) == 0) {
 					TIFFErrorExt(tif->tif_clientdata, module,
-					    "Data buffer too small to hold strip %lu",
-					    (unsigned long) strip);
+					    "Data buffer too small to hold strip %"PRIu32,
+					    strip);
 					return (0);
 				}
 			}
@@ -962,7 +897,7 @@ TIFFFillStrip(TIFF* tif, uint32 strip)
  * tile is selected by the (x,y,z,s) coordinates.
  */
 tmsize_t
-TIFFReadTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s)
+TIFFReadTile(TIFF* tif, void* buf, uint32_t x, uint32_t y, uint32_t z, uint16_t s)
 {
 	if (!TIFFCheckRead(tif, 1) || !TIFFCheckTile(tif, x, y, z, s))
 		return ((tmsize_t)(-1));
@@ -975,7 +910,7 @@ TIFFReadTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s)
  * amount into the user-supplied buffer.
  */
 tmsize_t
-TIFFReadEncodedTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)
+TIFFReadEncodedTile(TIFF* tif, uint32_t tile, void* buf, tmsize_t size)
 {
 	static const char module[] = "TIFFReadEncodedTile";
 	TIFFDirectory *td = &tif->tif_dir;
@@ -985,8 +920,8 @@ TIFFReadEncodedTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)
 		return ((tmsize_t)(-1));
 	if (tile >= td->td_nstrips) {
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "%lu: Tile out of range, max %lu",
-		    (unsigned long) tile, (unsigned long) td->td_nstrips);
+		    "%"PRIu32": Tile out of range, max %"PRIu32,
+		    tile, td->td_nstrips);
 		return ((tmsize_t)(-1));
 	}
 
@@ -1012,8 +947,8 @@ TIFFReadEncodedTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)
 	else if (size > tilesize)
 		size = tilesize;
 	if (TIFFFillTile(tif, tile) && (*tif->tif_decodetile)(tif,
-	    (uint8*) buf, size, (uint16)(tile/td->td_stripsperimage))) {
-		(*tif->tif_postdecode)(tif, (uint8*) buf, size);
+                                                          (uint8_t*) buf, size, (uint16_t)(tile / td->td_stripsperimage))) {
+		(*tif->tif_postdecode)(tif, (uint8_t*) buf, size);
 		return (size);
 	} else
 		return ((tmsize_t)(-1));
@@ -1028,7 +963,7 @@ TIFFReadEncodedTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)
 tmsize_t
 _TIFFReadTileAndAllocBuffer(TIFF* tif,
                             void **buf, tmsize_t bufsizetoalloc,
-                            uint32 x, uint32 y, uint32 z, uint16 s)
+                            uint32_t x, uint32_t y, uint32_t z, uint16_t s)
 {
     if (!TIFFCheckRead(tif, 1) || !TIFFCheckTile(tif, x, y, z, s))
             return ((tmsize_t)(-1));
@@ -1045,9 +980,9 @@ _TIFFReadTileAndAllocBuffer(TIFF* tif,
  * * calls regular TIFFReadEncodedTile() if *buf != NULL
  */
 tmsize_t
-_TIFFReadEncodedTileAndAllocBuffer(TIFF* tif, uint32 tile,
-                                    void **buf, tmsize_t bufsizetoalloc,
-                                    tmsize_t size_to_read)
+_TIFFReadEncodedTileAndAllocBuffer(TIFF* tif, uint32_t tile,
+                                   void **buf, tmsize_t bufsizetoalloc,
+                                   tmsize_t size_to_read)
 {
     static const char module[] = "_TIFFReadEncodedTileAndAllocBuffer";
     TIFFDirectory *td = &tif->tif_dir;
@@ -1062,8 +997,8 @@ _TIFFReadEncodedTileAndAllocBuffer(TIFF* tif, uint32 tile,
             return ((tmsize_t)(-1));
     if (tile >= td->td_nstrips) {
             TIFFErrorExt(tif->tif_clientdata, module,
-                "%lu: Tile out of range, max %lu",
-                (unsigned long) tile, (unsigned long) td->td_nstrips);
+                "%"PRIu32": Tile out of range, max %"PRIu32,
+                tile, td->td_nstrips);
             return ((tmsize_t)(-1));
     }
 
@@ -1083,15 +1018,15 @@ _TIFFReadEncodedTileAndAllocBuffer(TIFF* tif, uint32 tile,
     else if (size_to_read > tilesize)
         size_to_read = tilesize;
     if( (*tif->tif_decodetile)(tif,
-        (uint8*) *buf, size_to_read, (uint16)(tile/td->td_stripsperimage))) {
-        (*tif->tif_postdecode)(tif, (uint8*) *buf, size_to_read);
+                               (uint8_t*) *buf, size_to_read, (uint16_t)(tile / td->td_stripsperimage))) {
+        (*tif->tif_postdecode)(tif, (uint8_t*) *buf, size_to_read);
         return (size_to_read);
     } else
         return ((tmsize_t)(-1));
 }
 
 static tmsize_t
-TIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* module)
+TIFFReadRawTile1(TIFF* tif, uint32_t tile, void* buf, tmsize_t size, const char* module)
 {
 	assert((tif->tif_flags&TIFF_NOREADRAW)==0);
 	if (!isMapped(tif)) {
@@ -1099,29 +1034,20 @@ TIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* m
 
 		if (!SeekOK(tif, TIFFGetStrileOffset(tif, tile))) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-			    "Seek error at row %lu, col %lu, tile %lu",
-			    (unsigned long) tif->tif_row,
-			    (unsigned long) tif->tif_col,
-			    (unsigned long) tile);
+			    "Seek error at row %"PRIu32", col %"PRIu32", tile %"PRIu32,
+			    tif->tif_row,
+			    tif->tif_col,
+			    tile);
 			return ((tmsize_t)(-1));
 		}
 		cc = TIFFReadFile(tif, buf, size);
 		if (cc != size) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-			TIFFErrorExt(tif->tif_clientdata, module,
-	"Read error at row %lu, col %lu; got %I64u bytes, expected %I64u",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long) tif->tif_col,
-				     (unsigned __int64) cc,
-				     (unsigned __int64) size);
-#else
 			TIFFErrorExt(tif->tif_clientdata, module,
-	"Read error at row %lu, col %lu; got %llu bytes, expected %llu",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long) tif->tif_col,
-				     (unsigned long long) cc,
-				     (unsigned long long) size);
-#endif
+	"Read error at row %"PRIu32", col %"PRIu32"; got %"TIFF_SSIZE_FORMAT" bytes, expected %"TIFF_SSIZE_FORMAT,
+				     tif->tif_row,
+				     tif->tif_col,
+				     cc,
+				     size);
 			return ((tmsize_t)(-1));
 		}
 	} else {
@@ -1129,30 +1055,20 @@ TIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* m
 		tmsize_t n;
 		ma=(tmsize_t)TIFFGetStrileOffset(tif, tile);
 		mb=ma+size;
-		if ((TIFFGetStrileOffset(tif, tile) > (uint64)TIFF_TMSIZE_T_MAX)||(ma>tif->tif_size))
+		if ((TIFFGetStrileOffset(tif, tile) > (uint64_t)TIFF_TMSIZE_T_MAX) || (ma > tif->tif_size))
 			n=0;
 		else if ((mb<ma)||(mb<size)||(mb>tif->tif_size))
 			n=tif->tif_size-ma;
 		else
 			n=size;
 		if (n!=size) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-			TIFFErrorExt(tif->tif_clientdata, module,
-"Read error at row %lu, col %lu, tile %lu; got %I64u bytes, expected %I64u",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long) tif->tif_col,
-				     (unsigned long) tile,
-				     (unsigned __int64) n,
-				     (unsigned __int64) size);
-#else
 			TIFFErrorExt(tif->tif_clientdata, module,
-"Read error at row %lu, col %lu, tile %lu; got %llu bytes, expected %llu",
-				     (unsigned long) tif->tif_row,
-				     (unsigned long) tif->tif_col,
-				     (unsigned long) tile,
-				     (unsigned long long) n,
-				     (unsigned long long) size);
-#endif
+"Read error at row %"PRIu32", col %"PRIu32", tile %"PRIu32"; got %"TIFF_SSIZE_FORMAT" bytes, expected %"TIFF_SSIZE_FORMAT,
+				     tif->tif_row,
+				     tif->tif_col,
+				     tile,
+				     n,
+				     size);
 			return ((tmsize_t)(-1));
 		}
 		_TIFFmemcpy(buf, tif->tif_base + ma, size);
@@ -1164,19 +1080,19 @@ TIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* m
  * Read a tile of data from the file.
  */
 tmsize_t
-TIFFReadRawTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)
+TIFFReadRawTile(TIFF* tif, uint32_t tile, void* buf, tmsize_t size)
 {
 	static const char module[] = "TIFFReadRawTile";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint64 bytecount64;
+	uint64_t bytecount64;
 	tmsize_t bytecountm;
 
 	if (!TIFFCheckRead(tif, 1))
 		return ((tmsize_t)(-1));
 	if (tile >= td->td_nstrips) {
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "%lu: Tile out of range, max %lu",
-		    (unsigned long) tile, (unsigned long) td->td_nstrips);
+		    "%"PRIu32": Tile out of range, max %"PRIu32,
+		    tile, td->td_nstrips);
 		return ((tmsize_t)(-1));
 	}
 	if (tif->tif_flags&TIFF_NOREADRAW)
@@ -1186,7 +1102,7 @@ TIFFReadRawTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)
 		return ((tmsize_t)(-1));
 	}
 	bytecount64 = TIFFGetStrileByteCount(tif, tile);
-	if (size != (tmsize_t)(-1) && (uint64)size <= bytecount64)
+	if (size != (tmsize_t)(-1) && (uint64_t)size <= bytecount64)
 		bytecountm = size;
 	else
 		bytecountm = _TIFFCastUInt64ToSSize(tif, bytecount64, module);
@@ -1201,26 +1117,19 @@ TIFFReadRawTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)
  * expanded, as necessary, to hold the tile's data.
  */
 int
-TIFFFillTile(TIFF* tif, uint32 tile)
+TIFFFillTile(TIFF* tif, uint32_t tile)
 {
 	static const char module[] = "TIFFFillTile";
 	TIFFDirectory *td = &tif->tif_dir;
 
 	if ((tif->tif_flags&TIFF_NOREADRAW)==0)
 	{
-		uint64 bytecount = TIFFGetStrileByteCount(tif, tile);
-		if( bytecount == 0 || bytecount > (uint64)TIFF_INT64_MAX ) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
+		uint64_t bytecount = TIFFGetStrileByteCount(tif, tile);
+		if( bytecount == 0 || bytecount > (uint64_t)TIFF_INT64_MAX ) {
 			TIFFErrorExt(tif->tif_clientdata, module,
-				"%I64u: Invalid tile byte count, tile %lu",
-				     (unsigned __int64) bytecount,
-				     (unsigned long) tile);
-#else
-			TIFFErrorExt(tif->tif_clientdata, module,
-				"%llu: Invalid tile byte count, tile %lu",
-				     (unsigned long long) bytecount,
-				     (unsigned long) tile);
-#endif
+				"%"PRIu64": Invalid tile byte count, tile %"PRIu32,
+				     bytecount,
+				     tile);
 			return (0);
 		}
 
@@ -1233,24 +1142,16 @@ TIFFFillTile(TIFF* tif, uint32 tile)
 			/* Hopefully they are safe enough for all codecs */
 			tmsize_t stripsize = TIFFTileSize(tif);
 			if( stripsize != 0 &&
-			    (bytecount - 4096) / 10 > (uint64)stripsize  )
+			    (bytecount - 4096) / 10 > (uint64_t)stripsize  )
 			{
-				uint64 newbytecount = (uint64)stripsize * 10 + 4096;
-				if( newbytecount == 0 || newbytecount > (uint64)TIFF_INT64_MAX )
+				uint64_t newbytecount = (uint64_t)stripsize * 10 + 4096;
+				if( newbytecount == 0 || newbytecount > (uint64_t)TIFF_INT64_MAX )
 				{
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
-					TIFFWarningExt(tif->tif_clientdata, module,
-					  "Too large tile byte count %I64u, tile %lu. Limiting to %I64u",
-					     (unsigned __int64) bytecount,
-					     (unsigned long) tile,
-					     (unsigned __int64) newbytecount);
-#else
 					TIFFErrorExt(tif->tif_clientdata, module,
-					  "Too large tile byte count %llu, tile %lu. Limiting to %llu",
-					     (unsigned long long) bytecount,
-					     (unsigned long) tile,
-					     (unsigned long long) newbytecount);
-#endif
+					  "Too large tile byte count %"PRIu64", tile %"PRIu32". Limiting to %"PRIu64,
+					     bytecount,
+					     tile,
+					     newbytecount);
 					bytecount = newbytecount;
 				}
 			}
@@ -1266,8 +1167,8 @@ TIFFFillTile(TIFF* tif, uint32 tile)
 			 * comparison (which can overflow) we do the following
 			 * two comparisons:
 			 */
-			if (bytecount > (uint64)tif->tif_size ||
-			    TIFFGetStrileOffset(tif, tile) > (uint64)tif->tif_size - bytecount) {
+			if (bytecount > (uint64_t)tif->tif_size ||
+			    TIFFGetStrileOffset(tif, tile) > (uint64_t)tif->tif_size - bytecount) {
 				tif->tif_curtile = NOTILE;
 				return (0);
 			}
@@ -1308,7 +1209,7 @@ TIFFFillTile(TIFF* tif, uint32 tile)
 			 */
 			tmsize_t bytecountm;
 			bytecountm=(tmsize_t)bytecount;
-			if ((uint64)bytecountm!=bytecount)
+			if ((uint64_t)bytecountm != bytecount)
 			{
 				TIFFErrorExt(tif->tif_clientdata,module,"Integer overflow");
 				return(0);
@@ -1317,8 +1218,8 @@ TIFFFillTile(TIFF* tif, uint32 tile)
 				tif->tif_curtile = NOTILE;
 				if ((tif->tif_flags & TIFF_MYBUFFER) == 0) {
 					TIFFErrorExt(tif->tif_clientdata, module,
-					    "Data buffer too small to hold tile %lu",
-					    (unsigned long) tile);
+					    "Data buffer too small to hold tile %"PRIu32,
+					    tile);
 					return (0);
 				}
 			}
@@ -1390,10 +1291,10 @@ TIFFReadBufferSetup(TIFF* tif, void* bp, tmsize_t size)
 	}
 	if (bp) {
 		tif->tif_rawdatasize = size;
-		tif->tif_rawdata = (uint8*) bp;
+		tif->tif_rawdata = (uint8_t*) bp;
 		tif->tif_flags &= ~TIFF_MYBUFFER;
 	} else {
-		tif->tif_rawdatasize = (tmsize_t)TIFFroundup_64((uint64)size, 1024);
+		tif->tif_rawdatasize = (tmsize_t)TIFFroundup_64((uint64_t)size, 1024);
 		if (tif->tif_rawdatasize==0) {
 		    TIFFErrorExt(tif->tif_clientdata, module,
 				 "Invalid buffer size");
@@ -1401,13 +1302,13 @@ TIFFReadBufferSetup(TIFF* tif, void* bp, tmsize_t size)
 		}
 		/* Initialize to zero to avoid uninitialized buffers in case of */
                 /* short reads (http://bugzilla.maptools.org/show_bug.cgi?id=2651) */
-		tif->tif_rawdata = (uint8*) _TIFFcalloc(1, tif->tif_rawdatasize);
+		tif->tif_rawdata = (uint8_t*) _TIFFcalloc(1, tif->tif_rawdatasize);
 		tif->tif_flags |= TIFF_MYBUFFER;
 	}
 	if (tif->tif_rawdata == NULL) {
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "No space for data buffer at scanline %lu",
-		    (unsigned long) tif->tif_row);
+		    "No space for data buffer at scanline %"PRIu32,
+		    tif->tif_row);
 		tif->tif_rawdatasize = 0;
 		return (0);
 	}
@@ -1419,7 +1320,7 @@ TIFFReadBufferSetup(TIFF* tif, void* bp, tmsize_t size)
  * strip has just been read in.
  */
 static int
-TIFFStartStrip(TIFF* tif, uint32 strip)
+TIFFStartStrip(TIFF* tif, uint32_t strip)
 {
 	TIFFDirectory *td = &tif->tif_dir;
 
@@ -1445,8 +1346,16 @@ TIFFStartStrip(TIFF* tif, uint32 strip)
 		else
 			tif->tif_rawcc = (tmsize_t)TIFFGetStrileByteCount(tif, strip);
 	}
-	return ((*tif->tif_predecode)(tif,
-			(uint16)(strip / td->td_stripsperimage)));
+	if ((*tif->tif_predecode)(tif,
+			(uint16_t)(strip / td->td_stripsperimage)) == 0 ) {
+            /* Needed for example for scanline access, if tif_predecode */
+            /* fails, and we try to read the same strip again. Without invalidating */
+            /* tif_curstrip, we'd call tif_decoderow() on a possibly invalid */
+            /* codec state. */
+            tif->tif_curstrip = NOSTRIP;
+            return 0;
+        }
+        return 1;
 }
 
 /*
@@ -1454,11 +1363,11 @@ TIFFStartStrip(TIFF* tif, uint32 strip)
  * tile has just been read in.
  */
 static int
-TIFFStartTile(TIFF* tif, uint32 tile)
+TIFFStartTile(TIFF* tif, uint32_t tile)
 {
         static const char module[] = "TIFFStartTile";
 	TIFFDirectory *td = &tif->tif_dir;
-        uint32 howmany32;
+        uint32_t howmany32;
 
 	if ((tif->tif_flags & TIFF_CODERSETUP) == 0) {
 		if (!(*tif->tif_setupdecode)(tif))
@@ -1493,7 +1402,7 @@ TIFFStartTile(TIFF* tif, uint32 tile)
 			tif->tif_rawcc = (tmsize_t)TIFFGetStrileByteCount(tif, tile);
 	}
 	return ((*tif->tif_predecode)(tif,
-			(uint16)(tile/td->td_stripsperimage)));
+			(uint16_t)(tile / td->td_stripsperimage)));
 }
 
 static int
@@ -1521,14 +1430,14 @@ TIFFCheckRead(TIFF* tif, int tiles)
  * inbuf content must be writable (if bit reversal is needed)
  * Returns 1 in case of success, 0 otherwise.
  */
-int      TIFFReadFromUserBuffer(TIFF* tif, uint32 strile,
+int      TIFFReadFromUserBuffer(TIFF* tif, uint32_t strile,
                                 void* inbuf, tmsize_t insize,
                                 void* outbuf, tmsize_t outsize)
 {
     static const char module[] = "TIFFReadFromUserBuffer";
     TIFFDirectory *td = &tif->tif_dir;
     int ret = 1;
-    uint32 old_tif_flags = tif->tif_flags;
+    uint32_t old_tif_flags = tif->tif_flags;
     tmsize_t old_rawdatasize = tif->tif_rawdatasize;
     void* old_rawdata = tif->tif_rawdata;
 
@@ -1559,29 +1468,29 @@ int      TIFFReadFromUserBuffer(TIFF* tif, uint32 strile,
     if( TIFFIsTiled(tif) )
     {
         if( !TIFFStartTile(tif, strile) ||
-            !(*tif->tif_decodetile)(tif, (uint8*) outbuf, outsize, 
-                                    (uint16)(strile/td->td_stripsperimage)) )
+            !(*tif->tif_decodetile)(tif, (uint8_t*) outbuf, outsize,
+                                    (uint16_t)(strile / td->td_stripsperimage)) )
         {
             ret = 0;
         }
     }
     else
     {
-        uint32 rowsperstrip=td->td_rowsperstrip;
-        uint32 stripsperplane;
+        uint32_t rowsperstrip=td->td_rowsperstrip;
+        uint32_t stripsperplane;
         if (rowsperstrip>td->td_imagelength)
             rowsperstrip=td->td_imagelength;
         stripsperplane= TIFFhowmany_32_maxuint_compat(td->td_imagelength, rowsperstrip);
         if( !TIFFStartStrip(tif, strile) ||
-            !(*tif->tif_decodestrip)(tif, (uint8*) outbuf, outsize, 
-                                     (uint16)(strile/stripsperplane)) )
+            !(*tif->tif_decodestrip)(tif, (uint8_t*) outbuf, outsize,
+                                     (uint16_t)(strile / stripsperplane)) )
         {
             ret = 0;
         }
     }
     if( ret )
     {
-        (*tif->tif_postdecode)(tif, (uint8*) outbuf, outsize);
+        (*tif->tif_postdecode)(tif, (uint8_t*) outbuf, outsize);
     }
 
     if (!isFillOrder(tif, td->td_fillorder) &&
@@ -1600,37 +1509,37 @@ int      TIFFReadFromUserBuffer(TIFF* tif, uint32 strile,
 }
 
 void
-_TIFFNoPostDecode(TIFF* tif, uint8* buf, tmsize_t cc)
+_TIFFNoPostDecode(TIFF* tif, uint8_t* buf, tmsize_t cc)
 {
     (void) tif; (void) buf; (void) cc;
 }
 
 void
-_TIFFSwab16BitData(TIFF* tif, uint8* buf, tmsize_t cc)
+_TIFFSwab16BitData(TIFF* tif, uint8_t* buf, tmsize_t cc)
 {
     (void) tif;
     assert((cc & 1) == 0);
-    TIFFSwabArrayOfShort((uint16*) buf, cc/2);
+    TIFFSwabArrayOfShort((uint16_t*) buf, cc / 2);
 }
 
 void
-_TIFFSwab24BitData(TIFF* tif, uint8* buf, tmsize_t cc)
+_TIFFSwab24BitData(TIFF* tif, uint8_t* buf, tmsize_t cc)
 {
     (void) tif;
     assert((cc % 3) == 0);
-    TIFFSwabArrayOfTriples((uint8*) buf, cc/3);
+    TIFFSwabArrayOfTriples((uint8_t*) buf, cc / 3);
 }
 
 void
-_TIFFSwab32BitData(TIFF* tif, uint8* buf, tmsize_t cc)
+_TIFFSwab32BitData(TIFF* tif, uint8_t* buf, tmsize_t cc)
 {
     (void) tif;
     assert((cc & 3) == 0);
-    TIFFSwabArrayOfLong((uint32*) buf, cc/4);
+    TIFFSwabArrayOfLong((uint32_t*) buf, cc / 4);
 }
 
 void
-_TIFFSwab64BitData(TIFF* tif, uint8* buf, tmsize_t cc)
+_TIFFSwab64BitData(TIFF* tif, uint8_t* buf, tmsize_t cc)
 {
     (void) tif;
     assert((cc & 7) == 0);
diff --git a/src/3rdparty/libtiff/libtiff/tif_stream.cxx b/src/3rdparty/libtiff/libtiff/tif_stream.cxx
index 7f640a9..ea22416 100644
--- a/src/3rdparty/libtiff/libtiff/tif_stream.cxx
+++ b/src/3rdparty/libtiff/libtiff/tif_stream.cxx
@@ -28,9 +28,7 @@
 #include "tiffiop.h"
 #include <iostream>
 
-#ifndef __VMS
 using namespace std;
-#endif
 
 /*
   ISO C++ uses a 'std::streamsize' type to define counts.  This makes
@@ -82,10 +80,10 @@ extern "C" {
 	static tmsize_t _tiffisReadProc(thandle_t fd, void* buf, tmsize_t size);
 	static tmsize_t _tiffosWriteProc(thandle_t fd, void* buf, tmsize_t size);
 	static tmsize_t _tiffisWriteProc(thandle_t, void*, tmsize_t);
-	static uint64   _tiffosSeekProc(thandle_t fd, uint64 off, int whence);
-	static uint64   _tiffisSeekProc(thandle_t fd, uint64 off, int whence);
-	static uint64   _tiffosSizeProc(thandle_t fd);
-	static uint64   _tiffisSizeProc(thandle_t fd);
+	static uint64_t   _tiffosSeekProc(thandle_t fd, uint64_t off, int whence);
+	static uint64_t   _tiffisSeekProc(thandle_t fd, uint64_t off, int whence);
+	static uint64_t   _tiffosSizeProc(thandle_t fd);
+	static uint64_t   _tiffisSizeProc(thandle_t fd);
 	static int      _tiffosCloseProc(thandle_t fd);
 	static int      _tiffisCloseProc(thandle_t fd);
 	static int 	_tiffDummyMapProc(thandle_t , void** base, toff_t* size );
@@ -148,26 +146,26 @@ _tiffisWriteProc(thandle_t, void*, tmsize_t)
 	return 0;
 }
 
-static uint64
-_tiffosSeekProc(thandle_t fd, uint64 off, int whence)
+static uint64_t
+_tiffosSeekProc(thandle_t fd, uint64_t off, int whence)
 {
 	tiffos_data	*data = reinterpret_cast<tiffos_data *>(fd);
 	ostream		*os = data->stream;
 
 	// if the stream has already failed, don't do anything
 	if( os->fail() )
-		return static_cast<uint64>(-1);
+		return static_cast<uint64_t>(-1);
 
 	switch(whence) {
 	case SEEK_SET:
 		{
 			// Compute 64-bit offset
-			uint64 new_offset = static_cast<uint64>(data->start_pos) + off;
+			uint64_t new_offset = static_cast<uint64_t>(data->start_pos) + off;
 
 			// Verify that value does not overflow
 			ios::off_type offset = static_cast<ios::off_type>(new_offset);
-			if (static_cast<uint64>(offset) != new_offset)
-				return static_cast<uint64>(-1);
+			if (static_cast<uint64_t>(offset) != new_offset)
+				return static_cast<uint64_t>(-1);
 			
 			os->seekp(offset, ios::beg);
 		break;
@@ -176,8 +174,8 @@ _tiffosSeekProc(thandle_t fd, uint64 off, int whence)
 		{
 			// Verify that value does not overflow
 			ios::off_type offset = static_cast<ios::off_type>(off);
-			if (static_cast<uint64>(offset) != off)
-				return static_cast<uint64>(-1);
+			if (static_cast<uint64_t>(offset) != off)
+				return static_cast<uint64_t>(-1);
 
 			os->seekp(offset, ios::cur);
 			break;
@@ -186,8 +184,8 @@ _tiffosSeekProc(thandle_t fd, uint64 off, int whence)
 		{
 			// Verify that value does not overflow
 			ios::off_type offset = static_cast<ios::off_type>(off);
-			if (static_cast<uint64>(offset) != off)
-				return static_cast<uint64>(-1);
+			if (static_cast<uint64_t>(offset) != off)
+				return static_cast<uint64_t>(-1);
 
 			os->seekp(offset, ios::end);
 			break;
@@ -199,11 +197,7 @@ _tiffosSeekProc(thandle_t fd, uint64 off, int whence)
 	// ostrstream/ostringstream does. In that situation, add intermediate
 	// '\0' characters.
 	if( os->fail() ) {
-#ifdef __VMS
-		int		old_state;
-#else
 		ios::iostate	old_state;
-#endif
 		ios::pos_type	origin;
 
 		old_state = os->rdstate();
@@ -226,28 +220,28 @@ _tiffosSeekProc(thandle_t fd, uint64 off, int whence)
 		os->clear(old_state);	
 
 		// only do something if desired seek position is valid
-		if( (static_cast<uint64>(origin) + off) > static_cast<uint64>(data->start_pos) ) {
-			uint64	num_fill;
+		if((static_cast<uint64_t>(origin) + off) > static_cast<uint64_t>(data->start_pos) ) {
+			uint64_t	num_fill;
 
 			// clear the fail bit 
 			os->clear(os->rdstate() & ~ios::failbit);
 
 			// extend the stream to the expected size
 			os->seekp(0, ios::end);
-			num_fill = (static_cast<uint64>(origin)) + off - os->tellp();
-			for( uint64 i = 0; i < num_fill; i++ )
+			num_fill = (static_cast<uint64_t>(origin)) + off - os->tellp();
+			for(uint64_t i = 0; i < num_fill; i++ )
 				os->put('\0');
 
 			// retry the seek
-			os->seekp(static_cast<ios::off_type>(static_cast<uint64>(origin) + off), ios::beg);
+			os->seekp(static_cast<ios::off_type>(static_cast<uint64_t>(origin) + off), ios::beg);
 		}
 	}
 
-	return static_cast<uint64>(os->tellp());
+	return static_cast<uint64_t>(os->tellp());
 }
 
-static uint64
-_tiffisSeekProc(thandle_t fd, uint64 off, int whence)
+static uint64_t
+_tiffisSeekProc(thandle_t fd, uint64_t off, int whence)
 {
 	tiffis_data	*data = reinterpret_cast<tiffis_data *>(fd);
 
@@ -255,12 +249,12 @@ _tiffisSeekProc(thandle_t fd, uint64 off, int whence)
 	case SEEK_SET:
 		{
 			// Compute 64-bit offset
-			uint64 new_offset = static_cast<uint64>(data->start_pos) + off;
+			uint64_t new_offset = static_cast<uint64_t>(data->start_pos) + off;
 			
 			// Verify that value does not overflow
 			ios::off_type offset = static_cast<ios::off_type>(new_offset);
-			if (static_cast<uint64>(offset) != new_offset)
-				return static_cast<uint64>(-1);
+			if (static_cast<uint64_t>(offset) != new_offset)
+				return static_cast<uint64_t>(-1);
 
 			data->stream->seekg(offset, ios::beg);
 			break;
@@ -269,8 +263,8 @@ _tiffisSeekProc(thandle_t fd, uint64 off, int whence)
 		{
 			// Verify that value does not overflow
 			ios::off_type offset = static_cast<ios::off_type>(off);
-			if (static_cast<uint64>(offset) != off)
-				return static_cast<uint64>(-1);
+			if (static_cast<uint64_t>(offset) != off)
+				return static_cast<uint64_t>(-1);
 
 			data->stream->seekg(offset, ios::cur);
 			break;
@@ -279,18 +273,18 @@ _tiffisSeekProc(thandle_t fd, uint64 off, int whence)
 		{
 			// Verify that value does not overflow
 			ios::off_type offset = static_cast<ios::off_type>(off);
-			if (static_cast<uint64>(offset) != off)
-				return static_cast<uint64>(-1);
+			if (static_cast<uint64_t>(offset) != off)
+				return static_cast<uint64_t>(-1);
 
 			data->stream->seekg(offset, ios::end);
 			break;
 		}
 	}
 
-	return (uint64) (data->stream->tellg() - data->start_pos);
+	return (uint64_t) (data->stream->tellg() - data->start_pos);
 }
 
-static uint64
+static uint64_t
 _tiffosSizeProc(thandle_t fd)
 {
 	tiffos_data	*data = reinterpret_cast<tiffos_data *>(fd);
@@ -302,10 +296,10 @@ _tiffosSizeProc(thandle_t fd)
 	len = os->tellp();
 	os->seekp(pos);
 
-	return (uint64) len;
+	return (uint64_t) len;
 }
 
-static uint64
+static uint64_t
 _tiffisSizeProc(thandle_t fd)
 {
 	tiffis_data	*data = reinterpret_cast<tiffis_data *>(fd);
@@ -316,7 +310,7 @@ _tiffisSizeProc(thandle_t fd)
 	len = data->stream->tellg();
 	data->stream->seekg(pos);
 
-	return (uint64) len;
+	return (uint64_t) len;
 }
 
 static int
diff --git a/src/3rdparty/libtiff/libtiff/tif_strip.c b/src/3rdparty/libtiff/libtiff/tif_strip.c
index c08c60a..d7b2752 100644
--- a/src/3rdparty/libtiff/libtiff/tif_strip.c
+++ b/src/3rdparty/libtiff/libtiff/tif_strip.c
@@ -32,12 +32,12 @@
 /*
  * Compute which strip a (row,sample) value is in.
  */
-uint32
-TIFFComputeStrip(TIFF* tif, uint32 row, uint16 sample)
+uint32_t
+TIFFComputeStrip(TIFF* tif, uint32_t row, uint16_t sample)
 {
 	static const char module[] = "TIFFComputeStrip";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint32 strip;
+	uint32_t strip;
 
 	strip = row / td->td_rowsperstrip;
 	if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
@@ -47,7 +47,7 @@ TIFFComputeStrip(TIFF* tif, uint32 row, uint16 sample)
 			    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);
 			return (0);
 		}
-		strip += (uint32)sample*td->td_stripsperimage;
+		strip += (uint32_t)sample * td->td_stripsperimage;
 	}
 	return (strip);
 }
@@ -55,16 +55,16 @@ TIFFComputeStrip(TIFF* tif, uint32 row, uint16 sample)
 /*
  * Compute how many strips are in an image.
  */
-uint32
+uint32_t
 TIFFNumberOfStrips(TIFF* tif)
 {
 	TIFFDirectory *td = &tif->tif_dir;
-	uint32 nstrips;
+	uint32_t nstrips;
 
-	nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :
-	     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));
+	nstrips = (td->td_rowsperstrip == (uint32_t) -1 ? 1 :
+               TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));
 	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
-		nstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,
+		nstrips = _TIFFMultiply32(tif, nstrips, (uint32_t)td->td_samplesperpixel,
 		    "TIFFNumberOfStrips");
 	return (nstrips);
 }
@@ -72,12 +72,12 @@ TIFFNumberOfStrips(TIFF* tif)
 /*
  * Compute the # bytes in a variable height, row-aligned strip.
  */
-uint64
-TIFFVStripSize64(TIFF* tif, uint32 nrows)
+uint64_t
+TIFFVStripSize64(TIFF* tif, uint32_t nrows)
 {
 	static const char module[] = "TIFFVStripSize64";
 	TIFFDirectory *td = &tif->tif_dir;
-	if (nrows==(uint32)(-1))
+	if (nrows==(uint32_t)(-1))
 		nrows=td->td_imagelength;
 	if ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&
 	    (td->td_photometric == PHOTOMETRIC_YCBCR)&&
@@ -91,12 +91,12 @@ TIFFVStripSize64(TIFF* tif, uint32 nrows)
 		 * horizontal/vertical subsampling area include
 		 * YCbCr data for the extended image.
 		 */
-		uint16 ycbcrsubsampling[2];
-		uint16 samplingblock_samples;
-		uint32 samplingblocks_hor;
-		uint32 samplingblocks_ver;
-		uint64 samplingrow_samples;
-		uint64 samplingrow_size;
+		uint16_t ycbcrsubsampling[2];
+		uint16_t samplingblock_samples;
+		uint32_t samplingblocks_hor;
+		uint32_t samplingblocks_ver;
+		uint64_t samplingrow_samples;
+		uint64_t samplingrow_size;
 		if(td->td_samplesperpixel!=3)
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,
@@ -125,10 +125,10 @@ TIFFVStripSize64(TIFF* tif, uint32 nrows)
 		return(_TIFFMultiply64(tif,nrows,TIFFScanlineSize64(tif),module));
 }
 tmsize_t
-TIFFVStripSize(TIFF* tif, uint32 nrows)
+TIFFVStripSize(TIFF* tif, uint32_t nrows)
 {
 	static const char module[] = "TIFFVStripSize";
-	uint64 m;
+	uint64_t m;
 	m=TIFFVStripSize64(tif,nrows);
         return _TIFFCastUInt64ToSSize(tif, m, module);
 }
@@ -136,43 +136,36 @@ TIFFVStripSize(TIFF* tif, uint32 nrows)
 /*
  * Compute the # bytes in a raw strip.
  */
-uint64
-TIFFRawStripSize64(TIFF* tif, uint32 strip)
+uint64_t
+TIFFRawStripSize64(TIFF* tif, uint32_t strip)
 {
 	static const char module[] = "TIFFRawStripSize64";
-	uint64 bytecount = TIFFGetStrileByteCount(tif, strip);
+	uint64_t bytecount = TIFFGetStrileByteCount(tif, strip);
 
 	if (bytecount == 0)
 	{
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
-			     "%I64u: Invalid strip byte count, strip %lu",
-			     (unsigned __int64) bytecount,
+			     "%"PRIu64": Invalid strip byte count, strip %lu",
+			     (uint64_t) bytecount,
 			     (unsigned long) strip);
-#else
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "%llu: Invalid strip byte count, strip %lu",
-			     (unsigned long long) bytecount,
-			     (unsigned long) strip);
-#endif
-		bytecount = (uint64) -1;
+		bytecount = (uint64_t) -1;
 	}
 
 	return bytecount;
 }
 tmsize_t
-TIFFRawStripSize(TIFF* tif, uint32 strip)
+TIFFRawStripSize(TIFF* tif, uint32_t strip)
 {
 	static const char module[] = "TIFFRawStripSize";
-	uint64 m;
+	uint64_t m;
 	tmsize_t n;
 	m=TIFFRawStripSize64(tif,strip);
-	if (m==(uint64)(-1))
+	if (m==(uint64_t)(-1))
 		n=(tmsize_t)(-1);
 	else
 	{
 		n=(tmsize_t)m;
-		if ((uint64)n!=m)
+		if ((uint64_t)n != m)
 		{
 			TIFFErrorExt(tif->tif_clientdata,module,"Integer overflow");
 			n=0;
@@ -189,11 +182,11 @@ TIFFRawStripSize(TIFF* tif, uint32 strip)
  * truncated to reflect the actual space required
  * to hold the strip.
  */
-uint64
+uint64_t
 TIFFStripSize64(TIFF* tif)
 {
 	TIFFDirectory* td = &tif->tif_dir;
-	uint32 rps = td->td_rowsperstrip;
+	uint32_t rps = td->td_rowsperstrip;
 	if (rps > td->td_imagelength)
 		rps = td->td_imagelength;
 	return (TIFFVStripSize64(tif, rps));
@@ -202,7 +195,7 @@ tmsize_t
 TIFFStripSize(TIFF* tif)
 {
 	static const char module[] = "TIFFStripSize";
-	uint64 m;
+	uint64_t m;
 	m=TIFFStripSize64(tif);
 	return _TIFFCastUInt64ToSSize(tif, m, module);
 }
@@ -213,32 +206,32 @@ TIFFStripSize(TIFF* tif)
  * request is <1 then we choose a strip size according
  * to certain heuristics.
  */
-uint32
-TIFFDefaultStripSize(TIFF* tif, uint32 request)
+uint32_t
+TIFFDefaultStripSize(TIFF* tif, uint32_t request)
 {
 	return (*tif->tif_defstripsize)(tif, request);
 }
 
-uint32
-_TIFFDefaultStripSize(TIFF* tif, uint32 s)
+uint32_t
+_TIFFDefaultStripSize(TIFF* tif, uint32_t s)
 {
-	if ((int32) s < 1) {
+	if ((int32_t) s < 1) {
 		/*
 		 * If RowsPerStrip is unspecified, try to break the
 		 * image up into strips that are approximately
 		 * STRIP_SIZE_DEFAULT bytes long.
 		 */
-		uint64 scanlinesize;
-		uint64 rows;
+		uint64_t scanlinesize;
+		uint64_t rows;
 		scanlinesize=TIFFScanlineSize64(tif);
 		if (scanlinesize==0)
 			scanlinesize=1;
-		rows=(uint64)STRIP_SIZE_DEFAULT/scanlinesize;
+		rows= (uint64_t)STRIP_SIZE_DEFAULT / scanlinesize;
 		if (rows==0)
 			rows=1;
 		else if (rows>0xFFFFFFFF)
 			rows=0xFFFFFFFF;
-		s=(uint32)rows;
+		s=(uint32_t)rows;
 	}
 	return (s);
 }
@@ -253,23 +246,23 @@ _TIFFDefaultStripSize(TIFF* tif, uint32 s)
  * subsampling lines divided by vertical subsampling. It should thus make
  * sense when multiplied by a multiple of vertical subsampling.
  */
-uint64
+uint64_t
 TIFFScanlineSize64(TIFF* tif)
 {
 	static const char module[] = "TIFFScanlineSize64";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint64 scanline_size;
+	uint64_t scanline_size;
 	if (td->td_planarconfig==PLANARCONFIG_CONTIG)
 	{
 		if ((td->td_photometric==PHOTOMETRIC_YCBCR)&&
 		    (td->td_samplesperpixel==3)&&
 		    (!isUpSampled(tif)))
 		{
-			uint16 ycbcrsubsampling[2];
-			uint16 samplingblock_samples;
-			uint32 samplingblocks_hor;
-			uint64 samplingrow_samples;
-			uint64 samplingrow_size;
+			uint16_t ycbcrsubsampling[2];
+			uint16_t samplingblock_samples;
+			uint32_t samplingblocks_hor;
+			uint64_t samplingrow_samples;
+			uint64_t samplingrow_size;
 			if(td->td_samplesperpixel!=3)
 			{
                             TIFFErrorExt(tif->tif_clientdata,module,
@@ -294,7 +287,7 @@ TIFFScanlineSize64(TIFF* tif)
 		}
 		else
 		{
-			uint64 scanline_samples;
+			uint64_t scanline_samples;
 			scanline_samples=_TIFFMultiply64(tif,td->td_imagewidth,td->td_samplesperpixel,module);
 			scanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,scanline_samples,td->td_bitspersample,module),8);
 		}
@@ -314,7 +307,7 @@ tmsize_t
 TIFFScanlineSize(TIFF* tif)
 {
 	static const char module[] = "TIFFScanlineSize";
-	uint64 m;
+	uint64_t m;
 	m=TIFFScanlineSize64(tif);
 	return _TIFFCastUInt64ToSSize(tif, m, module);
 }
@@ -325,12 +318,12 @@ TIFFScanlineSize(TIFF* tif)
  * I/O size returned by TIFFScanlineSize which may be less
  * if data is store as separate planes).
  */
-uint64
+uint64_t
 TIFFRasterScanlineSize64(TIFF* tif)
 {
 	static const char module[] = "TIFFRasterScanlineSize64";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint64 scanline;
+	uint64_t scanline;
 
 	scanline = _TIFFMultiply64(tif, td->td_bitspersample, td->td_imagewidth, module);
 	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
@@ -344,7 +337,7 @@ tmsize_t
 TIFFRasterScanlineSize(TIFF* tif)
 {
 	static const char module[] = "TIFFRasterScanlineSize";
-	uint64 m;
+	uint64_t m;
 	m=TIFFRasterScanlineSize64(tif);
 	return _TIFFCastUInt64ToSSize(tif, m, module);
 }
diff --git a/src/3rdparty/libtiff/libtiff/tif_swab.c b/src/3rdparty/libtiff/libtiff/tif_swab.c
index b174ba6..3d4bb6c 100644
--- a/src/3rdparty/libtiff/libtiff/tif_swab.c
+++ b/src/3rdparty/libtiff/libtiff/tif_swab.c
@@ -31,22 +31,22 @@
 
 #if defined(DISABLE_CHECK_TIFFSWABMACROS) || !defined(TIFFSwabShort)
 void
-TIFFSwabShort(uint16* wp)
+TIFFSwabShort(uint16_t* wp)
 {
 	register unsigned char* cp = (unsigned char*) wp;
 	unsigned char t;
-	assert(sizeof(uint16)==2);
+	assert(sizeof(uint16_t) == 2);
 	t = cp[1]; cp[1] = cp[0]; cp[0] = t;
 }
 #endif
 
 #if defined(DISABLE_CHECK_TIFFSWABMACROS) || !defined(TIFFSwabLong)
 void
-TIFFSwabLong(uint32* lp)
+TIFFSwabLong(uint32_t* lp)
 {
 	register unsigned char* cp = (unsigned char*) lp;
 	unsigned char t;
-	assert(sizeof(uint32)==4);
+	assert(sizeof(uint32_t) == 4);
 	t = cp[3]; cp[3] = cp[0]; cp[0] = t;
 	t = cp[2]; cp[2] = cp[1]; cp[1] = t;
 }
@@ -54,11 +54,11 @@ TIFFSwabLong(uint32* lp)
 
 #if defined(DISABLE_CHECK_TIFFSWABMACROS) || !defined(TIFFSwabLong8)
 void
-TIFFSwabLong8(uint64* lp)
+TIFFSwabLong8(uint64_t* lp)
 {
 	register unsigned char* cp = (unsigned char*) lp;
 	unsigned char t;
-	assert(sizeof(uint64)==8);
+	assert(sizeof(uint64_t) == 8);
 	t = cp[7]; cp[7] = cp[0]; cp[0] = t;
 	t = cp[6]; cp[6] = cp[1]; cp[1] = t;
 	t = cp[5]; cp[5] = cp[2]; cp[2] = t;
@@ -68,11 +68,11 @@ TIFFSwabLong8(uint64* lp)
 
 #if defined(DISABLE_CHECK_TIFFSWABMACROS) || !defined(TIFFSwabArrayOfShort)
 void
-TIFFSwabArrayOfShort(register uint16* wp, tmsize_t n)
+TIFFSwabArrayOfShort(register uint16_t* wp, tmsize_t n)
 {
 	register unsigned char* cp;
 	register unsigned char t;
-	assert(sizeof(uint16)==2);
+	assert(sizeof(uint16_t) == 2);
 	/* XXX unroll loop some */
 	while (n-- > 0) {
 		cp = (unsigned char*) wp;
@@ -84,7 +84,7 @@ TIFFSwabArrayOfShort(register uint16* wp, tmsize_t n)
 
 #if defined(DISABLE_CHECK_TIFFSWABMACROS) || !defined(TIFFSwabArrayOfTriples)
 void
-TIFFSwabArrayOfTriples(register uint8* tp, tmsize_t n)
+TIFFSwabArrayOfTriples(register uint8_t* tp, tmsize_t n)
 {
 	unsigned char* cp;
 	unsigned char t;
@@ -100,11 +100,11 @@ TIFFSwabArrayOfTriples(register uint8* tp, tmsize_t n)
 
 #if defined(DISABLE_CHECK_TIFFSWABMACROS) || !defined(TIFFSwabArrayOfLong)
 void
-TIFFSwabArrayOfLong(register uint32* lp, tmsize_t n)
+TIFFSwabArrayOfLong(register uint32_t* lp, tmsize_t n)
 {
 	register unsigned char *cp;
 	register unsigned char t;
-	assert(sizeof(uint32)==4);
+	assert(sizeof(uint32_t) == 4);
 	/* XXX unroll loop some */
 	while (n-- > 0) {
 		cp = (unsigned char *)lp;
@@ -117,11 +117,11 @@ TIFFSwabArrayOfLong(register uint32* lp, tmsize_t n)
 
 #if defined(DISABLE_CHECK_TIFFSWABMACROS) || !defined(TIFFSwabArrayOfLong8)
 void
-TIFFSwabArrayOfLong8(register uint64* lp, tmsize_t n)
+TIFFSwabArrayOfLong8(register uint64_t* lp, tmsize_t n)
 {
 	register unsigned char *cp;
 	register unsigned char t;
-	assert(sizeof(uint64)==8);
+	assert(sizeof(uint64_t) == 8);
 	/* XXX unroll loop some */
 	while (n-- > 0) {
 		cp = (unsigned char *)lp;
@@ -281,7 +281,7 @@ TIFFGetBitRevTable(int reversed)
 }
 
 void
-TIFFReverseBits(uint8* cp, tmsize_t n)  
+TIFFReverseBits(uint8_t* cp, tmsize_t n)
 {
 	for (; n > 8; n -= 8) {
 		cp[0] = TIFFBitRevTable[cp[0]];
diff --git a/src/3rdparty/libtiff/libtiff/tif_thunder.c b/src/3rdparty/libtiff/libtiff/tif_thunder.c
index db6383a..3e703d8 100644
--- a/src/3rdparty/libtiff/libtiff/tif_thunder.c
+++ b/src/3rdparty/libtiff/libtiff/tif_thunder.c
@@ -61,7 +61,7 @@ static const int threebitdeltas[8] = { 0, 1, 2, 3, 0, -3, -2, -1 };
 	  if (npixels++ & 1)                  \
 	    *op++ |= lastpixel;               \
 	  else                                \
-	    op[0] = (uint8) (lastpixel << 4); \
+	    op[0] = (uint8_t) (lastpixel << 4); \
         }                                     \
 }
 
@@ -83,7 +83,7 @@ ThunderSetupDecode(TIFF* tif)
 }
 
 static int
-ThunderDecode(TIFF* tif, uint8* op, tmsize_t maxpixels)
+ThunderDecode(TIFF* tif, uint8_t* op, tmsize_t maxpixels)
 {
 	static const char module[] = "ThunderDecode";
 	register unsigned char *bp;
@@ -114,7 +114,7 @@ ThunderDecode(TIFF* tif, uint8* op, tmsize_t maxpixels)
 			npixels += n;
 			if (npixels < maxpixels) {
 				for (; n > 0; n -= 2)
-					*op++ = (uint8) lastpixel;
+					*op++ = (uint8_t) lastpixel;
 			}
 			if (n == -1)
 				*--op &= 0xf0;
@@ -139,24 +139,15 @@ ThunderDecode(TIFF* tif, uint8* op, tmsize_t maxpixels)
 			break;
 		}
 	}
-	tif->tif_rawcp = (uint8*) bp;
+	tif->tif_rawcp = (uint8_t*) bp;
 	tif->tif_rawcc = cc;
 	if (npixels != maxpixels) {
-#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
-			     "%s data at scanline %lu (%I64u != %I64u)",
+			     "%s data at scanline %lu (%"PRIu64" != %"PRIu64")",
 			     npixels < maxpixels ? "Not enough" : "Too much",
 			     (unsigned long) tif->tif_row,
-			     (unsigned __int64) npixels,
-			     (unsigned __int64) maxpixels);
-#else
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "%s data at scanline %lu (%llu != %llu)",
-			     npixels < maxpixels ? "Not enough" : "Too much",
-			     (unsigned long) tif->tif_row,
-			     (unsigned long long) npixels,
-			     (unsigned long long) maxpixels);
-#endif
+			     (uint64_t) npixels,
+			     (uint64_t) maxpixels);
 		return (0);
 	}
 
@@ -164,10 +155,10 @@ ThunderDecode(TIFF* tif, uint8* op, tmsize_t maxpixels)
 }
 
 static int
-ThunderDecodeRow(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
+ThunderDecodeRow(TIFF* tif, uint8_t* buf, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "ThunderDecodeRow";
-	uint8* row = buf;
+	uint8_t* row = buf;
 	
 	(void) s;
 	if (occ % tif->tif_scanlinesize)
diff --git a/src/3rdparty/libtiff/libtiff/tif_tile.c b/src/3rdparty/libtiff/libtiff/tif_tile.c
index 661cc77..058be9f 100644
--- a/src/3rdparty/libtiff/libtiff/tif_tile.c
+++ b/src/3rdparty/libtiff/libtiff/tif_tile.c
@@ -32,27 +32,27 @@
 /*
  * Compute which tile an (x,y,z,s) value is in.
  */
-uint32
-TIFFComputeTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s)
+uint32_t
+TIFFComputeTile(TIFF* tif, uint32_t x, uint32_t y, uint32_t z, uint16_t s)
 {
 	TIFFDirectory *td = &tif->tif_dir;
-	uint32 dx = td->td_tilewidth;
-	uint32 dy = td->td_tilelength;
-	uint32 dz = td->td_tiledepth;
-	uint32 tile = 1;
+	uint32_t dx = td->td_tilewidth;
+	uint32_t dy = td->td_tilelength;
+	uint32_t dz = td->td_tiledepth;
+	uint32_t tile = 1;
 
 	if (td->td_imagedepth == 1)
 		z = 0;
-	if (dx == (uint32) -1)
+	if (dx == (uint32_t) -1)
 		dx = td->td_imagewidth;
-	if (dy == (uint32) -1)
+	if (dy == (uint32_t) -1)
 		dy = td->td_imagelength;
-	if (dz == (uint32) -1)
+	if (dz == (uint32_t) -1)
 		dz = td->td_imagedepth;
 	if (dx != 0 && dy != 0 && dz != 0) {
-		uint32 xpt = TIFFhowmany_32(td->td_imagewidth, dx);
-		uint32 ypt = TIFFhowmany_32(td->td_imagelength, dy);
-		uint32 zpt = TIFFhowmany_32(td->td_imagedepth, dz);
+		uint32_t xpt = TIFFhowmany_32(td->td_imagewidth, dx);
+		uint32_t ypt = TIFFhowmany_32(td->td_imagelength, dy);
+		uint32_t zpt = TIFFhowmany_32(td->td_imagedepth, dz);
 
 		if (td->td_planarconfig == PLANARCONFIG_SEPARATE) 
 			tile = (xpt*ypt*zpt)*s +
@@ -70,7 +70,7 @@ TIFFComputeTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s)
  * against the image bounds.
  */
 int
-TIFFCheckTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s)
+TIFFCheckTile(TIFF* tif, uint32_t x, uint32_t y, uint32_t z, uint16_t s)
 {
 	TIFFDirectory *td = &tif->tif_dir;
 
@@ -109,20 +109,20 @@ TIFFCheckTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s)
 /*
  * Compute how many tiles are in an image.
  */
-uint32
+uint32_t
 TIFFNumberOfTiles(TIFF* tif)
 {
 	TIFFDirectory *td = &tif->tif_dir;
-	uint32 dx = td->td_tilewidth;
-	uint32 dy = td->td_tilelength;
-	uint32 dz = td->td_tiledepth;
-	uint32 ntiles;
+	uint32_t dx = td->td_tilewidth;
+	uint32_t dy = td->td_tilelength;
+	uint32_t dz = td->td_tiledepth;
+	uint32_t ntiles;
 
-	if (dx == (uint32) -1)
+	if (dx == (uint32_t) -1)
 		dx = td->td_imagewidth;
-	if (dy == (uint32) -1)
+	if (dy == (uint32_t) -1)
 		dy = td->td_imagelength;
-	if (dz == (uint32) -1)
+	if (dz == (uint32_t) -1)
 		dz = td->td_imagedepth;
 	ntiles = (dx == 0 || dy == 0 || dz == 0) ? 0 :
 	    _TIFFMultiply32(tif, _TIFFMultiply32(tif, TIFFhowmany_32(td->td_imagewidth, dx),
@@ -138,13 +138,13 @@ TIFFNumberOfTiles(TIFF* tif)
 /*
  * Compute the # bytes in each row of a tile.
  */
-uint64
+uint64_t
 TIFFTileRowSize64(TIFF* tif)
 {
         static const char module[] = "TIFFTileRowSize64";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint64 rowsize;
-	uint64 tilerowsize;
+	uint64_t rowsize;
+	uint64_t tilerowsize;
 
 	if (td->td_tilelength == 0)
         {
@@ -180,7 +180,7 @@ tmsize_t
 TIFFTileRowSize(TIFF* tif)
 {
 	static const char module[] = "TIFFTileRowSize";
-	uint64 m;
+	uint64_t m;
 	m=TIFFTileRowSize64(tif);
 	return _TIFFCastUInt64ToSSize(tif, m, module);
 }
@@ -188,8 +188,8 @@ TIFFTileRowSize(TIFF* tif)
 /*
  * Compute the # bytes in a variable length, row-aligned tile.
  */
-uint64
-TIFFVTileSize64(TIFF* tif, uint32 nrows)
+uint64_t
+TIFFVTileSize64(TIFF* tif, uint32_t nrows)
 {
 	static const char module[] = "TIFFVTileSize64";
 	TIFFDirectory *td = &tif->tif_dir;
@@ -209,12 +209,12 @@ TIFFVTileSize64(TIFF* tif, uint32 nrows)
 		 * horizontal/vertical subsampling area include
 		 * YCbCr data for the extended image.
 		 */
-		uint16 ycbcrsubsampling[2];
-		uint16 samplingblock_samples;
-		uint32 samplingblocks_hor;
-		uint32 samplingblocks_ver;
-		uint64 samplingrow_samples;
-		uint64 samplingrow_size;
+		uint16_t ycbcrsubsampling[2];
+		uint16_t samplingblock_samples;
+		uint32_t samplingblocks_hor;
+		uint32_t samplingblocks_ver;
+		uint64_t samplingrow_samples;
+		uint64_t samplingrow_size;
 		TIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,
 		    ycbcrsubsampling+1);
 		if ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 && ycbcrsubsampling[0] != 4)
@@ -237,10 +237,10 @@ TIFFVTileSize64(TIFF* tif, uint32 nrows)
 		return(_TIFFMultiply64(tif,nrows,TIFFTileRowSize64(tif),module));
 }
 tmsize_t
-TIFFVTileSize(TIFF* tif, uint32 nrows)
+TIFFVTileSize(TIFF* tif, uint32_t nrows)
 {
 	static const char module[] = "TIFFVTileSize";
-	uint64 m;
+	uint64_t m;
 	m=TIFFVTileSize64(tif,nrows);
 	return _TIFFCastUInt64ToSSize(tif, m, module);
 }
@@ -248,7 +248,7 @@ TIFFVTileSize(TIFF* tif, uint32 nrows)
 /*
  * Compute the # bytes in a row-aligned tile.
  */
-uint64
+uint64_t
 TIFFTileSize64(TIFF* tif)
 {
 	return (TIFFVTileSize64(tif, tif->tif_dir.td_tilelength));
@@ -257,7 +257,7 @@ tmsize_t
 TIFFTileSize(TIFF* tif)
 {
 	static const char module[] = "TIFFTileSize";
-	uint64 m;
+	uint64_t m;
 	m=TIFFTileSize64(tif);
 	return _TIFFCastUInt64ToSSize(tif, m, module);
 }
@@ -269,18 +269,18 @@ TIFFTileSize(TIFF* tif)
  * to certain heuristics.
  */
 void
-TIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)
+TIFFDefaultTileSize(TIFF* tif, uint32_t* tw, uint32_t* th)
 {
 	(*tif->tif_deftilesize)(tif, tw, th);
 }
 
 void
-_TIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)
+_TIFFDefaultTileSize(TIFF* tif, uint32_t* tw, uint32_t* th)
 {
 	(void) tif;
-	if (*(int32*) tw < 1)
+	if (*(int32_t*) tw < 1)
 		*tw = 256;
-	if (*(int32*) th < 1)
+	if (*(int32_t*) th < 1)
 		*th = 256;
 	/* roundup to a multiple of 16 per the spec */
 	if (*tw & 0xf)
diff --git a/src/3rdparty/libtiff/libtiff/tif_unix.c b/src/3rdparty/libtiff/libtiff/tif_unix.c
index 874f1fe..cb54354 100644
--- a/src/3rdparty/libtiff/libtiff/tif_unix.c
+++ b/src/3rdparty/libtiff/libtiff/tif_unix.c
@@ -120,18 +120,18 @@ _tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)
 	/* return ((tmsize_t) write(fdh.fd, buf, bytes_total)); */
 }
 
-static uint64
-_tiffSeekProc(thandle_t fd, uint64 off, int whence)
+static uint64_t
+_tiffSeekProc(thandle_t fd, uint64_t off, int whence)
 {
 	fd_as_handle_union_t fdh;
 	_TIFF_off_t off_io = (_TIFF_off_t) off;
-	if ((uint64) off_io != off)
+	if ((uint64_t) off_io != off)
 	{
 		errno=EINVAL;
-		return (uint64) -1; /* this is really gross */
+		return (uint64_t) -1; /* this is really gross */
 	}
 	fdh.h = fd;
-	return((uint64)_TIFF_lseek_f(fdh.fd,off_io,whence));
+	return((uint64_t)_TIFF_lseek_f(fdh.fd, off_io, whence));
 }
 
 static int
@@ -142,7 +142,7 @@ _tiffCloseProc(thandle_t fd)
 	return(close(fdh.fd));
 }
 
-static uint64
+static uint64_t
 _tiffSizeProc(thandle_t fd)
 {
 	_TIFF_stat_s sb;
@@ -151,7 +151,7 @@ _tiffSizeProc(thandle_t fd)
 	if (_TIFF_fstat_f(fdh.fd,&sb)<0)
 		return(0);
 	else
-		return((uint64)sb.st_size);
+		return((uint64_t)sb.st_size);
 }
 
 #ifdef HAVE_MMAP
@@ -160,9 +160,9 @@ _tiffSizeProc(thandle_t fd)
 static int
 _tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)
 {
-	uint64 size64 = _tiffSizeProc(fd);
+	uint64_t size64 = _tiffSizeProc(fd);
 	tmsize_t sizem = (tmsize_t)size64;
-	if ((uint64)sizem==size64) {
+	if (size64 && (uint64_t)sizem == size64) {
 		fd_as_handle_union_t fdh;
 		fdh.h = fd;
 		*pbase = (void*)
diff --git a/src/3rdparty/libtiff/libtiff/tif_webp.c b/src/3rdparty/libtiff/libtiff/tif_webp.c
new file mode 100644
index 0000000..d5b99d3
--- /dev/null
+++ b/src/3rdparty/libtiff/libtiff/tif_webp.c
@@ -0,0 +1,702 @@
+/*
+* Copyright (c) 2018, Mapbox
+* Author: <norman.barker at mapbox.com>
+*
+* Permission to use, copy, modify, distribute, and sell this software and
+* its documentation for any purpose is hereby granted without fee, provided
+* that (i) the above copyright notices and this permission notice appear in
+* all copies of the software and related documentation, and (ii) the names of
+* Sam Leffler and Silicon Graphics may not be used in any advertising or
+* publicity relating to the software without the specific, prior written
+* permission of Sam Leffler and Silicon Graphics.
+*
+* THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
+* WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+*
+* IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+* ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+* OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+* WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
+* LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+* OF THIS SOFTWARE.
+*/
+
+#include "tiffiop.h"
+#ifdef WEBP_SUPPORT
+/*
+ * TIFF Library.
+ *
+ * WEBP Compression Support
+ *
+ */
+
+#include "webp/decode.h"
+#include "webp/encode.h"
+
+#include <stdio.h>
+
+#define LSTATE_INIT_DECODE 0x01
+#define LSTATE_INIT_ENCODE 0x02
+/*
+ * State block for each open TIFF
+ * file using WEBP compression/decompression.
+ */
+typedef struct {
+  uint16_t           nSamples;               /* number of samples per pixel */
+  
+  int              lossless;               /* lossy/lossless compression */
+  int              quality_level;          /* compression level */
+  WebPPicture      sPicture;               /* WebP Picture */
+  WebPConfig       sEncoderConfig;         /* WebP encoder config */
+  uint8_t*           pBuffer;                /* buffer to hold raw data on encoding */
+  unsigned int     buffer_offset;          /* current offset into the buffer */
+  unsigned int     buffer_size;
+  
+  WebPIDecoder*    psDecoder;              /* WebPIDecoder */
+  WebPDecBuffer    sDecBuffer;             /* Decoder buffer */
+  int              last_y;                 /* Last row decoded */
+  
+  int              state;                  /* state flags */
+  
+	TIFFVGetMethod   vgetparent;             /* super-class method */
+	TIFFVSetMethod   vsetparent;             /* super-class method */
+} WebPState;
+
+#define LState(tif)            ((WebPState*) (tif)->tif_data)
+#define DecoderState(tif)       LState(tif)
+#define EncoderState(tif)       LState(tif)
+
+static int TWebPEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s);
+static int TWebPDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s);
+
+static
+int TWebPDatasetWriter(const uint8_t* data, size_t data_size,
+                      const WebPPicture* const picture)
+{
+  static const char module[] = "TWebPDatasetWriter";
+  TIFF* tif = (TIFF*)(picture->custom_ptr);
+  
+  if ( (tif->tif_rawcc + (tmsize_t)data_size) > tif->tif_rawdatasize ) {
+    TIFFErrorExt(tif->tif_clientdata, module,
+                 "Buffer too small by %"TIFF_SIZE_FORMAT" bytes.",
+                 (size_t) (tif->tif_rawcc + data_size - tif->tif_rawdatasize));
+    return 0;
+  } else {
+    _TIFFmemcpy(tif->tif_rawcp, data, data_size);
+    tif->tif_rawcc += data_size;
+    tif->tif_rawcp += data_size;
+    return 1;    
+  }
+}
+
+/*
+ * Encode a chunk of pixels.
+ */
+static int
+TWebPEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
+{
+  static const char module[] = "TWebPEncode";
+  WebPState *sp = EncoderState(tif);
+  (void) s;
+
+  assert(sp != NULL);
+  assert(sp->state == LSTATE_INIT_ENCODE);
+    
+  if((uint64_t)sp->buffer_offset +
+     (uint64_t)cc > sp->buffer_size )
+  {
+      TIFFErrorExt(tif->tif_clientdata, module,
+                   "Too many bytes to be written");
+      return 0;
+  }
+
+  memcpy(sp->pBuffer + sp->buffer_offset,
+         bp, cc);
+  sp->buffer_offset += (unsigned)cc;
+
+  return 1;
+  
+}
+
+static int
+TWebPDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
+{
+  static const char module[] = "WebPDecode";
+  VP8StatusCode status = VP8_STATUS_OK;
+  WebPState *sp = DecoderState(tif);
+  (void) s;  
+
+  assert(sp != NULL);
+  assert(sp->state == LSTATE_INIT_DECODE);
+  
+  if (occ % sp->sDecBuffer.u.RGBA.stride)
+  {
+    TIFFErrorExt(tif->tif_clientdata, module,
+                 "Fractional scanlines cannot be read");
+    return 0;
+  }
+
+  status = WebPIAppend(sp->psDecoder, tif->tif_rawcp, tif->tif_rawcc);
+
+  if (status != VP8_STATUS_OK && status != VP8_STATUS_SUSPENDED) {
+    if (status == VP8_STATUS_INVALID_PARAM) {
+       TIFFErrorExt(tif->tif_clientdata, module,
+         "Invalid parameter used.");      
+    } else if (status == VP8_STATUS_OUT_OF_MEMORY) {
+      TIFFErrorExt(tif->tif_clientdata, module,
+        "Out of memory.");         
+    } else {
+      TIFFErrorExt(tif->tif_clientdata, module,
+        "Unrecognized error.");   
+    }
+    return 0;
+  } else {
+    int current_y, stride;
+    uint8_t* buf;
+
+    /* Returns the RGB/A image decoded so far */
+    buf = WebPIDecGetRGB(sp->psDecoder, &current_y, NULL, NULL, &stride);
+    
+    if ((buf != NULL) &&
+        (occ <= (tmsize_t)stride * (current_y - sp->last_y))) {
+      memcpy(op,   
+         buf + (sp->last_y * stride),
+         occ);
+
+      tif->tif_rawcp += tif->tif_rawcc;
+      tif->tif_rawcc = 0;
+      sp->last_y += occ / sp->sDecBuffer.u.RGBA.stride;
+      return 1;
+    } else {
+      TIFFErrorExt(tif->tif_clientdata, module, "Unable to decode WebP data."); 
+      return 0;
+    }
+  }
+}
+
+static int
+TWebPFixupTags(TIFF* tif)
+{
+  (void) tif;
+  if (tif->tif_dir.td_planarconfig != PLANARCONFIG_CONTIG) {
+    static const char module[] = "TWebPFixupTags";
+    TIFFErrorExt(tif->tif_clientdata, module,
+      "TIFF WEBP requires data to be stored contiguously in RGB e.g. RGBRGBRGB "
+#if WEBP_ENCODER_ABI_VERSION >= 0x0100
+      "or RGBARGBARGBA"
+#endif
+    );
+    return 0;
+  }
+  return 1;
+}
+
+static int
+TWebPSetupDecode(TIFF* tif)
+{
+  static const char module[] = "WebPSetupDecode";
+  uint16_t nBitsPerSample = tif->tif_dir.td_bitspersample;
+  uint16_t sampleFormat = tif->tif_dir.td_sampleformat;
+
+  WebPState* sp = DecoderState(tif);
+  assert(sp != NULL);
+
+  sp->nSamples = tif->tif_dir.td_samplesperpixel;
+
+  /* check band count */
+  if ( sp->nSamples != 3
+#if WEBP_ENCODER_ABI_VERSION >= 0x0100
+    && sp->nSamples != 4
+#endif
+  )
+  {
+    TIFFErrorExt(tif->tif_clientdata, module,
+      "WEBP driver doesn't support %d bands. Must be 3 (RGB) "
+  #if WEBP_ENCODER_ABI_VERSION >= 0x0100
+      "or 4 (RGBA) "
+  #endif
+    "bands.",
+    sp->nSamples );
+    return 0;
+  }
+
+  /* check bits per sample and data type */
+  if ((nBitsPerSample != 8) && (sampleFormat != 1)) {
+    TIFFErrorExt(tif->tif_clientdata, module,
+                "WEBP driver requires 8 bit unsigned data");
+    return 0;
+  }
+  
+  /* if we were last encoding, terminate this mode */
+  if (sp->state & LSTATE_INIT_ENCODE) {
+      WebPPictureFree(&sp->sPicture);
+      if (sp->pBuffer != NULL) {
+        _TIFFfree(sp->pBuffer);
+        sp->pBuffer = NULL;
+      }
+      sp->buffer_offset = 0;
+      sp->state = 0;
+  }
+
+  sp->state |= LSTATE_INIT_DECODE;
+
+  return 1;
+}
+
+/*
+* Setup state for decoding a strip.
+*/
+static int
+TWebPPreDecode(TIFF* tif, uint16_t s)
+{
+  static const char module[] = "TWebPPreDecode";
+  uint32_t segment_width, segment_height;
+  WebPState* sp = DecoderState(tif);
+  TIFFDirectory* td = &tif->tif_dir;
+  (void) s;
+  assert(sp != NULL);
+  
+  if (isTiled(tif)) {
+    segment_width = td->td_tilewidth;
+    segment_height = td->td_tilelength;
+  } else {
+    segment_width = td->td_imagewidth;
+    segment_height = td->td_imagelength - tif->tif_row;
+    if (segment_height > td->td_rowsperstrip)
+      segment_height = td->td_rowsperstrip;
+  }
+
+  if( segment_width > 16383 || segment_height > 16383 ) {
+      TIFFErrorExt(tif->tif_clientdata, module,
+                   "WEBP maximum image dimensions are 16383 x 16383.");
+      return 0;
+  }
+
+  if( (sp->state & LSTATE_INIT_DECODE) == 0 )
+      tif->tif_setupdecode(tif);
+      
+  if (sp->psDecoder != NULL) {
+    WebPIDelete(sp->psDecoder);
+    WebPFreeDecBuffer(&sp->sDecBuffer);
+    sp->psDecoder = NULL;
+  }
+
+  sp->last_y = 0;
+  
+  WebPInitDecBuffer(&sp->sDecBuffer);
+  
+  sp->sDecBuffer.is_external_memory = 0;
+  sp->sDecBuffer.width = segment_width;
+  sp->sDecBuffer.height = segment_height;
+  sp->sDecBuffer.u.RGBA.stride = segment_width * sp->nSamples;
+  sp->sDecBuffer.u.RGBA.size = segment_width * sp->nSamples * segment_height;
+  
+  if (sp->nSamples > 3) {
+    sp->sDecBuffer.colorspace = MODE_RGBA;
+  } else {
+    sp->sDecBuffer.colorspace = MODE_RGB;
+  }
+  
+  sp->psDecoder = WebPINewDecoder(&sp->sDecBuffer);
+  
+  if (sp->psDecoder == NULL) {
+    TIFFErrorExt(tif->tif_clientdata, module,
+                "Unable to allocate WebP decoder.");
+    return 0;
+  }
+  
+  return 1;
+}
+
+static int
+TWebPSetupEncode(TIFF* tif)
+{
+  static const char module[] = "WebPSetupEncode";
+  uint16_t nBitsPerSample = tif->tif_dir.td_bitspersample;
+  uint16_t sampleFormat = tif->tif_dir.td_sampleformat;
+  
+  WebPState* sp = EncoderState(tif);
+  assert(sp != NULL);
+
+  sp->nSamples = tif->tif_dir.td_samplesperpixel;
+
+  /* check band count */
+  if ( sp->nSamples != 3
+#if WEBP_ENCODER_ABI_VERSION >= 0x0100
+    && sp->nSamples != 4
+#endif
+  )
+  {
+    TIFFErrorExt(tif->tif_clientdata, module,
+      "WEBP driver doesn't support %d bands. Must be 3 (RGB) "
+#if WEBP_ENCODER_ABI_VERSION >= 0x0100
+      "or 4 (RGBA) "
+#endif
+    "bands.",
+    sp->nSamples );
+    return 0;
+  }
+  
+  /* check bits per sample and data type */
+  if ((nBitsPerSample != 8) || (sampleFormat != SAMPLEFORMAT_UINT)) {
+    TIFFErrorExt(tif->tif_clientdata, module,
+                "WEBP driver requires 8 bit unsigned data");
+    return 0;
+  }
+  
+  if (sp->state & LSTATE_INIT_DECODE) {
+    WebPIDelete(sp->psDecoder);
+    WebPFreeDecBuffer(&sp->sDecBuffer);
+    sp->psDecoder = NULL;
+    sp->last_y = 0;
+    sp->state = 0;
+  }
+
+  sp->state |= LSTATE_INIT_ENCODE;
+
+  if (!WebPPictureInit(&sp->sPicture)) {
+    TIFFErrorExt(tif->tif_clientdata, module,
+        "Error initializing WebP picture.");
+    return 0;
+  }
+
+  if (!WebPConfigInitInternal(&sp->sEncoderConfig, WEBP_PRESET_DEFAULT,
+                              (float)sp->quality_level,
+                              WEBP_ENCODER_ABI_VERSION)) {
+    TIFFErrorExt(tif->tif_clientdata, module,
+      "Error creating WebP encoder configuration.");
+    return 0;
+  }
+
+  // WebPConfigInitInternal above sets lossless to false
+  #if WEBP_ENCODER_ABI_VERSION >= 0x0100
+    sp->sEncoderConfig.lossless = sp->lossless;
+    if (sp->lossless) {
+      sp->sPicture.use_argb = 1;
+    }
+  #endif
+
+  if (!WebPValidateConfig(&sp->sEncoderConfig)) {
+    TIFFErrorExt(tif->tif_clientdata, module,
+      "Error with WebP encoder configuration.");
+    return 0;
+  }
+
+  return 1;
+}
+
+/*
+* Reset encoding state at the start of a strip.
+*/
+static int
+TWebPPreEncode(TIFF* tif, uint16_t s)
+{
+  static const char module[] = "TWebPPreEncode";
+  uint32_t segment_width, segment_height;
+  WebPState *sp = EncoderState(tif);
+  TIFFDirectory* td = &tif->tif_dir;
+
+  (void) s;
+
+  assert(sp != NULL);
+  if( sp->state != LSTATE_INIT_ENCODE )
+    tif->tif_setupencode(tif);
+
+  /*
+   * Set encoding parameters for this strip/tile.
+   */
+  if (isTiled(tif)) {
+    segment_width = td->td_tilewidth;
+    segment_height = td->td_tilelength;
+  } else {
+    segment_width = td->td_imagewidth;
+    segment_height = td->td_imagelength - tif->tif_row;
+    if (segment_height > td->td_rowsperstrip)
+      segment_height = td->td_rowsperstrip;
+  }
+
+  if( segment_width > 16383 || segment_height > 16383 ) {
+      TIFFErrorExt(tif->tif_clientdata, module, 
+                   "WEBP maximum image dimensions are 16383 x 16383.");
+      return 0;
+  }
+
+  /* set up buffer for raw data */
+  /* given above check and that nSamples <= 4, buffer_size is <= 1 GB */
+  sp->buffer_size = segment_width * segment_height * sp->nSamples;
+  
+  if (sp->pBuffer != NULL) {
+      _TIFFfree(sp->pBuffer);
+      sp->pBuffer = NULL;    
+  }
+  
+  sp->pBuffer = _TIFFmalloc(sp->buffer_size);
+  if( !sp->pBuffer) {
+      TIFFErrorExt(tif->tif_clientdata, module, "Cannot allocate buffer");
+      return 0;
+  }
+  sp->buffer_offset = 0;
+
+  sp->sPicture.width = segment_width;
+  sp->sPicture.height = segment_height;
+  sp->sPicture.writer = TWebPDatasetWriter;
+  sp->sPicture.custom_ptr = tif;
+
+  return 1;
+}
+
+/*
+* Finish off an encoded strip by flushing it.
+*/
+static int
+TWebPPostEncode(TIFF* tif)
+{
+  static const char module[] = "WebPPostEncode";
+  int64_t stride;
+  WebPState *sp = EncoderState(tif);
+  assert(sp != NULL);
+
+  assert(sp->state == LSTATE_INIT_ENCODE);
+
+  stride = (int64_t)sp->sPicture.width * sp->nSamples;
+
+#if WEBP_ENCODER_ABI_VERSION >= 0x0100
+  if (sp->nSamples == 4) {
+      if (!WebPPictureImportRGBA(&sp->sPicture, sp->pBuffer, (int)stride)) {
+          TIFFErrorExt(tif->tif_clientdata, module,
+                    "WebPPictureImportRGBA() failed" );
+          return 0;
+      }
+  }
+  else
+#endif
+  if (!WebPPictureImportRGB(&sp->sPicture, sp->pBuffer, (int)stride)) {
+      TIFFErrorExt(tif->tif_clientdata, module,
+                    "WebPPictureImportRGB() failed");
+      return 0;
+  }
+  
+  if (!WebPEncode(&sp->sEncoderConfig, &sp->sPicture)) {
+
+#if WEBP_ENCODER_ABI_VERSION >= 0x0100
+    const char* pszErrorMsg = NULL;
+    switch(sp->sPicture.error_code) {
+    case VP8_ENC_ERROR_OUT_OF_MEMORY:
+        pszErrorMsg = "Out of memory"; break;
+    case VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY:
+        pszErrorMsg = "Out of memory while flushing bits"; break;
+    case VP8_ENC_ERROR_NULL_PARAMETER:
+        pszErrorMsg = "A pointer parameter is NULL"; break;
+    case VP8_ENC_ERROR_INVALID_CONFIGURATION:
+        pszErrorMsg = "Configuration is invalid"; break;
+    case VP8_ENC_ERROR_BAD_DIMENSION:
+        pszErrorMsg = "Picture has invalid width/height"; break;
+    case VP8_ENC_ERROR_PARTITION0_OVERFLOW:
+        pszErrorMsg = "Partition is bigger than 512k. Try using less "
+            "SEGMENTS, or increase PARTITION_LIMIT value";
+        break;
+    case VP8_ENC_ERROR_PARTITION_OVERFLOW:
+        pszErrorMsg = "Partition is bigger than 16M";
+        break;
+    case VP8_ENC_ERROR_BAD_WRITE:
+        pszErrorMsg = "Error while fludshing bytes"; break;
+    case VP8_ENC_ERROR_FILE_TOO_BIG:
+        pszErrorMsg = "File is bigger than 4G"; break;
+    case VP8_ENC_ERROR_USER_ABORT:
+        pszErrorMsg = "User interrupted";
+        break;
+    default:
+        TIFFErrorExt(tif->tif_clientdata, module,
+                "WebPEncode returned an unknown error code: %d",
+                sp->sPicture.error_code);
+        pszErrorMsg = "Unknown WebP error type.";
+        break;
+    }
+    TIFFErrorExt(tif->tif_clientdata, module,
+             "WebPEncode() failed : %s", pszErrorMsg);
+#else
+    TIFFErrorExt(tif->tif_clientdata, module,
+             "Error in WebPEncode()");
+#endif
+    return 0;
+  }
+
+  sp->sPicture.custom_ptr = NULL;
+
+  if (!TIFFFlushData1(tif))
+  {
+    TIFFErrorExt(tif->tif_clientdata, module,
+      "Error flushing TIFF WebP encoder.");
+    return 0;
+  }
+
+  return 1;
+}
+
+static void
+TWebPCleanup(TIFF* tif)
+{
+  WebPState* sp = LState(tif);
+
+  assert(sp != 0);
+
+  tif->tif_tagmethods.vgetfield = sp->vgetparent;
+  tif->tif_tagmethods.vsetfield = sp->vsetparent;
+
+  if (sp->state & LSTATE_INIT_ENCODE) {
+    WebPPictureFree(&sp->sPicture);
+  }
+
+  if (sp->psDecoder != NULL) {
+    WebPIDelete(sp->psDecoder);
+    WebPFreeDecBuffer(&sp->sDecBuffer);
+    sp->psDecoder = NULL;
+    sp->last_y = 0;
+  }
+  
+  if (sp->pBuffer != NULL) {
+      _TIFFfree(sp->pBuffer);
+      sp->pBuffer = NULL;    
+  }
+
+  _TIFFfree(tif->tif_data);
+  tif->tif_data = NULL;
+
+  _TIFFSetDefaultCompressionState(tif);
+}
+
+static int
+TWebPVSetField(TIFF* tif, uint32_t tag, va_list ap)
+{
+	static const char module[] = "WebPVSetField";
+  WebPState* sp = LState(tif);
+
+  switch (tag) {
+  case TIFFTAG_WEBP_LEVEL:
+    sp->quality_level = (int) va_arg(ap, int);
+    if( sp->quality_level <= 0 ||
+        sp->quality_level > 100.0f ) {
+      TIFFWarningExt(tif->tif_clientdata, module,
+                     "WEBP_LEVEL should be between 1 and 100");
+    }
+    return 1;
+  case TIFFTAG_WEBP_LOSSLESS:
+    #if WEBP_ENCODER_ABI_VERSION >= 0x0100
+    sp->lossless = va_arg(ap, int);
+    if (sp->lossless){
+      sp->quality_level = 100;
+    }
+    return 1;
+    #else
+      TIFFErrorExt(tif->tif_clientdata, module,
+                  "Need to upgrade WEBP driver, this version doesn't support "
+                  "lossless compression.");
+      return 0;
+    #endif 
+  default:
+    return (*sp->vsetparent)(tif, tag, ap);
+  }
+  /*NOTREACHED*/
+}
+
+static int
+TWebPVGetField(TIFF* tif, uint32_t tag, va_list ap)
+{
+  WebPState* sp = LState(tif);
+
+  switch (tag) {
+  case TIFFTAG_WEBP_LEVEL:
+    *va_arg(ap, int*) = sp->quality_level;
+    break;
+  case TIFFTAG_WEBP_LOSSLESS:
+    *va_arg(ap, int*) = sp->lossless;
+    break;
+  default:
+    return (*sp->vgetparent)(tif, tag, ap);
+  }
+  return 1;
+}
+
+static const TIFFField TWebPFields[] = {
+  { TIFFTAG_WEBP_LEVEL, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT,
+    TIFF_SETGET_UNDEFINED,
+    FIELD_PSEUDO, TRUE, FALSE, "WEBP quality", NULL },
+  { TIFFTAG_WEBP_LOSSLESS, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT,
+    TIFF_SETGET_UNDEFINED,
+    FIELD_PSEUDO, TRUE, FALSE, "WEBP lossless/lossy", NULL
+  },
+};
+
+int
+TIFFInitWebP(TIFF* tif, int scheme)
+{
+  static const char module[] = "TIFFInitWebP";
+  WebPState* sp;
+
+  (void)scheme;
+  assert( scheme == COMPRESSION_WEBP );
+
+  /*
+  * Merge codec-specific tag information.
+  */
+  if ( !_TIFFMergeFields(tif, TWebPFields, TIFFArrayCount(TWebPFields)) ) {
+    TIFFErrorExt(tif->tif_clientdata, module,
+                "Merging WebP codec-specific tags failed");
+    return 0;
+  }
+
+  /*
+  * Allocate state block so tag methods have storage to record values.
+  */
+  tif->tif_data = (uint8_t*) _TIFFmalloc(sizeof(WebPState));
+  if (tif->tif_data == NULL)
+    goto bad;
+  sp = LState(tif);
+
+  /*
+  * Override parent get/set field methods.
+  */
+  sp->vgetparent = tif->tif_tagmethods.vgetfield;
+  tif->tif_tagmethods.vgetfield = TWebPVGetField;	/* hook for codec tags */
+  sp->vsetparent = tif->tif_tagmethods.vsetfield;
+  tif->tif_tagmethods.vsetfield = TWebPVSetField;	/* hook for codec tags */
+
+  /* Default values for codec-specific fields */
+  sp->quality_level = 75;		/* default comp. level */
+  sp->lossless = 0; /* default to false */
+  sp->state = 0;
+  sp->nSamples = 0;
+  sp->psDecoder = NULL;
+  sp->last_y = 0;
+  
+  sp->buffer_offset = 0;
+  sp->pBuffer = NULL;
+
+  /*
+  * Install codec methods.
+  * Notes:
+  * encoderow is not supported
+  */
+  tif->tif_fixuptags = TWebPFixupTags;
+  tif->tif_setupdecode = TWebPSetupDecode;
+  tif->tif_predecode = TWebPPreDecode;
+  tif->tif_decoderow = TWebPDecode;
+  tif->tif_decodestrip = TWebPDecode;
+  tif->tif_decodetile = TWebPDecode;
+  tif->tif_setupencode = TWebPSetupEncode;
+  tif->tif_preencode = TWebPPreEncode;
+  tif->tif_postencode = TWebPPostEncode;
+  tif->tif_encoderow = TWebPEncode;
+  tif->tif_encodestrip = TWebPEncode;
+  tif->tif_encodetile = TWebPEncode;
+  tif->tif_cleanup = TWebPCleanup;
+
+  return 1;
+bad:
+  TIFFErrorExt(tif->tif_clientdata, module,
+  	     "No space for WebP state block");
+  return 0;
+}
+
+#endif /* WEBP_SUPPORT */
diff --git a/src/3rdparty/libtiff/libtiff/tif_win32.c b/src/3rdparty/libtiff/libtiff/tif_win32.c
index 088880e..c6ca151 100644
--- a/src/3rdparty/libtiff/libtiff/tif_win32.c
+++ b/src/3rdparty/libtiff/libtiff/tif_win32.c
@@ -27,33 +27,37 @@
  * Scott Wagner (wagner@itek.com), Itek Graphix, Rochester, NY USA
  */
 
-/*
-  CreateFileA/CreateFileW return type 'HANDLE'.
-
-  thandle_t is declared like
-
-    DECLARE_HANDLE(thandle_t);
+#include "tiffiop.h"
 
-  in tiffio.h.
+#include <windows.h>
 
-  Windows (from winnt.h) DECLARE_HANDLE logic looks like
+/*
+  CreateFileA/CreateFileW return type 'HANDLE' while TIFFFdOpen() takes 'int',
+  which is formally incompatible and can even seemingly be of different size:
+  HANDLE is 64 bit under Win64, while int is still 32 bits there.
 
-  #ifdef STRICT
-    typedef void *HANDLE;
-  #define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
-  #else
-    typedef PVOID HANDLE;
-  #define DECLARE_HANDLE(name) typedef HANDLE name
-  #endif
+  However, only the lower 32 bits of a HANDLE are significant under Win64 as,
+  for interoperability reasons, they must have the same values in 32- and
+  64-bit programs running on the same system, see
 
-  See http://bugzilla.maptools.org/show_bug.cgi?id=1941 for problems in WIN64
-  builds resulting from this.  Unfortunately, the proposed patch was lost.
+  https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication
 
+  Because of this, it is safe to define the following trivial functions for
+  casting between ints and HANDLEs, which are only really needed to avoid
+  compiler warnings (and, perhaps, to make the code slightly more clear).
+  Note that using the intermediate cast to "intptr_t" is crucial for warning
+  avoidance, as this integer type has the same size as HANDLE in all builds.
 */
-  
-#include "tiffiop.h"
 
-#include <windows.h>
+static inline thandle_t thandle_from_int(int ifd)
+{
+    return (thandle_t)(intptr_t)ifd;
+}
+
+static inline int thandle_to_int(thandle_t fd)
+{
+    return (int)(intptr_t)fd;
+}
 
 static tmsize_t
 _tiffReadProc(thandle_t fd, void* buf, tmsize_t size)
@@ -61,18 +65,18 @@ _tiffReadProc(thandle_t fd, void* buf, tmsize_t size)
 	/* tmsize_t is 64bit on 64bit systems, but the WinAPI ReadFile takes
 	 * 32bit sizes, so we loop through the data in suitable 32bit sized
 	 * chunks */
-	uint8* ma;
-	uint64 mb;
+	uint8_t* ma;
+	uint64_t mb;
 	DWORD n;
 	DWORD o;
 	tmsize_t p;
-	ma=(uint8*)buf;
+	ma=(uint8_t*)buf;
 	mb=size;
 	p=0;
 	while (mb>0)
 	{
 		n=0x80000000UL;
-		if ((uint64)n>mb)
+		if ((uint64_t)n>mb)
 			n=(DWORD)mb;
 		if (!ReadFile(fd,(LPVOID)ma,n,&o,NULL))
 			return(0);
@@ -91,18 +95,18 @@ _tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)
 	/* tmsize_t is 64bit on 64bit systems, but the WinAPI WriteFile takes
 	 * 32bit sizes, so we loop through the data in suitable 32bit sized
 	 * chunks */
-	uint8* ma;
-	uint64 mb;
+	uint8_t* ma;
+	uint64_t mb;
 	DWORD n;
 	DWORD o;
 	tmsize_t p;
-	ma=(uint8*)buf;
+	ma=(uint8_t*)buf;
 	mb=size;
 	p=0;
 	while (mb>0)
 	{
 		n=0x80000000UL;
-		if ((uint64)n>mb)
+		if ((uint64_t)n>mb)
 			n=(DWORD)mb;
 		if (!WriteFile(fd,(LPVOID)ma,n,&o,NULL))
 			return(0);
@@ -115,8 +119,8 @@ _tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)
 	return(p);
 }
 
-static uint64
-_tiffSeekProc(thandle_t fd, uint64 off, int whence)
+static uint64_t
+_tiffSeekProc(thandle_t fd, uint64_t off, int whence)
 {
 	LARGE_INTEGER offli;
 	DWORD dwMoveMethod;
@@ -148,12 +152,14 @@ _tiffCloseProc(thandle_t fd)
 	return (CloseHandle(fd) ? 0 : -1);
 }
 
-static uint64
+static uint64_t
 _tiffSizeProc(thandle_t fd)
 {
-	ULARGE_INTEGER m;
-	m.LowPart=GetFileSize(fd,&m.HighPart);
-	return(m.QuadPart);
+	LARGE_INTEGER m;
+	if (GetFileSizeEx(fd,&m))
+		return(m.QuadPart);
+	else
+		return(0);
 }
 
 static int
@@ -179,13 +185,13 @@ _tiffDummyMapProc(thandle_t fd, void** pbase, toff_t* psize)
 static int
 _tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)
 {
-	uint64 size;
+	uint64_t size;
 	tmsize_t sizem;
 	HANDLE hMapFile;
 
 	size = _tiffSizeProc(fd);
 	sizem = (tmsize_t)size;
-	if ((uint64)sizem!=size)
+	if (!size || (uint64_t)sizem!=size)
 		return (0);
 
 	/* By passing in 0 for the maximum file size, it specifies that we
@@ -237,7 +243,7 @@ TIFFFdOpen(int ifd, const char* name, const char* mode)
 			break;
 		}
 	}
-	tif = TIFFClientOpen(name, mode, (thandle_t)ifd, /* FIXME: WIN64 cast to pointer warning */
+	tif = TIFFClientOpen(name, mode, thandle_from_int(ifd),
 			_tiffReadProc, _tiffWriteProc,
 			_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
 			fSuppressMap ? _tiffDummyMapProc : _tiffMapProc,
@@ -282,7 +288,7 @@ TIFFOpen(const char* name, const char* mode)
 		return ((TIFF *)0);
 	}
 
-	tif = TIFFFdOpen((int)fd, name, mode);   /* FIXME: WIN64 cast from pointer to int warning */
+	tif = TIFFFdOpen(thandle_to_int(fd), name, mode);
 	if(!tif)
 		CloseHandle(fd);
 	return tif;
@@ -337,7 +343,7 @@ TIFFOpenW(const wchar_t* name, const char* mode)
 				    NULL, NULL);
 	}
 
-	tif = TIFFFdOpen((int)fd,    /* FIXME: WIN64 cast from pointer to int warning */
+	tif = TIFFFdOpen(thandle_to_int(fd),
 			 (mbname != NULL) ? mbname : "<unknown>", mode);
 	if(!tif)
 		CloseHandle(fd);
@@ -398,10 +404,6 @@ _TIFFmemcmp(const void* p1, const void* p2, tmsize_t c)
 
 #ifndef _WIN32_WCE
 
-#if (_MSC_VER < 1500)
-#  define vsnprintf _vsnprintf
-#endif
-
 static void
 Win32WarningHandler(const char* module, const char* fmt, va_list ap)
 {
diff --git a/src/3rdparty/libtiff/libtiff/tif_write.c b/src/3rdparty/libtiff/libtiff/tif_write.c
index 33e803c..b5ef21d 100644
--- a/src/3rdparty/libtiff/libtiff/tif_write.c
+++ b/src/3rdparty/libtiff/libtiff/tif_write.c
@@ -40,16 +40,16 @@
 	((((tif)->tif_flags & TIFF_BUFFERSETUP) && tif->tif_rawdata) ||	\
 	    TIFFWriteBufferSetup((tif), NULL, (tmsize_t) -1))
 
-static int TIFFGrowStrips(TIFF* tif, uint32 delta, const char* module);
-static int TIFFAppendToStrip(TIFF* tif, uint32 strip, uint8* data, tmsize_t cc);
+static int TIFFGrowStrips(TIFF* tif, uint32_t delta, const char* module);
+static int TIFFAppendToStrip(TIFF* tif, uint32_t strip, uint8_t* data, tmsize_t cc);
 
 int
-TIFFWriteScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)
+TIFFWriteScanline(TIFF* tif, void* buf, uint32_t row, uint16_t sample)
 {
 	static const char module[] = "TIFFWriteScanline";
 	register TIFFDirectory *td;
 	int status, imagegrew = 0;
-	uint32 strip;
+	uint32_t strip;
 
 	if (!WRITECHECKSTRIPS(tif, module))
 		return (-1);
@@ -166,9 +166,9 @@ TIFFWriteScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)
 	}
 
 	/* swab if needed - note that source buffer will be altered */
-	tif->tif_postdecode( tif, (uint8*) buf, tif->tif_scanlinesize );
+	tif->tif_postdecode(tif, (uint8_t*) buf, tif->tif_scanlinesize );
 
-	status = (*tif->tif_encoderow)(tif, (uint8*) buf,
+	status = (*tif->tif_encoderow)(tif, (uint8_t*) buf,
 	    tif->tif_scanlinesize, sample);
 
         /* we are now poised at the beginning of the next row */
@@ -180,14 +180,14 @@ TIFFWriteScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)
 /* more bytes available in the output buffer than the previous byte count, */
 /* so that TIFFAppendToStrip() will detect the overflow when it is called the first */
 /* time if the new compressed tile is bigger than the older one. (GDAL #4771) */
-static int _TIFFReserveLargeEnoughWriteBuffer(TIFF* tif, uint32 strip_or_tile)
+static int _TIFFReserveLargeEnoughWriteBuffer(TIFF* tif, uint32_t strip_or_tile)
 {
     TIFFDirectory *td = &tif->tif_dir;
     if( td->td_stripbytecount_p[strip_or_tile] > 0 )
     {
         /* The +1 is to ensure at least one extra bytes */
         /* The +4 is because the LZW encoder flushes 4 bytes before the limit */
-        uint64 safe_buffer_size = (uint64)(td->td_stripbytecount_p[strip_or_tile] + 1 + 4);
+        uint64_t safe_buffer_size = (uint64_t)(td->td_stripbytecount_p[strip_or_tile] + 1 + 4);
         if( tif->tif_rawdatasize <= (tmsize_t)safe_buffer_size )
         {
             if( !(TIFFWriteBufferSetup(tif, NULL,
@@ -209,11 +209,11 @@ static int _TIFFReserveLargeEnoughWriteBuffer(TIFF* tif, uint32 strip_or_tile)
  * NB: Image length must be setup before writing.
  */
 tmsize_t
-TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
+TIFFWriteEncodedStrip(TIFF* tif, uint32_t strip, void* data, tmsize_t cc)
 {
 	static const char module[] = "TIFFWriteEncodedStrip";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint16 sample;
+	uint16_t sample;
 
 	if (!WRITECHECKSTRIPS(tif, module))
 		return ((tmsize_t) -1);
@@ -273,26 +273,26 @@ TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
     if( td->td_compression == COMPRESSION_NONE )
     {
         /* swab if needed - note that source buffer will be altered */
-        tif->tif_postdecode( tif, (uint8*) data, cc );
+        tif->tif_postdecode(tif, (uint8_t*) data, cc );
 
         if (!isFillOrder(tif, td->td_fillorder) &&
             (tif->tif_flags & TIFF_NOBITREV) == 0)
-            TIFFReverseBits((uint8*) data, cc);
+            TIFFReverseBits((uint8_t*) data, cc);
 
         if (cc > 0 &&
-            !TIFFAppendToStrip(tif, strip, (uint8*) data, cc))
+            !TIFFAppendToStrip(tif, strip, (uint8_t*) data, cc))
             return ((tmsize_t) -1);
         return (cc);
     }
 
-	sample = (uint16)(strip / td->td_stripsperimage);
+	sample = (uint16_t)(strip / td->td_stripsperimage);
 	if (!(*tif->tif_preencode)(tif, sample))
 		return ((tmsize_t) -1);
 
         /* swab if needed - note that source buffer will be altered */
-	tif->tif_postdecode( tif, (uint8*) data, cc );
+	tif->tif_postdecode(tif, (uint8_t*) data, cc );
 
-	if (!(*tif->tif_encodestrip)(tif, (uint8*) data, cc, sample))
+	if (!(*tif->tif_encodestrip)(tif, (uint8_t*) data, cc, sample))
 		return ((tmsize_t) -1);
 	if (!(*tif->tif_postencode)(tif))
 		return ((tmsize_t) -1);
@@ -313,7 +313,7 @@ TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
  * NB: Image length must be setup before writing.
  */
 tmsize_t
-TIFFWriteRawStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
+TIFFWriteRawStrip(TIFF* tif, uint32_t strip, void* data, tmsize_t cc)
 {
 	static const char module[] = "TIFFWriteRawStrip";
 	TIFFDirectory *td = &tif->tif_dir;
@@ -352,7 +352,7 @@ TIFFWriteRawStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
                 return ((tmsize_t) -1);
         }
 	tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;
-	return (TIFFAppendToStrip(tif, strip, (uint8*) data, cc) ?
+	return (TIFFAppendToStrip(tif, strip, (uint8_t*) data, cc) ?
 	    cc : (tmsize_t) -1);
 }
 
@@ -361,7 +361,7 @@ TIFFWriteRawStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
  * tile is selected by the (x,y,z,s) coordinates.
  */
 tmsize_t
-TIFFWriteTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s)
+TIFFWriteTile(TIFF* tif, void* buf, uint32_t x, uint32_t y, uint32_t z, uint16_t s)
 {
 	if (!TIFFCheckTile(tif, x, y, z, s))
 		return ((tmsize_t)(-1));
@@ -388,12 +388,12 @@ TIFFWriteTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s)
  *     the image on each write (as TIFFWriteScanline does).
  */
 tmsize_t
-TIFFWriteEncodedTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)
+TIFFWriteEncodedTile(TIFF* tif, uint32_t tile, void* data, tmsize_t cc)
 {
 	static const char module[] = "TIFFWriteEncodedTile";
 	TIFFDirectory *td;
-	uint16 sample;
-        uint32 howmany32;
+	uint16_t sample;
+        uint32_t howmany32;
 
 	if (!WRITECHECKTILES(tif, module))
 		return ((tmsize_t)(-1));
@@ -457,31 +457,31 @@ TIFFWriteEncodedTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)
     if( td->td_compression == COMPRESSION_NONE )
     {
         /* swab if needed - note that source buffer will be altered */
-        tif->tif_postdecode( tif, (uint8*) data, cc );
+        tif->tif_postdecode(tif, (uint8_t*) data, cc );
 
         if (!isFillOrder(tif, td->td_fillorder) &&
             (tif->tif_flags & TIFF_NOBITREV) == 0)
-            TIFFReverseBits((uint8*) data, cc);
+            TIFFReverseBits((uint8_t*) data, cc);
 
         if (cc > 0 &&
-            !TIFFAppendToStrip(tif, tile, (uint8*) data, cc))
+            !TIFFAppendToStrip(tif, tile, (uint8_t*) data, cc))
             return ((tmsize_t) -1);
         return (cc);
     }
 
-    sample = (uint16)(tile/td->td_stripsperimage);
+    sample = (uint16_t)(tile / td->td_stripsperimage);
     if (!(*tif->tif_preencode)(tif, sample))
         return ((tmsize_t)(-1));
     /* swab if needed - note that source buffer will be altered */
-    tif->tif_postdecode( tif, (uint8*) data, cc );
+    tif->tif_postdecode(tif, (uint8_t*) data, cc );
 
-    if (!(*tif->tif_encodetile)(tif, (uint8*) data, cc, sample))
+    if (!(*tif->tif_encodetile)(tif, (uint8_t*) data, cc, sample))
             return ((tmsize_t) -1);
     if (!(*tif->tif_postencode)(tif))
             return ((tmsize_t)(-1));
     if (!isFillOrder(tif, td->td_fillorder) &&
         (tif->tif_flags & TIFF_NOBITREV) == 0)
-            TIFFReverseBits((uint8*)tif->tif_rawdata, tif->tif_rawcc);
+            TIFFReverseBits((uint8_t*)tif->tif_rawdata, tif->tif_rawcc);
     if (tif->tif_rawcc > 0 && !TIFFAppendToStrip(tif, tile,
         tif->tif_rawdata, tif->tif_rawcc))
             return ((tmsize_t)(-1));
@@ -500,7 +500,7 @@ TIFFWriteEncodedTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)
  *     the image on each write (as TIFFWriteScanline does).
  */
 tmsize_t
-TIFFWriteRawTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)
+TIFFWriteRawTile(TIFF* tif, uint32_t tile, void* data, tmsize_t cc)
 {
 	static const char module[] = "TIFFWriteRawTile";
 
@@ -512,7 +512,7 @@ TIFFWriteRawTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)
 		    (unsigned long) tif->tif_dir.td_nstrips);
 		return ((tmsize_t)(-1));
 	}
-	return (TIFFAppendToStrip(tif, tile, (uint8*) data, cc) ?
+	return (TIFFAppendToStrip(tif, tile, (uint8_t*) data, cc) ?
 	    cc : (tmsize_t)(-1));
 }
 
@@ -533,13 +533,20 @@ TIFFSetupStrips(TIFF* tif)
 		    isUnspecified(tif, FIELD_ROWSPERSTRIP) ?
 			td->td_samplesperpixel : TIFFNumberOfStrips(tif);
 	td->td_nstrips = td->td_stripsperimage;
+        /* TIFFWriteDirectoryTagData has a limitation to 0x80000000U bytes */
+        if( td->td_nstrips >= 0x80000000U / ((tif->tif_flags&TIFF_BIGTIFF)?0x8U:0x4U) )
+        {
+            TIFFErrorExt(tif->tif_clientdata, "TIFFSetupStrips",
+                         "Too large Strip/Tile Offsets/ByteCounts arrays");
+            return 0;
+        }
 	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
 		td->td_stripsperimage /= td->td_samplesperpixel;
-	td->td_stripoffset_p = (uint64 *)
-            _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),
+	td->td_stripoffset_p = (uint64_t *)
+            _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64_t),
                              "for \"StripOffsets\" array");
-	td->td_stripbytecount_p = (uint64 *)
-            _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),
+	td->td_stripbytecount_p = (uint64_t *)
+            _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64_t),
                              "for \"StripByteCounts\" array");
 	if (td->td_stripoffset_p == NULL || td->td_stripbytecount_p == NULL)
 		return (0);
@@ -547,8 +554,8 @@ TIFFSetupStrips(TIFF* tif)
 	 * Place data at the end-of-file
 	 * (by setting offsets to zero).
 	 */
-	_TIFFmemset(td->td_stripoffset_p, 0, td->td_nstrips*sizeof (uint64));
-	_TIFFmemset(td->td_stripbytecount_p, 0, td->td_nstrips*sizeof (uint64));
+	_TIFFmemset(td->td_stripoffset_p, 0, td->td_nstrips*sizeof (uint64_t));
+	_TIFFmemset(td->td_stripbytecount_p, 0, td->td_nstrips*sizeof (uint64_t));
 	TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
 	TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);
 	return (1);
@@ -661,6 +668,10 @@ TIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size)
 	if (size == (tmsize_t)(-1)) {
 		size = (isTiled(tif) ?
 		    tif->tif_tilesize : TIFFStripSize(tif));
+
+                /* Adds 10% margin for cases where compression would expand a bit */
+                if( size < TIFF_TMSIZE_T_MAX - size / 10 )
+                    size += size / 10;
 		/*
 		 * Make raw data buffer at least 8K
 		 */
@@ -677,7 +688,7 @@ TIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size)
 		tif->tif_flags |= TIFF_MYBUFFER;
 	} else
 		tif->tif_flags &= ~TIFF_MYBUFFER;
-	tif->tif_rawdata = (uint8*) bp;
+	tif->tif_rawdata = (uint8_t*) bp;
 	tif->tif_rawdatasize = size;
 	tif->tif_rawcc = 0;
 	tif->tif_rawcp = tif->tif_rawdata;
@@ -689,17 +700,17 @@ TIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size)
  * Grow the strip data structures by delta strips.
  */
 static int
-TIFFGrowStrips(TIFF* tif, uint32 delta, const char* module)
+TIFFGrowStrips(TIFF* tif, uint32_t delta, const char* module)
 {
 	TIFFDirectory *td = &tif->tif_dir;
-	uint64* new_stripoffset;
-	uint64* new_stripbytecount;
+	uint64_t* new_stripoffset;
+	uint64_t* new_stripbytecount;
 
 	assert(td->td_planarconfig == PLANARCONFIG_CONTIG);
-	new_stripoffset = (uint64*)_TIFFrealloc(td->td_stripoffset_p,
-		(td->td_nstrips + delta) * sizeof (uint64));
-	new_stripbytecount = (uint64*)_TIFFrealloc(td->td_stripbytecount_p,
-		(td->td_nstrips + delta) * sizeof (uint64));
+	new_stripoffset = (uint64_t*)_TIFFrealloc(td->td_stripoffset_p,
+		(td->td_nstrips + delta) * sizeof (uint64_t));
+	new_stripbytecount = (uint64_t*)_TIFFrealloc(td->td_stripbytecount_p,
+		(td->td_nstrips + delta) * sizeof (uint64_t));
 	if (new_stripoffset == NULL || new_stripbytecount == NULL) {
 		if (new_stripoffset)
 			_TIFFfree(new_stripoffset);
@@ -712,9 +723,9 @@ TIFFGrowStrips(TIFF* tif, uint32 delta, const char* module)
 	td->td_stripoffset_p = new_stripoffset;
 	td->td_stripbytecount_p = new_stripbytecount;
 	_TIFFmemset(td->td_stripoffset_p + td->td_nstrips,
-		    0, delta*sizeof (uint64));
+		    0, delta*sizeof (uint64_t));
 	_TIFFmemset(td->td_stripbytecount_p + td->td_nstrips,
-		    0, delta*sizeof (uint64));
+		    0, delta*sizeof (uint64_t));
 	td->td_nstrips += delta;
         tif->tif_flags |= TIFF_DIRTYDIRECT;
 
@@ -725,19 +736,19 @@ TIFFGrowStrips(TIFF* tif, uint32 delta, const char* module)
  * Append the data to the specified strip.
  */
 static int
-TIFFAppendToStrip(TIFF* tif, uint32 strip, uint8* data, tmsize_t cc)
+TIFFAppendToStrip(TIFF* tif, uint32_t strip, uint8_t* data, tmsize_t cc)
 {
 	static const char module[] = "TIFFAppendToStrip";
 	TIFFDirectory *td = &tif->tif_dir;
-	uint64 m;
-        int64 old_byte_count = -1;
+	uint64_t m;
+        int64_t old_byte_count = -1;
 
 	if (td->td_stripoffset_p[strip] == 0 || tif->tif_curoff == 0) {
             assert(td->td_nstrips > 0);
 
             if( td->td_stripbytecount_p[strip] != 0 
                 && td->td_stripoffset_p[strip] != 0 
-                && td->td_stripbytecount_p[strip] >= (uint64) cc )
+                && td->td_stripbytecount_p[strip] >= (uint64_t) cc )
             {
                 /* 
                  * There is already tile data on disk, and the new tile
@@ -774,8 +785,8 @@ TIFFAppendToStrip(TIFF* tif, uint32 strip, uint8* data, tmsize_t cc)
 
 	m = tif->tif_curoff+cc;
 	if (!(tif->tif_flags&TIFF_BIGTIFF))
-		m = (uint32)m;
-	if ((m<tif->tif_curoff)||(m<(uint64)cc))
+		m = (uint32_t)m;
+	if ((m<tif->tif_curoff)||(m<(uint64_t)cc))
 	{
 		TIFFErrorExt(tif->tif_clientdata, module, "Maximum TIFF file size exceeded");
 		return (0);
@@ -788,7 +799,7 @@ TIFFAppendToStrip(TIFF* tif, uint32 strip, uint8* data, tmsize_t cc)
 	tif->tif_curoff = m;
 	td->td_stripbytecount_p[strip] += cc;
 
-        if( (int64) td->td_stripbytecount_p[strip] != old_byte_count )
+        if((int64_t) td->td_stripbytecount_p[strip] != old_byte_count )
             tif->tif_flags |= TIFF_DIRTYSTRIP;
             
 	return (1);
@@ -805,7 +816,7 @@ TIFFFlushData1(TIFF* tif)
 	if (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {
 		if (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&
 		    (tif->tif_flags & TIFF_NOBITREV) == 0)
-			TIFFReverseBits((uint8*)tif->tif_rawdata,
+			TIFFReverseBits((uint8_t*)tif->tif_rawdata,
 			    tif->tif_rawcc);
 		if (!TIFFAppendToStrip(tif,
 		    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,
diff --git a/src/3rdparty/libtiff/libtiff/tif_zip.c b/src/3rdparty/libtiff/libtiff/tif_zip.c
index c750773..be35e49 100644
--- a/src/3rdparty/libtiff/libtiff/tif_zip.c
+++ b/src/3rdparty/libtiff/libtiff/tif_zip.c
@@ -29,24 +29,22 @@
  *
  * ZIP (aka Deflate) Compression Support
  *
- * This file is simply an interface to the zlib library written by
+ * This file is an interface to the zlib library written by
  * Jean-loup Gailly and Mark Adler.  You must use version 1.0 or later
- * of the library: this code assumes the 1.0 API and also depends on
- * the ability to write the zlib header multiple times (one per strip)
- * which was not possible with versions prior to 0.95.  Note also that
- * older versions of this codec avoided this bug by suppressing the header
- * entirely.  This means that files written with the old library cannot
- * be read; they should be converted to a different compression scheme
- * and then reconverted.
+ * of the library.
  *
- * The data format used by the zlib library is described in the files
- * zlib-3.1.doc, deflate-1.1.doc and gzip-4.1.doc, available in the
- * directory ftp://ftp.uu.net/pub/archiving/zip/doc.  The library was
- * last found at ftp://ftp.uu.net/pub/archiving/zip/zlib/zlib-0.99.tar.gz.
+ * Optionally, libdeflate (https://github.com/ebiggers/libdeflate) may be used
+ * to do the compression and decompression, but only for whole strips and tiles.
+ * For scanline access, zlib will be sued as a fallback.
  */
 #include "tif_predict.h"
 #include "zlib.h"
 
+#if LIBDEFLATE_SUPPORT
+#include "libdeflate.h"
+#endif
+#define LIBDEFLATE_MAX_COMPRESSION_LEVEL 12
+
 #include <stdio.h>
 
 /*
@@ -70,6 +68,12 @@ typedef struct {
         z_stream        stream;
 	int             zipquality;            /* compression level */
 	int             state;                 /* state flags */
+	int             subcodec;              /* DEFLATE_SUBCODEC_ZLIB or DEFLATE_SUBCODEC_LIBDEFLATE */
+#if LIBDEFLATE_SUPPORT
+	int             libdeflate_state;       /* -1 = until first time ZIPEncode() / ZIPDecode() is called, 0 = use zlib, 1 = use libdeflate */
+	struct libdeflate_decompressor* libdeflate_dec;
+	struct libdeflate_compressor*   libdeflate_enc;
+#endif
 #define ZSTATE_INIT_DECODE 0x01
 #define ZSTATE_INIT_ENCODE 0x02
 
@@ -81,8 +85,8 @@ typedef struct {
 #define DecoderState(tif)       ZState(tif)
 #define EncoderState(tif)       ZState(tif)
 
-static int ZIPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s);
-static int ZIPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s);
+static int ZIPEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s);
+static int ZIPDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s);
 
 static int
 ZIPFixupTags(TIFF* tif)
@@ -122,7 +126,7 @@ ZIPSetupDecode(TIFF* tif)
  * Setup state for decoding a strip.
  */
 static int
-ZIPPreDecode(TIFF* tif, uint16 s)
+ZIPPreDecode(TIFF* tif, uint16_t s)
 {
 	ZIPState* sp = DecoderState(tif);
 
@@ -132,17 +136,20 @@ ZIPPreDecode(TIFF* tif, uint16 s)
 	if( (sp->state & ZSTATE_INIT_DECODE) == 0 )
             tif->tif_setupdecode( tif );
 
+#if LIBDEFLATE_SUPPORT
+        sp->libdeflate_state = -1;
+#endif
 	sp->stream.next_in = tif->tif_rawdata;
 	assert(sizeof(sp->stream.avail_in)==4);  /* if this assert gets raised,
 	    we need to simplify this code to reflect a ZLib that is likely updated
 	    to deal with 8byte memory sizes, though this code will respond
 	    appropriately even before we simplify it */
-	sp->stream.avail_in = (uint64)tif->tif_rawcc < 0xFFFFFFFFU ? (uInt) tif->tif_rawcc : 0xFFFFFFFFU;
+	sp->stream.avail_in = (uint64_t)tif->tif_rawcc < 0xFFFFFFFFU ? (uInt) tif->tif_rawcc : 0xFFFFFFFFU;
 	return (inflateReset(&sp->stream) == Z_OK);
 }
 
 static int
-ZIPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
+ZIPDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
 {
 	static const char module[] = "ZIPDecode";
 	ZIPState* sp = DecoderState(tif);
@@ -151,6 +158,77 @@ ZIPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	assert(sp != NULL);
 	assert(sp->state == ZSTATE_INIT_DECODE);
 
+#if LIBDEFLATE_SUPPORT
+        if( sp->libdeflate_state == 1 )
+            return 0;
+
+        /* If we have libdeflate support and we are asked to read a whole */
+        /* strip/tile, then go for using it */
+        do {
+            TIFFDirectory *td = &tif->tif_dir;
+
+            if( sp->libdeflate_state == 0 )
+                break;
+            if( sp->subcodec == DEFLATE_SUBCODEC_ZLIB )
+                break;
+
+            /* Check if we are in the situation where we can use libdeflate */
+            if (isTiled(tif)) {
+                if( TIFFTileSize64(tif) != (uint64_t)occ )
+                    break;
+            } else {
+                uint32_t strip_height = td->td_imagelength - tif->tif_row;
+                if (strip_height > td->td_rowsperstrip)
+                    strip_height = td->td_rowsperstrip;
+                if( TIFFVStripSize64(tif, strip_height) != (uint64_t)occ )
+                    break;
+            }
+
+            /* Check for overflow */
+            if( (size_t)tif->tif_rawcc != (uint64_t)tif->tif_rawcc )
+                break;
+            if( (size_t)occ != (uint64_t)occ )
+                break;
+
+            /* Go for decompression using libdeflate */
+            {
+                enum libdeflate_result res;
+                if( sp->libdeflate_dec == NULL )
+                {
+                    sp->libdeflate_dec = libdeflate_alloc_decompressor();
+                    if( sp->libdeflate_dec == NULL )
+                    {
+                        break;
+                    }
+                }
+
+                sp->libdeflate_state = 1;
+
+                res = libdeflate_zlib_decompress(
+                    sp->libdeflate_dec, tif->tif_rawcp, (size_t)tif->tif_rawcc, op, (size_t)occ, NULL);
+
+                tif->tif_rawcp += tif->tif_rawcc;
+                tif->tif_rawcc = 0;
+
+                /* We accept LIBDEFLATE_INSUFFICIENT_SPACE has a return */
+                /* There are odd files in the wild where the last strip, when */
+                /* it is smaller in height than td_rowsperstrip, actually contains */
+                /* data for td_rowsperstrip lines. Just ignore that silently. */
+                if( res != LIBDEFLATE_SUCCESS &&
+                    res != LIBDEFLATE_INSUFFICIENT_SPACE )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "Decoding error at scanline %lu",
+                                 (unsigned long) tif->tif_row);
+                    return 0;
+                }
+
+                return 1;
+            }
+        } while(0);
+        sp->libdeflate_state = 0;
+#endif /* LIBDEFLATE_SUPPORT */
+
         sp->stream.next_in = tif->tif_rawcp;
         
 	sp->stream.next_out = op;
@@ -160,8 +238,8 @@ ZIPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	    appropriately even before we simplify it */
 	do {
                 int state;
-                uInt avail_in_before = (uint64)tif->tif_rawcc <= 0xFFFFFFFFU ? (uInt)tif->tif_rawcc : 0xFFFFFFFFU;
-                uInt avail_out_before = (uint64)occ < 0xFFFFFFFFU ? (uInt) occ : 0xFFFFFFFFU;
+                uInt avail_in_before = (uint64_t)tif->tif_rawcc <= 0xFFFFFFFFU ? (uInt)tif->tif_rawcc : 0xFFFFFFFFU;
+                uInt avail_out_before = (uint64_t)occ < 0xFFFFFFFFU ? (uInt) occ : 0xFFFFFFFFU;
                 sp->stream.avail_in = avail_in_before;
                 sp->stream.avail_out = avail_out_before;
 		state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
@@ -183,8 +261,8 @@ ZIPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 	} while (occ > 0);
 	if (occ != 0) {
 		TIFFErrorExt(tif->tif_clientdata, module,
-		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",
-		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) occ);
+		    "Not enough data at scanline %lu (short %" PRIu64 " bytes)",
+		    (unsigned long) tif->tif_row, (uint64_t) occ);
 		return (0);
 	}
 
@@ -198,6 +276,7 @@ ZIPSetupEncode(TIFF* tif)
 {
 	static const char module[] = "ZIPSetupEncode";
 	ZIPState* sp = EncoderState(tif);
+        int cappedQuality;
 
 	assert(sp != NULL);
 	if (sp->state & ZSTATE_INIT_DECODE) {
@@ -205,7 +284,11 @@ ZIPSetupEncode(TIFF* tif)
 		sp->state = 0;
 	}
 
-	if (deflateInit(&sp->stream, sp->zipquality) != Z_OK) {
+        cappedQuality = sp->zipquality;
+        if( cappedQuality > Z_BEST_COMPRESSION )
+            cappedQuality = Z_BEST_COMPRESSION;
+
+	if (deflateInit(&sp->stream, cappedQuality) != Z_OK) {
 		TIFFErrorExt(tif->tif_clientdata, module, "%s", SAFE_MSG(sp));
 		return (0);
 	} else {
@@ -218,7 +301,7 @@ ZIPSetupEncode(TIFF* tif)
  * Reset encoding state at the start of a strip.
  */
 static int
-ZIPPreEncode(TIFF* tif, uint16 s)
+ZIPPreEncode(TIFF* tif, uint16_t s)
 {
 	ZIPState *sp = EncoderState(tif);
 
@@ -227,12 +310,15 @@ ZIPPreEncode(TIFF* tif, uint16 s)
 	if( sp->state != ZSTATE_INIT_ENCODE )
             tif->tif_setupencode( tif );
 
+#if LIBDEFLATE_SUPPORT
+        sp->libdeflate_state = -1;
+#endif
 	sp->stream.next_out = tif->tif_rawdata;
 	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
 	    we need to simplify this code to reflect a ZLib that is likely updated
 	    to deal with 8byte memory sizes, though this code will respond
 	    appropriately even before we simplify it */
-	sp->stream.avail_out = (uint64)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;
+	sp->stream.avail_out = (uint64_t)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;
 	return (deflateReset(&sp->stream) == Z_OK);
 }
 
@@ -240,7 +326,7 @@ ZIPPreEncode(TIFF* tif, uint16 s)
  * Encode a chunk of pixels.
  */
 static int
-ZIPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
+ZIPEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
 {
 	static const char module[] = "ZIPEncode";
 	ZIPState *sp = EncoderState(tif);
@@ -249,13 +335,102 @@ ZIPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 	assert(sp->state == ZSTATE_INIT_ENCODE);
 
 	(void) s;
+
+#if LIBDEFLATE_SUPPORT
+        if( sp->libdeflate_state == 1 )
+            return 0;
+
+        /* If we have libdeflate support and we are asked to write a whole */
+        /* strip/tile, then go for using it */
+        do {
+            TIFFDirectory *td = &tif->tif_dir;
+
+            if( sp->libdeflate_state == 0 )
+                break;
+            if( sp->subcodec == DEFLATE_SUBCODEC_ZLIB )
+                break;
+
+            /* Libdeflate does not support the 0-compression level */
+            if( sp->zipquality == Z_NO_COMPRESSION )
+                break;
+
+            /* Check if we are in the situation where we can use libdeflate */
+            if (isTiled(tif)) {
+                if( TIFFTileSize64(tif) != (uint64_t)cc )
+                    break;
+            } else {
+                uint32_t strip_height = td->td_imagelength - tif->tif_row;
+                if (strip_height > td->td_rowsperstrip)
+                    strip_height = td->td_rowsperstrip;
+                if( TIFFVStripSize64(tif, strip_height) != (uint64_t)cc )
+                    break;
+            }
+
+            /* Check for overflow */
+            if( (size_t)tif->tif_rawdatasize != (uint64_t)tif->tif_rawdatasize )
+                break;
+            if( (size_t)cc != (uint64_t)cc )
+                break;
+
+            /* Go for compression using libdeflate */
+            {
+                size_t nCompressedBytes;
+                if( sp->libdeflate_enc == NULL )
+                {
+                    /* To get results as good as zlib, we asked for an extra */
+                    /* level of compression */
+                    sp->libdeflate_enc = libdeflate_alloc_compressor(
+                        sp->zipquality == Z_DEFAULT_COMPRESSION ? 7 :
+                        sp->zipquality >= 6 && sp->zipquality <= 9 ? sp->zipquality + 1 :
+                        sp->zipquality);
+                    if( sp->libdeflate_enc == NULL )
+                    {
+                        TIFFErrorExt(tif->tif_clientdata, module,
+                                    "Cannot allocate compressor");
+                        break;
+                    }
+                }
+
+                /* Make sure the output buffer is large enough for the worse case. */
+                /* In TIFFWriteBufferSetup(), when libtiff allocates the buffer */
+                /* we've taken a 10% margin over the uncompressed size, which should */
+                /* be large enough even for the the worse case scenario. */
+                if( libdeflate_zlib_compress_bound(sp->libdeflate_enc, (size_t)cc) >
+                        (size_t)tif->tif_rawdatasize)
+                {
+                    break;
+                }
+
+                sp->libdeflate_state = 1;
+                nCompressedBytes = libdeflate_zlib_compress(
+                    sp->libdeflate_enc, bp, (size_t)cc, tif->tif_rawdata, (size_t)tif->tif_rawdatasize);
+
+                if( nCompressedBytes == 0 )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "Encoder error at scanline %lu",
+                                 (unsigned long) tif->tif_row);
+                    return 0;
+                }
+
+                tif->tif_rawcc = nCompressedBytes;
+
+                if( !TIFFFlushData1(tif) )
+                    return 0;
+
+                return 1;
+            }
+        } while(0);
+        sp->libdeflate_state = 0;
+#endif /* LIBDEFLATE_SUPPORT */
+
 	sp->stream.next_in = bp;
 	assert(sizeof(sp->stream.avail_in)==4);  /* if this assert gets raised,
 	    we need to simplify this code to reflect a ZLib that is likely updated
 	    to deal with 8byte memory sizes, though this code will respond
 	    appropriately even before we simplify it */
 	do {
-                uInt avail_in_before = (uint64)cc <= 0xFFFFFFFFU ? (uInt)cc : 0xFFFFFFFFU;
+                uInt avail_in_before = (uint64_t)cc <= 0xFFFFFFFFU ? (uInt)cc : 0xFFFFFFFFU;
                 sp->stream.avail_in = avail_in_before;
 		if (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) {
 			TIFFErrorExt(tif->tif_clientdata, module, 
@@ -265,9 +440,10 @@ ZIPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 		}
 		if (sp->stream.avail_out == 0) {
 			tif->tif_rawcc = tif->tif_rawdatasize;
-			TIFFFlushData1(tif);
+			if (!TIFFFlushData1(tif))
+				return 0;
 			sp->stream.next_out = tif->tif_rawdata;
-			sp->stream.avail_out = (uint64)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;
+			sp->stream.avail_out = (uint64_t)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;
 		}
 		cc -= (avail_in_before - sp->stream.avail_in);
 	} while (cc > 0);
@@ -285,6 +461,11 @@ ZIPPostEncode(TIFF* tif)
 	ZIPState *sp = EncoderState(tif);
 	int state;
 
+#if LIBDEFLATE_SUPPORT
+        if( sp->libdeflate_state == 1 )
+            return 1;
+#endif
+
 	sp->stream.avail_in = 0;
 	do {
 		state = deflate(&sp->stream, Z_FINISH);
@@ -294,9 +475,10 @@ ZIPPostEncode(TIFF* tif)
 			if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize)
 			{
 				tif->tif_rawcc =  tif->tif_rawdatasize - sp->stream.avail_out;
-				TIFFFlushData1(tif);
+				if (!TIFFFlushData1(tif))
+					return 0;
 				sp->stream.next_out = tif->tif_rawdata;
-				sp->stream.avail_out = (uint64)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;
+				sp->stream.avail_out = (uint64_t)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;
 			}
 			break;
 		default:
@@ -327,6 +509,14 @@ ZIPCleanup(TIFF* tif)
 		inflateEnd(&sp->stream);
 		sp->state = 0;
 	}
+
+#if LIBDEFLATE_SUPPORT
+        if( sp->libdeflate_dec )
+            libdeflate_free_decompressor(sp->libdeflate_dec);
+        if( sp->libdeflate_enc )
+            libdeflate_free_compressor(sp->libdeflate_enc);
+#endif
+
 	_TIFFfree(sp);
 	tif->tif_data = NULL;
 
@@ -334,7 +524,7 @@ ZIPCleanup(TIFF* tif)
 }
 
 static int
-ZIPVSetField(TIFF* tif, uint32 tag, va_list ap)
+ZIPVSetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	static const char module[] = "ZIPVSetField";
 	ZIPState* sp = ZState(tif);
@@ -342,15 +532,55 @@ ZIPVSetField(TIFF* tif, uint32 tag, va_list ap)
 	switch (tag) {
 	case TIFFTAG_ZIPQUALITY:
 		sp->zipquality = (int) va_arg(ap, int);
-		if ( sp->state&ZSTATE_INIT_ENCODE ) {
+                if( sp->zipquality < Z_DEFAULT_COMPRESSION ||
+                    sp->zipquality > LIBDEFLATE_MAX_COMPRESSION_LEVEL ) {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "Invalid ZipQuality value. Should be in [-1,%d] range",
+                                 LIBDEFLATE_MAX_COMPRESSION_LEVEL);
+                    return 0;
+                }
+
+                if ( sp->state&ZSTATE_INIT_ENCODE ) {
+                        int cappedQuality = sp->zipquality;
+                        if( cappedQuality > Z_BEST_COMPRESSION )
+                            cappedQuality = Z_BEST_COMPRESSION;
 			if (deflateParams(&sp->stream,
-			    sp->zipquality, Z_DEFAULT_STRATEGY) != Z_OK) {
+			    cappedQuality, Z_DEFAULT_STRATEGY) != Z_OK) {
 				TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",
 					     SAFE_MSG(sp));
 				return (0);
 			}
 		}
+
+#if LIBDEFLATE_SUPPORT
+                if( sp->libdeflate_enc )
+                {
+                    libdeflate_free_compressor(sp->libdeflate_enc);
+                    sp->libdeflate_enc = NULL;
+                }
+#endif
+
 		return (1);
+
+        case TIFFTAG_DEFLATE_SUBCODEC:
+                sp->subcodec = (int) va_arg(ap, int);
+                if( sp->subcodec != DEFLATE_SUBCODEC_ZLIB &&
+                    sp->subcodec != DEFLATE_SUBCODEC_LIBDEFLATE )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "Invalid DeflateCodec value.");
+                    return 0;
+                }
+#if !LIBDEFLATE_SUPPORT
+                if( sp->subcodec == DEFLATE_SUBCODEC_LIBDEFLATE )
+                {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                 "DeflateCodec = DEFLATE_SUBCODEC_LIBDEFLATE unsupported in this build");
+                    return 0;
+                }
+#endif
+                return 1;
+
 	default:
 		return (*sp->vsetparent)(tif, tag, ap);
 	}
@@ -358,7 +588,7 @@ ZIPVSetField(TIFF* tif, uint32 tag, va_list ap)
 }
 
 static int
-ZIPVGetField(TIFF* tif, uint32 tag, va_list ap)
+ZIPVGetField(TIFF* tif, uint32_t tag, va_list ap)
 {
 	ZIPState* sp = ZState(tif);
 
@@ -366,6 +596,11 @@ ZIPVGetField(TIFF* tif, uint32 tag, va_list ap)
 	case TIFFTAG_ZIPQUALITY:
 		*va_arg(ap, int*) = sp->zipquality;
 		break;
+
+        case TIFFTAG_DEFLATE_SUBCODEC:
+		*va_arg(ap, int*) = sp->subcodec;
+		break;
+
 	default:
 		return (*sp->vgetparent)(tif, tag, ap);
 	}
@@ -374,6 +609,7 @@ ZIPVGetField(TIFF* tif, uint32 tag, va_list ap)
 
 static const TIFFField zipFields[] = {
     { TIFFTAG_ZIPQUALITY, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT, TIFF_SETGET_UNDEFINED, FIELD_PSEUDO, TRUE, FALSE, "", NULL },
+    { TIFFTAG_DEFLATE_SUBCODEC, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT, TIFF_SETGET_UNDEFINED, FIELD_PSEUDO, TRUE, FALSE, "", NULL },
 };
 
 int
@@ -384,6 +620,9 @@ TIFFInitZIP(TIFF* tif, int scheme)
 
 	assert( (scheme == COMPRESSION_DEFLATE)
 		|| (scheme == COMPRESSION_ADOBE_DEFLATE));
+#ifdef NDEBUG
+	(void)scheme;
+#endif
 
 	/*
 	 * Merge codec-specific tag information.
@@ -397,7 +636,7 @@ TIFFInitZIP(TIFF* tif, int scheme)
 	/*
 	 * Allocate state block so tag methods have storage to record values.
 	 */
-	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (ZIPState));
+	tif->tif_data = (uint8_t*) _TIFFcalloc(sizeof (ZIPState), 1);
 	if (tif->tif_data == NULL)
 		goto bad;
 	sp = ZState(tif);
@@ -417,6 +656,11 @@ TIFFInitZIP(TIFF* tif, int scheme)
 	/* Default values for codec-specific fields */
 	sp->zipquality = Z_DEFAULT_COMPRESSION;	/* default comp. level */
 	sp->state = 0;
+#if LIBDEFLATE_SUPPORT
+        sp->subcodec = DEFLATE_SUBCODEC_LIBDEFLATE;
+#else
+        sp->subcodec = DEFLATE_SUBCODEC_ZLIB;
+#endif
 
 	/*
 	 * Install codec methods.
diff --git a/src/3rdparty/libtiff/libtiff/tif_zstd.c b/src/3rdparty/libtiff/libtiff/tif_zstd.c
new file mode 100644
index 0000000..14ac081
--- /dev/null
+++ b/src/3rdparty/libtiff/libtiff/tif_zstd.c
@@ -0,0 +1,443 @@
+/*
+* Copyright (c) 2017, Planet Labs
+* Author: <even.rouault at spatialys.com>
+*
+* Permission to use, copy, modify, distribute, and sell this software and
+* its documentation for any purpose is hereby granted without fee, provided
+* that (i) the above copyright notices and this permission notice appear in
+* all copies of the software and related documentation, and (ii) the names of
+* Sam Leffler and Silicon Graphics may not be used in any advertising or
+* publicity relating to the software without the specific, prior written
+* permission of Sam Leffler and Silicon Graphics.
+*
+* THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
+* WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+*
+* IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+* ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+* OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+* WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
+* LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+* OF THIS SOFTWARE.
+*/
+
+#include "tiffiop.h"
+#ifdef ZSTD_SUPPORT
+/*
+* TIFF Library.
+*
+* ZSTD Compression Support
+*
+*/
+
+#include "tif_predict.h"
+#include "zstd.h"
+
+#include <stdio.h>
+
+/*
+* State block for each open TIFF file using ZSTD compression/decompression.
+*/
+typedef struct {
+        TIFFPredictorState predict;
+        ZSTD_DStream*   dstream;
+        ZSTD_CStream*   cstream;
+        int             compression_level;      /* compression level */
+        ZSTD_outBuffer  out_buffer;
+        int             state;                  /* state flags */
+#define LSTATE_INIT_DECODE 0x01
+#define LSTATE_INIT_ENCODE 0x02
+
+        TIFFVGetMethod  vgetparent;            /* super-class method */
+        TIFFVSetMethod  vsetparent;            /* super-class method */
+} ZSTDState;
+
+#define LState(tif)             ((ZSTDState*) (tif)->tif_data)
+#define DecoderState(tif)       LState(tif)
+#define EncoderState(tif)       LState(tif)
+
+static int ZSTDEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s);
+static int ZSTDDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s);
+
+static int
+ZSTDFixupTags(TIFF* tif)
+{
+        (void) tif;
+        return 1;
+}
+
+static int
+ZSTDSetupDecode(TIFF* tif)
+{
+        ZSTDState* sp = DecoderState(tif);
+
+        assert(sp != NULL);
+
+        /* if we were last encoding, terminate this mode */
+        if (sp->state & LSTATE_INIT_ENCODE) {
+            ZSTD_freeCStream(sp->cstream);
+            sp->cstream = NULL;
+            sp->state = 0;
+        }
+
+        sp->state |= LSTATE_INIT_DECODE;
+        return 1;
+}
+
+/*
+* Setup state for decoding a strip.
+*/
+static int
+ZSTDPreDecode(TIFF* tif, uint16_t s)
+{
+        static const char module[] = "ZSTDPreDecode";
+        ZSTDState* sp = DecoderState(tif);
+        size_t zstd_ret;
+
+        (void) s;
+        assert(sp != NULL);
+
+        if( (sp->state & LSTATE_INIT_DECODE) == 0 )
+            tif->tif_setupdecode(tif);
+
+        if( sp->dstream )
+        {
+            ZSTD_freeDStream(sp->dstream);
+            sp->dstream = NULL;
+        }
+
+        sp->dstream = ZSTD_createDStream();
+        if( sp->dstream == NULL ) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Cannot allocate decompression stream");
+            return 0;
+        }
+        zstd_ret = ZSTD_initDStream(sp->dstream);
+        if( ZSTD_isError(zstd_ret) ) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Error in ZSTD_initDStream(): %s",
+                         ZSTD_getErrorName(zstd_ret));
+            return 0;
+        }
+
+        return 1;
+}
+
+static int
+ZSTDDecode(TIFF* tif, uint8_t* op, tmsize_t occ, uint16_t s)
+{
+        static const char module[] = "ZSTDDecode";
+        ZSTDState* sp = DecoderState(tif);
+        ZSTD_inBuffer   in_buffer;
+        ZSTD_outBuffer  out_buffer;
+        size_t          zstd_ret;
+
+        (void) s;
+        assert(sp != NULL);
+        assert(sp->state == LSTATE_INIT_DECODE);
+
+        in_buffer.src = tif->tif_rawcp;
+        in_buffer.size = (size_t) tif->tif_rawcc;
+        in_buffer.pos = 0;
+
+        out_buffer.dst = op;
+        out_buffer.size = (size_t) occ;
+        out_buffer.pos = 0;
+
+        do {
+                zstd_ret = ZSTD_decompressStream(sp->dstream, &out_buffer,
+                                                 &in_buffer);
+                if( ZSTD_isError(zstd_ret) ) {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                "Error in ZSTD_decompressStream(): %s",
+                                ZSTD_getErrorName(zstd_ret));
+                    return 0;
+                }
+        } while( zstd_ret != 0 &&
+                 in_buffer.pos < in_buffer.size &&
+                 out_buffer.pos < out_buffer.size );
+
+        if (out_buffer.pos < (size_t)occ) {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                    "Not enough data at scanline %lu (short %lu bytes)",
+                    (unsigned long) tif->tif_row,
+                    (unsigned long) (size_t)occ - out_buffer.pos);
+                return 0;
+        }
+
+        tif->tif_rawcp += in_buffer.pos;
+        tif->tif_rawcc -= in_buffer.pos;
+
+        return 1;
+}
+
+static int
+ZSTDSetupEncode(TIFF* tif)
+{
+        ZSTDState* sp = EncoderState(tif);
+
+        assert(sp != NULL);
+        if (sp->state & LSTATE_INIT_DECODE) {
+                ZSTD_freeDStream(sp->dstream);
+                sp->dstream = NULL;
+                sp->state = 0;
+        }
+
+        sp->state |= LSTATE_INIT_ENCODE;
+        return 1;
+}
+
+/*
+* Reset encoding state at the start of a strip.
+*/
+static int
+ZSTDPreEncode(TIFF* tif, uint16_t s)
+{
+        static const char module[] = "ZSTDPreEncode";
+        ZSTDState *sp = EncoderState(tif);
+        size_t zstd_ret;
+
+        (void) s;
+        assert(sp != NULL);
+        if( sp->state != LSTATE_INIT_ENCODE )
+            tif->tif_setupencode(tif);
+
+        if (sp->cstream) {
+            ZSTD_freeCStream(sp->cstream);
+            sp->cstream = NULL;
+        }
+        sp->cstream = ZSTD_createCStream();
+        if( sp->cstream == NULL ) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Cannot allocate compression stream");
+            return 0;
+        }
+
+        zstd_ret = ZSTD_initCStream(sp->cstream, sp->compression_level);
+        if( ZSTD_isError(zstd_ret) ) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                         "Error in ZSTD_initCStream(): %s",
+                         ZSTD_getErrorName(zstd_ret));
+            return 0;
+        }
+
+        sp->out_buffer.dst = tif->tif_rawdata;
+        sp->out_buffer.size = (size_t)tif->tif_rawdatasize;
+        sp->out_buffer.pos = 0;
+
+        return 1;
+}
+
+/*
+* Encode a chunk of pixels.
+*/
+static int
+ZSTDEncode(TIFF* tif, uint8_t* bp, tmsize_t cc, uint16_t s)
+{
+        static const char module[] = "ZSTDEncode";
+        ZSTDState *sp = EncoderState(tif);
+        ZSTD_inBuffer   in_buffer;
+        size_t          zstd_ret;
+
+        assert(sp != NULL);
+        assert(sp->state == LSTATE_INIT_ENCODE);
+
+        (void) s;
+
+        in_buffer.src = bp;
+        in_buffer.size = (size_t)cc;
+        in_buffer.pos = 0;
+
+        do {
+                zstd_ret = ZSTD_compressStream(sp->cstream, &sp->out_buffer,
+                                               &in_buffer);
+                if( ZSTD_isError(zstd_ret) ) {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                "Error in ZSTD_compressStream(): %s",
+                                ZSTD_getErrorName(zstd_ret));
+                    return 0;
+                }
+                if( sp->out_buffer.pos == sp->out_buffer.size ) {
+                        tif->tif_rawcc = tif->tif_rawdatasize;
+                        if (!TIFFFlushData1(tif))
+                                return 0;
+                        sp->out_buffer.dst = tif->tif_rawcp;
+                        sp->out_buffer.pos = 0;
+                }
+        } while( in_buffer.pos < in_buffer.size );
+
+        return 1;
+}
+
+/*
+* Finish off an encoded strip by flushing it.
+*/
+static int
+ZSTDPostEncode(TIFF* tif)
+{
+        static const char module[] = "ZSTDPostEncode";
+        ZSTDState *sp = EncoderState(tif);
+        size_t          zstd_ret;
+
+        do {
+                zstd_ret = ZSTD_endStream(sp->cstream, &sp->out_buffer);
+                if( ZSTD_isError(zstd_ret) ) {
+                    TIFFErrorExt(tif->tif_clientdata, module,
+                                "Error in ZSTD_endStream(): %s",
+                                ZSTD_getErrorName(zstd_ret));
+                    return 0;
+                }
+                if( sp->out_buffer.pos > 0 ) {
+                        tif->tif_rawcc = sp->out_buffer.pos;
+                        if (!TIFFFlushData1(tif))
+                                return 0;
+                        sp->out_buffer.dst = tif->tif_rawcp;
+                        sp->out_buffer.pos = 0;
+                }
+        } while (zstd_ret != 0);
+        return 1;
+}
+
+static void
+ZSTDCleanup(TIFF* tif)
+{
+        ZSTDState* sp = LState(tif);
+
+        assert(sp != 0);
+
+        (void)TIFFPredictorCleanup(tif);
+
+        tif->tif_tagmethods.vgetfield = sp->vgetparent;
+        tif->tif_tagmethods.vsetfield = sp->vsetparent;
+
+        if (sp->dstream) {
+            ZSTD_freeDStream(sp->dstream);
+            sp->dstream = NULL;
+        }
+        if (sp->cstream) {
+            ZSTD_freeCStream(sp->cstream);
+            sp->cstream = NULL;
+        }
+        _TIFFfree(sp);
+        tif->tif_data = NULL;
+
+        _TIFFSetDefaultCompressionState(tif);
+}
+
+static int
+ZSTDVSetField(TIFF* tif, uint32_t tag, va_list ap)
+{
+	static const char module[] = "ZSTDVSetField";
+        ZSTDState* sp = LState(tif);
+
+        switch (tag) {
+        case TIFFTAG_ZSTD_LEVEL:
+                sp->compression_level = (int) va_arg(ap, int);
+                if( sp->compression_level <= 0 ||
+                    sp->compression_level > ZSTD_maxCLevel() )
+                {
+                    TIFFWarningExt(tif->tif_clientdata, module,
+                                   "ZSTD_LEVEL should be between 1 and %d",
+                                   ZSTD_maxCLevel());
+                }
+                return 1;
+        default:
+                return (*sp->vsetparent)(tif, tag, ap);
+        }
+        /*NOTREACHED*/
+}
+
+static int
+ZSTDVGetField(TIFF* tif, uint32_t tag, va_list ap)
+{
+        ZSTDState* sp = LState(tif);
+
+        switch (tag) {
+        case TIFFTAG_ZSTD_LEVEL:
+                *va_arg(ap, int*) = sp->compression_level;
+                break;
+        default:
+                return (*sp->vgetparent)(tif, tag, ap);
+        }
+        return 1;
+}
+
+static const TIFFField ZSTDFields[] = {
+        { TIFFTAG_ZSTD_LEVEL, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT,
+          TIFF_SETGET_UNDEFINED,
+          FIELD_PSEUDO, TRUE, FALSE, "ZSTD compression_level", NULL },
+};
+
+int
+TIFFInitZSTD(TIFF* tif, int scheme)
+{
+        static const char module[] = "TIFFInitZSTD";
+        ZSTDState* sp;
+
+        (void) scheme;
+        assert( scheme == COMPRESSION_ZSTD );
+
+        /*
+        * Merge codec-specific tag information.
+        */
+        if (!_TIFFMergeFields(tif, ZSTDFields, TIFFArrayCount(ZSTDFields))) {
+                TIFFErrorExt(tif->tif_clientdata, module,
+                            "Merging ZSTD codec-specific tags failed");
+                return 0;
+        }
+
+        /*
+        * Allocate state block so tag methods have storage to record values.
+        */
+        tif->tif_data = (uint8_t*) _TIFFmalloc(sizeof(ZSTDState));
+        if (tif->tif_data == NULL)
+                goto bad;
+        sp = LState(tif);
+
+        /*
+        * Override parent get/set field methods.
+        */
+        sp->vgetparent = tif->tif_tagmethods.vgetfield;
+        tif->tif_tagmethods.vgetfield = ZSTDVGetField;	/* hook for codec tags */
+        sp->vsetparent = tif->tif_tagmethods.vsetfield;
+        tif->tif_tagmethods.vsetfield = ZSTDVSetField;	/* hook for codec tags */
+
+        /* Default values for codec-specific fields */
+        sp->compression_level = 9;		/* default comp. level */
+        sp->state = 0;
+        sp->dstream = 0;
+        sp->cstream = 0;
+        sp->out_buffer.dst = NULL;
+        sp->out_buffer.size = 0;
+        sp->out_buffer.pos = 0;
+
+        /*
+        * Install codec methods.
+        */
+        tif->tif_fixuptags = ZSTDFixupTags;
+        tif->tif_setupdecode = ZSTDSetupDecode;
+        tif->tif_predecode = ZSTDPreDecode;
+        tif->tif_decoderow = ZSTDDecode;
+        tif->tif_decodestrip = ZSTDDecode;
+        tif->tif_decodetile = ZSTDDecode;
+        tif->tif_setupencode = ZSTDSetupEncode;
+        tif->tif_preencode = ZSTDPreEncode;
+        tif->tif_postencode = ZSTDPostEncode;
+        tif->tif_encoderow = ZSTDEncode;
+        tif->tif_encodestrip = ZSTDEncode;
+        tif->tif_encodetile = ZSTDEncode;
+        tif->tif_cleanup = ZSTDCleanup;
+        /*
+        * Setup predictor setup.
+        */
+        (void) TIFFPredictorInit(tif);
+        return 1;
+bad:
+        TIFFErrorExt(tif->tif_clientdata, module,
+                    "No space for ZSTD state block");
+        return 0;
+}
+#endif /* ZSTD_SUPPORT */
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff --git a/src/3rdparty/libtiff/libtiff/tiff.h b/src/3rdparty/libtiff/libtiff/tiff.h
index 5b0a0c9..bd79270 100644
--- a/src/3rdparty/libtiff/libtiff/tiff.h
+++ b/src/3rdparty/libtiff/libtiff/tiff.h
@@ -56,24 +56,37 @@
 /*
  * Intrinsic data types required by the file format:
  *
- * 8-bit quantities     int8/uint8
- * 16-bit quantities    int16/uint16
- * 32-bit quantities    int32/uint32
- * 64-bit quantities    int64/uint64
+ * 8-bit quantities     int8_t/uint_8_t
+ * 16-bit quantities    int16_t/uint_16_t
+ * 32-bit quantities    int32_t/uint_32_t
+ * 64-bit quantities    int64_t/uint_64_t
  * strings              unsigned char*
  */
+#ifdef __GNUC__
+#define TIFF_GCC_DEPRECATED __attribute__((deprecated))
+#else
+#define TIFF_GCC_DEPRECATED
+#endif
+#ifdef _MSC_VER
+#define TIFF_MSC_DEPRECATED __declspec(deprecated("libtiff type deprecated; please use corresponding C99 stdint.h type"))
+#else
+#define TIFF_MSC_DEPRECATED
+#endif
 
-typedef TIFF_INT8_T   int8;
-typedef TIFF_UINT8_T  uint8;
+#ifndef TIFF_DISABLE_DEPRECATED
+typedef TIFF_MSC_DEPRECATED int8_t   int8   TIFF_GCC_DEPRECATED;
+typedef TIFF_MSC_DEPRECATED uint8_t  uint8  TIFF_GCC_DEPRECATED;
 
-typedef TIFF_INT16_T  int16;
-typedef TIFF_UINT16_T uint16;
+typedef TIFF_MSC_DEPRECATED int16_t  int16  TIFF_GCC_DEPRECATED;
+typedef TIFF_MSC_DEPRECATED uint16_t uint16 TIFF_GCC_DEPRECATED;
 
-typedef TIFF_INT32_T  int32;
-typedef TIFF_UINT32_T uint32;
+typedef TIFF_MSC_DEPRECATED int32_t  int32  TIFF_GCC_DEPRECATED;
+typedef TIFF_MSC_DEPRECATED uint32_t uint32 TIFF_GCC_DEPRECATED;
+
+typedef TIFF_MSC_DEPRECATED int64_t  int64  TIFF_GCC_DEPRECATED;
+typedef TIFF_MSC_DEPRECATED uint64_t uint64 TIFF_GCC_DEPRECATED;
+#endif /* TIFF_DISABLE_DEPRECATED */
 
-typedef TIFF_INT64_T  int64;
-typedef TIFF_UINT64_T uint64;
 
 /*
  * Some types as promoted in a variable argument list
@@ -89,20 +102,20 @@ typedef int uint16_vap;
  * TIFF header.
  */
 typedef struct {
-	uint16 tiff_magic;      /* magic number (defines byte order) */
-	uint16 tiff_version;    /* TIFF version number */
+	uint16_t tiff_magic;      /* magic number (defines byte order) */
+	uint16_t tiff_version;    /* TIFF version number */
 } TIFFHeaderCommon;
 typedef struct {
-	uint16 tiff_magic;      /* magic number (defines byte order) */
-	uint16 tiff_version;    /* TIFF version number */
-	uint32 tiff_diroff;     /* byte offset to first directory */
+	uint16_t tiff_magic;      /* magic number (defines byte order) */
+	uint16_t tiff_version;    /* TIFF version number */
+	uint32_t tiff_diroff;     /* byte offset to first directory */
 } TIFFHeaderClassic;
 typedef struct {
-	uint16 tiff_magic;      /* magic number (defines byte order) */
-	uint16 tiff_version;    /* TIFF version number */
-	uint16 tiff_offsetsize; /* size of offsets, should be 8 */
-	uint16 tiff_unused;     /* unused word, should be 0 */
-	uint64 tiff_diroff;     /* byte offset to first directory */
+	uint16_t tiff_magic;      /* magic number (defines byte order) */
+	uint16_t tiff_version;    /* TIFF version number */
+	uint16_t tiff_offsetsize; /* size of offsets, should be 8 */
+	uint16_t tiff_unused;     /* unused word, should be 0 */
+	uint64_t tiff_diroff;     /* byte offset to first directory */
 } TIFFHeaderBig;
 
 
@@ -119,6 +132,11 @@ typedef struct {
  * Tag data type information.
  *
  * Note: RATIONALs are the ratio of two 32-bit integer values.
+ *--:
+ * Note2: TIFF_IFD8 data type is used in tiffFields[]-tag definition in order to distinguish the write-handling 
+          of those tags between ClassicTIFF and BigTiff:
+		  For ClassicTIFF libtiff writes a 32-bit value and the TIFF_IFD type-id into the file
+		  For BigTIFF     libtiff writes a 64-bit value and the TIFF_IFD8 type-id into the file
  */
 typedef enum {
 	TIFF_NOTYPE = 0,      /* placeholder */
@@ -192,6 +210,7 @@ typedef enum {
 #define	    COMPRESSION_LZMA		34925	/* LZMA2 */
 #define	    COMPRESSION_ZSTD		50000	/* ZSTD: WARNING not registered in Adobe-maintained registry */
 #define	    COMPRESSION_WEBP		50001	/* WEBP: WARNING not registered in Adobe-maintained registry */
+#define	    COMPRESSION_JXL		50002	/* JPEGXL: WARNING not registered in Adobe-maintained registry */
 #define	TIFFTAG_PHOTOMETRIC		262	/* photometric interpretation */
 #define	    PHOTOMETRIC_MINISWHITE	0	/* min value is white */
 #define	    PHOTOMETRIC_MINISBLACK	1	/* min value is black */
@@ -375,6 +394,7 @@ typedef enum {
 						   January 2004 */
 #define TIFFTAG_OPIIMAGEID		32781	/* %OPI ImageID
 						   [Adobe TIFF technote] */
+#define	TIFFTAG_TIFFANNOTATIONDATA	32932	/* http://web.archive.org/web/20050309141348/http://www.kofile.com/support%20pro/faqs/annospec.htm */
 /* tags 32952-32956 are private tags registered to Island Graphics */
 #define TIFFTAG_REFPTS			32953	/* image reference points */
 #define TIFFTAG_REGIONTACKPOINT		32954	/* region-xform tack point */
@@ -409,8 +429,23 @@ typedef enum {
 #define TIFFTAG_CFAPATTERN		33422	/* color filter array pattern */
 /* tag 33432 is listed in the 6.0 spec w/ unknown ownership */
 #define	TIFFTAG_COPYRIGHT		33432	/* copyright string */
+/* Tags 33445-33452 are used for GEL fileformat, see
+ * http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf
+ */
+#define	TIFFTAG_MD_FILETAG		33445	/* http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf */
+#define	TIFFTAG_MD_SCALEPIXEL	33446	/* http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf */
+#define	TIFFTAG_MD_COLORTABLE	33447	/* http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf */
+#define	TIFFTAG_MD_LABNAME	33448	/* http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf */
+#define	TIFFTAG_MD_SAMPLEINFO	33449	/* http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf */
+#define	TIFFTAG_MD_PREPDATE	33450	/* http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf */
+#define	TIFFTAG_MD_PREPTIME	33451	/* http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf */
+#define	TIFFTAG_MD_FILEUNITS	33452	/* http://research.stowers-institute.org/mcm/efg/ScientificSoftware/Utility/TiffTags/GEL-FileFormat.pdf */
 /* IPTC TAG from RichTIFF specifications */
 #define TIFFTAG_RICHTIFFIPTC		33723
+#define	TIFFTAG_INGR_PACKET_DATA_TAG	33918	/* Intergraph Application specific storage. */
+#define	TIFFTAG_INGR_FLAG_REGISTERS	33919	/* Intergraph Application specific flags. */
+#define	TIFFTAG_IRASB_TRANSORMATION_MATRIX	33920	/* Originally part of Intergraph's GeoTIFF tags, but likely understood by IrasB only. */
+#define	TIFFTAG_MODELTIEPOINTTAG	33922	/* GeoTIFF */
 /* 34016-34029 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
 #define TIFFTAG_IT8SITE			34016	/* site name */
 #define TIFFTAG_IT8COLORSEQUENCE	34017	/* color seq. [RGB,CMYK,etc] */
@@ -432,6 +467,7 @@ typedef enum {
 #define TIFFTAG_IT8CMYKEQUIVALENT	34032	/* CMYK color equivalents */
 /* tags 34232-34236 are private tags registered to Texas Instruments */
 #define TIFFTAG_FRAMECOUNT              34232   /* Sequence Frame Count */
+#define TIFFTAG_MODELTRANSFORMATIONTAG	34264	/* Used in interchangeable GeoTIFF files */
 /* tag 34377 is private tag registered to Adobe for PhotoShop */
 #define TIFFTAG_PHOTOSHOP		34377 
 /* tags 34665, 34853 and 40965 are documented in EXIF specification */
@@ -443,7 +479,7 @@ typedef enum {
 #define	TIFFTAG_JBIGOPTIONS		34750	/* JBIG options */
 #define TIFFTAG_GPSIFD			34853	/* Pointer to GPS private directory */
 /* tags 34908-34914 are private tags registered to SGI */
-#define	TIFFTAG_FAXRECVPARAMS		34908	/* encoded Class 2 ses. parms */
+#define	TIFFTAG_FAXRECVPARAMS		34908	/* encoded Class 2 ses. params */
 #define	TIFFTAG_FAXSUBADDRESS		34909	/* received SubAddr string */
 #define	TIFFTAG_FAXRECVTIME		34910	/* receive time (secs) */
 #define	TIFFTAG_FAXDCS			34911	/* encoded fax ses. params, Table 2/T.30 */
@@ -451,7 +487,15 @@ typedef enum {
 #define TIFFTAG_STONITS			37439	/* Sample value to Nits */
 /* tag 34929 is a private tag registered to FedEx */
 #define	TIFFTAG_FEDEX_EDR		34929	/* unknown use */
+#define	TIFFTAG_IMAGESOURCEDATA		37724	/* http://justsolve.archiveteam.org/wiki/PSD, http://www.adobe.com/devnet-apps/photoshop/fileformatashtml/ */
 #define TIFFTAG_INTEROPERABILITYIFD	40965	/* Pointer to Interoperability private directory */
+#define	TIFFTAG_GDAL_METADATA		42112	/* Used by the GDAL library */
+#define	TIFFTAG_GDAL_NODATA		42113	/* Used by the GDAL library */
+#define	TIFFTAG_OCE_SCANJOB_DESCRIPTION	50215	/* Used in the Oce scanning process */
+#define	TIFFTAG_OCE_APPLICATION_SELECTOR	50216	/* Used in the Oce scanning process. */
+#define	TIFFTAG_OCE_IDENTIFICATION_NUMBER	50217
+#define	TIFFTAG_OCE_IMAGELOGIC_CHARACTERISTICS	50218
+
 /* tags 50674 to 50677 are reserved for ESRI */
 #define TIFFTAG_LERC_PARAMETERS         50674   /* Stores LERC version and additional compression method */
 /* Adobe Digital Negative (DNG) format tags */
@@ -535,6 +579,17 @@ typedef enum {
 						   into ICC profile space */
 #define TIFFTAG_CURRENTICCPROFILE	50833	/* & */
 #define TIFFTAG_CURRENTPREPROFILEMATRIX	50834	/* & */
+
+#define TIFFTAG_RPCCOEFFICIENT          50844   /* Define by GDAL for geospatial georeferencing through RPC: http://geotiff.maptools.org/rpc_prop.html */
+
+#define	TIFFTAG_ALIAS_LAYER_METADATA	50784	/* Alias Sketchbook Pro layer usage description. */
+
+/* GeoTIFF DGIWG */
+#define TIFFTAG_TIFF_RSID               50908   /* https://www.awaresystems.be/imaging/tiff/tifftags/tiff_rsid.html */
+#define TIFFTAG_GEO_METADATA            50909   /* https://www.awaresystems.be/imaging/tiff/tifftags/geo_metadata.html */
+
+#define TIFFTAG_EXTRACAMERAPROFILES 50933  /* http://wwwimages.adobe.com/www.adobe.com/content/dam/Adobe/en/products/photoshop/pdfs/dng_spec_1.4.0.0.pdf */
+
 /* tag 65535 is an undefined tag used by Eastman Kodak */
 #define TIFFTAG_DCSHUESHIFTVALUES       65535   /* hue shift correction data */
 
@@ -615,8 +670,11 @@ typedef enum {
 #define     LERC_ADD_COMPRESSION_DEFLATE 1
 #define     LERC_ADD_COMPRESSION_ZSTD    2
 #define TIFFTAG_LERC_MAXZERROR          65567    /* LERC maximum error */
-#define TIFFTAG_WEBP_LEVEL		  65568	/* WebP compression level: WARNING not registered in Adobe-maintained registry */
-#define TIFFTAG_WEBP_LOSSLESS		65569	/* WebP lossless/lossy : WARNING not registered in Adobe-maintained registry */
+#define TIFFTAG_WEBP_LEVEL		  65568	/* WebP compression level */
+#define TIFFTAG_WEBP_LOSSLESS		65569	/* WebP lossless/lossy */
+#define	TIFFTAG_DEFLATE_SUBCODEC	65570	/* ZIP codec: to get/set the sub-codec to use. Will default to libdeflate when available */
+#define     DEFLATE_SUBCODEC_ZLIB       0
+#define     DEFLATE_SUBCODEC_LIBDEFLATE 1
 
 /*
  * EXIF tags
@@ -626,8 +684,8 @@ typedef enum {
 #define EXIFTAG_EXPOSUREPROGRAM		34850	/* Exposure program */
 #define EXIFTAG_SPECTRALSENSITIVITY	34852	/* Spectral sensitivity */
 #define EXIFTAG_ISOSPEEDRATINGS		34855	/* ISO speed rating */
-#define EXIFTAG_OECF			34856	/* Optoelectric conversion
-						   factor */
+#define EXIFTAG_PHOTOGRAPHICSENSITIVITY	34855 /* Photographic Sensitivity (new name for tag 34855) */
+#define EXIFTAG_OECF			34856	/* Optoelectric conversion factor */
 #define EXIFTAG_EXIFVERSION		36864	/* Exif version */
 #define EXIFTAG_DATETIMEORIGINAL	36867	/* Date and time of original
 						   data generation */
@@ -679,10 +737,71 @@ typedef enum {
 #define EXIFTAG_SHARPNESS		41994	/* Sharpness */
 #define EXIFTAG_DEVICESETTINGDESCRIPTION 41995	/* Device settings description */
 #define EXIFTAG_SUBJECTDISTANCERANGE	41996	/* Subject distance range */
-#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
-#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
 #define EXIFTAG_IMAGEUNIQUEID		42016	/* Unique image ID */
 
+/*--: New for EXIF-Version 2.32, May 2019 ... */
+#define EXIFTAG_SENSITIVITYTYPE		34864		/* The SensitivityType tag indicates which one of the parameters of ISO12232 is the PhotographicSensitivity tag. */
+#define EXIFTAG_STANDARDOUTPUTSENSITIVITY		34865		/* This tag indicates the standard output sensitivity value of a camera or input device defined in ISO 12232. */
+#define EXIFTAG_RECOMMENDEDEXPOSUREINDEX		34866		/* recommended exposure index */
+#define EXIFTAG_ISOSPEED		34867		/* ISO speed value */
+#define EXIFTAG_ISOSPEEDLATITUDEYYY		34868		/* ISO speed latitude yyy */
+#define EXIFTAG_ISOSPEEDLATITUDEZZZ		34869		/* ISO speed latitude zzz */
+#define EXIFTAG_OFFSETTIME		36880		/* offset from UTC of the time of DateTime tag. */
+#define EXIFTAG_OFFSETTIMEORIGINAL		36881		/* offset from UTC of the time of DateTimeOriginal tag. */
+#define EXIFTAG_OFFSETTIMEDIGITIZED		36882		/* offset from UTC of the time of DateTimeDigitized tag. */
+#define EXIFTAG_TEMPERATURE		37888		/* Temperature as the ambient situation at the shot in dergee Celsius */
+#define EXIFTAG_HUMIDITY		37889		/* Humidity as the ambient situation at the shot in percent */
+#define EXIFTAG_PRESSURE		37890		/* Pressure as the ambient situation at the shot hecto-Pascal (hPa) */
+#define EXIFTAG_WATERDEPTH		37891		/* WaterDepth as the ambient situation at the shot in meter (m) */
+#define EXIFTAG_ACCELERATION		37892		/* Acceleration (a scalar regardless of direction) as the ambient situation at the shot in units of mGal (10-5 m/s^2) */
+#define EXIFTAG_CAMERAELEVATIONANGLE		37893		/* Elevation/depression. angle of the orientation of the camera(imaging optical axis) as the ambient situation at the shot in degree from -180deg to +180deg. */
+#define EXIFTAG_CAMERAOWNERNAME		42032		/* owner of a camera */
+#define EXIFTAG_BODYSERIALNUMBER		42033		/* serial number of the body of the camera */
+#define EXIFTAG_LENSSPECIFICATION		42034		/* minimum focal length (in mm), maximum focal length (in mm), minimum F number in the minimum focal length, and minimum F number in the maximum focal length, */
+#define EXIFTAG_LENSMAKE		42035		/* the lens manufacturer */
+#define EXIFTAG_LENSMODEL		42036		/* the lens model name and model number */
+#define EXIFTAG_LENSSERIALNUMBER		42037		/* the serial number of the interchangeable lens */
+#define EXIFTAG_GAMMA		42240		/* value of coefficient gamma */
+#define EXIFTAG_COMPOSITEIMAGE		42080	/* composite image */
+#define EXIFTAG_SOURCEIMAGENUMBEROFCOMPOSITEIMAGE		42081	/* source image number of composite image */
+#define EXIFTAG_SOURCEEXPOSURETIMESOFCOMPOSITEIMAGE		42082	/* source exposure times of composite image */
+
+/*
+ * EXIF-GPS tags  (Version 2.31, July 2016)
+ */
+#define		GPSTAG_VERSIONID		0			/* 	Indicates the version of GPSInfoIFD.	 */
+#define		GPSTAG_LATITUDEREF		1			/* 	Indicates whether the latitude is north or south latitude.	 */
+#define		GPSTAG_LATITUDE		2			/* 	Indicates the latitude.	 */
+#define		GPSTAG_LONGITUDEREF		3			/* 	Indicates whether the longitude is east or west longitude.	 */
+#define		GPSTAG_LONGITUDE		4			/* 	Indicates the longitude.	 */
+#define		GPSTAG_ALTITUDEREF		5			/* 	Indicates the altitude used as the reference altitude.	 */
+#define		GPSTAG_ALTITUDE		6			/* 	Indicates the altitude based on the reference in GPSAltitudeRef.	 */
+#define		GPSTAG_TIMESTAMP		7			/* 	Indicates the time as UTC (Coordinated Universal Time).	 */
+#define		GPSTAG_SATELLITES		8			/* 	Indicates the GPS satellites used for measurements.	 */
+#define		GPSTAG_STATUS		9			/* 	Indicates the status of the GPS receiver when the image is recorded.	 */
+#define		GPSTAG_MEASUREMODE		10			/* 	Indicates the GPS measurement mode.	 */
+#define		GPSTAG_DOP		11			/* 	Indicates the GPS DOP (data degree of precision).	 */
+#define		GPSTAG_SPEEDREF		12			/* 	Indicates the unit used to express the GPS receiver speed of movement.	 */
+#define		GPSTAG_SPEED		13			/* 	Indicates the speed of GPS receiver movement.	 */
+#define		GPSTAG_TRACKREF		14			/* 	Indicates the reference for giving the direction of GPS receiver movement.	 */
+#define		GPSTAG_TRACK		15			/* 	Indicates the direction of GPS receiver movement.	 */
+#define		GPSTAG_IMGDIRECTIONREF		16			/* 	Indicates the reference for giving the direction of the image when it is captured.	 */
+#define		GPSTAG_IMGDIRECTION		17			/* 	Indicates the direction of the image when it was captured.	 */
+#define		GPSTAG_MAPDATUM		18			/* 	Indicates the geodetic survey data used by the GPS receiver. (e.g. WGS-84)	 */
+#define		GPSTAG_DESTLATITUDEREF		19			/* 	Indicates whether the latitude of the destination point is north or south latitude.	 */
+#define		GPSTAG_DESTLATITUDE		20			/* 	Indicates the latitude of the destination point.	 */
+#define		GPSTAG_DESTLONGITUDEREF		21			/* 	Indicates whether the longitude of the destination point is east or west longitude.	 */
+#define		GPSTAG_DESTLONGITUDE		22			/* 	Indicates the longitude of the destination point.	 */
+#define		GPSTAG_DESTBEARINGREF		23			/* 	Indicates the reference used for giving the bearing to the destination point.	 */
+#define		GPSTAG_DESTBEARING		24			/* 	Indicates the bearing to the destination point.	 */
+#define		GPSTAG_DESTDISTANCEREF		25			/* 	Indicates the unit used to express the distance to the destination point.	 */
+#define		GPSTAG_DESTDISTANCE		26			/* 	Indicates the distance to the destination point.	 */
+#define		GPSTAG_PROCESSINGMETHOD		27			/* 	A character string recording the name of the method used for location finding.	 */
+#define		GPSTAG_AREAINFORMATION		28			/* 	A character string recording the name of the GPS area.	 */
+#define		GPSTAG_DATESTAMP		29			/* 	A character string recording date and time information relative to UTC (Coordinated Universal Time).	 */
+#define		GPSTAG_DIFFERENTIAL		30			/* 	Indicates whether differential correction is applied to the GPS receiver.	 */
+#define		GPSTAG_GPSHPOSITIONINGERROR		31			/* Indicates horizontal positioning errors in meters.		 */
+
 #endif /* _TIFF_ */
 
 /* vim: set ts=8 sts=8 sw=8 noet: */
diff --git a/src/3rdparty/libtiff/libtiff/tiffconf.h b/src/3rdparty/libtiff/libtiff/tiffconf.h
index f37b0b5..57e50df 100644
--- a/src/3rdparty/libtiff/libtiff/tiffconf.h
+++ b/src/3rdparty/libtiff/libtiff/tiffconf.h
@@ -9,29 +9,36 @@
 
 #include <qglobal.h>
 
+#define TIFF_DISABLE_DEPRECATED 1
+
+#include <stddef.h>
+#include <stdint.h>
+#include <inttypes.h>
+
+
 /* Signed 16-bit type */
-#define TIFF_INT16_T qint16
+/* #undef TIFF_INT16_T */
 
 /* Signed 32-bit type */
-#define TIFF_INT32_T qint32
+/* #undef TIFF_INT32_T */
 
 /* Signed 64-bit type */
-#define TIFF_INT64_T qint64
+/* #undef TIFF_INT64_T */
 
 /* Signed 8-bit type */
-#define TIFF_INT8_T qint8
+/* #undef TIFF_INT8_T */
 
 /* Unsigned 16-bit type */
-#define TIFF_UINT16_T quint16
+/* #undef TIFF_UINT16_T */
 
 /* Unsigned 32-bit type */
-#define TIFF_UINT32_T quint32
+/* #undef TIFF_UINT32_T */
 
 /* Unsigned 64-bit type */
-#define TIFF_UINT64_T quint64
+/* #undef TIFF_UINT64_T */
 
 /* Unsigned 8-bit type */
-#define TIFF_UINT8_T quint8
+/* #undef TIFF_UINT8_T */
 
 /* Signed size type */
 #if QT_POINTER_SIZE == 4
@@ -40,21 +47,9 @@
 #define TIFF_SSIZE_T qint64
 #endif
 
-/* Pointer difference type */
-#define TIFF_PTRDIFF_T ptrdiff_t
-
-/* Define to 1 if the system has the type `int16'. */
-/* #undef HAVE_INT16 */
-
-/* Define to 1 if the system has the type `int32'. */
-/* #undef HAVE_INT32 */
-
-/* Define to 1 if the system has the type `int8'. */
-/* #undef HAVE_INT8 */
-
 /* Compatibility stuff. */
 
-/* Define as 0 or 1 according to the floating point format suported by the
+/* Define as 0 or 1 according to the floating point format supported by the
    machine */
 #define HAVE_IEEEFP 1
 
@@ -75,6 +70,12 @@
 /* Support JPEG compression (requires IJG JPEG library) */
 /* #undef JPEG_SUPPORT */
 
+/* Support JBIG compression (requires JBIG-KIT library) */
+/* #undef JBIG_SUPPORT */
+
+/* Support LERC compression */
+/* #undef LERC_SUPPORT */
+
 /* Support LogLuv high dynamic range encoding */
 #define LOGLUV_SUPPORT 1
 
@@ -100,8 +101,11 @@
 /* Support Deflate compression */
 #define ZIP_SUPPORT 1
 
+/* Support libdeflate enhanced compression */
+/* #undef LIBDEFLATE_SUPPORT */
+
 /* Support strip chopping (whether or not to convert single-strip uncompressed
-   images to mutiple strips of ~8Kb to reduce memory usage) */
+   images to multiple strips of ~8Kb to reduce memory usage) */
 #define STRIPCHOP_DEFAULT TIFF_STRIPCHOP
 
 /* Enable SubIFD tag (330) support */
@@ -114,7 +118,7 @@
 
 /* Pick up YCbCr subsampling info from the JPEG data stream to support files
    lacking the tag (default enabled). */
-#define CHECK_JPEG_YCBCR_SUBSAMPLING 1
+/* #undef CHECK_JPEG_YCBCR_SUBSAMPLING */
 
 /* Support MS MDI magic number files as TIFF */
 #define MDI_SUPPORT 1
diff --git a/src/3rdparty/libtiff/libtiff/tiffconf.vc.h b/src/3rdparty/libtiff/libtiff/tiffconf.h.cmake.in
similarity index 57%
rename from src/3rdparty/libtiff/libtiff/tiffconf.vc.h
rename to src/3rdparty/libtiff/libtiff/tiffconf.h.cmake.in
index fb37a75..66ab354 100644
--- a/src/3rdparty/libtiff/libtiff/tiffconf.vc.h
+++ b/src/3rdparty/libtiff/libtiff/tiffconf.h.cmake.in
@@ -7,128 +7,110 @@
 #ifndef _TIFFCONF_
 #define _TIFFCONF_
 
-/* The size of a `int', as computed by sizeof. */
-#define SIZEOF_INT 4
 
-/* Signed 8-bit type */
-#define TIFF_INT8_T signed char
+#include <stddef.h>
+#include <stdint.h>
+#include <inttypes.h>
 
-/* Unsigned 8-bit type */
-#define TIFF_UINT8_T unsigned char
 
 /* Signed 16-bit type */
-#define TIFF_INT16_T signed short
-
-/* Unsigned 16-bit type */
-#define TIFF_UINT16_T unsigned short
-
-/* Signed 32-bit type formatter */
-#define TIFF_INT32_FORMAT "%d"
+#define TIFF_INT16_T @TIFF_INT16_T@
 
 /* Signed 32-bit type */
-#define TIFF_INT32_T signed int
-
-/* Unsigned 32-bit type formatter */
-#define TIFF_UINT32_FORMAT "%u"
-
-/* Unsigned 32-bit type */
-#define TIFF_UINT32_T unsigned int
-
-/* Signed 64-bit type formatter */
-#define TIFF_INT64_FORMAT "%I64d"
+#define TIFF_INT32_T @TIFF_INT32_T@
 
 /* Signed 64-bit type */
-#define TIFF_INT64_T signed __int64
+#define TIFF_INT64_T @TIFF_INT64_T@
 
-/* Unsigned 64-bit type formatter */
-#define TIFF_UINT64_FORMAT "%I64u"
+/* Signed 8-bit type */
+#define TIFF_INT8_T @TIFF_INT8_T@
 
-/* Unsigned 64-bit type */
-#define TIFF_UINT64_T unsigned __int64
+/* Unsigned 16-bit type */
+#define TIFF_UINT16_T @TIFF_UINT16_T@
 
-#if _WIN64
-/*
-  Windows 64-bit build
-*/
+/* Unsigned 32-bit type */
+#define TIFF_UINT32_T @TIFF_UINT32_T@
 
-/* Signed size type */
-#  define TIFF_SSIZE_T TIFF_INT64_T
+/* Unsigned 64-bit type */
+#define TIFF_UINT64_T @TIFF_UINT64_T@
 
-#else
-/*
-  Windows 32-bit build
-*/
+/* Unsigned 8-bit type */
+#define TIFF_UINT8_T @TIFF_UINT8_T@
 
 /* Signed size type */
-#  define TIFF_SSIZE_T signed int
-
-#endif
+#define TIFF_SSIZE_T @TIFF_SSIZE_T@
 
 /* Compatibility stuff. */
 
-/* Define as 0 or 1 according to the floating point format suported by the
+/* Define as 0 or 1 according to the floating point format supported by the
    machine */
-#define HAVE_IEEEFP 1
+#cmakedefine HAVE_IEEEFP 1
 
 /* Set the native cpu bit order (FILLORDER_LSB2MSB or FILLORDER_MSB2LSB) */
-#define HOST_FILLORDER FILLORDER_LSB2MSB
+#define HOST_FILLORDER @HOST_FILLORDER@
 
 /* Native cpu byte order: 1 if big-endian (Motorola) or 0 if little-endian
    (Intel) */
-#define HOST_BIGENDIAN 0
+#define HOST_BIGENDIAN @HOST_BIG_ENDIAN@
 
 /* Support CCITT Group 3 & 4 algorithms */
-#define CCITT_SUPPORT 1
+#cmakedefine CCITT_SUPPORT 1
 
 /* Support JPEG compression (requires IJG JPEG library) */
-/* #undef JPEG_SUPPORT */
+#cmakedefine JPEG_SUPPORT 1
 
 /* Support JBIG compression (requires JBIG-KIT library) */
-/* #undef JBIG_SUPPORT */
+#cmakedefine JBIG_SUPPORT
+
+/* Support LERC compression */
+#cmakedefine LERC_SUPPORT 1
 
 /* Support LogLuv high dynamic range encoding */
-#define LOGLUV_SUPPORT 1
+#cmakedefine LOGLUV_SUPPORT 1
 
 /* Support LZW algorithm */
-#define LZW_SUPPORT 1
+#cmakedefine LZW_SUPPORT 1
 
 /* Support NeXT 2-bit RLE algorithm */
-#define NEXT_SUPPORT 1
+#cmakedefine NEXT_SUPPORT 1
 
 /* Support Old JPEG compresson (read contrib/ojpeg/README first! Compilation
    fails with unpatched IJG JPEG library) */
-/* #undef OJPEG_SUPPORT */
+#cmakedefine OJPEG_SUPPORT 1
 
 /* Support Macintosh PackBits algorithm */
-#define PACKBITS_SUPPORT 1
+#cmakedefine PACKBITS_SUPPORT 1
 
 /* Support Pixar log-format algorithm (requires Zlib) */
-/* #undef PIXARLOG_SUPPORT */
+#cmakedefine PIXARLOG_SUPPORT 1
 
 /* Support ThunderScan 4-bit RLE algorithm */
-#define THUNDER_SUPPORT 1
+#cmakedefine THUNDER_SUPPORT 1
 
 /* Support Deflate compression */
-/* #undef ZIP_SUPPORT */
+#cmakedefine ZIP_SUPPORT 1
+
+/* Support libdeflate enhanced compression */
+#cmakedefine LIBDEFLATE_SUPPORT 1
 
 /* Support strip chopping (whether or not to convert single-strip uncompressed
-   images to mutiple strips of ~8Kb to reduce memory usage) */
-#define STRIPCHOP_DEFAULT TIFF_STRIPCHOP
+   images to multiple strips of ~8Kb to reduce memory usage) */
+#cmakedefine STRIPCHOP_DEFAULT 1
 
 /* Enable SubIFD tag (330) support */
-#define SUBIFD_SUPPORT 1
+#cmakedefine SUBIFD_SUPPORT 1
 
 /* Treat extra sample as alpha (default enabled). The RGBA interface will
    treat a fourth sample with no EXTRASAMPLE_ value as being ASSOCALPHA. Many
    packages produce RGBA files but don't mark the alpha properly. */
-#define DEFAULT_EXTRASAMPLE_AS_ALPHA 1
+#cmakedefine DEFAULT_EXTRASAMPLE_AS_ALPHA 1
 
 /* Pick up YCbCr subsampling info from the JPEG data stream to support files
    lacking the tag (default enabled). */
-#define CHECK_JPEG_YCBCR_SUBSAMPLING 1
+#cmakedefine CHECK_JPEG_YCBCR_SUBSAMPLING 1
 
 /* Support MS MDI magic number files as TIFF */
-/* #undef MDI_SUPPORT */
+#cmakedefine MDI_SUPPORT 1
 
 /*
  * Feature support definitions.
@@ -143,10 +125,3 @@
 #define IPTC_SUPPORT
 
 #endif /* _TIFFCONF_ */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/src/3rdparty/libtiff/libtiff/tiffconf.h.in b/src/3rdparty/libtiff/libtiff/tiffconf.h.in
index 5de30c9..6703eb0 100644
--- a/src/3rdparty/libtiff/libtiff/tiffconf.h.in
+++ b/src/3rdparty/libtiff/libtiff/tiffconf.h.in
@@ -7,6 +7,12 @@
 #ifndef _TIFFCONF_
 #define _TIFFCONF_
 
+
+#include <stddef.h>
+#include <stdint.h>
+#include <inttypes.h>
+
+
 /* Signed 16-bit type */
 #undef TIFF_INT16_T
 
@@ -34,12 +40,9 @@
 /* Signed size type */
 #undef TIFF_SSIZE_T
 
-/* Pointer difference type */
-#undef TIFF_PTRDIFF_T
-
 /* Compatibility stuff. */
 
-/* Define as 0 or 1 according to the floating point format suported by the
+/* Define as 0 or 1 according to the floating point format supported by the
    machine */
 #undef HAVE_IEEEFP
 
@@ -59,6 +62,9 @@
 /* Support JBIG compression (requires JBIG-KIT library) */
 #undef JBIG_SUPPORT
 
+/* Support LERC compression */
+#undef LERC_SUPPORT
+
 /* Support LogLuv high dynamic range encoding */
 #undef LOGLUV_SUPPORT
 
@@ -84,8 +90,11 @@
 /* Support Deflate compression */
 #undef ZIP_SUPPORT
 
+/* Support libdeflate enhanced compression */
+#undef LIBDEFLATE_SUPPORT
+
 /* Support strip chopping (whether or not to convert single-strip uncompressed
-   images to mutiple strips of ~8Kb to reduce memory usage) */
+   images to multiple strips of ~8Kb to reduce memory usage) */
 #undef STRIPCHOP_DEFAULT
 
 /* Enable SubIFD tag (330) support */
diff --git a/src/3rdparty/libtiff/libtiff/tiffconf.wince.h b/src/3rdparty/libtiff/libtiff/tiffconf.wince.h
deleted file mode 100644
index 013b096..0000000
--- a/src/3rdparty/libtiff/libtiff/tiffconf.wince.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Windows CE platform tiffconf.wince.h
- * Created by Mateusz Loskot (mateusz@loskot.net)
- *
- * NOTE: Requires WCELIBCEX library with wceex_* functions,
- * It's an extension to C library on Windows CE platform.
- * For example, HAVE_STDIO_H definition indicates there are
- * following files available:
- * stdio.h - from Windows CE / Windows Mobile SDK 
- * wce_stdio.h - from WCELIBCEX library
- */
-
-
-/*
-  Configuration defines for installed libtiff.
-  This file maintained for backward compatibility. Do not use definitions
-  from this file in your programs.
-*/
-
-#ifndef _WIN32_WCE
-# error This version of tif_config.h header is dedicated for Windows CE platform!
-#endif
-
-
-#ifndef _TIFFCONF_
-#define _TIFFCONF_
-
-/* The size of a `int', as computed by sizeof. */
-#define SIZEOF_INT 4
-
-/* Compatibility stuff. */
-
-/* Define as 0 or 1 according to the floating point format suported by the
-   machine */
-#define HAVE_IEEEFP 1
-
-/* Set the native cpu bit order (FILLORDER_LSB2MSB or FILLORDER_MSB2LSB) */
-#define HOST_FILLORDER FILLORDER_LSB2MSB
-
-/* Native cpu byte order: 1 if big-endian (Motorola) or 0 if little-endian
-   (Intel) */
-#define HOST_BIGENDIAN 0
-
-/* Support CCITT Group 3 & 4 algorithms */
-#define CCITT_SUPPORT 1
-
-/* Support JPEG compression (requires IJG JPEG library) */
-/* #undef JPEG_SUPPORT */
-
-/* Support LogLuv high dynamic range encoding */
-#define LOGLUV_SUPPORT 1
-
-/* Support LZW algorithm */
-#define LZW_SUPPORT 1
-
-/* Support NeXT 2-bit RLE algorithm */
-#define NEXT_SUPPORT 1
-
-/* Support Old JPEG compresson (read contrib/ojpeg/README first! Compilation
-   fails with unpatched IJG JPEG library) */
-/* #undef OJPEG_SUPPORT */
-
-/* Support Macintosh PackBits algorithm */
-#define PACKBITS_SUPPORT 1
-
-/* Support Pixar log-format algorithm (requires Zlib) */
-/* #undef PIXARLOG_SUPPORT */
-
-/* Support ThunderScan 4-bit RLE algorithm */
-#define THUNDER_SUPPORT 1
-
-/* Support Deflate compression */
-/* #undef ZIP_SUPPORT */
-
-/* Support strip chopping (whether or not to convert single-strip uncompressed
-   images to mutiple strips of ~8Kb to reduce memory usage) */
-#define STRIPCHOP_DEFAULT TIFF_STRIPCHOP
-
-/* Enable SubIFD tag (330) support */
-#define SUBIFD_SUPPORT 1
-
-/* Treat extra sample as alpha (default enabled). The RGBA interface will
-   treat a fourth sample with no EXTRASAMPLE_ value as being ASSOCALPHA. Many
-   packages produce RGBA files but don't mark the alpha properly. */
-#define DEFAULT_EXTRASAMPLE_AS_ALPHA 1
-
-/* Pick up YCbCr subsampling info from the JPEG data stream to support files
-   lacking the tag (default enabled). */
-#define CHECK_JPEG_YCBCR_SUBSAMPLING 1
-
-/*
- * Feature support definitions.
- * XXX: These macros are obsoleted. Don't use them in your apps!
- * Macros stays here for backward compatibility and should be always defined.
- */
-#define COLORIMETRY_SUPPORT
-#define YCBCR_SUPPORT
-#define CMYK_SUPPORT
-#define ICC_SUPPORT
-#define PHOTOSHOP_SUPPORT
-#define IPTC_SUPPORT
-
-#endif /* _TIFFCONF_ */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/src/3rdparty/libtiff/libtiff/tiffio.h b/src/3rdparty/libtiff/libtiff/tiffio.h
index 198481d..c6a192c 100644
--- a/src/3rdparty/libtiff/libtiff/tiffio.h
+++ b/src/3rdparty/libtiff/libtiff/tiffio.h
@@ -60,16 +60,18 @@ typedef struct tiff TIFF;
  */
 /*
  * this is the machine addressing size type, only it's signed, so make it
- * int32 on 32bit machines, int64 on 64bit machines
+ * int32_t on 32bit machines, int64_t on 64bit machines
  */
 typedef TIFF_SSIZE_T tmsize_t;
-typedef uint64 toff_t;          /* file offset */
+#define TIFF_TMSIZE_T_MAX (tmsize_t)(SIZE_MAX >> 1)
+
+typedef uint64_t toff_t;          /* file offset */
 /* the following are deprecated and should be replaced by their defining
    counterparts */
-typedef uint32 ttag_t;          /* directory tag */
-typedef uint16 tdir_t;          /* directory index */
-typedef uint16 tsample_t;       /* sample number */
-typedef uint32 tstrile_t;       /* strip or tile number */
+typedef uint32_t ttag_t;          /* directory tag */
+typedef uint16_t tdir_t;          /* directory index */
+typedef uint16_t tsample_t;       /* sample number */
+typedef uint32_t tstrile_t;       /* strip or tile number */
 typedef tstrile_t tstrip_t;     /* strip number */
 typedef tstrile_t ttile_t;      /* tile number */
 typedef tmsize_t tsize_t;       /* i/o size in bytes */
@@ -140,9 +142,9 @@ typedef struct {
 	float d_YCR;                              /* Light o/p for reference white */
 	float d_YCG;
 	float d_YCB;
-	uint32 d_Vrwr;                            /* Pixel values for ref. white */
-	uint32 d_Vrwg;
-	uint32 d_Vrwb;
+	uint32_t d_Vrwr;                            /* Pixel values for ref. white */
+	uint32_t d_Vrwg;
+	uint32_t d_Vrwb;
 	float d_Y0R;                              /* Residual light for black pixel */
 	float d_Y0G;
 	float d_Y0B;
@@ -155,9 +157,9 @@ typedef struct {                                  /* YCbCr->RGB support */
 	TIFFRGBValue* clamptab;                   /* range clamping table */
 	int* Cr_r_tab;
 	int* Cb_b_tab;
-	int32* Cr_g_tab;
-	int32* Cb_g_tab;
-	int32* Y_tab;
+	int32_t* Cr_g_tab;
+	int32_t* Cb_g_tab;
+	int32_t* Y_tab;
 } TIFFYCbCrToRGB;
 
 typedef struct {                                  /* CIE Lab 1976->RGB support */
@@ -186,11 +188,11 @@ typedef struct _TIFFRGBAImage TIFFRGBAImage;
  * and draw the unpacked raster on the display.
  */
 typedef void (*tileContigRoutine)
-    (TIFFRGBAImage*, uint32*, uint32, uint32, uint32, uint32, int32, int32,
-	unsigned char*);
+    (TIFFRGBAImage*, uint32_t*, uint32_t, uint32_t, uint32_t, uint32_t, int32_t, int32_t,
+     unsigned char*);
 typedef void (*tileSeparateRoutine)
-    (TIFFRGBAImage*, uint32*, uint32, uint32, uint32, uint32, int32, int32,
-	unsigned char*, unsigned char*, unsigned char*, unsigned char*);
+    (TIFFRGBAImage*, uint32_t*, uint32_t, uint32_t, uint32_t, uint32_t, int32_t, int32_t,
+     unsigned char*, unsigned char*, unsigned char*, unsigned char*);
 /*
  * RGBA-reader state.
  */
@@ -199,18 +201,18 @@ struct _TIFFRGBAImage {
 	int stoponerr;                          /* stop on read error */
 	int isContig;                           /* data is packed/separate */
 	int alpha;                              /* type of alpha data present */
-	uint32 width;                           /* image width */
-	uint32 height;                          /* image height */
-	uint16 bitspersample;                   /* image bits/sample */
-	uint16 samplesperpixel;                 /* image samples/pixel */
-	uint16 orientation;                     /* image orientation */
-	uint16 req_orientation;                 /* requested orientation */
-	uint16 photometric;                     /* image photometric interp */
-	uint16* redcmap;                        /* colormap palette */
-	uint16* greencmap;
-	uint16* bluecmap;
+	uint32_t width;                           /* image width */
+	uint32_t height;                          /* image height */
+	uint16_t bitspersample;                   /* image bits/sample */
+	uint16_t samplesperpixel;                 /* image samples/pixel */
+	uint16_t orientation;                     /* image orientation */
+	uint16_t req_orientation;                 /* requested orientation */
+	uint16_t photometric;                     /* image photometric interp */
+	uint16_t* redcmap;                        /* colormap palette */
+	uint16_t* greencmap;
+	uint16_t* bluecmap;
 	/* get image data routine */
-	int (*get)(TIFFRGBAImage*, uint32*, uint32, uint32);
+	int (*get)(TIFFRGBAImage*, uint32_t*, uint32_t, uint32_t);
 	/* put decoded strip/tile */
 	union {
 	    void (*any)(TIFFRGBAImage*);
@@ -218,13 +220,13 @@ struct _TIFFRGBAImage {
 	    tileSeparateRoutine separate;
 	} put;
 	TIFFRGBValue* Map;                      /* sample mapping array */
-	uint32** BWmap;                         /* black&white map */
-	uint32** PALmap;                        /* palette image map */
+	uint32_t** BWmap;                         /* black&white map */
+	uint32_t** PALmap;                        /* palette image map */
 	TIFFYCbCrToRGB* ycbcr;                  /* YCbCr conversion state */
 	TIFFCIELabToRGB* cielab;                /* CIE L*a*b conversion state */
 
-	uint8* UaToAa;                          /* Unassociated alpha to associated alpha conversion LUT */
-	uint8* Bitdepth16To8;                   /* LUT for conversion from 16bit to 8bit values */
+	uint8_t* UaToAa;                          /* Unassociated alpha to associated alpha conversion LUT */
+	uint8_t* Bitdepth16To8;                   /* LUT for conversion from 16bit to 8bit values */
 
 	int row_offset;
 	int col_offset;
@@ -249,7 +251,7 @@ struct _TIFFRGBAImage {
 typedef int (*TIFFInitMethod)(TIFF*, int);
 typedef struct {
 	char* name;
-	uint16 scheme;
+	uint16_t scheme;
 	TIFFInitMethod init;
 } TIFFCodec;
 
@@ -261,8 +263,10 @@ typedef struct {
 #define LOGLUV_PUBLIC 1
 #endif
 
-#if !defined(__GNUC__) && !defined(__attribute__)
-#  define __attribute__(x) /*nothing*/
+#if defined(__GNUC__) || defined(__attribute__)
+#  define TIFF_ATTRIBUTE(x)    __attribute__(x)
+#else
+#  define TIFF_ATTRIBUTE(x) /*nothing*/
 #endif
 
 #if defined(c_plusplus) || defined(__cplusplus)
@@ -280,10 +284,10 @@ typedef void (*TIFFExtendProc)(TIFF*);
 
 extern const char* TIFFGetVersion(void);
 
-extern const TIFFCodec* TIFFFindCODEC(uint16);
-extern TIFFCodec* TIFFRegisterCODEC(uint16, const char*, TIFFInitMethod);
+extern const TIFFCodec* TIFFFindCODEC(uint16_t);
+extern TIFFCodec* TIFFRegisterCODEC(uint16_t, const char*, TIFFInitMethod);
 extern void TIFFUnRegisterCODEC(TIFFCodec*);
-extern int TIFFIsCODECConfigured(uint16);
+extern int TIFFIsCODECConfigured(uint16_t);
 extern TIFFCodec* TIFFGetConfiguredCODECs(void);
 
 /*
@@ -302,31 +306,31 @@ extern void _TIFFfree(void* p);
 ** Stuff, related to tag handling and creating custom tags.
 */
 extern int TIFFGetTagListCount( TIFF * );
-extern uint32 TIFFGetTagListEntry( TIFF *, int tag_index );
+extern uint32_t TIFFGetTagListEntry(TIFF *, int tag_index );
     
 #define TIFF_ANY       TIFF_NOTYPE     /* for field descriptor searching */
 #define TIFF_VARIABLE  -1              /* marker for variable length tags */
 #define TIFF_SPP       -2              /* marker for SamplesPerPixel tags */
-#define TIFF_VARIABLE2 -3              /* marker for uint32 var-length tags */
+#define TIFF_VARIABLE2 -3              /* marker for uint32_t var-length tags */
 
 #define FIELD_CUSTOM    65
 
 typedef struct _TIFFField TIFFField;
 typedef struct _TIFFFieldArray TIFFFieldArray;
 
-extern const TIFFField* TIFFFindField(TIFF *, uint32, TIFFDataType);
-extern const TIFFField* TIFFFieldWithTag(TIFF*, uint32);
+extern const TIFFField* TIFFFindField(TIFF *, uint32_t, TIFFDataType);
+extern const TIFFField* TIFFFieldWithTag(TIFF*, uint32_t);
 extern const TIFFField* TIFFFieldWithName(TIFF*, const char *);
 
-extern uint32 TIFFFieldTag(const TIFFField*);
+extern uint32_t TIFFFieldTag(const TIFFField*);
 extern const char* TIFFFieldName(const TIFFField*);
 extern TIFFDataType TIFFFieldDataType(const TIFFField*);
 extern int TIFFFieldPassCount(const TIFFField*);
 extern int TIFFFieldReadCount(const TIFFField*);
 extern int TIFFFieldWriteCount(const TIFFField*);
 
-typedef int (*TIFFVSetMethod)(TIFF*, uint32, va_list);
-typedef int (*TIFFVGetMethod)(TIFF*, uint32, va_list);
+typedef int (*TIFFVSetMethod)(TIFF*, uint32_t, va_list);
+typedef int (*TIFFVGetMethod)(TIFF*, uint32_t, va_list);
 typedef void (*TIFFPrintMethod)(TIFF*, FILE*, long);
 
 typedef struct {
@@ -343,31 +347,32 @@ extern void TIFFCleanup(TIFF* tif);
 extern void TIFFClose(TIFF* tif);
 extern int TIFFFlush(TIFF* tif);
 extern int TIFFFlushData(TIFF* tif);
-extern int TIFFGetField(TIFF* tif, uint32 tag, ...);
-extern int TIFFVGetField(TIFF* tif, uint32 tag, va_list ap);
-extern int TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...);
-extern int TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap);
+extern int TIFFGetField(TIFF* tif, uint32_t tag, ...);
+extern int TIFFVGetField(TIFF* tif, uint32_t tag, va_list ap);
+extern int TIFFGetFieldDefaulted(TIFF* tif, uint32_t tag, ...);
+extern int TIFFVGetFieldDefaulted(TIFF* tif, uint32_t tag, va_list ap);
 extern int TIFFReadDirectory(TIFF* tif);
 extern int TIFFReadCustomDirectory(TIFF* tif, toff_t diroff, const TIFFFieldArray* infoarray);
 extern int TIFFReadEXIFDirectory(TIFF* tif, toff_t diroff);
-extern uint64 TIFFScanlineSize64(TIFF* tif);
+extern int TIFFReadGPSDirectory(TIFF* tif, toff_t diroff);
+extern uint64_t TIFFScanlineSize64(TIFF* tif);
 extern tmsize_t TIFFScanlineSize(TIFF* tif);
-extern uint64 TIFFRasterScanlineSize64(TIFF* tif);
+extern uint64_t TIFFRasterScanlineSize64(TIFF* tif);
 extern tmsize_t TIFFRasterScanlineSize(TIFF* tif);
-extern uint64 TIFFStripSize64(TIFF* tif);
+extern uint64_t TIFFStripSize64(TIFF* tif);
 extern tmsize_t TIFFStripSize(TIFF* tif);
-extern uint64 TIFFRawStripSize64(TIFF* tif, uint32 strip);
-extern tmsize_t TIFFRawStripSize(TIFF* tif, uint32 strip);
-extern uint64 TIFFVStripSize64(TIFF* tif, uint32 nrows);
-extern tmsize_t TIFFVStripSize(TIFF* tif, uint32 nrows);
-extern uint64 TIFFTileRowSize64(TIFF* tif);
+extern uint64_t TIFFRawStripSize64(TIFF* tif, uint32_t strip);
+extern tmsize_t TIFFRawStripSize(TIFF* tif, uint32_t strip);
+extern uint64_t TIFFVStripSize64(TIFF* tif, uint32_t nrows);
+extern tmsize_t TIFFVStripSize(TIFF* tif, uint32_t nrows);
+extern uint64_t TIFFTileRowSize64(TIFF* tif);
 extern tmsize_t TIFFTileRowSize(TIFF* tif);
-extern uint64 TIFFTileSize64(TIFF* tif);
+extern uint64_t TIFFTileSize64(TIFF* tif);
 extern tmsize_t TIFFTileSize(TIFF* tif);
-extern uint64 TIFFVTileSize64(TIFF* tif, uint32 nrows);
-extern tmsize_t TIFFVTileSize(TIFF* tif, uint32 nrows);
-extern uint32 TIFFDefaultStripSize(TIFF* tif, uint32 request);
-extern void TIFFDefaultTileSize(TIFF*, uint32*, uint32*);
+extern uint64_t TIFFVTileSize64(TIFF* tif, uint32_t nrows);
+extern tmsize_t TIFFVTileSize(TIFF* tif, uint32_t nrows);
+extern uint32_t TIFFDefaultStripSize(TIFF* tif, uint32_t request);
+extern void TIFFDefaultTileSize(TIFF*, uint32_t*, uint32_t*);
 extern int TIFFFileno(TIFF*);
 extern int TIFFSetFileno(TIFF*, int);
 extern thandle_t TIFFClientdata(TIFF*);
@@ -386,12 +391,12 @@ extern TIFFCloseProc TIFFGetCloseProc(TIFF*);
 extern TIFFSizeProc TIFFGetSizeProc(TIFF*);
 extern TIFFMapFileProc TIFFGetMapFileProc(TIFF*);
 extern TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF*);
-extern uint32 TIFFCurrentRow(TIFF*);
-extern uint16 TIFFCurrentDirectory(TIFF*);
-extern uint16 TIFFNumberOfDirectories(TIFF*);
-extern uint64 TIFFCurrentDirOffset(TIFF*);
-extern uint32 TIFFCurrentStrip(TIFF*);
-extern uint32 TIFFCurrentTile(TIFF* tif);
+extern uint32_t TIFFCurrentRow(TIFF*);
+extern uint16_t TIFFCurrentDirectory(TIFF*);
+extern uint16_t TIFFNumberOfDirectories(TIFF*);
+extern uint64_t TIFFCurrentDirOffset(TIFF*);
+extern uint32_t TIFFCurrentStrip(TIFF*);
+extern uint32_t TIFFCurrentTile(TIFF* tif);
 extern int TIFFReadBufferSetup(TIFF* tif, void* bp, tmsize_t size);
 extern int TIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size);  
 extern int TIFFSetupStrips(TIFF *);
@@ -400,15 +405,16 @@ extern void TIFFFreeDirectory(TIFF*);
 extern int TIFFCreateDirectory(TIFF*);
 extern int TIFFCreateCustomDirectory(TIFF*,const TIFFFieldArray*);
 extern int TIFFCreateEXIFDirectory(TIFF*);
+extern int TIFFCreateGPSDirectory(TIFF*);
 extern int TIFFLastDirectory(TIFF*);
-extern int TIFFSetDirectory(TIFF*, uint16);
-extern int TIFFSetSubDirectory(TIFF*, uint64);
-extern int TIFFUnlinkDirectory(TIFF*, uint16);
-extern int TIFFSetField(TIFF*, uint32, ...);
-extern int TIFFVSetField(TIFF*, uint32, va_list);
-extern int TIFFUnsetField(TIFF*, uint32);
+extern int TIFFSetDirectory(TIFF*, uint16_t);
+extern int TIFFSetSubDirectory(TIFF*, uint64_t);
+extern int TIFFUnlinkDirectory(TIFF*, uint16_t);
+extern int TIFFSetField(TIFF*, uint32_t, ...);
+extern int TIFFVSetField(TIFF*, uint32_t, va_list);
+extern int TIFFUnsetField(TIFF*, uint32_t);
 extern int TIFFWriteDirectory(TIFF *);
-extern int TIFFWriteCustomDirectory(TIFF *, uint64 *);
+extern int TIFFWriteCustomDirectory(TIFF *, uint64_t *);
 extern int TIFFCheckpointDirectory(TIFF *);
 extern int TIFFRewriteDirectory(TIFF *);
 extern int TIFFDeferStrileArrayWriting(TIFF *);
@@ -416,26 +422,26 @@ extern int TIFFForceStrileArrayWriting(TIFF* );
 
 #if defined(c_plusplus) || defined(__cplusplus)
 extern void TIFFPrintDirectory(TIFF*, FILE*, long = 0);
-extern int TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample = 0);
-extern int TIFFWriteScanline(TIFF* tif, void* buf, uint32 row, uint16 sample = 0);
-extern int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int = 0);
-extern int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*,
+extern int TIFFReadScanline(TIFF* tif, void* buf, uint32_t row, uint16_t sample = 0);
+extern int TIFFWriteScanline(TIFF* tif, void* buf, uint32_t row, uint16_t sample = 0);
+extern int TIFFReadRGBAImage(TIFF*, uint32_t, uint32_t, uint32_t*, int = 0);
+extern int TIFFReadRGBAImageOriented(TIFF*, uint32_t, uint32_t, uint32_t*,
     int = ORIENTATION_BOTLEFT, int = 0);
 #else
 extern void TIFFPrintDirectory(TIFF*, FILE*, long);
-extern int TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample);
-extern int TIFFWriteScanline(TIFF* tif, void* buf, uint32 row, uint16 sample);
-extern int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int);
-extern int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*, int, int);
+extern int TIFFReadScanline(TIFF* tif, void* buf, uint32_t row, uint16_t sample);
+extern int TIFFWriteScanline(TIFF* tif, void* buf, uint32_t row, uint16_t sample);
+extern int TIFFReadRGBAImage(TIFF*, uint32_t, uint32_t, uint32_t*, int);
+extern int TIFFReadRGBAImageOriented(TIFF*, uint32_t, uint32_t, uint32_t*, int, int);
 #endif
 
-extern int TIFFReadRGBAStrip(TIFF*, uint32, uint32 * );
-extern int TIFFReadRGBATile(TIFF*, uint32, uint32, uint32 * );
-extern int TIFFReadRGBAStripExt(TIFF*, uint32, uint32 *, int stop_on_error );
-extern int TIFFReadRGBATileExt(TIFF*, uint32, uint32, uint32 *, int stop_on_error );
+extern int TIFFReadRGBAStrip(TIFF*, uint32_t, uint32_t * );
+extern int TIFFReadRGBATile(TIFF*, uint32_t, uint32_t, uint32_t * );
+extern int TIFFReadRGBAStripExt(TIFF*, uint32_t, uint32_t *, int stop_on_error );
+extern int TIFFReadRGBATileExt(TIFF*, uint32_t, uint32_t, uint32_t *, int stop_on_error );
 extern int TIFFRGBAImageOK(TIFF*, char [1024]);
 extern int TIFFRGBAImageBegin(TIFFRGBAImage*, TIFF*, int, char [1024]);
-extern int TIFFRGBAImageGet(TIFFRGBAImage*, uint32*, uint32, uint32);
+extern int TIFFRGBAImageGet(TIFFRGBAImage*, uint32_t*, uint32_t, uint32_t);
 extern void TIFFRGBAImageEnd(TIFFRGBAImage*);
 extern TIFF* TIFFOpen(const char*, const char*);
 # ifdef __WIN32__
@@ -450,53 +456,53 @@ extern TIFF* TIFFClientOpen(const char*, const char*,
 	    TIFFMapFileProc, TIFFUnmapFileProc);
 extern const char* TIFFFileName(TIFF*);
 extern const char* TIFFSetFileName(TIFF*, const char *);
-extern void TIFFError(const char*, const char*, ...) __attribute__((__format__ (__printf__,2,3)));
-extern void TIFFErrorExt(thandle_t, const char*, const char*, ...) __attribute__((__format__ (__printf__,3,4)));
-extern void TIFFWarning(const char*, const char*, ...) __attribute__((__format__ (__printf__,2,3)));
-extern void TIFFWarningExt(thandle_t, const char*, const char*, ...) __attribute__((__format__ (__printf__,3,4)));
+extern void TIFFError(const char*, const char*, ...) TIFF_ATTRIBUTE((__format__ (__printf__,2,3)));
+extern void TIFFErrorExt(thandle_t, const char*, const char*, ...) TIFF_ATTRIBUTE((__format__ (__printf__,3,4)));
+extern void TIFFWarning(const char*, const char*, ...) TIFF_ATTRIBUTE((__format__ (__printf__,2,3)));
+extern void TIFFWarningExt(thandle_t, const char*, const char*, ...) TIFF_ATTRIBUTE((__format__ (__printf__,3,4)));
 extern TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler);
 extern TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt);
 extern TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler);
 extern TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt);
 extern TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc);
-extern uint32 TIFFComputeTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s);
-extern int TIFFCheckTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s);
-extern uint32 TIFFNumberOfTiles(TIFF*);
-extern tmsize_t TIFFReadTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s);  
-extern tmsize_t TIFFWriteTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s);
-extern uint32 TIFFComputeStrip(TIFF*, uint32, uint16);
-extern uint32 TIFFNumberOfStrips(TIFF*);
-extern tmsize_t TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size);
-extern tmsize_t TIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size);  
-extern tmsize_t TIFFReadEncodedTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size);  
-extern tmsize_t TIFFReadRawTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size);  
-extern int      TIFFReadFromUserBuffer(TIFF* tif, uint32 strile,
+extern uint32_t TIFFComputeTile(TIFF* tif, uint32_t x, uint32_t y, uint32_t z, uint16_t s);
+extern int TIFFCheckTile(TIFF* tif, uint32_t x, uint32_t y, uint32_t z, uint16_t s);
+extern uint32_t TIFFNumberOfTiles(TIFF*);
+extern tmsize_t TIFFReadTile(TIFF* tif, void* buf, uint32_t x, uint32_t y, uint32_t z, uint16_t s);
+extern tmsize_t TIFFWriteTile(TIFF* tif, void* buf, uint32_t x, uint32_t y, uint32_t z, uint16_t s);
+extern uint32_t TIFFComputeStrip(TIFF*, uint32_t, uint16_t);
+extern uint32_t TIFFNumberOfStrips(TIFF*);
+extern tmsize_t TIFFReadEncodedStrip(TIFF* tif, uint32_t strip, void* buf, tmsize_t size);
+extern tmsize_t TIFFReadRawStrip(TIFF* tif, uint32_t strip, void* buf, tmsize_t size);
+extern tmsize_t TIFFReadEncodedTile(TIFF* tif, uint32_t tile, void* buf, tmsize_t size);
+extern tmsize_t TIFFReadRawTile(TIFF* tif, uint32_t tile, void* buf, tmsize_t size);
+extern int      TIFFReadFromUserBuffer(TIFF* tif, uint32_t strile,
                                        void* inbuf, tmsize_t insize,
                                        void* outbuf, tmsize_t outsize);
-extern tmsize_t TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc);
-extern tmsize_t TIFFWriteRawStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc);  
-extern tmsize_t TIFFWriteEncodedTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc);  
-extern tmsize_t TIFFWriteRawTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc);  
+extern tmsize_t TIFFWriteEncodedStrip(TIFF* tif, uint32_t strip, void* data, tmsize_t cc);
+extern tmsize_t TIFFWriteRawStrip(TIFF* tif, uint32_t strip, void* data, tmsize_t cc);
+extern tmsize_t TIFFWriteEncodedTile(TIFF* tif, uint32_t tile, void* data, tmsize_t cc);
+extern tmsize_t TIFFWriteRawTile(TIFF* tif, uint32_t tile, void* data, tmsize_t cc);
 extern int TIFFDataWidth(TIFFDataType);    /* table of tag datatype widths */
 extern void TIFFSetWriteOffset(TIFF* tif, toff_t off);
-extern void TIFFSwabShort(uint16*);
-extern void TIFFSwabLong(uint32*);
-extern void TIFFSwabLong8(uint64*);
+extern void TIFFSwabShort(uint16_t*);
+extern void TIFFSwabLong(uint32_t*);
+extern void TIFFSwabLong8(uint64_t*);
 extern void TIFFSwabFloat(float*);
 extern void TIFFSwabDouble(double*);
-extern void TIFFSwabArrayOfShort(uint16* wp, tmsize_t n);
-extern void TIFFSwabArrayOfTriples(uint8* tp, tmsize_t n);
-extern void TIFFSwabArrayOfLong(uint32* lp, tmsize_t n);
-extern void TIFFSwabArrayOfLong8(uint64* lp, tmsize_t n);
+extern void TIFFSwabArrayOfShort(uint16_t* wp, tmsize_t n);
+extern void TIFFSwabArrayOfTriples(uint8_t* tp, tmsize_t n);
+extern void TIFFSwabArrayOfLong(uint32_t* lp, tmsize_t n);
+extern void TIFFSwabArrayOfLong8(uint64_t* lp, tmsize_t n);
 extern void TIFFSwabArrayOfFloat(float* fp, tmsize_t n);
 extern void TIFFSwabArrayOfDouble(double* dp, tmsize_t n);
-extern void TIFFReverseBits(uint8* cp, tmsize_t n);
+extern void TIFFReverseBits(uint8_t* cp, tmsize_t n);
 extern const unsigned char* TIFFGetBitRevTable(int);
 
-extern uint64 TIFFGetStrileOffset(TIFF *tif, uint32 strile);
-extern uint64 TIFFGetStrileByteCount(TIFF *tif, uint32 strile);
-extern uint64 TIFFGetStrileOffsetWithErr(TIFF *tif, uint32 strile, int *pbErr);
-extern uint64 TIFFGetStrileByteCountWithErr(TIFF *tif, uint32 strile, int *pbErr);
+extern uint64_t TIFFGetStrileOffset(TIFF *tif, uint32_t strile);
+extern uint64_t TIFFGetStrileByteCount(TIFF *tif, uint32_t strile);
+extern uint64_t TIFFGetStrileOffsetWithErr(TIFF *tif, uint32_t strile, int *pbErr);
+extern uint64_t TIFFGetStrileByteCountWithErr(TIFF *tif, uint32_t strile, int *pbErr);
 
 #ifdef LOGLUV_PUBLIC
 #define U_NEU		0.210526316
@@ -504,34 +510,34 @@ extern uint64 TIFFGetStrileByteCountWithErr(TIFF *tif, uint32 strile, int *pbErr
 #define UVSCALE		410.
 extern double LogL16toY(int);
 extern double LogL10toY(int);
-extern void XYZtoRGB24(float*, uint8*);
+extern void XYZtoRGB24(float*, uint8_t*);
 extern int uv_decode(double*, double*, int);
-extern void LogLuv24toXYZ(uint32, float*);
-extern void LogLuv32toXYZ(uint32, float*);
+extern void LogLuv24toXYZ(uint32_t, float*);
+extern void LogLuv32toXYZ(uint32_t, float*);
 #if defined(c_plusplus) || defined(__cplusplus)
 extern int LogL16fromY(double, int = SGILOGENCODE_NODITHER);
 extern int LogL10fromY(double, int = SGILOGENCODE_NODITHER);
 extern int uv_encode(double, double, int = SGILOGENCODE_NODITHER);
-extern uint32 LogLuv24fromXYZ(float*, int = SGILOGENCODE_NODITHER);
-extern uint32 LogLuv32fromXYZ(float*, int = SGILOGENCODE_NODITHER);
+extern uint32_t LogLuv24fromXYZ(float*, int = SGILOGENCODE_NODITHER);
+extern uint32_t LogLuv32fromXYZ(float*, int = SGILOGENCODE_NODITHER);
 #else
 extern int LogL16fromY(double, int);
 extern int LogL10fromY(double, int);
 extern int uv_encode(double, double, int);
-extern uint32 LogLuv24fromXYZ(float*, int);
-extern uint32 LogLuv32fromXYZ(float*, int);
+extern uint32_t LogLuv24fromXYZ(float*, int);
+extern uint32_t LogLuv32fromXYZ(float*, int);
 #endif
 #endif /* LOGLUV_PUBLIC */
 
 extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB*, const TIFFDisplay *, float*);
-extern void TIFFCIELabToXYZ(TIFFCIELabToRGB *, uint32, int32, int32,
-    float *, float *, float *);
+extern void TIFFCIELabToXYZ(TIFFCIELabToRGB *, uint32_t, int32_t, int32_t,
+                            float *, float *, float *);
 extern void TIFFXYZToRGB(TIFFCIELabToRGB *, float, float, float,
-    uint32 *, uint32 *, uint32 *);
+                         uint32_t *, uint32_t *, uint32_t *);
 
 extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB*, float*, float*);
-extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *, uint32, int32, int32,
-    uint32 *, uint32 *, uint32 *);
+extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *, uint32_t, int32_t, int32_t,
+                           uint32_t *, uint32_t *, uint32_t *);
 
 /****************************************************************************
  *               O B S O L E T E D    I N T E R F A C E S
@@ -550,7 +556,7 @@ typedef	struct {
 	char	*field_name;		/* ASCII name */
 } TIFFFieldInfo;
 
-extern int TIFFMergeFieldInfo(TIFF*, const TIFFFieldInfo[], uint32);
+extern int TIFFMergeFieldInfo(TIFF*, const TIFFFieldInfo[], uint32_t);
         
 #if defined(c_plusplus) || defined(__cplusplus)
 }
diff --git a/src/3rdparty/libtiff/libtiff/tiffiop.h b/src/3rdparty/libtiff/libtiff/tiffiop.h
index 45a7932..f1151f5 100644
--- a/src/3rdparty/libtiff/libtiff/tiffiop.h
+++ b/src/3rdparty/libtiff/libtiff/tiffiop.h
@@ -38,9 +38,7 @@
 # include <sys/types.h>
 #endif
 
-#ifdef HAVE_STRING_H
-# include <string.h>
-#endif
+#include <string.h>
 
 #ifdef HAVE_ASSERT_H
 # include <assert.h>
@@ -48,19 +46,6 @@
 # define assert(x) 
 #endif
 
-#ifdef HAVE_SEARCH_H
-# include <search.h>
-#else
-extern void *lfind(const void *, const void *, size_t *, size_t,
-		   int (*)(const void *, const void *));
-#endif
-
-#if !defined(HAVE_SNPRINTF) && !defined(HAVE__SNPRINTF)
-#undef snprintf
-#define snprintf _TIFF_snprintf_f
-extern int snprintf(char* str, size_t size, const char* format, ...);
-#endif
-
 #include "tiffio.h"
 
 #include "tif_dir.h"
@@ -77,19 +62,6 @@ extern int snprintf(char* str, size_t size, const char* format, ...);
 #define	FALSE	0
 #endif
 
-#define TIFF_SIZE_T_MAX ((size_t) ~ ((size_t)0))
-#define TIFF_TMSIZE_T_MAX (tmsize_t)(TIFF_SIZE_T_MAX >> 1)
-
-/*
- * Largest 32-bit unsigned integer value.
- */
-#define TIFF_UINT32_MAX 0xFFFFFFFFU
-
-/*
- * Largest 64-bit unsigned integer value.
- */
-#define TIFF_UINT64_MAX (((uint64)(TIFF_UINT32_MAX)) << 32 | TIFF_UINT32_MAX)
-
 typedef struct client_info {
     struct client_info *next;
     void *data;
@@ -105,18 +77,18 @@ typedef tidataval_t* tidata_t;        /* reference to internal image data */
 
 typedef void (*TIFFVoidMethod)(TIFF*);
 typedef int (*TIFFBoolMethod)(TIFF*);
-typedef int (*TIFFPreMethod)(TIFF*, uint16);
-typedef int (*TIFFCodeMethod)(TIFF* tif, uint8* buf, tmsize_t size, uint16 sample);
-typedef int (*TIFFSeekMethod)(TIFF*, uint32);
-typedef void (*TIFFPostMethod)(TIFF* tif, uint8* buf, tmsize_t size);
-typedef uint32 (*TIFFStripMethod)(TIFF*, uint32);
-typedef void (*TIFFTileMethod)(TIFF*, uint32*, uint32*);
+typedef int (*TIFFPreMethod)(TIFF*, uint16_t);
+typedef int (*TIFFCodeMethod)(TIFF* tif, uint8_t* buf, tmsize_t size, uint16_t sample);
+typedef int (*TIFFSeekMethod)(TIFF*, uint32_t);
+typedef void (*TIFFPostMethod)(TIFF* tif, uint8_t* buf, tmsize_t size);
+typedef uint32_t (*TIFFStripMethod)(TIFF*, uint32_t);
+typedef void (*TIFFTileMethod)(TIFF*, uint32_t*, uint32_t*);
 
 struct tiff {
 	char*                tif_name;         /* name of open file */
 	int                  tif_fd;           /* open file descriptor */
 	int                  tif_mode;         /* open mode (O_*) */
-	uint32               tif_flags;
+	uint32_t               tif_flags;
 	#define TIFF_FILLORDER   0x00003U /* natural bit fill order for machine */
 	#define TIFF_DIRTYHEADER 0x00004U /* header must be written on close */
 	#define TIFF_DIRTYDIRECT 0x00008U /* current directory must be written */
@@ -143,11 +115,11 @@ struct tiff {
         #define TIFF_DEFERSTRILELOAD 0x1000000U /* defer strip/tile offset/bytecount array loading. */
         #define TIFF_LAZYSTRILELOAD  0x2000000U /* lazy/ondemand loading of strip/tile offset/bytecount values. Only used if TIFF_DEFERSTRILELOAD is set and in read-only mode */
         #define TIFF_CHOPPEDUPARRAYS 0x4000000U /* set when allocChoppedUpStripArrays() has modified strip array */
-	uint64               tif_diroff;       /* file offset of current directory */
-	uint64               tif_nextdiroff;   /* file offset of following directory */
-	uint64*              tif_dirlist;      /* list of offsets to already seen directories to prevent IFD looping */
-	uint16               tif_dirlistsize;  /* number of entries in offset list */
-	uint16               tif_dirnumber;    /* number of already seen directories */
+	uint64_t               tif_diroff;       /* file offset of current directory */
+	uint64_t               tif_nextdiroff;   /* file offset of following directory */
+	uint64_t*              tif_dirlist;      /* list of offsets to already seen directories to prevent IFD looping */
+	uint16_t               tif_dirlistsize;  /* number of entries in offset list */
+	uint16_t               tif_dirnumber;    /* number of already seen directories */
 	TIFFDirectory        tif_dir;          /* internal rep of current directory */
 	TIFFDirectory        tif_customdir;    /* custom IFDs are separated from the main ones */
 	union {
@@ -155,18 +127,18 @@ struct tiff {
 		TIFFHeaderClassic classic;
 		TIFFHeaderBig big;
 	} tif_header;
-	uint16               tif_header_size;  /* file's header block and its length */
-	uint32               tif_row;          /* current scanline */
-	uint16               tif_curdir;       /* current directory (index) */
-	uint32               tif_curstrip;     /* current strip for read/write */
-	uint64               tif_curoff;       /* current offset for read/write */
-	uint64               tif_dataoff;      /* current offset for writing dir */
+	uint16_t               tif_header_size;  /* file's header block and its length */
+	uint32_t               tif_row;          /* current scanline */
+	uint16_t               tif_curdir;       /* current directory (index) */
+	uint32_t               tif_curstrip;     /* current strip for read/write */
+	uint64_t               tif_curoff;       /* current offset for read/write */
+	uint64_t               tif_dataoff;      /* current offset for writing dir */
 	/* SubIFD support */
-	uint16               tif_nsubifd;      /* remaining subifds to write */
-	uint64               tif_subifdoff;    /* offset for patching SubIFD link */
+	uint16_t               tif_nsubifd;      /* remaining subifds to write */
+	uint64_t               tif_subifdoff;    /* offset for patching SubIFD link */
 	/* tiling support */
-	uint32               tif_col;          /* current column (offset by row too) */
-	uint32               tif_curtile;      /* current tile for read/write */
+	uint32_t               tif_col;          /* current column (offset by row too) */
+	uint32_t               tif_curtile;      /* current tile for read/write */
 	tmsize_t             tif_tilesize;     /* # of bytes in a tile */
 	/* compression scheme hooks */
 	int                  tif_decodestatus;
@@ -188,18 +160,18 @@ struct tiff {
 	TIFFVoidMethod       tif_cleanup;      /* cleanup state routine */
 	TIFFStripMethod      tif_defstripsize; /* calculate/constrain strip size */
 	TIFFTileMethod       tif_deftilesize;  /* calculate/constrain tile size */
-	uint8*               tif_data;         /* compression scheme private data */
+	uint8_t*               tif_data;         /* compression scheme private data */
 	/* input/output buffering */
 	tmsize_t             tif_scanlinesize; /* # of bytes in a scanline */
 	tmsize_t             tif_scanlineskew; /* scanline skew for reading strips */
-	uint8*               tif_rawdata;      /* raw data buffer */
+	uint8_t*               tif_rawdata;      /* raw data buffer */
 	tmsize_t             tif_rawdatasize;  /* # of bytes in raw data buffer */
         tmsize_t             tif_rawdataoff;   /* rawdata offset within strip */
         tmsize_t             tif_rawdataloaded;/* amount of data in rawdata */
-	uint8*               tif_rawcp;        /* current spot in raw buffer */
+	uint8_t*               tif_rawcp;        /* current spot in raw buffer */
 	tmsize_t             tif_rawcc;        /* bytes unread from raw buffer */
 	/* memory-mapped file support */
-	uint8*               tif_base;         /* base of mapped file */
+	uint8_t*               tif_base;         /* base of mapped file */
 	tmsize_t             tif_size;         /* size of mapped file region (bytes, thus tmsize_t) */
 	TIFFMapFileProc      tif_mapproc;      /* map file method */
 	TIFFUnmapFileProc    tif_unmapproc;    /* unmap file method */
@@ -260,18 +232,18 @@ struct tiff {
 	(TIFFWriteFile((tif),(buf),(size))==(size))
 #endif
 
-/* NB: the uint32 casts are to silence certain ANSI-C compilers */
-#define TIFFhowmany_32(x, y) (((uint32)x < (0xffffffff - (uint32)(y-1))) ? \
-			   ((((uint32)(x))+(((uint32)(y))-1))/((uint32)(y))) : \
+/* NB: the uint32_t casts are to silence certain ANSI-C compilers */
+#define TIFFhowmany_32(x, y) (((uint32_t)x < (0xffffffff - (uint32_t)(y-1))) ? \
+			   ((((uint32_t)(x))+(((uint32_t)(y))-1))/((uint32_t)(y))) : \
 			   0U)
 /* Variant of TIFFhowmany_32() that doesn't return 0 if x close to MAXUINT. */
 /* Caution: TIFFhowmany_32_maxuint_compat(x,y)*y might overflow */
 #define TIFFhowmany_32_maxuint_compat(x, y) \
-			   (((uint32)(x) / (uint32)(y)) + ((((uint32)(x) % (uint32)(y)) != 0) ? 1 : 0))
-#define TIFFhowmany8_32(x) (((x)&0x07)?((uint32)(x)>>3)+1:(uint32)(x)>>3)
+			   (((uint32_t)(x) / (uint32_t)(y)) + ((((uint32_t)(x) % (uint32_t)(y)) != 0) ? 1 : 0))
+#define TIFFhowmany8_32(x) (((x)&0x07)?((uint32_t)(x)>>3)+1:(uint32_t)(x)>>3)
 #define TIFFroundup_32(x, y) (TIFFhowmany_32(x,y)*(y))
-#define TIFFhowmany_64(x, y) ((((uint64)(x))+(((uint64)(y))-1))/((uint64)(y)))
-#define TIFFhowmany8_64(x) (((x)&0x07)?((uint64)(x)>>3)+1:(uint64)(x)>>3)
+#define TIFFhowmany_64(x, y) ((((uint64_t)(x))+(((uint64_t)(y))-1))/((uint64_t)(y)))
+#define TIFFhowmany8_64(x) (((x)&0x07)?((uint64_t)(x)>>3)+1:(uint64_t)(x)>>3)
 #define TIFFroundup_64(x, y) (TIFFhowmany_64(x,y)*(y))
 
 /* Safe multiply which returns zero if there is an *unsigned* integer overflow. This macro is not safe for *signed* integer types */
@@ -344,35 +316,38 @@ typedef size_t TIFFIOSize_t;
 extern "C" {
 #endif
 extern int _TIFFgetMode(const char* mode, const char* module);
-extern int _TIFFNoRowEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s);
-extern int _TIFFNoStripEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s);
-extern int _TIFFNoTileEncode(TIFF*, uint8* pp, tmsize_t cc, uint16 s);
-extern int _TIFFNoRowDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s);
-extern int _TIFFNoStripDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s);
-extern int _TIFFNoTileDecode(TIFF*, uint8* pp, tmsize_t cc, uint16 s);
-extern void _TIFFNoPostDecode(TIFF* tif, uint8* buf, tmsize_t cc);
-extern int _TIFFNoPreCode(TIFF* tif, uint16 s);
-extern int _TIFFNoSeek(TIFF* tif, uint32 off);
-extern void _TIFFSwab16BitData(TIFF* tif, uint8* buf, tmsize_t cc);
-extern void _TIFFSwab24BitData(TIFF* tif, uint8* buf, tmsize_t cc);
-extern void _TIFFSwab32BitData(TIFF* tif, uint8* buf, tmsize_t cc);
-extern void _TIFFSwab64BitData(TIFF* tif, uint8* buf, tmsize_t cc);
+extern int _TIFFNoRowEncode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s);
+extern int _TIFFNoStripEncode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s);
+extern int _TIFFNoTileEncode(TIFF*, uint8_t* pp, tmsize_t cc, uint16_t s);
+extern int _TIFFNoRowDecode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s);
+extern int _TIFFNoStripDecode(TIFF* tif, uint8_t* pp, tmsize_t cc, uint16_t s);
+extern int _TIFFNoTileDecode(TIFF*, uint8_t* pp, tmsize_t cc, uint16_t s);
+extern void _TIFFNoPostDecode(TIFF* tif, uint8_t* buf, tmsize_t cc);
+extern int _TIFFNoPreCode(TIFF* tif, uint16_t s);
+extern int _TIFFNoSeek(TIFF* tif, uint32_t off);
+extern void _TIFFSwab16BitData(TIFF* tif, uint8_t* buf, tmsize_t cc);
+extern void _TIFFSwab24BitData(TIFF* tif, uint8_t* buf, tmsize_t cc);
+extern void _TIFFSwab32BitData(TIFF* tif, uint8_t* buf, tmsize_t cc);
+extern void _TIFFSwab64BitData(TIFF* tif, uint8_t* buf, tmsize_t cc);
 extern int TIFFFlushData1(TIFF* tif);
 extern int TIFFDefaultDirectory(TIFF* tif);
 extern void _TIFFSetDefaultCompressionState(TIFF* tif);
-extern int _TIFFRewriteField(TIFF *, uint16, TIFFDataType, tmsize_t, void *);
+extern int _TIFFRewriteField(TIFF *, uint16_t, TIFFDataType, tmsize_t, void *);
 extern int TIFFSetCompressionScheme(TIFF* tif, int scheme);
 extern int TIFFSetDefaultCompressionState(TIFF* tif);
-extern uint32 _TIFFDefaultStripSize(TIFF* tif, uint32 s);
-extern void _TIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th);
+extern uint32_t _TIFFDefaultStripSize(TIFF* tif, uint32_t s);
+extern void _TIFFDefaultTileSize(TIFF* tif, uint32_t* tw, uint32_t* th);
 extern int _TIFFDataSize(TIFFDataType type);
 
-extern void _TIFFsetByteArray(void**, void*, uint32);
+/*--: Rational2Double: Return size of TIFFSetGetFieldType in bytes. */
+extern int _TIFFSetGetFieldSize(TIFFSetGetFieldType setgettype);
+
+extern void _TIFFsetByteArray(void**, void*, uint32_t);
 extern void _TIFFsetString(char**, char*);
-extern void _TIFFsetShortArray(uint16**, uint16*, uint32);
-extern void _TIFFsetLongArray(uint32**, uint32*, uint32);
-extern void _TIFFsetFloatArray(float**, float*, uint32);
-extern void _TIFFsetDoubleArray(double**, double*, uint32);
+extern void _TIFFsetShortArray(uint16_t**, uint16_t*, uint32_t);
+extern void _TIFFsetLongArray(uint32_t**, uint32_t*, uint32_t);
+extern void _TIFFsetFloatArray(float**, float*, uint32_t);
+extern void _TIFFsetDoubleArray(double**, double*, uint32_t);
 
 extern void _TIFFprintAscii(FILE*, const char*);
 extern void _TIFFprintAsciiTag(FILE*, const char*, const char*);
@@ -382,30 +357,30 @@ extern TIFFErrorHandler _TIFFerrorHandler;
 extern TIFFErrorHandlerExt _TIFFwarningHandlerExt;
 extern TIFFErrorHandlerExt _TIFFerrorHandlerExt;
 
-extern uint32 _TIFFMultiply32(TIFF*, uint32, uint32, const char*);
-extern uint64 _TIFFMultiply64(TIFF*, uint64, uint64, const char*);
+extern uint32_t _TIFFMultiply32(TIFF*, uint32_t, uint32_t, const char*);
+extern uint64_t _TIFFMultiply64(TIFF*, uint64_t, uint64_t, const char*);
 extern tmsize_t _TIFFMultiplySSize(TIFF*, tmsize_t, tmsize_t, const char*);
-extern tmsize_t _TIFFCastUInt64ToSSize(TIFF*, uint64, const char*);
+extern tmsize_t _TIFFCastUInt64ToSSize(TIFF*, uint64_t, const char*);
 extern void* _TIFFCheckMalloc(TIFF*, tmsize_t, tmsize_t, const char*);
 extern void* _TIFFCheckRealloc(TIFF*, void*, tmsize_t, tmsize_t, const char*);
 
-extern double _TIFFUInt64ToDouble(uint64);
-extern float _TIFFUInt64ToFloat(uint64);
+extern double _TIFFUInt64ToDouble(uint64_t);
+extern float _TIFFUInt64ToFloat(uint64_t);
 
 extern float _TIFFClampDoubleToFloat(double);
 
 extern tmsize_t
-_TIFFReadEncodedStripAndAllocBuffer(TIFF* tif, uint32 strip,
+_TIFFReadEncodedStripAndAllocBuffer(TIFF* tif, uint32_t strip,
                                     void **buf, tmsize_t bufsizetoalloc,
                                     tmsize_t size_to_read);
 extern tmsize_t
-_TIFFReadEncodedTileAndAllocBuffer(TIFF* tif, uint32 tile,
-                                    void **buf, tmsize_t bufsizetoalloc,
-                                    tmsize_t size_to_read);
+_TIFFReadEncodedTileAndAllocBuffer(TIFF* tif, uint32_t tile,
+                                   void **buf, tmsize_t bufsizetoalloc,
+                                   tmsize_t size_to_read);
 extern tmsize_t
 _TIFFReadTileAndAllocBuffer(TIFF* tif,
                             void **buf, tmsize_t bufsizetoalloc,
-                            uint32 x, uint32 y, uint32 z, uint16 s);
+                            uint32_t x, uint32_t y, uint32_t z, uint16_t s);
 extern int _TIFFSeekOK(TIFF* tif, toff_t off);
 
 extern int TIFFInitDumpMode(TIFF*, int);
@@ -444,6 +419,9 @@ extern int TIFFInitPixarLog(TIFF*, int);
 #ifdef LOGLUV_SUPPORT
 extern int TIFFInitSGILog(TIFF*, int);
 #endif
+#ifdef LERC_SUPPORT
+extern int TIFFInitLERC(TIFF* tif, int);
+#endif
 #ifdef LZMA_SUPPORT
 extern int TIFFInitLZMA(TIFF*, int);
 #endif
@@ -453,11 +431,7 @@ extern int TIFFInitZSTD(TIFF*, int);
 #ifdef WEBP_SUPPORT
 extern int TIFFInitWebP(TIFF*, int);
 #endif
-#ifdef VMS
 extern const TIFFCodec _TIFFBuiltinCODECS[];
-#else
-extern TIFFCodec _TIFFBuiltinCODECS[];
-#endif
 
 #if defined(__cplusplus)
 }
diff --git a/src/3rdparty/libtiff/libtiff/tiffvers.h b/src/3rdparty/libtiff/libtiff/tiffvers.h
index aa3f613..dbe5596 100644
--- a/src/3rdparty/libtiff/libtiff/tiffvers.h
+++ b/src/3rdparty/libtiff/libtiff/tiffvers.h
@@ -1,4 +1,4 @@
-#define TIFFLIB_VERSION_STR "LIBTIFF, Version 4.1.0\nCopyright (c) 1988-1996 Sam Leffler\nCopyright (c) 1991-1996 Silicon Graphics, Inc."
+#define TIFFLIB_VERSION_STR "LIBTIFF, Version 4.3.0\nCopyright (c) 1988-1996 Sam Leffler\nCopyright (c) 1991-1996 Silicon Graphics, Inc."
 /*
  * This define can be used in code that requires
  * compilation-related definitions specific to a
@@ -6,4 +6,4 @@
  * version checking should be done based on the
  * string returned by TIFFGetVersion.
  */
-#define TIFFLIB_VERSION 20191103
+#define TIFFLIB_VERSION 20210416
diff --git a/src/3rdparty/libtiff/port/dummy.c b/src/3rdparty/libtiff/port/dummy.c
deleted file mode 100644
index 346a07e..0000000
--- a/src/3rdparty/libtiff/port/dummy.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/*
- * Dummy function, just to be ensure that the library always will be created.
- */
-
-void
-libport_dummy_function()
-{
-        return;
-}
-
diff --git a/src/3rdparty/libtiff/port/getopt.c b/src/3rdparty/libtiff/port/getopt.c
deleted file mode 100644
index c7bdb11..0000000
--- a/src/3rdparty/libtiff/port/getopt.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (c) 1987, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#if 0
-static char sccsid[] = "@(#)getopt.c	8.3 (Berkeley) 4/27/95";
-__RCSID("$NetBSD: getopt.c,v 1.26 2003/08/07 16:43:40 agc Exp $");
-#endif
-
-#include <stdio.h>
-#include <string.h>
-#include "libport.h"
-
-int	opterr = 1,		/* if error message should be printed */
-	optind = 1,		/* index into parent argv vector */
-	optopt,			/* character checked for validity */
-	optreset;		/* reset getopt */
-char	*optarg;		/* argument associated with option */
-
-#define	BADCH	(int)'?'
-#define	BADARG	(int)':'
-#define	EMSG	""
-
-/*
- * getopt --
- *	Parse argc/argv argument vector.
- */
-int
-getopt(int argc, char * const argv[], const char *optstring)
-{
-	static char *place = EMSG;		/* option letter processing */
-	char *oli;				/* option letter list index */
-
-	if (optreset || *place == 0) {		/* update scanning pointer */
-		optreset = 0;
-		place = argv[optind];
-		if (optind >= argc || *place++ != '-') {
-			/* Argument is absent or is not an option */
-			place = EMSG;
-			return (-1);
-		}
-		optopt = *place++;
-		if (optopt == '-' && *place == 0) {
-			/* "--" => end of options */
-			++optind;
-			place = EMSG;
-			return (-1);
-		}
-		if (optopt == 0) {
-			/* Solitary '-', treat as a '-' option
-			   if the program (eg su) is looking for it. */
-			place = EMSG;
-			if (strchr(optstring, '-') == NULL)
-				return -1;
-			optopt = '-';
-		}
-	} else
-		optopt = *place++;
-
-	/* See if option letter is one the caller wanted... */
-	if (optopt == ':' || (oli = strchr(optstring, optopt)) == NULL) {
-		if (*place == 0)
-			++optind;
-		if (opterr && *optstring != ':')
-			(void)fprintf(stderr,
-                                      "unknown option -- %c\n", optopt);
-		return (BADCH);
-	}
-
-	/* Does this option need an argument? */
-	if (oli[1] != ':') {
-		/* don't need argument */
-		optarg = NULL;
-		if (*place == 0)
-			++optind;
-	} else {
-		/* Option-argument is either the rest of this argument or the
-		   entire next argument. */
-		if (*place)
-			optarg = place;
-		else if (argc > ++optind)
-			optarg = argv[optind];
-		else {
-			/* option-argument absent */
-			place = EMSG;
-			if (*optstring == ':')
-				return (BADARG);
-			if (opterr)
-				(void)fprintf(stderr,
-                                        "option requires an argument -- %c\n",
-                                        optopt);
-			return (BADCH);
-		}
-		place = EMSG;
-		++optind;
-	}
-	return (optopt);			/* return option letter */
-}
diff --git a/src/3rdparty/libtiff/port/lfind.c b/src/3rdparty/libtiff/port/lfind.c
deleted file mode 100644
index 00ab649..0000000
--- a/src/3rdparty/libtiff/port/lfind.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (c) 1989, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Roger L. Snyder.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#if 0
-static char sccsid[] = "@(#)lsearch.c	8.1 (Berkeley) 6/4/93";
-__RCSID("$NetBSD: lsearch.c,v 1.2 2005/07/06 15:47:15 drochner Exp $");
-#endif
-
-#ifdef _WIN32_WCE
-# include <wce_types.h>
-#else
-# include <sys/types.h>
-#endif
-
-#ifndef NULL
-# define NULL 0
-#endif
-
-void *
-lfind(const void *key, const void *base, size_t *nmemb, size_t size,
-      int(*compar)(const void *, const void *))
-{
-	char *element, *end;
-
-	end = (char *)base + *nmemb * size;
-	for (element = (char *)base; element < end; element += size)
-		if (!compar(element, key))		/* key found */
-			return element;
-
-	return NULL;
-}
diff --git a/src/3rdparty/libtiff/port/libport.h b/src/3rdparty/libtiff/port/libport.h
deleted file mode 100644
index ff26263..0000000
--- a/src/3rdparty/libtiff/port/libport.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2009 Frank Warmerdam
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
- * OF THIS SOFTWARE.
- */
-
-#ifndef _LIBPORT_
-#define	_LIBPORT_
-
-int getopt(int argc, char * const argv[], const char *optstring);
-extern   char *optarg;
-extern   int opterr;
-extern   int optind;
-extern   int optopt;
-
-int strcasecmp(const char *s1, const char *s2);
-
-#ifndef HAVE_GETOPT
-#  define HAVE_GETOPT 1
-#endif
-
-#if HAVE_STRTOL
-long strtol(const char *nptr, char **endptr, int base);
-#endif
-#if HAVE_STRTOLL
-long long strtoll(const char *nptr, char **endptr, int base);
-#endif
-#if HAVE_STRTOUL
-unsigned long strtoul(const char *nptr, char **endptr, int base);
-#endif
-#if HAVE_STRTOULL
-unsigned long long strtoull(const char *nptr, char **endptr, int base);
-#endif
-
-#if 0
-void *
-lfind(const void *key, const void *base, size_t *nmemb, size_t size,
-      int(*compar)(const void *, const void *));
-#endif
-
-#if !defined(HAVE_SNPRINTF)
-#undef vsnprintf
-#define vsnprintf _TIFF_vsnprintf_f
-
-#undef snprintf
-#define snprintf _TIFF_snprintf_f
-int snprintf(char* str, size_t size, const char* format, ...);
-#endif
-
-#endif /* ndef _LIBPORT_ */
diff --git a/src/3rdparty/libtiff/port/snprintf.c b/src/3rdparty/libtiff/port/snprintf.c
deleted file mode 100644
index 3542ab7..0000000
--- a/src/3rdparty/libtiff/port/snprintf.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/**
- * Workaround for lack of snprintf(3) in Visual Studio.  See
- * http://stackoverflow.com/questions/2915672/snprintf-and-visual-studio-2010/8712996#8712996
- * It's a trivial wrapper around the builtin _vsnprintf_s and
- * _vscprintf functions.
- */
-
-#ifdef _MSC_VER
-
-#include <stdio.h>
-#include <stdarg.h>
-#include "libport.h"
-
-int _TIFF_vsnprintf_f(char* str, size_t size, const char* format, va_list ap)
-{
-  int count = -1;
-
-  if (size != 0)
-#if _MSC_VER <=	1310
-    count = _vsnprintf(str, size, format, ap);
-#else
-    count = _vsnprintf_s(str, size, _TRUNCATE, format, ap);
-#endif
-  if (count == -1)
-    count = _vscprintf(format, ap);
-
-  return count;
-}
-
-int _TIFF_snprintf_f(char* str, size_t size, const char* format, ...)
-{
-  int count;
-  va_list ap;
-
-  va_start(ap, format);
-  count = vsnprintf(str, size, format, ap);
-  va_end(ap);
-
-  return count;
-}
-
-#endif // _MSC_VER
diff --git a/src/3rdparty/libtiff/port/strcasecmp.c b/src/3rdparty/libtiff/port/strcasecmp.c
deleted file mode 100644
index 65e2b41..0000000
--- a/src/3rdparty/libtiff/port/strcasecmp.c
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 1987, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#if 0
-static char sccsid[] = "@(#)strcasecmp.c	8.1 (Berkeley) 6/4/93";
-__RCSID("$NetBSD: strcasecmp.c,v 1.16 2003/08/07 16:43:49 agc Exp $");
-#endif
-
-#include <ctype.h>
-#include <string.h>
-#include "libport.h"
-
-int
-strcasecmp(const char *s1, const char *s2)
-{
-	const unsigned char *us1 = (const unsigned char *)s1,
-			*us2 = (const unsigned char *)s2;
-
-	while (tolower((int) *us1) == tolower((int) *us2++))
-		if (*us1++ == '\0')
-			return (0);
-	return (tolower((int) *us1) - tolower((int) *--us2));
-}
diff --git a/src/3rdparty/libtiff/port/strtoul.c b/src/3rdparty/libtiff/port/strtoul.c
deleted file mode 100644
index dbd44f1..0000000
--- a/src/3rdparty/libtiff/port/strtoul.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/* $NetBSD: strtoul.c,v 1.3 2008/08/20 19:58:34 oster Exp $ */
-
-/*-
- * Copyright (c) 2005 The DragonFly Project.  All rights reserved.
- * Copyright (c) 2003 Citrus Project,
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#if 0
-__RCSID("$NetBSD: strtoul.c,v 1.3 2008/08/20 19:58:34 oster Exp $");
-#endif
-
-#include <assert.h>
-#include <ctype.h>
-#include <errno.h>
-#include <limits.h>
-#include <stdlib.h>
-
-#define	_FUNCNAME	strtoul
-#define	__UINT		unsigned long int
-#define	__UINT_MAX	ULONG_MAX
-
-#include "_strtoul.h"
diff --git a/src/3rdparty/libtiff/port/strtoull.c b/src/3rdparty/libtiff/port/strtoull.c
deleted file mode 100644
index 91e4ddf..0000000
--- a/src/3rdparty/libtiff/port/strtoull.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/* $NetBSD: strtoul.c,v 1.3 2008/08/20 19:58:34 oster Exp $ */
-
-/*-
- * Copyright (c) 2005 The DragonFly Project.  All rights reserved.
- * Copyright (c) 2003 Citrus Project,
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#if 0
-__RCSID("$NetBSD: strtoul.c,v 1.3 2008/08/20 19:58:34 oster Exp $");
-#endif
-
-#include <assert.h>
-#include <ctype.h>
-#include <errno.h>
-#include <limits.h>
-#include <stdlib.h>
-
-#define	_FUNCNAME	strtoull
-#define	__UINT		unsigned long long int
-#define	__UINT_MAX	ULLONG_MAX
-
-#include "_strtoul.h"
diff --git a/src/3rdparty/libtiff/qt_attribution.json b/src/3rdparty/libtiff/qt_attribution.json
index 283f5e6..9d7837e 100644
--- a/src/3rdparty/libtiff/qt_attribution.json
+++ b/src/3rdparty/libtiff/qt_attribution.json
@@ -6,9 +6,10 @@
 
     "Description": "",
     "Homepage": "http://www.simplesystems.org/libtiff/",
-    "Version": "4.1.0",
+    "Version": "4.3.0",
     "License": "libtiff License",
     "LicenseId": "libtiff",
     "LicenseFile": "COPYRIGHT",
     "Copyright": "Copyright (c) 1988-1997 Sam Leffler\nCopyright (c) 1991-1997 Silicon Graphics, Inc."
 }
+
diff --git a/src/3rdparty/libwebp.pri b/src/3rdparty/libwebp.pri
index c193ddf..22f82bf 100644
--- a/src/3rdparty/libwebp.pri
+++ b/src/3rdparty/libwebp.pri
@@ -71,6 +71,7 @@ SOURCES += \
     $$PWD/libwebp/src/dsp/yuv.c \
     $$PWD/libwebp/src/dsp/yuv_mips_dsp_r2.c \
     $$PWD/libwebp/src/dsp/lossless_sse2.c \
+    $$PWD/libwebp/src/dsp/lossless_sse41.c \
     $$PWD/libwebp/src/dsp/yuv_mips32.c \
     $$PWD/libwebp/src/dsp/yuv_sse2.c \
     $$PWD/libwebp/src/dsp/yuv_sse41.c \
diff --git a/src/3rdparty/libwebp/AUTHORS b/src/3rdparty/libwebp/AUTHORS
index 32ff2fb..30abde0 100644
--- a/src/3rdparty/libwebp/AUTHORS
+++ b/src/3rdparty/libwebp/AUTHORS
@@ -4,8 +4,12 @@ Contributors:
 - Charles Munger (clm at google dot com)
 - Cheng Yi (cyi at google dot com)
 - Christian Duvivier (cduvivier at google dot com)
+- Christopher Degawa (ccom at randomderp dot com)
+- Clement Courbet (courbet at google dot com)
 - Djordje Pesut (djordje dot pesut at imgtec dot com)
 - Hui Su (huisu at google dot com)
+- Ilya Kurdyukov (jpegqs at gmail dot com)
+- Ingvar Stepanyan (rreverser at google dot com)
 - James Zern (jzern at google dot com)
 - Jan Engelhardt (jengelh at medozas dot de)
 - Jehan (jehan at girinstud dot io)
@@ -41,5 +45,7 @@ Contributors:
 - Vikas Arora (vikasa at google dot com)
 - Vincent Rabaud (vrabaud at google dot com)
 - Vlad Tsyrklevich (vtsyrklevich at chromium dot org)
+- Wan-Teh Chang (wtc at google dot com)
 - Yang Zhang (yang dot zhang at arm dot com)
 - Yannis Guyon (yguyon at google dot com)
+- Zhi An Ng (zhin at chromium dot org)
diff --git a/src/3rdparty/libwebp/ChangeLog b/src/3rdparty/libwebp/ChangeLog
index 0a286fc..6185fb6 100644
--- a/src/3rdparty/libwebp/ChangeLog
+++ b/src/3rdparty/libwebp/ChangeLog
@@ -1,4 +1,181 @@
+d9191588 fuzzer/*: normalize src/ includes
+53b6f762 fix indent
+731246ba update ChangeLog (tag: v1.2.1-rc2)
+d250f01d dsp/*: use WEBP_HAVE_* to determine Init availability
+3a4d3ecd update NEWS
+b2bc8093 bump version to 1.2.1
+e542fc7a update AUTHORS
+e0241154 Merge "libwebp/CMake: Add <BUILD_INTERFACE> to webp incl" into main
+edea6444 libwebp/CMake: Add <BUILD_INTERFACE> to webp incl
+ece18e55 dsp.h: respect --disable-sse2/sse4.1/neon
+a89a3230 wicdec: support alpha from WebP WIC decoder
+26f4aa01 Merge "alpha_processing: fix visual studio warnings" into main
+8f594663 alpha_processing: fix visual studio warnings
+46d844e6 Merge "cpu.cmake: fix compiler flag detection w/3.17.0+" into main
+298d26ea Merge changes I593adf92,If20675e7,Ifac68eac into main
+a1e5dae0 alpha_processing*: use WEBP_RESTRICT qualifier
+327ef24f cpu.cmake: fix compiler flag detection w/3.17.0+
+f70819de configure: enable libwebpmux by default
+dc7e2b42 configure: add informational notices when disabling binaries
+9df23ddd configure: move lib flag checks before binaries
+a2e18f10 Merge "WebPConfig.config.in: correct WEBP_INCLUDE_DIRS" into main
+e1a8d4f3 Merge "bit_reader_inl_utils: uniformly apply WEBP_RESTRICT" into main
+4de35f43 rescaler.c: fix alignment
+0f13eec7 bit_reader_inl_utils: uniformly apply WEBP_RESTRICT
+277d3074 Fix size_t overflow in  WebPRescalerInit
+97adbba5 WebPConfig.config.in: correct WEBP_INCLUDE_DIRS
+b60d4603 advanced_api_fuzzer: add extreme config value coverage
+72fe52f6 anim_encode.c,cosmetics: normalize indent
+116d235c anim_encode: Fix encoded_frames_[] overflow
+6f445b3e CMake: set CMP0072 to NEW
+b1cf887f define WEBP_RESTRICT for MSVC
+3e265136 Add WEBP_RESTRICT & use it in VP8BitReader
+f6d29247 vp8l_dec::ProcessRows: fix int overflow in multiply
+de3b4ba8 CMake: add WEBP_BUILD_LIBWEBPMUX
+7f09d3d1 CMakeLists.txt: rm libwebpmux dep from anim_{diff,dump}
+4edea4a6 Init{RGB,YUV}Rescaler: fix a few more int overflows
+c9e26bdb rescaler_utils: set max valid scaled w/h to INT_MAX/2
+28d488e6 utils.h: add SizeOverflow()
+695bdaa2 Export/EmitRescaledRowsRGBA: fix pointer offset int overflow
+685d073e Init{RGB,YUV}Rescaler: fix int overflows in multiplication
+d38bd0dd WebPFlipBuffer: fix integer overflow
+109ff0f1 utils: allow MALLOC_LIMIT to indicate a max
+a2fce867 WebPRescalerImportRowExpand_C: promote some vals before multiply
+776983d4 AllocateBuffer: fix int multiplication overflow check
+315abbd6 Merge "Revert "Do not use a palette for one color images.""
+eae815d0 Merge changes Ica3bbf75,I82f82954
+afbca5a1 Require Emscripten 2.0.18
+3320416b CMakeLists,emscripten: use EXPORTED_RUNTIME_METHODS
+29145ed6 Update README instructions for using Emscripten
+1f579139 cosmetics: remove use of 'sanity' / 'master'
+29b6129c WebPAnimEncoderNewInternal: remove some unnecessary inits
+b60869a1 Revert "Do not use a palette for one color images."
+6fb4cddc demux: move padded size calc post unpadded validation
+05b72d42 vp8l_enc.c: normalize index types
+b6513fba Do not use a palette for one color images.
+98bbe35b Fix multi-threading with palettes.
+b1674240 Add modified Zeng's method to palette sorting.
+88c90c45 add CONTRIBUTING.md
+6a9916d7 WebPRescalerInit: add missing int64_t promotion
+b6cf52d5 WebPIoInitFromOptions: treat use_scaling as a bool
+3b12b7f4 WebPIoInitFromOptions: treat use_cropping as a bool
+595fa13f add WebPCheckCropDimensions()
+8fdaecb0 Disable cross-color when palette is used.
+8933bac2 WebPIoInitFromOptions: respect incoming bypass_filtering val
+7d416ff0 webpdec,cosmetics: match error text to function call
+ec6cfeb5 Fix typo on WebPPictureAlloc() in README
+7e58a1a2 *.cmake: add license header
+5651a6b2 cmake: fix .so versioning
+25ae67b3 xcframeworkbuild.sh: add arm64 simulator target
+5d4ee4c3 cosmetics: remove use of the term 'dummy'
+01b38ee1 faster CollectColorXXXTransforms_SSE41
+652aa344 Merge "Use BitCtz for FastSLog2Slow_C"
+0320e1e3 add the missing default BitsCtz() code
+8886f620 Use BitCtz for FastSLog2Slow_C
+fae41617 faster CombinedShannonEntropy_SSE2
+5bd2704e Introduce the BitCtz() function.
+fee64287 Merge "wicdec,icc: treat unsupported op as non-fatal"
+33ddb894 lossless_sse{2,41}: remove some unneeded includes
+b27ea852 wicdec,icc: treat unsupported op as non-fatal
+b78494a9 Merge "Fix undefined signed shift."
+e79974cd Fix undefined signed shift.
+a8853394 SSE4.1 versions of BGRA to RGB/BGR color-space conversions
+a09a6472 SSE4.1 version of TransformColorInverse
+401da22b Merge "pngdec: check version before using png_get_chunk_malloc_max"
+26907822 pngdec: check version before using png_get_chunk_malloc_max
+06c1e72e Code cleanup
+8f0d41aa Merge changes Id135bbf4,I99e59797
+373eb170 gif2webp: don't store loop-count if there's only 1 frame
+759b9d5a cmake: add WEBP_USE_THREAD option
+926ce921 cmake: don't install binaries from extras/
+9c367bc6 WebPAnimDecoderNewInternal: validate bitstream before alloc
+47f64f6e filters_sse2: import Chromium change
+cc3577e9 fuzzer/*: use src/ based include paths
+004d77ff Merge tag 'v1.2.0'
+fedac6cc update ChangeLog (tag: v1.2.0-rc3, tag: v1.2.0)
+170a8712 Fix check_c_source_compiles with pthread.
+ceddb5fc Fix check_c_source_compiles with pthread.
+85995719 disable CombinedShannonEntropy_SSE2 on x86
+289757fe TiffDec: enforce stricter mem/dimension limit on tiles
+8af7436f Merge "{ios,xcframework}build.sh: make min version(s) more visible" into 1.2.0
+e56c3c5b pngdec: raise memory limit if needed
+8696147d pngdec: raise memory limit if needed
+13b8e9fe {ios,xcframework}build.sh: make min version(s) more visible
+a9225410 animdecoder_fuzzer: fix memory leak
+d6c2285d update gradle to 6.1.1
+8df77fb1 animdecoder_fuzzer: fix memory leak
+52ce6333 update NEWS
+28c49820 bump version to 1.2.0
+7363dff2 webp/encode.h: restore WEBP_ENCODER_ABI_VERSION to v1.1.0
+826aafa5 update AUTHORS
+63258823 animdecoder_fuzzer: validate canvas size
+9eb26381 CMake: remove duplicate "include(GNUInstallDirs)"
+2e7bed79 WebPPicture: clarify the ownership of user-owned data.
+cccf5e33 webpmux: add an '-set loop <value>' option
+c9a3f6a1 Merge changes Ie29f9867,I289c54c4
+319f56f1 iosbuild.sh: sync some aspects of xcframeworkbuild.sh
+e8e8db98 add xcframeworkbuild.sh
+ae545534 dsp.h: allow config.h to override MSVC SIMD autodetection
+fef789f3 Merge "cmake: fix per-file assembly flags"
+fc14fc03 Have C encoding predictors use decoding predictors.
+7656f0b3 README,cosmetics: fix a couple typos
+d2e245ea cmake: disable webp.js if WEBP_ENABLE_SIMD=1
+96099a79 cmake: fix per-file assembly flags
+5abb5582 Merge "cmake: fix compilation w/Xcode generator"
+8484a120 cmake: fix compilation w/Xcode generator
+d7bf01c9 Merge changes Ifcae0f38,Iee2d7401
+36c81ff6 WASM-SIMD: port 2 patches from rreverser@'s tree
+988b02ab Merge "Couple of fixes to allow SIMD on Emscripten"
+26faf770 wicdec: fail with animated images
+ab2d08a8 [cd]webp: document lack of animated webp support
+52273943 Couple of fixes to allow SIMD on Emscripten
+8870ba7f Fix skia bug #10952
+4b3c6953 Detect if StoreFrame read more than anmf_payload_size bytes
+17fd4ba8 webp/decode.h,cosmetics: normalize 'flip' comment
+411d3677 remove some unreachable break statements
+3700ffd7 WebPPictureHasTransparency: remove unreachable return
+83604bf3 {animencoder,enc_dec}_fuzzer: convert some abort()s to returns
+eb44119c Merge changes I8ae09473,I678c8b1e
+9f6055fc fuzz_utils.h: rename max() to Max()
+695788e7 fuzz_utils.h: make functions WEBP_INLINE
+906c1fcd make ImgIoUtilReadFile use WebPMalloc instead of malloc
+8cb7e536 rename demux_api_fuzzer.c -> mux_demux_api_fuzzer.c
+443db47d add animdecoder_fuzzer.cc
+36a6eea3 Merge "import fuzzers from oss-fuzz/chromium"
+ec5f12c1 Makefile.vc: remove deprecated /Gm option
+64425a08 picture_tools_enc: fix windows build warning
+bd94090a import fuzzers from oss-fuzz/chromium
+cf847cba use WEBP_DSP_INIT_FUNC for Init{GammaTables*,GetCoeffs}
+55a080e5 Add WebPReplaceTransparentPixels() in dsp
+84739717 GetBackgroundColorGIF: promote to uint32_t before << 24
+def64e92 cwebp: Fix -print_psnr for near_lossless
+cf2f88b3 Add palette and spatial for q >= 75 and -m 5
+f0110bae Add no-color cache configuration to the cruncher
+749a8b99 Better estimate of the cache cost.
+4f9f00cc Use spatial predictors on top of palette no matter what.
+7658c686 Add spatial prediction on top of palette in cruncher.
+133ff0e3 webp_js: force WASM=0 option explicitly
+e3c259a2 Fix integer overflow in EmitFancyRGB.
+b3ff0bde man/{gif2,img2}webp,webpmux: normalize some wording
+f9b30586 fix ABI breakage introduced by 6a0ff358
+1d58dcfc README.webp_js: update note about emscripten version
+44070266 README.webp_js: s/fastcomp/upstream/
+2565fa8f README.webp_js: update cmake command
+47309ef5 webp: WEBP_OFFSET_PTR()
+687ab00e DC{4,8,16}_NEON: replace vmovl w/vaddl
+1b92fe75 DC16_NEON,aarch64: use vaddlv
+53f3d8cf dec_neon,DC8_NEON: use vaddlv instead of movl+vaddv
+27d08240 Fix integer overflow in WebPAnimDecoderGetNext()
+69776e38 Merge "remove call to MBAnalyzeBestIntra4Mode for method >= 5"
+a99078c1 remove call to MBAnalyzeBestIntra4Mode for method >= 5
+22e404cc CMakeLists.txt: fix set(CACHE) argument order
+71690b52 fix MSVC warning
+6a0ff358 Enc: add a qmin / qmax range for quality factor
+0fa56f30 Merge tag 'v1.1.0'
+6cf504d0 PNM decoding: handle max_value != 255
+d7844e97 update ChangeLog (tag: v1.1.0-rc2, tag: v1.1.0, origin/1.1.0)
 7f006436 Makefile.vc: fix webp_quality.exe link
+cf047e83 Makefile.vc: fix webp_quality.exe link
 c074c653 update NEWS
 30f09551 bump version to 1.1.0
 a76694a1 update AUTHORS
diff --git a/src/3rdparty/libwebp/NEWS b/src/3rdparty/libwebp/NEWS
index 46daa09..a691761 100644
--- a/src/3rdparty/libwebp/NEWS
+++ b/src/3rdparty/libwebp/NEWS
@@ -1,3 +1,27 @@
+- 7/20/2021: version 1.2.1
+  This is a binary compatible release.
+  * minor lossless encoder improvements and x86 color conversion speed up
+  * add ARM64 simulator support to xcframeworkbuild.sh (#510)
+  * further security related hardening in libwebp & examples
+    (issues: #497, #508, #518)
+    (chromium: #1196480, #1196773, #1196775, #1196777, #1196778, #1196850)
+    (oss-fuzz: #28658, #28978)
+  * toolchain updates and bug fixes (#498, #501, #502, #504, #505, #506, #509,
+                                     #533)
+  * use more inclusive language within the source (#507)
+
+- 12/23/2020: version 1.2.0
+  * API changes:
+    - libwebp:
+      encode.h: add a qmin / qmax range for quality factor (cwebp adds -qrange)
+  * lossless encoder improvements
+  * SIMD support for Wasm builds
+  * add xcframeworkbuild.sh, supports Mac Catalyst builds
+  * import fuzzers from oss-fuzz & chromium (#409)
+  * webpmux: add an '-set loop <value>' option (#494)
+  * toolchain updates and bug fixes (#449, #463, #470, #475, #477, #478, #479,
+    #488, #491)
+
 - 12/18/2019: version 1.1.0
   * API changes:
     - libwebp:
diff --git a/src/3rdparty/libwebp/README b/src/3rdparty/libwebp/README
index 0592727..54c5175 100644
--- a/src/3rdparty/libwebp/README
+++ b/src/3rdparty/libwebp/README
@@ -4,7 +4,7 @@
           \__\__/\____/\_____/__/ ____  ___
                 / _/ /    \    \ /  _ \/ _/
                /  \_/   / /   \ \   __/  \__
-               \____/____/\_____/_____/____/v1.1.0
+               \____/____/\_____/_____/____/v1.2.1
 
 Description:
 ============
@@ -113,7 +113,7 @@ make install
 
 CMake:
 ------
-With CMake, you can compile libwebp, cwebp, dwebp, gif2web, img2webp, webpinfo
+With CMake, you can compile libwebp, cwebp, dwebp, gif2webp, img2webp, webpinfo
 and the JS bindings.
 
 Prerequisites:
@@ -225,6 +225,7 @@ Usage:
 
 If input size (-s) for an image is not specified, it is
 assumed to be a PNG, JPEG, TIFF or WebP file.
+Note: Animated PNG and WebP files are not supported.
 
 Options:
   -h / -help ............. short help
@@ -254,6 +255,8 @@ Options:
   -partition_limit <int> . limit quality to fit the 512k limit on
                            the first partition (0=no degradation ... 100=full)
   -pass <int> ............ analysis pass number (1..10)
+  -qrange <min> <max> .... specifies the permissible quality range
+                           (default: 0 100)
   -crop <x> <y> <w> <h> .. crop picture with the given rectangle
   -resize <w> <h> ........ resize picture (after any cropping)
   -mt .................... use multi-threading if available
@@ -294,6 +297,7 @@ Experimental Options:
   -af .................... auto-adjust filter strength
   -pre <int> ............. pre-processing filter
 
+
 The main options you might want to try in order to further tune the
 visual quality are:
  -preset
@@ -341,7 +345,9 @@ The full list of options is available using -h:
 > dwebp -h
 Usage: dwebp in_file [options] [-o out_file]
 
-Decodes the WebP image file to PNG format [Default]
+Decodes the WebP image file to PNG format [Default].
+Note: Animated WebP files are not supported.
+
 Use following options to convert into alternate image formats:
   -pam ......... save the raw RGBA samples as a color PAM
   -ppm ......... save the raw RGB samples as a color PPM
@@ -423,7 +429,7 @@ Prerequisites:
 1) OpenGL & OpenGL Utility Toolkit (GLUT)
   Linux:
     $ sudo apt-get install freeglut3-dev mesa-common-dev
-  Mac + XCode:
+  Mac + Xcode:
     - These libraries should be available in the OpenGL / GLUT frameworks.
   Windows:
     http://freeglut.sourceforge.net/index.php#download
@@ -613,7 +619,7 @@ The encoding flow looks like:
   pic.width = width;
   pic.height = height;
   // allocated picture of dimension width x height
-  if (!WebPPictureAllocate(&pic)) {
+  if (!WebPPictureAlloc(&pic)) {
     return 0;   // memory error
   }
   // at this point, 'pic' has been initialized as a container,
diff --git a/src/3rdparty/libwebp/qt_attribution.json b/src/3rdparty/libwebp/qt_attribution.json
index 618c31c..f854c64 100644
--- a/src/3rdparty/libwebp/qt_attribution.json
+++ b/src/3rdparty/libwebp/qt_attribution.json
@@ -6,7 +6,7 @@
 
     "Description": "WebP is a new image format that provides lossless and lossy compression for images on the web.",
     "Homepage": "https://developers.google.com/speed/webp/",
-    "Version": "1.1.0",
+    "Version": "1.2.1",
     "License": "BSD 3-clause \"New\" or \"Revised\" License",
     "LicenseId": "BSD-3-Clause",
     "LicenseFile": "COPYING",
diff --git a/src/3rdparty/libwebp/src/dec/alpha_dec.c b/src/3rdparty/libwebp/src/dec/alpha_dec.c
index bce735b..0b93a30 100644
--- a/src/3rdparty/libwebp/src/dec/alpha_dec.c
+++ b/src/3rdparty/libwebp/src/dec/alpha_dec.c
@@ -183,7 +183,7 @@ const uint8_t* VP8DecompressAlphaRows(VP8Decoder* const dec,
   assert(dec != NULL && io != NULL);
 
   if (row < 0 || num_rows <= 0 || row + num_rows > height) {
-    return NULL;    // sanity check.
+    return NULL;
   }
 
   if (!dec->is_alpha_decoded_) {
diff --git a/src/3rdparty/libwebp/src/dec/buffer_dec.c b/src/3rdparty/libwebp/src/dec/buffer_dec.c
index 3cd94eb..4786cf0 100644
--- a/src/3rdparty/libwebp/src/dec/buffer_dec.c
+++ b/src/3rdparty/libwebp/src/dec/buffer_dec.c
@@ -102,7 +102,7 @@ static VP8StatusCode AllocateBuffer(WebPDecBuffer* const buffer) {
     int stride;
     uint64_t size;
 
-    if ((uint64_t)w * kModeBpp[mode] >= (1ull << 32)) {
+    if ((uint64_t)w * kModeBpp[mode] >= (1ull << 31)) {
       return VP8_STATUS_INVALID_PARAM;
     }
     stride = w * kModeBpp[mode];
@@ -117,7 +117,6 @@ static VP8StatusCode AllocateBuffer(WebPDecBuffer* const buffer) {
     }
     total_size = size + 2 * uv_size + a_size;
 
-    // Security/sanity checks
     output = (uint8_t*)WebPSafeMalloc(total_size, sizeof(*output));
     if (output == NULL) {
       return VP8_STATUS_OUT_OF_MEMORY;
@@ -156,11 +155,11 @@ VP8StatusCode WebPFlipBuffer(WebPDecBuffer* const buffer) {
   }
   if (WebPIsRGBMode(buffer->colorspace)) {
     WebPRGBABuffer* const buf = &buffer->u.RGBA;
-    buf->rgba += (buffer->height - 1) * buf->stride;
+    buf->rgba += (int64_t)(buffer->height - 1) * buf->stride;
     buf->stride = -buf->stride;
   } else {
     WebPYUVABuffer* const buf = &buffer->u.YUVA;
-    const int H = buffer->height;
+    const int64_t H = buffer->height;
     buf->y += (H - 1) * buf->y_stride;
     buf->y_stride = -buf->y_stride;
     buf->u += ((H - 1) >> 1) * buf->u_stride;
@@ -188,8 +187,7 @@ VP8StatusCode WebPAllocateDecBuffer(int width, int height,
       const int ch = options->crop_height;
       const int x = options->crop_left & ~1;
       const int y = options->crop_top & ~1;
-      if (x < 0 || y < 0 || cw <= 0 || ch <= 0 ||
-          x + cw > width || y + ch > height) {
+      if (!WebPCheckCropDimensions(width, height, x, y, cw, ch)) {
         return VP8_STATUS_INVALID_PARAM;   // out of frame boundary.
       }
       width = cw;
diff --git a/src/3rdparty/libwebp/src/dec/frame_dec.c b/src/3rdparty/libwebp/src/dec/frame_dec.c
index 04609a8..91ca1f8 100644
--- a/src/3rdparty/libwebp/src/dec/frame_dec.c
+++ b/src/3rdparty/libwebp/src/dec/frame_dec.c
@@ -705,7 +705,7 @@ static int AllocateMemory(VP8Decoder* const dec) {
                         + cache_size + alpha_size + WEBP_ALIGN_CST;
   uint8_t* mem;
 
-  if (needed != (size_t)needed) return 0;  // check for overflow
+  if (!CheckSizeOverflow(needed)) return 0;  // check for overflow
   if (needed > dec->mem_size_) {
     WebPSafeFree(dec->mem_);
     dec->mem_size_ = 0;
diff --git a/src/3rdparty/libwebp/src/dec/io_dec.c b/src/3rdparty/libwebp/src/dec/io_dec.c
index e603f19..5ef6298 100644
--- a/src/3rdparty/libwebp/src/dec/io_dec.c
+++ b/src/3rdparty/libwebp/src/dec/io_dec.c
@@ -25,21 +25,16 @@
 static int EmitYUV(const VP8Io* const io, WebPDecParams* const p) {
   WebPDecBuffer* output = p->output;
   const WebPYUVABuffer* const buf = &output->u.YUVA;
-  uint8_t* const y_dst = buf->y + io->mb_y * buf->y_stride;
-  uint8_t* const u_dst = buf->u + (io->mb_y >> 1) * buf->u_stride;
-  uint8_t* const v_dst = buf->v + (io->mb_y >> 1) * buf->v_stride;
+  uint8_t* const y_dst = buf->y + (size_t)io->mb_y * buf->y_stride;
+  uint8_t* const u_dst = buf->u + (size_t)(io->mb_y >> 1) * buf->u_stride;
+  uint8_t* const v_dst = buf->v + (size_t)(io->mb_y >> 1) * buf->v_stride;
   const int mb_w = io->mb_w;
   const int mb_h = io->mb_h;
   const int uv_w = (mb_w + 1) / 2;
   const int uv_h = (mb_h + 1) / 2;
-  int j;
-  for (j = 0; j < mb_h; ++j) {
-    memcpy(y_dst + j * buf->y_stride, io->y + j * io->y_stride, mb_w);
-  }
-  for (j = 0; j < uv_h; ++j) {
-    memcpy(u_dst + j * buf->u_stride, io->u + j * io->uv_stride, uv_w);
-    memcpy(v_dst + j * buf->v_stride, io->v + j * io->uv_stride, uv_w);
-  }
+  WebPCopyPlane(io->y, io->y_stride, y_dst, buf->y_stride, mb_w, mb_h);
+  WebPCopyPlane(io->u, io->uv_stride, u_dst, buf->u_stride, uv_w, uv_h);
+  WebPCopyPlane(io->v, io->uv_stride, v_dst, buf->v_stride, uv_w, uv_h);
   return io->mb_h;
 }
 
@@ -47,7 +42,7 @@ static int EmitYUV(const VP8Io* const io, WebPDecParams* const p) {
 static int EmitSampledRGB(const VP8Io* const io, WebPDecParams* const p) {
   WebPDecBuffer* const output = p->output;
   WebPRGBABuffer* const buf = &output->u.RGBA;
-  uint8_t* const dst = buf->rgba + io->mb_y * buf->stride;
+  uint8_t* const dst = buf->rgba + (size_t)io->mb_y * buf->stride;
   WebPSamplerProcessPlane(io->y, io->y_stride,
                           io->u, io->v, io->uv_stride,
                           dst, buf->stride, io->mb_w, io->mb_h,
@@ -62,7 +57,7 @@ static int EmitSampledRGB(const VP8Io* const io, WebPDecParams* const p) {
 static int EmitFancyRGB(const VP8Io* const io, WebPDecParams* const p) {
   int num_lines_out = io->mb_h;   // a priori guess
   const WebPRGBABuffer* const buf = &p->output->u.RGBA;
-  uint8_t* dst = buf->rgba + io->mb_y * buf->stride;
+  uint8_t* dst = buf->rgba + (size_t)io->mb_y * buf->stride;
   WebPUpsampleLinePairFunc upsample = WebPUpsamplers[p->output->colorspace];
   const uint8_t* cur_y = io->y;
   const uint8_t* cur_u = io->u;
@@ -133,7 +128,7 @@ static int EmitAlphaYUV(const VP8Io* const io, WebPDecParams* const p,
   const WebPYUVABuffer* const buf = &p->output->u.YUVA;
   const int mb_w = io->mb_w;
   const int mb_h = io->mb_h;
-  uint8_t* dst = buf->a + io->mb_y * buf->a_stride;
+  uint8_t* dst = buf->a + (size_t)io->mb_y * buf->a_stride;
   int j;
   (void)expected_num_lines_out;
   assert(expected_num_lines_out == mb_h);
@@ -186,7 +181,7 @@ static int EmitAlphaRGB(const VP8Io* const io, WebPDecParams* const p,
         (colorspace == MODE_ARGB || colorspace == MODE_Argb);
     const WebPRGBABuffer* const buf = &p->output->u.RGBA;
     int num_rows;
-    const int start_y = GetAlphaSourceRow(io, &alpha, &num_rows);
+    const size_t start_y = GetAlphaSourceRow(io, &alpha, &num_rows);
     uint8_t* const base_rgba = buf->rgba + start_y * buf->stride;
     uint8_t* const dst = base_rgba + (alpha_first ? 0 : 3);
     const int has_alpha = WebPDispatchAlpha(alpha, io->width, mb_w,
@@ -210,7 +205,7 @@ static int EmitAlphaRGBA4444(const VP8Io* const io, WebPDecParams* const p,
     const WEBP_CSP_MODE colorspace = p->output->colorspace;
     const WebPRGBABuffer* const buf = &p->output->u.RGBA;
     int num_rows;
-    const int start_y = GetAlphaSourceRow(io, &alpha, &num_rows);
+    const size_t start_y = GetAlphaSourceRow(io, &alpha, &num_rows);
     uint8_t* const base_rgba = buf->rgba + start_y * buf->stride;
 #if (WEBP_SWAP_16BIT_CSP == 1)
     uint8_t* alpha_dst = base_rgba;
@@ -276,9 +271,9 @@ static int EmitRescaledYUV(const VP8Io* const io, WebPDecParams* const p) {
 static int EmitRescaledAlphaYUV(const VP8Io* const io, WebPDecParams* const p,
                                 int expected_num_lines_out) {
   const WebPYUVABuffer* const buf = &p->output->u.YUVA;
-  uint8_t* const dst_a = buf->a + p->last_y * buf->a_stride;
+  uint8_t* const dst_a = buf->a + (size_t)p->last_y * buf->a_stride;
   if (io->a != NULL) {
-    uint8_t* const dst_y = buf->y + p->last_y * buf->y_stride;
+    uint8_t* const dst_y = buf->y + (size_t)p->last_y * buf->y_stride;
     const int num_lines_out = Rescale(io->a, io->width, io->mb_h, p->scaler_a);
     assert(expected_num_lines_out == num_lines_out);
     if (num_lines_out > 0) {   // unmultiply the Y
@@ -303,46 +298,57 @@ static int InitYUVRescaler(const VP8Io* const io, WebPDecParams* const p) {
   const int uv_out_height = (out_height + 1) >> 1;
   const int uv_in_width  = (io->mb_w + 1) >> 1;
   const int uv_in_height = (io->mb_h + 1) >> 1;
-  const size_t work_size = 2 * out_width;   // scratch memory for luma rescaler
+  // scratch memory for luma rescaler
+  const size_t work_size = 2 * (size_t)out_width;
   const size_t uv_work_size = 2 * uv_out_width;  // and for each u/v ones
-  size_t tmp_size, rescaler_size;
+  uint64_t total_size;
+  size_t rescaler_size;
   rescaler_t* work;
   WebPRescaler* scalers;
   const int num_rescalers = has_alpha ? 4 : 3;
 
-  tmp_size = (work_size + 2 * uv_work_size) * sizeof(*work);
+  total_size = ((uint64_t)work_size + 2 * uv_work_size) * sizeof(*work);
   if (has_alpha) {
-    tmp_size += work_size * sizeof(*work);
+    total_size += (uint64_t)work_size * sizeof(*work);
   }
   rescaler_size = num_rescalers * sizeof(*p->scaler_y) + WEBP_ALIGN_CST;
+  total_size += rescaler_size;
+  if (!CheckSizeOverflow(total_size)) {
+    return 0;
+  }
 
-  p->memory = WebPSafeMalloc(1ULL, tmp_size + rescaler_size);
+  p->memory = WebPSafeMalloc(1ULL, (size_t)total_size);
   if (p->memory == NULL) {
     return 0;   // memory error
   }
   work = (rescaler_t*)p->memory;
 
-  scalers = (WebPRescaler*)WEBP_ALIGN((const uint8_t*)work + tmp_size);
+  scalers = (WebPRescaler*)WEBP_ALIGN(
+      (const uint8_t*)work + total_size - rescaler_size);
   p->scaler_y = &scalers[0];
   p->scaler_u = &scalers[1];
   p->scaler_v = &scalers[2];
   p->scaler_a = has_alpha ? &scalers[3] : NULL;
 
-  WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h,
-                   buf->y, out_width, out_height, buf->y_stride, 1,
-                   work);
-  WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height,
-                   buf->u, uv_out_width, uv_out_height, buf->u_stride, 1,
-                   work + work_size);
-  WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height,
-                   buf->v, uv_out_width, uv_out_height, buf->v_stride, 1,
-                   work + work_size + uv_work_size);
+  if (!WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h,
+                        buf->y, out_width, out_height, buf->y_stride, 1,
+                        work) ||
+      !WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height,
+                        buf->u, uv_out_width, uv_out_height, buf->u_stride, 1,
+                        work + work_size) ||
+      !WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height,
+                        buf->v, uv_out_width, uv_out_height, buf->v_stride, 1,
+                        work + work_size + uv_work_size)) {
+    return 0;
+  }
   p->emit = EmitRescaledYUV;
 
   if (has_alpha) {
-    WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h,
-                     buf->a, out_width, out_height, buf->a_stride, 1,
-                     work + work_size + 2 * uv_work_size);
+    if (!WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h,
+                          buf->a, out_width, out_height, buf->a_stride, 1,
+                          work + work_size + 2 * uv_work_size)) {
+      return 0;
+    }
     p->emit_alpha = EmitRescaledAlphaYUV;
     WebPInitAlphaProcessing();
   }
@@ -356,7 +362,7 @@ static int ExportRGB(WebPDecParams* const p, int y_pos) {
   const WebPYUV444Converter convert =
       WebPYUV444Converters[p->output->colorspace];
   const WebPRGBABuffer* const buf = &p->output->u.RGBA;
-  uint8_t* dst = buf->rgba + y_pos * buf->stride;
+  uint8_t* dst = buf->rgba + (size_t)y_pos * buf->stride;
   int num_lines_out = 0;
   // For RGB rescaling, because of the YUV420, current scan position
   // U/V can be +1/-1 line from the Y one.  Hence the double test.
@@ -383,15 +389,15 @@ static int EmitRescaledRGB(const VP8Io* const io, WebPDecParams* const p) {
   while (j < mb_h) {
     const int y_lines_in =
         WebPRescalerImport(p->scaler_y, mb_h - j,
-                           io->y + j * io->y_stride, io->y_stride);
+                           io->y + (size_t)j * io->y_stride, io->y_stride);
     j += y_lines_in;
     if (WebPRescaleNeededLines(p->scaler_u, uv_mb_h - uv_j)) {
-      const int u_lines_in =
-          WebPRescalerImport(p->scaler_u, uv_mb_h - uv_j,
-                             io->u + uv_j * io->uv_stride, io->uv_stride);
-      const int v_lines_in =
-          WebPRescalerImport(p->scaler_v, uv_mb_h - uv_j,
-                             io->v + uv_j * io->uv_stride, io->uv_stride);
+      const int u_lines_in = WebPRescalerImport(
+          p->scaler_u, uv_mb_h - uv_j, io->u + (size_t)uv_j * io->uv_stride,
+          io->uv_stride);
+      const int v_lines_in = WebPRescalerImport(
+          p->scaler_v, uv_mb_h - uv_j, io->v + (size_t)uv_j * io->uv_stride,
+          io->uv_stride);
       (void)v_lines_in;   // remove a gcc warning
       assert(u_lines_in == v_lines_in);
       uv_j += u_lines_in;
@@ -403,7 +409,7 @@ static int EmitRescaledRGB(const VP8Io* const io, WebPDecParams* const p) {
 
 static int ExportAlpha(WebPDecParams* const p, int y_pos, int max_lines_out) {
   const WebPRGBABuffer* const buf = &p->output->u.RGBA;
-  uint8_t* const base_rgba = buf->rgba + y_pos * buf->stride;
+  uint8_t* const base_rgba = buf->rgba + (size_t)y_pos * buf->stride;
   const WEBP_CSP_MODE colorspace = p->output->colorspace;
   const int alpha_first =
       (colorspace == MODE_ARGB || colorspace == MODE_Argb);
@@ -431,7 +437,7 @@ static int ExportAlpha(WebPDecParams* const p, int y_pos, int max_lines_out) {
 static int ExportAlphaRGBA4444(WebPDecParams* const p, int y_pos,
                                int max_lines_out) {
   const WebPRGBABuffer* const buf = &p->output->u.RGBA;
-  uint8_t* const base_rgba = buf->rgba + y_pos * buf->stride;
+  uint8_t* const base_rgba = buf->rgba + (size_t)y_pos * buf->stride;
 #if (WEBP_SWAP_16BIT_CSP == 1)
   uint8_t* alpha_dst = base_rgba;
 #else
@@ -470,7 +476,7 @@ static int EmitRescaledAlphaRGB(const VP8Io* const io, WebPDecParams* const p,
     int lines_left = expected_num_out_lines;
     const int y_end = p->last_y + lines_left;
     while (lines_left > 0) {
-      const int row_offset = scaler->src_y - io->mb_y;
+      const int64_t row_offset = (int64_t)scaler->src_y - io->mb_y;
       WebPRescalerImport(scaler, io->mb_h + io->mb_y - scaler->src_y,
                          io->a + row_offset * io->width, io->width);
       lines_left -= p->emit_alpha_row(p, y_end - lines_left, lines_left);
@@ -485,51 +491,58 @@ static int InitRGBRescaler(const VP8Io* const io, WebPDecParams* const p) {
   const int out_height = io->scaled_height;
   const int uv_in_width  = (io->mb_w + 1) >> 1;
   const int uv_in_height = (io->mb_h + 1) >> 1;
-  const size_t work_size = 2 * out_width;   // scratch memory for one rescaler
+  // scratch memory for one rescaler
+  const size_t work_size = 2 * (size_t)out_width;
   rescaler_t* work;  // rescalers work area
   uint8_t* tmp;   // tmp storage for scaled YUV444 samples before RGB conversion
-  size_t tmp_size1, tmp_size2, total_size, rescaler_size;
+  uint64_t tmp_size1, tmp_size2, total_size;
+  size_t rescaler_size;
   WebPRescaler* scalers;
   const int num_rescalers = has_alpha ? 4 : 3;
 
-  tmp_size1 = 3 * work_size;
-  tmp_size2 = 3 * out_width;
-  if (has_alpha) {
-    tmp_size1 += work_size;
-    tmp_size2 += out_width;
-  }
+  tmp_size1 = (uint64_t)num_rescalers * work_size;
+  tmp_size2 = (uint64_t)num_rescalers * out_width;
   total_size = tmp_size1 * sizeof(*work) + tmp_size2 * sizeof(*tmp);
   rescaler_size = num_rescalers * sizeof(*p->scaler_y) + WEBP_ALIGN_CST;
+  total_size += rescaler_size;
+  if (!CheckSizeOverflow(total_size)) {
+    return 0;
+  }
 
-  p->memory = WebPSafeMalloc(1ULL, total_size + rescaler_size);
+  p->memory = WebPSafeMalloc(1ULL, (size_t)total_size);
   if (p->memory == NULL) {
     return 0;   // memory error
   }
   work = (rescaler_t*)p->memory;
   tmp = (uint8_t*)(work + tmp_size1);
 
-  scalers = (WebPRescaler*)WEBP_ALIGN((const uint8_t*)work + total_size);
+  scalers = (WebPRescaler*)WEBP_ALIGN(
+      (const uint8_t*)work + total_size - rescaler_size);
   p->scaler_y = &scalers[0];
   p->scaler_u = &scalers[1];
   p->scaler_v = &scalers[2];
   p->scaler_a = has_alpha ? &scalers[3] : NULL;
 
-  WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h,
-                   tmp + 0 * out_width, out_width, out_height, 0, 1,
-                   work + 0 * work_size);
-  WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height,
-                   tmp + 1 * out_width, out_width, out_height, 0, 1,
-                   work + 1 * work_size);
-  WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height,
-                   tmp + 2 * out_width, out_width, out_height, 0, 1,
-                   work + 2 * work_size);
+  if (!WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h,
+                        tmp + 0 * out_width, out_width, out_height, 0, 1,
+                        work + 0 * work_size) ||
+      !WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height,
+                        tmp + 1 * out_width, out_width, out_height, 0, 1,
+                        work + 1 * work_size) ||
+      !WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height,
+                        tmp + 2 * out_width, out_width, out_height, 0, 1,
+                        work + 2 * work_size)) {
+    return 0;
+  }
   p->emit = EmitRescaledRGB;
   WebPInitYUV444Converters();
 
   if (has_alpha) {
-    WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h,
-                     tmp + 3 * out_width, out_width, out_height, 0, 1,
-                     work + 3 * work_size);
+    if (!WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h,
+                          tmp + 3 * out_width, out_width, out_height, 0, 1,
+                          work + 3 * work_size)) {
+      return 0;
+    }
     p->emit_alpha = EmitRescaledAlphaRGB;
     if (p->output->colorspace == MODE_RGBA_4444 ||
         p->output->colorspace == MODE_rgbA_4444) {
diff --git a/src/3rdparty/libwebp/src/dec/vp8_dec.c b/src/3rdparty/libwebp/src/dec/vp8_dec.c
index 57efb69..5f405e4 100644
--- a/src/3rdparty/libwebp/src/dec/vp8_dec.c
+++ b/src/3rdparty/libwebp/src/dec/vp8_dec.c
@@ -335,7 +335,7 @@ int VP8GetHeaders(VP8Decoder* const dec, VP8Io* const io) {
     io->scaled_width = io->width;
     io->scaled_height = io->height;
 
-    io->mb_w = io->width;   // sanity check
+    io->mb_w = io->width;   // for soundness
     io->mb_h = io->height;  // ditto
 
     VP8ResetProba(&dec->proba_);
@@ -494,13 +494,11 @@ static int GetCoeffsAlt(VP8BitReader* const br,
   return 16;
 }
 
-static WEBP_TSAN_IGNORE_FUNCTION void InitGetCoeffs(void) {
-  if (GetCoeffs == NULL) {
-    if (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kSlowSSSE3)) {
-      GetCoeffs = GetCoeffsAlt;
-    } else {
-      GetCoeffs = GetCoeffsFast;
-    }
+WEBP_DSP_INIT_FUNC(InitGetCoeffs) {
+  if (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kSlowSSSE3)) {
+    GetCoeffs = GetCoeffsAlt;
+  } else {
+    GetCoeffs = GetCoeffsFast;
   }
 }
 
diff --git a/src/3rdparty/libwebp/src/dec/vp8i_dec.h b/src/3rdparty/libwebp/src/dec/vp8i_dec.h
index 600a684..20526a8 100644
--- a/src/3rdparty/libwebp/src/dec/vp8i_dec.h
+++ b/src/3rdparty/libwebp/src/dec/vp8i_dec.h
@@ -31,8 +31,8 @@ extern "C" {
 
 // version numbers
 #define DEC_MAJ_VERSION 1
-#define DEC_MIN_VERSION 1
-#define DEC_REV_VERSION 0
+#define DEC_MIN_VERSION 2
+#define DEC_REV_VERSION 1
 
 // YUV-cache parameters. Cache is 32-bytes wide (= one cacheline).
 // Constraints are: We need to store one 16x16 block of luma samples (y),
diff --git a/src/3rdparty/libwebp/src/dec/vp8l_dec.c b/src/3rdparty/libwebp/src/dec/vp8l_dec.c
index 93615d4..73c3b54 100644
--- a/src/3rdparty/libwebp/src/dec/vp8l_dec.c
+++ b/src/3rdparty/libwebp/src/dec/vp8l_dec.c
@@ -559,8 +559,11 @@ static int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {
   memory += work_size * sizeof(*work);
   scaled_data = (uint32_t*)memory;
 
-  WebPRescalerInit(dec->rescaler, in_width, in_height, (uint8_t*)scaled_data,
-                   out_width, out_height, 0, num_channels, work);
+  if (!WebPRescalerInit(dec->rescaler, in_width, in_height,
+                        (uint8_t*)scaled_data, out_width, out_height,
+                        0, num_channels, work)) {
+    return 0;
+  }
   return 1;
 }
 #endif   // WEBP_REDUCE_SIZE
@@ -574,13 +577,14 @@ static int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {
 static int Export(WebPRescaler* const rescaler, WEBP_CSP_MODE colorspace,
                   int rgba_stride, uint8_t* const rgba) {
   uint32_t* const src = (uint32_t*)rescaler->dst;
+  uint8_t* dst = rgba;
   const int dst_width = rescaler->dst_width;
   int num_lines_out = 0;
   while (WebPRescalerHasPendingOutput(rescaler)) {
-    uint8_t* const dst = rgba + num_lines_out * rgba_stride;
     WebPRescalerExportRow(rescaler);
     WebPMultARGBRow(src, dst_width, 1);
     VP8LConvertFromBGRA(src, dst_width, colorspace, dst);
+    dst += rgba_stride;
     ++num_lines_out;
   }
   return num_lines_out;
@@ -594,8 +598,8 @@ static int EmitRescaledRowsRGBA(const VP8LDecoder* const dec,
   int num_lines_in = 0;
   int num_lines_out = 0;
   while (num_lines_in < mb_h) {
-    uint8_t* const row_in = in + num_lines_in * in_stride;
-    uint8_t* const row_out = out + num_lines_out * out_stride;
+    uint8_t* const row_in = in + (uint64_t)num_lines_in * in_stride;
+    uint8_t* const row_out = out + (uint64_t)num_lines_out * out_stride;
     const int lines_left = mb_h - num_lines_in;
     const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);
     int lines_imported;
@@ -796,7 +800,8 @@ static void ProcessRows(VP8LDecoder* const dec, int row) {
       const WebPDecBuffer* const output = dec->output_;
       if (WebPIsRGBMode(output->colorspace)) {  // convert to RGBA
         const WebPRGBABuffer* const buf = &output->u.RGBA;
-        uint8_t* const rgba = buf->rgba + dec->last_out_row_ * buf->stride;
+        uint8_t* const rgba =
+            buf->rgba + (int64_t)dec->last_out_row_ * buf->stride;
         const int num_rows_out =
 #if !defined(WEBP_REDUCE_SIZE)
          io->use_scaling ?
@@ -947,7 +952,6 @@ static WEBP_INLINE void CopyBlock8b(uint8_t* const dst, int dist, int length) {
         break;
       default:
         goto Copy;
-        break;
     }
     CopySmallPattern8b(src, dst, length, pattern);
     return;
@@ -1515,7 +1519,7 @@ static int AllocateInternalBuffers32b(VP8LDecoder* const dec, int final_width) {
   assert(dec->width_ <= final_width);
   dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint32_t));
   if (dec->pixels_ == NULL) {
-    dec->argb_cache_ = NULL;    // for sanity check
+    dec->argb_cache_ = NULL;    // for soundness
     dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
     return 0;
   }
@@ -1525,7 +1529,7 @@ static int AllocateInternalBuffers32b(VP8LDecoder* const dec, int final_width) {
 
 static int AllocateInternalBuffers8b(VP8LDecoder* const dec) {
   const uint64_t total_num_pixels = (uint64_t)dec->width_ * dec->height_;
-  dec->argb_cache_ = NULL;    // for sanity check
+  dec->argb_cache_ = NULL;    // for soundness
   dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint8_t));
   if (dec->pixels_ == NULL) {
     dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
@@ -1667,7 +1671,6 @@ int VP8LDecodeImage(VP8LDecoder* const dec) {
   VP8Io* io = NULL;
   WebPDecParams* params = NULL;
 
-  // Sanity checks.
   if (dec == NULL) return 0;
 
   assert(dec->hdr_.huffman_tables_ != NULL);
diff --git a/src/3rdparty/libwebp/src/dec/webp_dec.c b/src/3rdparty/libwebp/src/dec/webp_dec.c
index 42d0988..77a54c5 100644
--- a/src/3rdparty/libwebp/src/dec/webp_dec.c
+++ b/src/3rdparty/libwebp/src/dec/webp_dec.c
@@ -785,6 +785,13 @@ VP8StatusCode WebPDecode(const uint8_t* data, size_t data_size,
 //------------------------------------------------------------------------------
 // Cropping and rescaling.
 
+int WebPCheckCropDimensions(int image_width, int image_height,
+                            int x, int y, int w, int h) {
+  return !(x < 0 || y < 0 || w <= 0 || h <= 0 ||
+           x >= image_width || w > image_width || w > image_width - x ||
+           y >= image_height || h > image_height || h > image_height - y);
+}
+
 int WebPIoInitFromOptions(const WebPDecoderOptions* const options,
                           VP8Io* const io, WEBP_CSP_MODE src_colorspace) {
   const int W = io->width;
@@ -792,7 +799,7 @@ int WebPIoInitFromOptions(const WebPDecoderOptions* const options,
   int x = 0, y = 0, w = W, h = H;
 
   // Cropping
-  io->use_cropping = (options != NULL) && (options->use_cropping > 0);
+  io->use_cropping = (options != NULL) && options->use_cropping;
   if (io->use_cropping) {
     w = options->crop_width;
     h = options->crop_height;
@@ -802,7 +809,7 @@ int WebPIoInitFromOptions(const WebPDecoderOptions* const options,
       x &= ~1;
       y &= ~1;
     }
-    if (x < 0 || y < 0 || w <= 0 || h <= 0 || x + w > W || y + h > H) {
+    if (!WebPCheckCropDimensions(W, H, x, y, w, h)) {
       return 0;  // out of frame boundary error
     }
   }
@@ -814,7 +821,7 @@ int WebPIoInitFromOptions(const WebPDecoderOptions* const options,
   io->mb_h = h;
 
   // Scaling
-  io->use_scaling = (options != NULL) && (options->use_scaling > 0);
+  io->use_scaling = (options != NULL) && options->use_scaling;
   if (io->use_scaling) {
     int scaled_width = options->scaled_width;
     int scaled_height = options->scaled_height;
@@ -835,8 +842,8 @@ int WebPIoInitFromOptions(const WebPDecoderOptions* const options,
 
   if (io->use_scaling) {
     // disable filter (only for large downscaling ratio).
-    io->bypass_filtering = (io->scaled_width < W * 3 / 4) &&
-                           (io->scaled_height < H * 3 / 4);
+    io->bypass_filtering |= (io->scaled_width < W * 3 / 4) &&
+                            (io->scaled_height < H * 3 / 4);
     io->fancy_upsampling = 0;
   }
   return 1;
diff --git a/src/3rdparty/libwebp/src/dec/webpi_dec.h b/src/3rdparty/libwebp/src/dec/webpi_dec.h
index 24baff5..3b97388 100644
--- a/src/3rdparty/libwebp/src/dec/webpi_dec.h
+++ b/src/3rdparty/libwebp/src/dec/webpi_dec.h
@@ -77,6 +77,10 @@ VP8StatusCode WebPParseHeaders(WebPHeaderStructure* const headers);
 //------------------------------------------------------------------------------
 // Misc utils
 
+// Returns true if crop dimensions are within image bounds.
+int WebPCheckCropDimensions(int image_width, int image_height,
+                            int x, int y, int w, int h);
+
 // Initializes VP8Io with custom setup, io and teardown functions. The default
 // hooks will use the supplied 'params' as io->opaque handle.
 void WebPInitCustomIo(WebPDecParams* const params, VP8Io* const io);
diff --git a/src/3rdparty/libwebp/src/demux/anim_decode.c b/src/3rdparty/libwebp/src/demux/anim_decode.c
index 05dd707..2bf4dcf 100644
--- a/src/3rdparty/libwebp/src/demux/anim_decode.c
+++ b/src/3rdparty/libwebp/src/demux/anim_decode.c
@@ -87,11 +87,19 @@ WebPAnimDecoder* WebPAnimDecoderNewInternal(
     int abi_version) {
   WebPAnimDecoderOptions options;
   WebPAnimDecoder* dec = NULL;
+  WebPBitstreamFeatures features;
   if (webp_data == NULL ||
       WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_DEMUX_ABI_VERSION)) {
     return NULL;
   }
 
+  // Validate the bitstream before doing expensive allocations. The demuxer may
+  // be more tolerant than the decoder.
+  if (WebPGetFeatures(webp_data->bytes, webp_data->size, &features) !=
+      VP8_STATUS_OK) {
+    return NULL;
+  }
+
   // Note: calloc() so that the pointer members are initialized to NULL.
   dec = (WebPAnimDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
   if (dec == NULL) goto Error;
@@ -145,7 +153,7 @@ static int ZeroFillCanvas(uint8_t* buf, uint32_t canvas_width,
                           uint32_t canvas_height) {
   const uint64_t size =
       (uint64_t)canvas_width * canvas_height * NUM_CHANNELS * sizeof(*buf);
-  if (size != (size_t)size) return 0;
+  if (!CheckSizeOverflow(size)) return 0;
   memset(buf, 0, (size_t)size);
   return 1;
 }
@@ -166,7 +174,7 @@ static void ZeroFillFrameRect(uint8_t* buf, int buf_stride, int x_offset,
 static int CopyCanvas(const uint8_t* src, uint8_t* dst,
                       uint32_t width, uint32_t height) {
   const uint64_t size = (uint64_t)width * height * NUM_CHANNELS;
-  if (size != (size_t)size) return 0;
+  if (!CheckSizeOverflow(size)) return 0;
   assert(src != NULL && dst != NULL);
   memcpy(dst, src, (size_t)size);
   return 1;
@@ -346,12 +354,15 @@ int WebPAnimDecoderGetNext(WebPAnimDecoder* dec,
   {
     const uint8_t* in = iter.fragment.bytes;
     const size_t in_size = iter.fragment.size;
-    const size_t out_offset =
-        (iter.y_offset * width + iter.x_offset) * NUM_CHANNELS;
+    const uint32_t stride = width * NUM_CHANNELS;  // at most 25 + 2 bits
+    const uint64_t out_offset = (uint64_t)iter.y_offset * stride +
+                                (uint64_t)iter.x_offset * NUM_CHANNELS;  // 53b
+    const uint64_t size = (uint64_t)iter.height * stride;  // at most 25 + 27b
     WebPDecoderConfig* const config = &dec->config_;
     WebPRGBABuffer* const buf = &config->output.u.RGBA;
-    buf->stride = NUM_CHANNELS * width;
-    buf->size = buf->stride * iter.height;
+    if ((size_t)size != size) goto Error;
+    buf->stride = (int)stride;
+    buf->size = (size_t)size;
     buf->rgba = dec->curr_frame_ + out_offset;
 
     if (WebPDecode(in, in_size, config) != VP8_STATUS_OK) {
diff --git a/src/3rdparty/libwebp/src/demux/demux.c b/src/3rdparty/libwebp/src/demux/demux.c
index 1b3cc2e..547a772 100644
--- a/src/3rdparty/libwebp/src/demux/demux.c
+++ b/src/3rdparty/libwebp/src/demux/demux.c
@@ -24,8 +24,8 @@
 #include "src/webp/format_constants.h"
 
 #define DMUX_MAJ_VERSION 1
-#define DMUX_MIN_VERSION 1
-#define DMUX_REV_VERSION 0
+#define DMUX_MIN_VERSION 2
+#define DMUX_REV_VERSION 1
 
 typedef struct {
   size_t start_;        // start location of the data
@@ -221,12 +221,16 @@ static ParseStatus StoreFrame(int frame_num, uint32_t min_size,
     const size_t chunk_start_offset = mem->start_;
     const uint32_t fourcc = ReadLE32(mem);
     const uint32_t payload_size = ReadLE32(mem);
-    const uint32_t payload_size_padded = payload_size + (payload_size & 1);
-    const size_t payload_available = (payload_size_padded > MemDataSize(mem))
-                                   ? MemDataSize(mem) : payload_size_padded;
-    const size_t chunk_size = CHUNK_HEADER_SIZE + payload_available;
+    uint32_t payload_size_padded;
+    size_t payload_available;
+    size_t chunk_size;
 
     if (payload_size > MAX_CHUNK_PAYLOAD) return PARSE_ERROR;
+
+    payload_size_padded = payload_size + (payload_size & 1);
+    payload_available = (payload_size_padded > MemDataSize(mem))
+                      ? MemDataSize(mem) : payload_size_padded;
+    chunk_size = CHUNK_HEADER_SIZE + payload_available;
     if (SizeIsInvalid(mem, payload_size_padded)) return PARSE_ERROR;
     if (payload_size_padded > MemDataSize(mem)) status = PARSE_NEED_MORE_DATA;
 
@@ -312,6 +316,7 @@ static ParseStatus ParseAnimationFrame(
   int bits;
   MemBuffer* const mem = &dmux->mem_;
   Frame* frame;
+  size_t start_offset;
   ParseStatus status =
       NewFrame(mem, ANMF_CHUNK_SIZE, frame_chunk_size, &frame);
   if (status != PARSE_OK) return status;
@@ -332,7 +337,11 @@ static ParseStatus ParseAnimationFrame(
 
   // Store a frame only if the animation flag is set there is some data for
   // this frame is available.
+  start_offset = mem->start_;
   status = StoreFrame(dmux->num_frames_ + 1, anmf_payload_size, mem, frame);
+  if (status != PARSE_ERROR && mem->start_ - start_offset > anmf_payload_size) {
+    status = PARSE_ERROR;
+  }
   if (status != PARSE_ERROR && is_animation && frame->frame_num_ > 0) {
     added_frame = AddFrame(dmux, frame);
     if (added_frame) {
@@ -446,9 +455,11 @@ static ParseStatus ParseVP8XChunks(WebPDemuxer* const dmux) {
     const size_t chunk_start_offset = mem->start_;
     const uint32_t fourcc = ReadLE32(mem);
     const uint32_t chunk_size = ReadLE32(mem);
-    const uint32_t chunk_size_padded = chunk_size + (chunk_size & 1);
+    uint32_t chunk_size_padded;
 
     if (chunk_size > MAX_CHUNK_PAYLOAD) return PARSE_ERROR;
+
+    chunk_size_padded = chunk_size + (chunk_size & 1);
     if (SizeIsInvalid(mem, chunk_size_padded)) return PARSE_ERROR;
 
     switch (fourcc) {
diff --git a/src/3rdparty/libwebp/src/dsp/alpha_processing.c b/src/3rdparty/libwebp/src/dsp/alpha_processing.c
index 819d139..1892929 100644
--- a/src/3rdparty/libwebp/src/dsp/alpha_processing.c
+++ b/src/3rdparty/libwebp/src/dsp/alpha_processing.c
@@ -157,7 +157,8 @@ void WebPMultARGBRow_C(uint32_t* const ptr, int width, int inverse) {
   }
 }
 
-void WebPMultRow_C(uint8_t* const ptr, const uint8_t* const alpha,
+void WebPMultRow_C(uint8_t* WEBP_RESTRICT const ptr,
+                   const uint8_t* WEBP_RESTRICT const alpha,
                    int width, int inverse) {
   int x;
   for (x = 0; x < width; ++x) {
@@ -178,7 +179,8 @@ void WebPMultRow_C(uint8_t* const ptr, const uint8_t* const alpha,
 #undef MFIX
 
 void (*WebPMultARGBRow)(uint32_t* const ptr, int width, int inverse);
-void (*WebPMultRow)(uint8_t* const ptr, const uint8_t* const alpha,
+void (*WebPMultRow)(uint8_t* WEBP_RESTRICT const ptr,
+                    const uint8_t* WEBP_RESTRICT const alpha,
                     int width, int inverse);
 
 //------------------------------------------------------------------------------
@@ -193,8 +195,8 @@ void WebPMultARGBRows(uint8_t* ptr, int stride, int width, int num_rows,
   }
 }
 
-void WebPMultRows(uint8_t* ptr, int stride,
-                  const uint8_t* alpha, int alpha_stride,
+void WebPMultRows(uint8_t* WEBP_RESTRICT ptr, int stride,
+                  const uint8_t* WEBP_RESTRICT alpha, int alpha_stride,
                   int width, int num_rows, int inverse) {
   int n;
   for (n = 0; n < num_rows; ++n) {
@@ -290,9 +292,9 @@ static void ApplyAlphaMultiply_16b_C(uint8_t* rgba4444,
 }
 
 #if !WEBP_NEON_OMIT_C_CODE
-static int DispatchAlpha_C(const uint8_t* alpha, int alpha_stride,
+static int DispatchAlpha_C(const uint8_t* WEBP_RESTRICT alpha, int alpha_stride,
                            int width, int height,
-                           uint8_t* dst, int dst_stride) {
+                           uint8_t* WEBP_RESTRICT dst, int dst_stride) {
   uint32_t alpha_mask = 0xff;
   int i, j;
 
@@ -309,9 +311,10 @@ static int DispatchAlpha_C(const uint8_t* alpha, int alpha_stride,
   return (alpha_mask != 0xff);
 }
 
-static void DispatchAlphaToGreen_C(const uint8_t* alpha, int alpha_stride,
-                                   int width, int height,
-                                   uint32_t* dst, int dst_stride) {
+static void DispatchAlphaToGreen_C(const uint8_t* WEBP_RESTRICT alpha,
+                                   int alpha_stride, int width, int height,
+                                   uint32_t* WEBP_RESTRICT dst,
+                                   int dst_stride) {
   int i, j;
   for (j = 0; j < height; ++j) {
     for (i = 0; i < width; ++i) {
@@ -322,9 +325,9 @@ static void DispatchAlphaToGreen_C(const uint8_t* alpha, int alpha_stride,
   }
 }
 
-static int ExtractAlpha_C(const uint8_t* argb, int argb_stride,
+static int ExtractAlpha_C(const uint8_t* WEBP_RESTRICT argb, int argb_stride,
                           int width, int height,
-                          uint8_t* alpha, int alpha_stride) {
+                          uint8_t* WEBP_RESTRICT alpha, int alpha_stride) {
   uint8_t alpha_mask = 0xff;
   int i, j;
 
@@ -340,7 +343,8 @@ static int ExtractAlpha_C(const uint8_t* argb, int argb_stride,
   return (alpha_mask == 0xff);
 }
 
-static void ExtractGreen_C(const uint32_t* argb, uint8_t* alpha, int size) {
+static void ExtractGreen_C(const uint32_t* WEBP_RESTRICT argb,
+                           uint8_t* WEBP_RESTRICT alpha, int size) {
   int i;
   for (i = 0; i < size; ++i) alpha[i] = argb[i] >> 8;
 }
@@ -359,6 +363,11 @@ static int HasAlpha32b_C(const uint8_t* src, int length) {
   return 0;
 }
 
+static void AlphaReplace_C(uint32_t* src, int length, uint32_t color) {
+  int x;
+  for (x = 0; x < length; ++x) if ((src[x] >> 24) == 0) src[x] = color;
+}
+
 //------------------------------------------------------------------------------
 // Simple channel manipulations.
 
@@ -367,8 +376,11 @@ static WEBP_INLINE uint32_t MakeARGB32(int a, int r, int g, int b) {
 }
 
 #ifdef WORDS_BIGENDIAN
-static void PackARGB_C(const uint8_t* a, const uint8_t* r, const uint8_t* g,
-                       const uint8_t* b, int len, uint32_t* out) {
+static void PackARGB_C(const uint8_t* WEBP_RESTRICT a,
+                       const uint8_t* WEBP_RESTRICT r,
+                       const uint8_t* WEBP_RESTRICT g,
+                       const uint8_t* WEBP_RESTRICT b,
+                       int len, uint32_t* WEBP_RESTRICT out) {
   int i;
   for (i = 0; i < len; ++i) {
     out[i] = MakeARGB32(a[4 * i], r[4 * i], g[4 * i], b[4 * i]);
@@ -376,8 +388,10 @@ static void PackARGB_C(const uint8_t* a, const uint8_t* r, const uint8_t* g,
 }
 #endif
 
-static void PackRGB_C(const uint8_t* r, const uint8_t* g, const uint8_t* b,
-                      int len, int step, uint32_t* out) {
+static void PackRGB_C(const uint8_t* WEBP_RESTRICT r,
+                      const uint8_t* WEBP_RESTRICT g,
+                      const uint8_t* WEBP_RESTRICT b,
+                      int len, int step, uint32_t* WEBP_RESTRICT out) {
   int i, offset = 0;
   for (i = 0; i < len; ++i) {
     out[i] = MakeARGB32(0xff, r[offset], g[offset], b[offset]);
@@ -387,19 +401,26 @@ static void PackRGB_C(const uint8_t* r, const uint8_t* g, const uint8_t* b,
 
 void (*WebPApplyAlphaMultiply)(uint8_t*, int, int, int, int);
 void (*WebPApplyAlphaMultiply4444)(uint8_t*, int, int, int);
-int (*WebPDispatchAlpha)(const uint8_t*, int, int, int, uint8_t*, int);
-void (*WebPDispatchAlphaToGreen)(const uint8_t*, int, int, int, uint32_t*, int);
-int (*WebPExtractAlpha)(const uint8_t*, int, int, int, uint8_t*, int);
-void (*WebPExtractGreen)(const uint32_t* argb, uint8_t* alpha, int size);
+int (*WebPDispatchAlpha)(const uint8_t* WEBP_RESTRICT, int, int, int,
+                         uint8_t* WEBP_RESTRICT, int);
+void (*WebPDispatchAlphaToGreen)(const uint8_t* WEBP_RESTRICT, int, int, int,
+                                 uint32_t* WEBP_RESTRICT, int);
+int (*WebPExtractAlpha)(const uint8_t* WEBP_RESTRICT, int, int, int,
+                        uint8_t* WEBP_RESTRICT, int);
+void (*WebPExtractGreen)(const uint32_t* WEBP_RESTRICT argb,
+                         uint8_t* WEBP_RESTRICT alpha, int size);
 #ifdef WORDS_BIGENDIAN
 void (*WebPPackARGB)(const uint8_t* a, const uint8_t* r, const uint8_t* g,
                      const uint8_t* b, int, uint32_t*);
 #endif
-void (*WebPPackRGB)(const uint8_t* r, const uint8_t* g, const uint8_t* b,
-                    int len, int step, uint32_t* out);
+void (*WebPPackRGB)(const uint8_t* WEBP_RESTRICT r,
+                    const uint8_t* WEBP_RESTRICT g,
+                    const uint8_t* WEBP_RESTRICT b,
+                    int len, int step, uint32_t* WEBP_RESTRICT out);
 
 int (*WebPHasAlpha8b)(const uint8_t* src, int length);
 int (*WebPHasAlpha32b)(const uint8_t* src, int length);
+void (*WebPAlphaReplace)(uint32_t* src, int length, uint32_t color);
 
 //------------------------------------------------------------------------------
 // Init function
@@ -428,13 +449,14 @@ WEBP_DSP_INIT_FUNC(WebPInitAlphaProcessing) {
 
   WebPHasAlpha8b = HasAlpha8b_C;
   WebPHasAlpha32b = HasAlpha32b_C;
+  WebPAlphaReplace = AlphaReplace_C;
 
   // If defined, use CPUInfo() to overwrite some pointers with faster versions.
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       WebPInitAlphaProcessingSSE2();
-#if defined(WEBP_USE_SSE41)
+#if defined(WEBP_HAVE_SSE41)
       if (VP8GetCPUInfo(kSSE4_1)) {
         WebPInitAlphaProcessingSSE41();
       }
@@ -448,7 +470,7 @@ WEBP_DSP_INIT_FUNC(WebPInitAlphaProcessing) {
 #endif
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     WebPInitAlphaProcessingNEON();
@@ -469,4 +491,5 @@ WEBP_DSP_INIT_FUNC(WebPInitAlphaProcessing) {
   assert(WebPPackRGB != NULL);
   assert(WebPHasAlpha8b != NULL);
   assert(WebPHasAlpha32b != NULL);
+  assert(WebPAlphaReplace != NULL);
 }
diff --git a/src/3rdparty/libwebp/src/dsp/alpha_processing_neon.c b/src/3rdparty/libwebp/src/dsp/alpha_processing_neon.c
index 9d55421..9e0ace9 100644
--- a/src/3rdparty/libwebp/src/dsp/alpha_processing_neon.c
+++ b/src/3rdparty/libwebp/src/dsp/alpha_processing_neon.c
@@ -80,9 +80,9 @@ static void ApplyAlphaMultiply_NEON(uint8_t* rgba, int alpha_first,
 
 //------------------------------------------------------------------------------
 
-static int DispatchAlpha_NEON(const uint8_t* alpha, int alpha_stride,
-                              int width, int height,
-                              uint8_t* dst, int dst_stride) {
+static int DispatchAlpha_NEON(const uint8_t* WEBP_RESTRICT alpha,
+                              int alpha_stride, int width, int height,
+                              uint8_t* WEBP_RESTRICT dst, int dst_stride) {
   uint32_t alpha_mask = 0xffffffffu;
   uint8x8_t mask8 = vdup_n_u8(0xff);
   uint32_t tmp[2];
@@ -112,9 +112,10 @@ static int DispatchAlpha_NEON(const uint8_t* alpha, int alpha_stride,
   return (alpha_mask != 0xffffffffu);
 }
 
-static void DispatchAlphaToGreen_NEON(const uint8_t* alpha, int alpha_stride,
-                                      int width, int height,
-                                      uint32_t* dst, int dst_stride) {
+static void DispatchAlphaToGreen_NEON(const uint8_t* WEBP_RESTRICT alpha,
+                                      int alpha_stride, int width, int height,
+                                      uint32_t* WEBP_RESTRICT dst,
+                                      int dst_stride) {
   int i, j;
   uint8x8x4_t greens;   // leave A/R/B channels zero'd.
   greens.val[0] = vdup_n_u8(0);
@@ -131,9 +132,9 @@ static void DispatchAlphaToGreen_NEON(const uint8_t* alpha, int alpha_stride,
   }
 }
 
-static int ExtractAlpha_NEON(const uint8_t* argb, int argb_stride,
+static int ExtractAlpha_NEON(const uint8_t* WEBP_RESTRICT argb, int argb_stride,
                              int width, int height,
-                             uint8_t* alpha, int alpha_stride) {
+                             uint8_t* WEBP_RESTRICT alpha, int alpha_stride) {
   uint32_t alpha_mask = 0xffffffffu;
   uint8x8_t mask8 = vdup_n_u8(0xff);
   uint32_t tmp[2];
@@ -161,8 +162,8 @@ static int ExtractAlpha_NEON(const uint8_t* argb, int argb_stride,
   return (alpha_mask == 0xffffffffu);
 }
 
-static void ExtractGreen_NEON(const uint32_t* argb,
-                              uint8_t* alpha, int size) {
+static void ExtractGreen_NEON(const uint32_t* WEBP_RESTRICT argb,
+                              uint8_t* WEBP_RESTRICT alpha, int size) {
   int i;
   for (i = 0; i + 16 <= size; i += 16) {
     const uint8x16x4_t rgbX = vld4q_u8((const uint8_t*)(argb + i));
diff --git a/src/3rdparty/libwebp/src/dsp/alpha_processing_sse2.c b/src/3rdparty/libwebp/src/dsp/alpha_processing_sse2.c
index 2871c56..a5f8c9f 100644
--- a/src/3rdparty/libwebp/src/dsp/alpha_processing_sse2.c
+++ b/src/3rdparty/libwebp/src/dsp/alpha_processing_sse2.c
@@ -18,9 +18,9 @@
 
 //------------------------------------------------------------------------------
 
-static int DispatchAlpha_SSE2(const uint8_t* alpha, int alpha_stride,
-                              int width, int height,
-                              uint8_t* dst, int dst_stride) {
+static int DispatchAlpha_SSE2(const uint8_t* WEBP_RESTRICT alpha,
+                              int alpha_stride, int width, int height,
+                              uint8_t* WEBP_RESTRICT dst, int dst_stride) {
   // alpha_and stores an 'and' operation of all the alpha[] values. The final
   // value is not 0xff if any of the alpha[] is not equal to 0xff.
   uint32_t alpha_and = 0xff;
@@ -72,9 +72,10 @@ static int DispatchAlpha_SSE2(const uint8_t* alpha, int alpha_stride,
   return (alpha_and != 0xff);
 }
 
-static void DispatchAlphaToGreen_SSE2(const uint8_t* alpha, int alpha_stride,
-                                      int width, int height,
-                                      uint32_t* dst, int dst_stride) {
+static void DispatchAlphaToGreen_SSE2(const uint8_t* WEBP_RESTRICT alpha,
+                                      int alpha_stride, int width, int height,
+                                      uint32_t* WEBP_RESTRICT dst,
+                                      int dst_stride) {
   int i, j;
   const __m128i zero = _mm_setzero_si128();
   const int limit = width & ~15;
@@ -98,9 +99,9 @@ static void DispatchAlphaToGreen_SSE2(const uint8_t* alpha, int alpha_stride,
   }
 }
 
-static int ExtractAlpha_SSE2(const uint8_t* argb, int argb_stride,
+static int ExtractAlpha_SSE2(const uint8_t* WEBP_RESTRICT argb, int argb_stride,
                              int width, int height,
-                             uint8_t* alpha, int alpha_stride) {
+                             uint8_t* WEBP_RESTRICT alpha, int alpha_stride) {
   // alpha_and stores an 'and' operation of all the alpha[] values. The final
   // value is not 0xff if any of the alpha[] is not equal to 0xff.
   uint32_t alpha_and = 0xff;
@@ -265,6 +266,27 @@ static int HasAlpha32b_SSE2(const uint8_t* src, int length) {
   return 0;
 }
 
+static void AlphaReplace_SSE2(uint32_t* src, int length, uint32_t color) {
+  const __m128i m_color = _mm_set1_epi32(color);
+  const __m128i zero = _mm_setzero_si128();
+  int i = 0;
+  for (; i + 8 <= length; i += 8) {
+    const __m128i a0 = _mm_loadu_si128((const __m128i*)(src + i + 0));
+    const __m128i a1 = _mm_loadu_si128((const __m128i*)(src + i + 4));
+    const __m128i b0 = _mm_srai_epi32(a0, 24);
+    const __m128i b1 = _mm_srai_epi32(a1, 24);
+    const __m128i c0 = _mm_cmpeq_epi32(b0, zero);
+    const __m128i c1 = _mm_cmpeq_epi32(b1, zero);
+    const __m128i d0 = _mm_and_si128(c0, m_color);
+    const __m128i d1 = _mm_and_si128(c1, m_color);
+    const __m128i e0 = _mm_andnot_si128(c0, a0);
+    const __m128i e1 = _mm_andnot_si128(c1, a1);
+    _mm_storeu_si128((__m128i*)(src + i + 0), _mm_or_si128(d0, e0));
+    _mm_storeu_si128((__m128i*)(src + i + 4), _mm_or_si128(d1, e1));
+  }
+  for (; i < length; ++i) if ((src[i] >> 24) == 0) src[i] = color;
+}
+
 // -----------------------------------------------------------------------------
 // Apply alpha value to rows
 
@@ -296,7 +318,8 @@ static void MultARGBRow_SSE2(uint32_t* const ptr, int width, int inverse) {
   if (width > 0) WebPMultARGBRow_C(ptr + x, width, inverse);
 }
 
-static void MultRow_SSE2(uint8_t* const ptr, const uint8_t* const alpha,
+static void MultRow_SSE2(uint8_t* WEBP_RESTRICT const ptr,
+                         const uint8_t* WEBP_RESTRICT const alpha,
                          int width, int inverse) {
   int x = 0;
   if (!inverse) {
@@ -334,6 +357,7 @@ WEBP_TSAN_IGNORE_FUNCTION void WebPInitAlphaProcessingSSE2(void) {
 
   WebPHasAlpha8b = HasAlpha8b_SSE2;
   WebPHasAlpha32b = HasAlpha32b_SSE2;
+  WebPAlphaReplace = AlphaReplace_SSE2;
 }
 
 #else  // !WEBP_USE_SSE2
diff --git a/src/3rdparty/libwebp/src/dsp/alpha_processing_sse41.c b/src/3rdparty/libwebp/src/dsp/alpha_processing_sse41.c
index 56040f9..cdf877c 100644
--- a/src/3rdparty/libwebp/src/dsp/alpha_processing_sse41.c
+++ b/src/3rdparty/libwebp/src/dsp/alpha_processing_sse41.c
@@ -19,9 +19,9 @@
 
 //------------------------------------------------------------------------------
 
-static int ExtractAlpha_SSE41(const uint8_t* argb, int argb_stride,
-                              int width, int height,
-                              uint8_t* alpha, int alpha_stride) {
+static int ExtractAlpha_SSE41(const uint8_t* WEBP_RESTRICT argb,
+                              int argb_stride, int width, int height,
+                              uint8_t* WEBP_RESTRICT alpha, int alpha_stride) {
   // alpha_and stores an 'and' operation of all the alpha[] values. The final
   // value is not 0xff if any of the alpha[] is not equal to 0xff.
   uint32_t alpha_and = 0xff;
diff --git a/src/3rdparty/libwebp/src/dsp/cost.c b/src/3rdparty/libwebp/src/dsp/cost.c
index cc681cd..460ec4f 100644
--- a/src/3rdparty/libwebp/src/dsp/cost.c
+++ b/src/3rdparty/libwebp/src/dsp/cost.c
@@ -395,12 +395,12 @@ WEBP_DSP_INIT_FUNC(VP8EncDspCostInit) {
       VP8EncDspCostInitMIPSdspR2();
     }
 #endif
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       VP8EncDspCostInitSSE2();
     }
 #endif
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
     if (VP8GetCPUInfo(kNEON)) {
       VP8EncDspCostInitNEON();
     }
diff --git a/src/3rdparty/libwebp/src/dsp/cpu.c b/src/3rdparty/libwebp/src/dsp/cpu.c
index 0fa5b6a..3145e19 100644
--- a/src/3rdparty/libwebp/src/dsp/cpu.c
+++ b/src/3rdparty/libwebp/src/dsp/cpu.c
@@ -55,12 +55,18 @@ static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
     : "=a"(cpu_info[0]), "=b"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
     : "a"(info_type), "c"(0));
 }
-#elif (defined(_M_X64) || defined(_M_IX86)) && \
-      defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 150030729  // >= VS2008 SP1
+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))
+
+#if defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 150030729  // >= VS2008 SP1
 #include <intrin.h>
 #define GetCPUInfo(info, type) __cpuidex(info, type, 0)  // set ecx=0
-#elif defined(WEBP_MSC_SSE2)
+#define WEBP_HAVE_MSC_CPUID
+#elif _MSC_VER > 1310
+#include <intrin.h>
 #define GetCPUInfo __cpuid
+#define WEBP_HAVE_MSC_CPUID
+#endif
+
 #endif
 
 // NaCl has no support for xgetbv or the raw opcode.
@@ -94,7 +100,7 @@ static WEBP_INLINE uint64_t xgetbv(void) {
 #define xgetbv() 0U  // no AVX for older x64 or unrecognized toolchains.
 #endif
 
-#if defined(__i386__) || defined(__x86_64__) || defined(WEBP_MSC_SSE2)
+#if defined(__i386__) || defined(__x86_64__) || defined(WEBP_HAVE_MSC_CPUID)
 
 // helper function for run-time detection of slow SSSE3 platforms
 static int CheckSlowModel(int info) {
@@ -179,9 +185,34 @@ static int AndroidCPUInfo(CPUFeature feature) {
   return 0;
 }
 VP8CPUInfo VP8GetCPUInfo = AndroidCPUInfo;
-#elif defined(WEBP_USE_NEON)
-// define a dummy function to enable turning off NEON at runtime by setting
-// VP8DecGetCPUInfo = NULL
+#elif defined(EMSCRIPTEN) // also needs to be before generic NEON test
+// Use compile flags as an indicator of SIMD support instead of a runtime check.
+static int wasmCPUInfo(CPUFeature feature) {
+  switch (feature) {
+#ifdef WEBP_HAVE_SSE2
+    case kSSE2:
+      return 1;
+#endif
+#ifdef WEBP_HAVE_SSE41
+    case kSSE3:
+    case kSlowSSSE3:
+    case kSSE4_1:
+      return 1;
+#endif
+#ifdef WEBP_HAVE_NEON
+    case kNEON:
+      return 1;
+#endif
+    default:
+      break;
+  }
+  return 0;
+}
+VP8CPUInfo VP8GetCPUInfo = wasmCPUInfo;
+#elif defined(WEBP_HAVE_NEON)
+// In most cases this function doesn't check for NEON support (it's assumed by
+// the configuration), but enables turning off NEON at runtime, for testing
+// purposes, by setting VP8DecGetCPUInfo = NULL.
 static int armCPUInfo(CPUFeature feature) {
   if (feature != kNEON) return 0;
 #if defined(__linux__) && defined(WEBP_HAVE_NEON_RTCD)
diff --git a/src/3rdparty/libwebp/src/dsp/dec.c b/src/3rdparty/libwebp/src/dsp/dec.c
index 1119842..537c701 100644
--- a/src/3rdparty/libwebp/src/dsp/dec.c
+++ b/src/3rdparty/libwebp/src/dsp/dec.c
@@ -807,10 +807,10 @@ WEBP_DSP_INIT_FUNC(VP8DspInit) {
 
   // If defined, use CPUInfo() to overwrite some pointers with faster versions.
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       VP8DspInitSSE2();
-#if defined(WEBP_USE_SSE41)
+#if defined(WEBP_HAVE_SSE41)
       if (VP8GetCPUInfo(kSSE4_1)) {
         VP8DspInitSSE41();
       }
@@ -834,7 +834,7 @@ WEBP_DSP_INIT_FUNC(VP8DspInit) {
 #endif
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     VP8DspInitNEON();
diff --git a/src/3rdparty/libwebp/src/dsp/dec_neon.c b/src/3rdparty/libwebp/src/dsp/dec_neon.c
index 239ec41..fa85170 100644
--- a/src/3rdparty/libwebp/src/dsp/dec_neon.c
+++ b/src/3rdparty/libwebp/src/dsp/dec_neon.c
@@ -1283,12 +1283,12 @@ static void DC4_NEON(uint8_t* dst) {    // DC
   const uint8x8_t A = vld1_u8(dst - BPS);  // top row
   const uint16x4_t p0 = vpaddl_u8(A);  // cascading summation of the top
   const uint16x4_t p1 = vpadd_u16(p0, p0);
-  const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + 0 * BPS - 1));
-  const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + 1 * BPS - 1));
-  const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + 2 * BPS - 1));
-  const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + 3 * BPS - 1));
-  const uint16x8_t s0 = vaddq_u16(L0, L1);
-  const uint16x8_t s1 = vaddq_u16(L2, L3);
+  const uint8x8_t L0 = vld1_u8(dst + 0 * BPS - 1);
+  const uint8x8_t L1 = vld1_u8(dst + 1 * BPS - 1);
+  const uint8x8_t L2 = vld1_u8(dst + 2 * BPS - 1);
+  const uint8x8_t L3 = vld1_u8(dst + 3 * BPS - 1);
+  const uint16x8_t s0 = vaddl_u8(L0, L1);
+  const uint16x8_t s1 = vaddl_u8(L2, L3);
   const uint16x8_t s01 = vaddq_u16(s0, s1);
   const uint16x8_t sum = vaddq_u16(s01, vcombine_u16(p1, p1));
   const uint8x8_t dc0 = vrshrn_n_u16(sum, 3);  // (sum + 4) >> 3
@@ -1429,8 +1429,7 @@ static WEBP_INLINE void DC8_NEON(uint8_t* dst, int do_top, int do_left) {
   if (do_top) {
     const uint8x8_t A = vld1_u8(dst - BPS);  // top row
 #if defined(__aarch64__)
-    const uint16x8_t B = vmovl_u8(A);
-    const uint16_t p2 = vaddvq_u16(B);
+    const uint16_t p2 = vaddlv_u8(A);
     sum_top = vdupq_n_u16(p2);
 #else
     const uint16x4_t p0 = vpaddl_u8(A);  // cascading summation of the top
@@ -1441,18 +1440,18 @@ static WEBP_INLINE void DC8_NEON(uint8_t* dst, int do_top, int do_left) {
   }
 
   if (do_left) {
-    const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + 0 * BPS - 1));
-    const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + 1 * BPS - 1));
-    const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + 2 * BPS - 1));
-    const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + 3 * BPS - 1));
-    const uint16x8_t L4 = vmovl_u8(vld1_u8(dst + 4 * BPS - 1));
-    const uint16x8_t L5 = vmovl_u8(vld1_u8(dst + 5 * BPS - 1));
-    const uint16x8_t L6 = vmovl_u8(vld1_u8(dst + 6 * BPS - 1));
-    const uint16x8_t L7 = vmovl_u8(vld1_u8(dst + 7 * BPS - 1));
-    const uint16x8_t s0 = vaddq_u16(L0, L1);
-    const uint16x8_t s1 = vaddq_u16(L2, L3);
-    const uint16x8_t s2 = vaddq_u16(L4, L5);
-    const uint16x8_t s3 = vaddq_u16(L6, L7);
+    const uint8x8_t L0 = vld1_u8(dst + 0 * BPS - 1);
+    const uint8x8_t L1 = vld1_u8(dst + 1 * BPS - 1);
+    const uint8x8_t L2 = vld1_u8(dst + 2 * BPS - 1);
+    const uint8x8_t L3 = vld1_u8(dst + 3 * BPS - 1);
+    const uint8x8_t L4 = vld1_u8(dst + 4 * BPS - 1);
+    const uint8x8_t L5 = vld1_u8(dst + 5 * BPS - 1);
+    const uint8x8_t L6 = vld1_u8(dst + 6 * BPS - 1);
+    const uint8x8_t L7 = vld1_u8(dst + 7 * BPS - 1);
+    const uint16x8_t s0 = vaddl_u8(L0, L1);
+    const uint16x8_t s1 = vaddl_u8(L2, L3);
+    const uint16x8_t s2 = vaddl_u8(L4, L5);
+    const uint16x8_t s3 = vaddl_u8(L6, L7);
     const uint16x8_t s01 = vaddq_u16(s0, s1);
     const uint16x8_t s23 = vaddq_u16(s2, s3);
     sum_left = vaddq_u16(s01, s23);
@@ -1512,29 +1511,34 @@ static WEBP_INLINE void DC16_NEON(uint8_t* dst, int do_top, int do_left) {
 
   if (do_top) {
     const uint8x16_t A = vld1q_u8(dst - BPS);  // top row
+#if defined(__aarch64__)
+    const uint16_t p3 = vaddlvq_u8(A);
+    sum_top = vdupq_n_u16(p3);
+#else
     const uint16x8_t p0 = vpaddlq_u8(A);  // cascading summation of the top
     const uint16x4_t p1 = vadd_u16(vget_low_u16(p0), vget_high_u16(p0));
     const uint16x4_t p2 = vpadd_u16(p1, p1);
     const uint16x4_t p3 = vpadd_u16(p2, p2);
     sum_top = vcombine_u16(p3, p3);
+#endif
   }
 
   if (do_left) {
     int i;
     sum_left = vdupq_n_u16(0);
     for (i = 0; i < 16; i += 8) {
-      const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + (i + 0) * BPS - 1));
-      const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + (i + 1) * BPS - 1));
-      const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + (i + 2) * BPS - 1));
-      const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + (i + 3) * BPS - 1));
-      const uint16x8_t L4 = vmovl_u8(vld1_u8(dst + (i + 4) * BPS - 1));
-      const uint16x8_t L5 = vmovl_u8(vld1_u8(dst + (i + 5) * BPS - 1));
-      const uint16x8_t L6 = vmovl_u8(vld1_u8(dst + (i + 6) * BPS - 1));
-      const uint16x8_t L7 = vmovl_u8(vld1_u8(dst + (i + 7) * BPS - 1));
-      const uint16x8_t s0 = vaddq_u16(L0, L1);
-      const uint16x8_t s1 = vaddq_u16(L2, L3);
-      const uint16x8_t s2 = vaddq_u16(L4, L5);
-      const uint16x8_t s3 = vaddq_u16(L6, L7);
+      const uint8x8_t L0 = vld1_u8(dst + (i + 0) * BPS - 1);
+      const uint8x8_t L1 = vld1_u8(dst + (i + 1) * BPS - 1);
+      const uint8x8_t L2 = vld1_u8(dst + (i + 2) * BPS - 1);
+      const uint8x8_t L3 = vld1_u8(dst + (i + 3) * BPS - 1);
+      const uint8x8_t L4 = vld1_u8(dst + (i + 4) * BPS - 1);
+      const uint8x8_t L5 = vld1_u8(dst + (i + 5) * BPS - 1);
+      const uint8x8_t L6 = vld1_u8(dst + (i + 6) * BPS - 1);
+      const uint8x8_t L7 = vld1_u8(dst + (i + 7) * BPS - 1);
+      const uint16x8_t s0 = vaddl_u8(L0, L1);
+      const uint16x8_t s1 = vaddl_u8(L2, L3);
+      const uint16x8_t s2 = vaddl_u8(L4, L5);
+      const uint16x8_t s3 = vaddl_u8(L6, L7);
       const uint16x8_t s01 = vaddq_u16(s0, s1);
       const uint16x8_t s23 = vaddq_u16(s2, s3);
       const uint16x8_t sum = vaddq_u16(s01, s23);
diff --git a/src/3rdparty/libwebp/src/dsp/dsp.h b/src/3rdparty/libwebp/src/dsp/dsp.h
index 7c75b26..35085e0 100644
--- a/src/3rdparty/libwebp/src/dsp/dsp.h
+++ b/src/3rdparty/libwebp/src/dsp/dsp.h
@@ -26,6 +26,23 @@ extern "C" {
 
 #define BPS 32   // this is the common stride for enc/dec
 
+//------------------------------------------------------------------------------
+// WEBP_RESTRICT
+
+// Declares a pointer with the restrict type qualifier if available.
+// This allows code to hint to the compiler that only this pointer references a
+// particular object or memory region within the scope of the block in which it
+// is declared. This may allow for improved optimizations due to the lack of
+// pointer aliasing. See also:
+// https://en.cppreference.com/w/c/language/restrict
+#if defined(__GNUC__)
+#define WEBP_RESTRICT __restrict__
+#elif defined(_MSC_VER)
+#define WEBP_RESTRICT __restrict
+#else
+#define WEBP_RESTRICT
+#endif
+
 //------------------------------------------------------------------------------
 // CPU detection
 
@@ -51,9 +68,7 @@ extern "C" {
 # define __has_builtin(x) 0
 #endif
 
-// for now, none of the optimizations below are available in emscripten
-#if !defined(EMSCRIPTEN)
-
+#if !defined(HAVE_CONFIG_H)
 #if defined(_MSC_VER) && _MSC_VER > 1310 && \
     (defined(_M_X64) || defined(_M_IX86)) && !defined(__clang__)
 #define WEBP_MSC_SSE2  // Visual C++ SSE2 targets
@@ -63,23 +78,37 @@ extern "C" {
     (defined(_M_X64) || defined(_M_IX86)) && !defined(__clang__)
 #define WEBP_MSC_SSE41  // Visual C++ SSE4.1 targets
 #endif
+#endif
 
 // WEBP_HAVE_* are used to indicate the presence of the instruction set in dsp
 // files without intrinsics, allowing the corresponding Init() to be called.
 // Files containing intrinsics will need to be built targeting the instruction
 // set so should succeed on one of the earlier tests.
-#if defined(__SSE2__) || defined(WEBP_MSC_SSE2) || defined(WEBP_HAVE_SSE2)
+#if (defined(__SSE2__) || defined(WEBP_MSC_SSE2)) && \
+    (!defined(HAVE_CONFIG_H) || defined(WEBP_HAVE_SSE2))
 #define WEBP_USE_SSE2
 #endif
 
-#if defined(__SSE4_1__) || defined(WEBP_MSC_SSE41) || defined(WEBP_HAVE_SSE41)
+#if defined(WEBP_USE_SSE2) && !defined(WEBP_HAVE_SSE2)
+#define WEBP_HAVE_SSE2
+#endif
+
+#if (defined(__SSE4_1__) || defined(WEBP_MSC_SSE41)) && \
+    (!defined(HAVE_CONFIG_H) || defined(WEBP_HAVE_SSE41))
 #define WEBP_USE_SSE41
 #endif
 
+#if defined(WEBP_USE_SSE41) && !defined(WEBP_HAVE_SSE41)
+#define WEBP_HAVE_SSE41
+#endif
+
+#undef WEBP_MSC_SSE41
+#undef WEBP_MSC_SSE2
+
 // The intrinsics currently cause compiler errors with arm-nacl-gcc and the
 // inline assembly would need to be modified for use with Native Client.
-#if (defined(__ARM_NEON__) || \
-     defined(__aarch64__) || defined(WEBP_HAVE_NEON)) && \
+#if ((defined(__ARM_NEON__) || defined(__aarch64__)) && \
+     (!defined(HAVE_CONFIG_H) || defined(WEBP_HAVE_NEON))) && \
     !defined(__native_client__)
 #define WEBP_USE_NEON
 #endif
@@ -95,6 +124,10 @@ extern "C" {
 #define WEBP_USE_INTRINSICS
 #endif
 
+#if defined(WEBP_USE_NEON) && !defined(WEBP_HAVE_NEON)
+#define WEBP_HAVE_NEON
+#endif
+
 #if defined(__mips__) && !defined(__mips64) && \
     defined(__mips_isa_rev) && (__mips_isa_rev >= 1) && (__mips_isa_rev < 6)
 #define WEBP_USE_MIPS32
@@ -110,13 +143,11 @@ extern "C" {
 #define WEBP_USE_MSA
 #endif
 
-#endif  /* EMSCRIPTEN */
-
 #ifndef WEBP_DSP_OMIT_C_CODE
 #define WEBP_DSP_OMIT_C_CODE 1
 #endif
 
-#if (defined(__aarch64__) || defined(__ARM_NEON__)) && WEBP_DSP_OMIT_C_CODE
+#if defined(WEBP_USE_NEON) && WEBP_DSP_OMIT_C_CODE
 #define WEBP_NEON_OMIT_C_CODE 1
 #else
 #define WEBP_NEON_OMIT_C_CODE 0
@@ -193,6 +224,12 @@ extern "C" {
 #endif
 #endif
 
+// If 'ptr' is NULL, returns NULL. Otherwise returns 'ptr + off'.
+// Prevents undefined behavior sanitizer nullptr-with-nonzero-offset warning.
+#if !defined(WEBP_OFFSET_PTR)
+#define WEBP_OFFSET_PTR(ptr, off) (((ptr) == NULL) ? NULL : ((ptr) + (off)))
+#endif
+
 // Regularize the definition of WEBP_SWAP_16BIT_CSP (backward compatibility)
 #if !defined(WEBP_SWAP_16BIT_CSP)
 #define WEBP_SWAP_16BIT_CSP 0
@@ -572,26 +609,29 @@ extern void (*WebPApplyAlphaMultiply4444)(
 
 // Dispatch the values from alpha[] plane to the ARGB destination 'dst'.
 // Returns true if alpha[] plane has non-trivial values different from 0xff.
-extern int (*WebPDispatchAlpha)(const uint8_t* alpha, int alpha_stride,
-                                int width, int height,
-                                uint8_t* dst, int dst_stride);
+extern int (*WebPDispatchAlpha)(const uint8_t* WEBP_RESTRICT alpha,
+                                int alpha_stride, int width, int height,
+                                uint8_t* WEBP_RESTRICT dst, int dst_stride);
 
 // Transfer packed 8b alpha[] values to green channel in dst[], zero'ing the
 // A/R/B values. 'dst_stride' is the stride for dst[] in uint32_t units.
-extern void (*WebPDispatchAlphaToGreen)(const uint8_t* alpha, int alpha_stride,
-                                        int width, int height,
-                                        uint32_t* dst, int dst_stride);
+extern void (*WebPDispatchAlphaToGreen)(const uint8_t* WEBP_RESTRICT alpha,
+                                        int alpha_stride, int width, int height,
+                                        uint32_t* WEBP_RESTRICT dst,
+                                        int dst_stride);
 
 // Extract the alpha values from 32b values in argb[] and pack them into alpha[]
 // (this is the opposite of WebPDispatchAlpha).
 // Returns true if there's only trivial 0xff alpha values.
-extern int (*WebPExtractAlpha)(const uint8_t* argb, int argb_stride,
-                               int width, int height,
-                               uint8_t* alpha, int alpha_stride);
+extern int (*WebPExtractAlpha)(const uint8_t* WEBP_RESTRICT argb,
+                               int argb_stride, int width, int height,
+                               uint8_t* WEBP_RESTRICT alpha,
+                               int alpha_stride);
 
 // Extract the green values from 32b values in argb[] and pack them into alpha[]
 // (this is the opposite of WebPDispatchAlphaToGreen).
-extern void (*WebPExtractGreen)(const uint32_t* argb, uint8_t* alpha, int size);
+extern void (*WebPExtractGreen)(const uint32_t* WEBP_RESTRICT argb,
+                                uint8_t* WEBP_RESTRICT alpha, int size);
 
 // Pre-Multiply operation transforms x into x * A / 255  (where x=Y,R,G or B).
 // Un-Multiply operation transforms x into x * 255 / A.
@@ -604,34 +644,42 @@ void WebPMultARGBRows(uint8_t* ptr, int stride, int width, int num_rows,
                       int inverse);
 
 // Same for a row of single values, with side alpha values.
-extern void (*WebPMultRow)(uint8_t* const ptr, const uint8_t* const alpha,
+extern void (*WebPMultRow)(uint8_t* WEBP_RESTRICT const ptr,
+                           const uint8_t* WEBP_RESTRICT const alpha,
                            int width, int inverse);
 
 // Same a WebPMultRow(), but for several 'num_rows' rows.
-void WebPMultRows(uint8_t* ptr, int stride,
-                  const uint8_t* alpha, int alpha_stride,
+void WebPMultRows(uint8_t* WEBP_RESTRICT ptr, int stride,
+                  const uint8_t* WEBP_RESTRICT alpha, int alpha_stride,
                   int width, int num_rows, int inverse);
 
 // Plain-C versions, used as fallback by some implementations.
-void WebPMultRow_C(uint8_t* const ptr, const uint8_t* const alpha,
+void WebPMultRow_C(uint8_t* WEBP_RESTRICT const ptr,
+                   const uint8_t* WEBP_RESTRICT const alpha,
                    int width, int inverse);
 void WebPMultARGBRow_C(uint32_t* const ptr, int width, int inverse);
 
 #ifdef WORDS_BIGENDIAN
 // ARGB packing function: a/r/g/b input is rgba or bgra order.
-extern void (*WebPPackARGB)(const uint8_t* a, const uint8_t* r,
-                            const uint8_t* g, const uint8_t* b, int len,
-                            uint32_t* out);
+extern void (*WebPPackARGB)(const uint8_t* WEBP_RESTRICT a,
+                            const uint8_t* WEBP_RESTRICT r,
+                            const uint8_t* WEBP_RESTRICT g,
+                            const uint8_t* WEBP_RESTRICT b,
+                            int len, uint32_t* WEBP_RESTRICT out);
 #endif
 
 // RGB packing function. 'step' can be 3 or 4. r/g/b input is rgb or bgr order.
-extern void (*WebPPackRGB)(const uint8_t* r, const uint8_t* g, const uint8_t* b,
-                           int len, int step, uint32_t* out);
+extern void (*WebPPackRGB)(const uint8_t* WEBP_RESTRICT r,
+                           const uint8_t* WEBP_RESTRICT g,
+                           const uint8_t* WEBP_RESTRICT b,
+                           int len, int step, uint32_t* WEBP_RESTRICT out);
 
 // This function returns true if src[i] contains a value different from 0xff.
 extern int (*WebPHasAlpha8b)(const uint8_t* src, int length);
 // This function returns true if src[4*i] contains a value different from 0xff.
 extern int (*WebPHasAlpha32b)(const uint8_t* src, int length);
+// replaces transparent values in src[] by 'color'.
+extern void (*WebPAlphaReplace)(uint32_t* src, int length, uint32_t color);
 
 // To be called first before using the above.
 void WebPInitAlphaProcessing(void);
diff --git a/src/3rdparty/libwebp/src/dsp/enc.c b/src/3rdparty/libwebp/src/dsp/enc.c
index 2fddbc4..ea47a3f 100644
--- a/src/3rdparty/libwebp/src/dsp/enc.c
+++ b/src/3rdparty/libwebp/src/dsp/enc.c
@@ -773,10 +773,10 @@ WEBP_DSP_INIT_FUNC(VP8EncDspInit) {
 
   // If defined, use CPUInfo() to overwrite some pointers with faster versions.
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       VP8EncDspInitSSE2();
-#if defined(WEBP_USE_SSE41)
+#if defined(WEBP_HAVE_SSE41)
       if (VP8GetCPUInfo(kSSE4_1)) {
         VP8EncDspInitSSE41();
       }
@@ -800,7 +800,7 @@ WEBP_DSP_INIT_FUNC(VP8EncDspInit) {
 #endif
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     VP8EncDspInitNEON();
diff --git a/src/3rdparty/libwebp/src/dsp/filters.c b/src/3rdparty/libwebp/src/dsp/filters.c
index 9e910d9..4506567 100644
--- a/src/3rdparty/libwebp/src/dsp/filters.c
+++ b/src/3rdparty/libwebp/src/dsp/filters.c
@@ -254,7 +254,7 @@ WEBP_DSP_INIT_FUNC(VP8FiltersInit) {
 #endif
 
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       VP8FiltersInitSSE2();
     }
@@ -271,7 +271,7 @@ WEBP_DSP_INIT_FUNC(VP8FiltersInit) {
 #endif
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     VP8FiltersInitNEON();
diff --git a/src/3rdparty/libwebp/src/dsp/filters_sse2.c b/src/3rdparty/libwebp/src/dsp/filters_sse2.c
index 4b3f2d0..5c33ec1 100644
--- a/src/3rdparty/libwebp/src/dsp/filters_sse2.c
+++ b/src/3rdparty/libwebp/src/dsp/filters_sse2.c
@@ -320,7 +320,12 @@ extern void VP8FiltersInitSSE2(void);
 
 WEBP_TSAN_IGNORE_FUNCTION void VP8FiltersInitSSE2(void) {
   WebPUnfilters[WEBP_FILTER_HORIZONTAL] = HorizontalUnfilter_SSE2;
+#if defined(CHROMIUM)
+  // TODO(crbug.com/654974)
+  (void)VerticalUnfilter_SSE2;
+#else
   WebPUnfilters[WEBP_FILTER_VERTICAL] = VerticalUnfilter_SSE2;
+#endif
   WebPUnfilters[WEBP_FILTER_GRADIENT] = GradientUnfilter_SSE2;
 
   WebPFilters[WEBP_FILTER_HORIZONTAL] = HorizontalFilter_SSE2;
diff --git a/src/3rdparty/libwebp/src/dsp/lossless.c b/src/3rdparty/libwebp/src/dsp/lossless.c
index aad5f43..d8bbb02 100644
--- a/src/3rdparty/libwebp/src/dsp/lossless.c
+++ b/src/3rdparty/libwebp/src/dsp/lossless.c
@@ -107,62 +107,62 @@ static WEBP_INLINE uint32_t Select(uint32_t a, uint32_t b, uint32_t c) {
 //------------------------------------------------------------------------------
 // Predictors
 
-static uint32_t Predictor0_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor0_C(uint32_t left, const uint32_t* const top) {
   (void)top;
   (void)left;
   return ARGB_BLACK;
 }
-static uint32_t Predictor1_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor1_C(uint32_t left, const uint32_t* const top) {
   (void)top;
   return left;
 }
-static uint32_t Predictor2_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor2_C(uint32_t left, const uint32_t* const top) {
   (void)left;
   return top[0];
 }
-static uint32_t Predictor3_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor3_C(uint32_t left, const uint32_t* const top) {
   (void)left;
   return top[1];
 }
-static uint32_t Predictor4_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor4_C(uint32_t left, const uint32_t* const top) {
   (void)left;
   return top[-1];
 }
-static uint32_t Predictor5_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor5_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = Average3(left, top[0], top[1]);
   return pred;
 }
-static uint32_t Predictor6_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor6_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = Average2(left, top[-1]);
   return pred;
 }
-static uint32_t Predictor7_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor7_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = Average2(left, top[0]);
   return pred;
 }
-static uint32_t Predictor8_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor8_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = Average2(top[-1], top[0]);
   (void)left;
   return pred;
 }
-static uint32_t Predictor9_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor9_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = Average2(top[0], top[1]);
   (void)left;
   return pred;
 }
-static uint32_t Predictor10_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor10_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = Average4(left, top[-1], top[0], top[1]);
   return pred;
 }
-static uint32_t Predictor11_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor11_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = Select(top[0], left, top[-1]);
   return pred;
 }
-static uint32_t Predictor12_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor12_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = ClampedAddSubtractFull(left, top[0], top[-1]);
   return pred;
 }
-static uint32_t Predictor13_C(uint32_t left, const uint32_t* const top) {
+uint32_t VP8LPredictor13_C(uint32_t left, const uint32_t* const top) {
   const uint32_t pred = ClampedAddSubtractHalf(left, top[0], top[-1]);
   return pred;
 }
@@ -182,18 +182,18 @@ static void PredictorAdd1_C(const uint32_t* in, const uint32_t* upper,
     out[i] = left = VP8LAddPixels(in[i], left);
   }
 }
-GENERATE_PREDICTOR_ADD(Predictor2_C, PredictorAdd2_C)
-GENERATE_PREDICTOR_ADD(Predictor3_C, PredictorAdd3_C)
-GENERATE_PREDICTOR_ADD(Predictor4_C, PredictorAdd4_C)
-GENERATE_PREDICTOR_ADD(Predictor5_C, PredictorAdd5_C)
-GENERATE_PREDICTOR_ADD(Predictor6_C, PredictorAdd6_C)
-GENERATE_PREDICTOR_ADD(Predictor7_C, PredictorAdd7_C)
-GENERATE_PREDICTOR_ADD(Predictor8_C, PredictorAdd8_C)
-GENERATE_PREDICTOR_ADD(Predictor9_C, PredictorAdd9_C)
-GENERATE_PREDICTOR_ADD(Predictor10_C, PredictorAdd10_C)
-GENERATE_PREDICTOR_ADD(Predictor11_C, PredictorAdd11_C)
-GENERATE_PREDICTOR_ADD(Predictor12_C, PredictorAdd12_C)
-GENERATE_PREDICTOR_ADD(Predictor13_C, PredictorAdd13_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor2_C, PredictorAdd2_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor3_C, PredictorAdd3_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor4_C, PredictorAdd4_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor5_C, PredictorAdd5_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor6_C, PredictorAdd6_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor7_C, PredictorAdd7_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor8_C, PredictorAdd8_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor9_C, PredictorAdd9_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor10_C, PredictorAdd10_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor11_C, PredictorAdd11_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor12_C, PredictorAdd12_C)
+GENERATE_PREDICTOR_ADD(VP8LPredictor13_C, PredictorAdd13_C)
 
 //------------------------------------------------------------------------------
 
@@ -562,7 +562,6 @@ VP8LPredictorFunc VP8LPredictors[16];
 
 // exposed plain-C implementations
 VP8LPredictorAddSubFunc VP8LPredictorsAdd_C[16];
-VP8LPredictorFunc VP8LPredictors_C[16];
 
 VP8LTransformColorInverseFunc VP8LTransformColorInverse;
 
@@ -576,6 +575,7 @@ VP8LMapARGBFunc VP8LMapColor32b;
 VP8LMapAlphaFunc VP8LMapColor8b;
 
 extern void VP8LDspInitSSE2(void);
+extern void VP8LDspInitSSE41(void);
 extern void VP8LDspInitNEON(void);
 extern void VP8LDspInitMIPSdspR2(void);
 extern void VP8LDspInitMSA(void);
@@ -600,8 +600,7 @@ extern void VP8LDspInitMSA(void);
 } while (0);
 
 WEBP_DSP_INIT_FUNC(VP8LDspInit) {
-  COPY_PREDICTOR_ARRAY(Predictor, VP8LPredictors)
-  COPY_PREDICTOR_ARRAY(Predictor, VP8LPredictors_C)
+  COPY_PREDICTOR_ARRAY(VP8LPredictor, VP8LPredictors)
   COPY_PREDICTOR_ARRAY(PredictorAdd, VP8LPredictorsAdd)
   COPY_PREDICTOR_ARRAY(PredictorAdd, VP8LPredictorsAdd_C)
 
@@ -623,9 +622,14 @@ WEBP_DSP_INIT_FUNC(VP8LDspInit) {
 
   // If defined, use CPUInfo() to overwrite some pointers with faster versions.
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       VP8LDspInitSSE2();
+#if defined(WEBP_HAVE_SSE41)
+      if (VP8GetCPUInfo(kSSE4_1)) {
+        VP8LDspInitSSE41();
+      }
+#endif
     }
 #endif
 #if defined(WEBP_USE_MIPS_DSP_R2)
@@ -640,7 +644,7 @@ WEBP_DSP_INIT_FUNC(VP8LDspInit) {
 #endif
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     VP8LDspInitNEON();
diff --git a/src/3rdparty/libwebp/src/dsp/lossless.h b/src/3rdparty/libwebp/src/dsp/lossless.h
index f709cc8..ebd316d 100644
--- a/src/3rdparty/libwebp/src/dsp/lossless.h
+++ b/src/3rdparty/libwebp/src/dsp/lossless.h
@@ -30,7 +30,22 @@ extern "C" {
 
 typedef uint32_t (*VP8LPredictorFunc)(uint32_t left, const uint32_t* const top);
 extern VP8LPredictorFunc VP8LPredictors[16];
-extern VP8LPredictorFunc VP8LPredictors_C[16];
+
+uint32_t VP8LPredictor0_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor1_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor2_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor3_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor4_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor5_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor6_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor7_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor8_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor9_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor10_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor11_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor12_C(uint32_t left, const uint32_t* const top);
+uint32_t VP8LPredictor13_C(uint32_t left, const uint32_t* const top);
+
 // These Add/Sub function expects upper[-1] and out[-1] to be readable.
 typedef void (*VP8LPredictorAddSubFunc)(const uint32_t* in,
                                         const uint32_t* upper, int num_pixels,
diff --git a/src/3rdparty/libwebp/src/dsp/lossless_common.h b/src/3rdparty/libwebp/src/dsp/lossless_common.h
index 9c2ebe6..96a106f 100644
--- a/src/3rdparty/libwebp/src/dsp/lossless_common.h
+++ b/src/3rdparty/libwebp/src/dsp/lossless_common.h
@@ -184,19 +184,6 @@ static void PREDICTOR_ADD(const uint32_t* in, const uint32_t* upper, \
   }                                                                  \
 }
 
-// It subtracts the prediction from the input pixel and stores the residual
-// in the output pixel.
-#define GENERATE_PREDICTOR_SUB(PREDICTOR, PREDICTOR_SUB)             \
-static void PREDICTOR_SUB(const uint32_t* in, const uint32_t* upper, \
-                          int num_pixels, uint32_t* out) {           \
-  int x;                                                             \
-  assert(upper != NULL);                                             \
-  for (x = 0; x < num_pixels; ++x) {                                 \
-    const uint32_t pred = (PREDICTOR)(in[x - 1], upper + x);         \
-    out[x] = VP8LSubPixels(in[x], pred);                             \
-  }                                                                  \
-}
-
 #ifdef __cplusplus
 }    // extern "C"
 #endif
diff --git a/src/3rdparty/libwebp/src/dsp/lossless_enc.c b/src/3rdparty/libwebp/src/dsp/lossless_enc.c
index 9c36055..c3e8537 100644
--- a/src/3rdparty/libwebp/src/dsp/lossless_enc.c
+++ b/src/3rdparty/libwebp/src/dsp/lossless_enc.c
@@ -329,6 +329,15 @@ const uint8_t kPrefixEncodeExtraBitsValue[PREFIX_LOOKUP_IDX_MAX] = {
 static float FastSLog2Slow_C(uint32_t v) {
   assert(v >= LOG_LOOKUP_IDX_MAX);
   if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
+#if !defined(WEBP_HAVE_SLOW_CLZ_CTZ)
+    // use clz if available
+    const int log_cnt = BitsLog2Floor(v) - 7;
+    const uint32_t y = 1 << log_cnt;
+    int correction = 0;
+    const float v_f = (float)v;
+    const uint32_t orig_v = v;
+    v >>= log_cnt;
+#else
     int log_cnt = 0;
     uint32_t y = 1;
     int correction = 0;
@@ -339,6 +348,7 @@ static float FastSLog2Slow_C(uint32_t v) {
       v = v >> 1;
       y = y << 1;
     } while (v >= LOG_LOOKUP_IDX_MAX);
+#endif
     // vf = (2^log_cnt) * Xf; where y = 2^log_cnt and Xf < 256
     // Xf = floor(Xf) * (1 + (v % y) / v)
     // log2(Xf) = log2(floor(Xf)) + log2(1 + (v % y) / v)
@@ -355,6 +365,14 @@ static float FastSLog2Slow_C(uint32_t v) {
 static float FastLog2Slow_C(uint32_t v) {
   assert(v >= LOG_LOOKUP_IDX_MAX);
   if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
+#if !defined(WEBP_HAVE_SLOW_CLZ_CTZ)
+    // use clz if available
+    const int log_cnt = BitsLog2Floor(v) - 7;
+    const uint32_t y = 1 << log_cnt;
+    const uint32_t orig_v = v;
+    double log_2;
+    v >>= log_cnt;
+#else
     int log_cnt = 0;
     uint32_t y = 1;
     const uint32_t orig_v = v;
@@ -364,6 +382,7 @@ static float FastLog2Slow_C(uint32_t v) {
       v = v >> 1;
       y = y << 1;
     } while (v >= LOG_LOOKUP_IDX_MAX);
+#endif
     log_2 = kLog2Table[v] + log_cnt;
     if (orig_v >= APPROX_LOG_MAX) {
       // Since the division is still expensive, add this correction factor only
@@ -702,140 +721,6 @@ void VP8LHistogramAdd(const VP8LHistogram* const a,
 //------------------------------------------------------------------------------
 // Image transforms.
 
-static WEBP_INLINE uint32_t Average2(uint32_t a0, uint32_t a1) {
-  return (((a0 ^ a1) & 0xfefefefeu) >> 1) + (a0 & a1);
-}
-
-static WEBP_INLINE uint32_t Average3(uint32_t a0, uint32_t a1, uint32_t a2) {
-  return Average2(Average2(a0, a2), a1);
-}
-
-static WEBP_INLINE uint32_t Average4(uint32_t a0, uint32_t a1,
-                                     uint32_t a2, uint32_t a3) {
-  return Average2(Average2(a0, a1), Average2(a2, a3));
-}
-
-static WEBP_INLINE uint32_t Clip255(uint32_t a) {
-  if (a < 256) {
-    return a;
-  }
-  // return 0, when a is a negative integer.
-  // return 255, when a is positive.
-  return ~a >> 24;
-}
-
-static WEBP_INLINE int AddSubtractComponentFull(int a, int b, int c) {
-  return Clip255(a + b - c);
-}
-
-static WEBP_INLINE uint32_t ClampedAddSubtractFull(uint32_t c0, uint32_t c1,
-                                                   uint32_t c2) {
-  const int a = AddSubtractComponentFull(c0 >> 24, c1 >> 24, c2 >> 24);
-  const int r = AddSubtractComponentFull((c0 >> 16) & 0xff,
-                                         (c1 >> 16) & 0xff,
-                                         (c2 >> 16) & 0xff);
-  const int g = AddSubtractComponentFull((c0 >> 8) & 0xff,
-                                         (c1 >> 8) & 0xff,
-                                         (c2 >> 8) & 0xff);
-  const int b = AddSubtractComponentFull(c0 & 0xff, c1 & 0xff, c2 & 0xff);
-  return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
-}
-
-static WEBP_INLINE int AddSubtractComponentHalf(int a, int b) {
-  return Clip255(a + (a - b) / 2);
-}
-
-static WEBP_INLINE uint32_t ClampedAddSubtractHalf(uint32_t c0, uint32_t c1,
-                                                   uint32_t c2) {
-  const uint32_t ave = Average2(c0, c1);
-  const int a = AddSubtractComponentHalf(ave >> 24, c2 >> 24);
-  const int r = AddSubtractComponentHalf((ave >> 16) & 0xff, (c2 >> 16) & 0xff);
-  const int g = AddSubtractComponentHalf((ave >> 8) & 0xff, (c2 >> 8) & 0xff);
-  const int b = AddSubtractComponentHalf((ave >> 0) & 0xff, (c2 >> 0) & 0xff);
-  return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
-}
-
-// gcc-4.9 on ARM generates incorrect code in Select() when Sub3() is inlined.
-#if defined(__arm__) && \
-    (LOCAL_GCC_VERSION == 0x409 || LOCAL_GCC_VERSION == 0x408)
-# define LOCAL_INLINE __attribute__ ((noinline))
-#else
-# define LOCAL_INLINE WEBP_INLINE
-#endif
-
-static LOCAL_INLINE int Sub3(int a, int b, int c) {
-  const int pb = b - c;
-  const int pa = a - c;
-  return abs(pb) - abs(pa);
-}
-
-#undef LOCAL_INLINE
-
-static WEBP_INLINE uint32_t Select(uint32_t a, uint32_t b, uint32_t c) {
-  const int pa_minus_pb =
-      Sub3((a >> 24)       , (b >> 24)       , (c >> 24)       ) +
-      Sub3((a >> 16) & 0xff, (b >> 16) & 0xff, (c >> 16) & 0xff) +
-      Sub3((a >>  8) & 0xff, (b >>  8) & 0xff, (c >>  8) & 0xff) +
-      Sub3((a      ) & 0xff, (b      ) & 0xff, (c      ) & 0xff);
-  return (pa_minus_pb <= 0) ? a : b;
-}
-
-//------------------------------------------------------------------------------
-// Predictors
-
-static uint32_t Predictor2(uint32_t left, const uint32_t* const top) {
-  (void)left;
-  return top[0];
-}
-static uint32_t Predictor3(uint32_t left, const uint32_t* const top) {
-  (void)left;
-  return top[1];
-}
-static uint32_t Predictor4(uint32_t left, const uint32_t* const top) {
-  (void)left;
-  return top[-1];
-}
-static uint32_t Predictor5(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = Average3(left, top[0], top[1]);
-  return pred;
-}
-static uint32_t Predictor6(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = Average2(left, top[-1]);
-  return pred;
-}
-static uint32_t Predictor7(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = Average2(left, top[0]);
-  return pred;
-}
-static uint32_t Predictor8(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = Average2(top[-1], top[0]);
-  (void)left;
-  return pred;
-}
-static uint32_t Predictor9(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = Average2(top[0], top[1]);
-  (void)left;
-  return pred;
-}
-static uint32_t Predictor10(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = Average4(left, top[-1], top[0], top[1]);
-  return pred;
-}
-static uint32_t Predictor11(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = Select(top[0], left, top[-1]);
-  return pred;
-}
-static uint32_t Predictor12(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = ClampedAddSubtractFull(left, top[0], top[-1]);
-  return pred;
-}
-static uint32_t Predictor13(uint32_t left, const uint32_t* const top) {
-  const uint32_t pred = ClampedAddSubtractHalf(left, top[0], top[-1]);
-  return pred;
-}
-
-//------------------------------------------------------------------------------
-
 static void PredictorSub0_C(const uint32_t* in, const uint32_t* upper,
                             int num_pixels, uint32_t* out) {
   int i;
@@ -850,18 +735,33 @@ static void PredictorSub1_C(const uint32_t* in, const uint32_t* upper,
   (void)upper;
 }
 
-GENERATE_PREDICTOR_SUB(Predictor2, PredictorSub2_C)
-GENERATE_PREDICTOR_SUB(Predictor3, PredictorSub3_C)
-GENERATE_PREDICTOR_SUB(Predictor4, PredictorSub4_C)
-GENERATE_PREDICTOR_SUB(Predictor5, PredictorSub5_C)
-GENERATE_PREDICTOR_SUB(Predictor6, PredictorSub6_C)
-GENERATE_PREDICTOR_SUB(Predictor7, PredictorSub7_C)
-GENERATE_PREDICTOR_SUB(Predictor8, PredictorSub8_C)
-GENERATE_PREDICTOR_SUB(Predictor9, PredictorSub9_C)
-GENERATE_PREDICTOR_SUB(Predictor10, PredictorSub10_C)
-GENERATE_PREDICTOR_SUB(Predictor11, PredictorSub11_C)
-GENERATE_PREDICTOR_SUB(Predictor12, PredictorSub12_C)
-GENERATE_PREDICTOR_SUB(Predictor13, PredictorSub13_C)
+// It subtracts the prediction from the input pixel and stores the residual
+// in the output pixel.
+#define GENERATE_PREDICTOR_SUB(PREDICTOR_I)                                \
+static void PredictorSub##PREDICTOR_I##_C(const uint32_t* in,              \
+                                          const uint32_t* upper,           \
+                                          int num_pixels, uint32_t* out) { \
+  int x;                                                                   \
+  assert(upper != NULL);                                                   \
+  for (x = 0; x < num_pixels; ++x) {                                       \
+    const uint32_t pred =                                                  \
+        VP8LPredictor##PREDICTOR_I##_C(in[x - 1], upper + x);              \
+    out[x] = VP8LSubPixels(in[x], pred);                                   \
+  }                                                                        \
+}
+
+GENERATE_PREDICTOR_SUB(2)
+GENERATE_PREDICTOR_SUB(3)
+GENERATE_PREDICTOR_SUB(4)
+GENERATE_PREDICTOR_SUB(5)
+GENERATE_PREDICTOR_SUB(6)
+GENERATE_PREDICTOR_SUB(7)
+GENERATE_PREDICTOR_SUB(8)
+GENERATE_PREDICTOR_SUB(9)
+GENERATE_PREDICTOR_SUB(10)
+GENERATE_PREDICTOR_SUB(11)
+GENERATE_PREDICTOR_SUB(12)
+GENERATE_PREDICTOR_SUB(13)
 
 //------------------------------------------------------------------------------
 
@@ -962,10 +862,10 @@ WEBP_DSP_INIT_FUNC(VP8LEncDspInit) {
 
   // If defined, use CPUInfo() to overwrite some pointers with faster versions.
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       VP8LEncDspInitSSE2();
-#if defined(WEBP_USE_SSE41)
+#if defined(WEBP_HAVE_SSE41)
       if (VP8GetCPUInfo(kSSE4_1)) {
         VP8LEncDspInitSSE41();
       }
@@ -989,7 +889,7 @@ WEBP_DSP_INIT_FUNC(VP8LEncDspInit) {
 #endif
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     VP8LEncDspInitNEON();
diff --git a/src/3rdparty/libwebp/src/dsp/lossless_enc_sse2.c b/src/3rdparty/libwebp/src/dsp/lossless_enc_sse2.c
index e676f6f..b2f83b8 100644
--- a/src/3rdparty/libwebp/src/dsp/lossless_enc_sse2.c
+++ b/src/3rdparty/libwebp/src/dsp/lossless_enc_sse2.c
@@ -232,76 +232,55 @@ static void AddVectorEq_SSE2(const uint32_t* a, uint32_t* out, int size) {
 //------------------------------------------------------------------------------
 // Entropy
 
-// Checks whether the X or Y contribution is worth computing and adding.
-// Used in loop unrolling.
-#define ANALYZE_X_OR_Y(x_or_y, j)                                           \
-  do {                                                                      \
-    if ((x_or_y)[i + (j)] != 0) retval -= VP8LFastSLog2((x_or_y)[i + (j)]); \
-  } while (0)
-
-// Checks whether the X + Y contribution is worth computing and adding.
-// Used in loop unrolling.
-#define ANALYZE_XY(j)                  \
-  do {                                 \
-    if (tmp[j] != 0) {                 \
-      retval -= VP8LFastSLog2(tmp[j]); \
-      ANALYZE_X_OR_Y(X, j);            \
-    }                                  \
-  } while (0)
+// TODO(https://crbug.com/webp/499): this function produces different results
+// from the C code due to use of double/float resulting in output differences
+// when compared to -noasm.
+#if !(defined(WEBP_HAVE_SLOW_CLZ_CTZ) || defined(__i386__) || defined(_M_IX86))
 
 static float CombinedShannonEntropy_SSE2(const int X[256], const int Y[256]) {
   int i;
   double retval = 0.;
-  int sumX, sumXY;
-  int32_t tmp[4];
-  __m128i zero = _mm_setzero_si128();
-  // Sums up X + Y, 4 ints at a time (and will merge it at the end for sumXY).
-  __m128i sumXY_128 = zero;
-  __m128i sumX_128 = zero;
-
-  for (i = 0; i < 256; i += 4) {
-    const __m128i x = _mm_loadu_si128((const __m128i*)(X + i));
-    const __m128i y = _mm_loadu_si128((const __m128i*)(Y + i));
-
-    // Check if any X is non-zero: this actually provides a speedup as X is
-    // usually sparse.
-    if (_mm_movemask_epi8(_mm_cmpeq_epi32(x, zero)) != 0xFFFF) {
-      const __m128i xy_128 = _mm_add_epi32(x, y);
-      sumXY_128 = _mm_add_epi32(sumXY_128, xy_128);
-
-      sumX_128 = _mm_add_epi32(sumX_128, x);
-
-      // Analyze the different X + Y.
-      _mm_storeu_si128((__m128i*)tmp, xy_128);
-
-      ANALYZE_XY(0);
-      ANALYZE_XY(1);
-      ANALYZE_XY(2);
-      ANALYZE_XY(3);
-    } else {
-      // X is fully 0, so only deal with Y.
-      sumXY_128 = _mm_add_epi32(sumXY_128, y);
-
-      ANALYZE_X_OR_Y(Y, 0);
-      ANALYZE_X_OR_Y(Y, 1);
-      ANALYZE_X_OR_Y(Y, 2);
-      ANALYZE_X_OR_Y(Y, 3);
+  int sumX = 0, sumXY = 0;
+  const __m128i zero = _mm_setzero_si128();
+
+  for (i = 0; i < 256; i += 16) {
+    const __m128i x0 = _mm_loadu_si128((const __m128i*)(X + i +  0));
+    const __m128i y0 = _mm_loadu_si128((const __m128i*)(Y + i +  0));
+    const __m128i x1 = _mm_loadu_si128((const __m128i*)(X + i +  4));
+    const __m128i y1 = _mm_loadu_si128((const __m128i*)(Y + i +  4));
+    const __m128i x2 = _mm_loadu_si128((const __m128i*)(X + i +  8));
+    const __m128i y2 = _mm_loadu_si128((const __m128i*)(Y + i +  8));
+    const __m128i x3 = _mm_loadu_si128((const __m128i*)(X + i + 12));
+    const __m128i y3 = _mm_loadu_si128((const __m128i*)(Y + i + 12));
+    const __m128i x4 = _mm_packs_epi16(_mm_packs_epi32(x0, x1),
+                                       _mm_packs_epi32(x2, x3));
+    const __m128i y4 = _mm_packs_epi16(_mm_packs_epi32(y0, y1),
+                                       _mm_packs_epi32(y2, y3));
+    const int32_t mx = _mm_movemask_epi8(_mm_cmpgt_epi8(x4, zero));
+    int32_t my = _mm_movemask_epi8(_mm_cmpgt_epi8(y4, zero)) | mx;
+    while (my) {
+      const int32_t j = BitsCtz(my);
+      int xy;
+      if ((mx >> j) & 1) {
+        const int x = X[i + j];
+        sumXY += x;
+        retval -= VP8LFastSLog2(x);
+      }
+      xy = X[i + j] + Y[i + j];
+      sumX += xy;
+      retval -= VP8LFastSLog2(xy);
+      my &= my - 1;
     }
   }
-
-  // Sum up sumX_128 to get sumX.
-  _mm_storeu_si128((__m128i*)tmp, sumX_128);
-  sumX = tmp[3] + tmp[2] + tmp[1] + tmp[0];
-
-  // Sum up sumXY_128 to get sumXY.
-  _mm_storeu_si128((__m128i*)tmp, sumXY_128);
-  sumXY = tmp[3] + tmp[2] + tmp[1] + tmp[0];
-
   retval += VP8LFastSLog2(sumX) + VP8LFastSLog2(sumXY);
   return (float)retval;
 }
-#undef ANALYZE_X_OR_Y
-#undef ANALYZE_XY
+
+#else
+
+#define DONT_USE_COMBINED_SHANNON_ENTROPY_SSE2_FUNC   // won't be faster
+
+#endif
 
 //------------------------------------------------------------------------------
 
@@ -460,20 +439,22 @@ static void PredictorSub0_SSE2(const uint32_t* in, const uint32_t* upper,
   (void)upper;
 }
 
-#define GENERATE_PREDICTOR_1(X, IN)                                           \
-static void PredictorSub##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
-                                   int num_pixels, uint32_t* out) {           \
-  int i;                                                                      \
-  for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
-    const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
-    const __m128i pred = _mm_loadu_si128((const __m128i*)&(IN));              \
-    const __m128i res = _mm_sub_epi8(src, pred);                              \
-    _mm_storeu_si128((__m128i*)&out[i], res);                                 \
-  }                                                                           \
-  if (i != num_pixels) {                                                      \
-    VP8LPredictorsSub_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
-  }                                                                           \
-}
+#define GENERATE_PREDICTOR_1(X, IN)                                         \
+  static void PredictorSub##X##_SSE2(const uint32_t* const in,              \
+                                     const uint32_t* const upper,           \
+                                     int num_pixels, uint32_t* const out) { \
+    int i;                                                                  \
+    for (i = 0; i + 4 <= num_pixels; i += 4) {                              \
+      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);          \
+      const __m128i pred = _mm_loadu_si128((const __m128i*)&(IN));          \
+      const __m128i res = _mm_sub_epi8(src, pred);                          \
+      _mm_storeu_si128((__m128i*)&out[i], res);                             \
+    }                                                                       \
+    if (i != num_pixels) {                                                  \
+      VP8LPredictorsSub_C[(X)](in + i, WEBP_OFFSET_PTR(upper, i),           \
+                               num_pixels - i, out + i);                    \
+    }                                                                       \
+  }
 
 GENERATE_PREDICTOR_1(1, in[i - 1])       // Predictor1: L
 GENERATE_PREDICTOR_1(2, upper[i])        // Predictor2: T
@@ -657,7 +638,9 @@ WEBP_TSAN_IGNORE_FUNCTION void VP8LEncDspInitSSE2(void) {
   VP8LCollectColorRedTransforms = CollectColorRedTransforms_SSE2;
   VP8LAddVector = AddVector_SSE2;
   VP8LAddVectorEq = AddVectorEq_SSE2;
+#if !defined(DONT_USE_COMBINED_SHANNON_ENTROPY_SSE2_FUNC)
   VP8LCombinedShannonEntropy = CombinedShannonEntropy_SSE2;
+#endif
   VP8LVectorMismatch = VectorMismatch_SSE2;
   VP8LBundleColorMap = BundleColorMap_SSE2;
 
diff --git a/src/3rdparty/libwebp/src/dsp/lossless_enc_sse41.c b/src/3rdparty/libwebp/src/dsp/lossless_enc_sse41.c
index 719d8ed..ad358a6 100644
--- a/src/3rdparty/libwebp/src/dsp/lossless_enc_sse41.c
+++ b/src/3rdparty/libwebp/src/dsp/lossless_enc_sse41.c
@@ -44,46 +44,47 @@ static void SubtractGreenFromBlueAndRed_SSE41(uint32_t* argb_data,
 //------------------------------------------------------------------------------
 // Color Transform
 
-#define SPAN 8
+#define MK_CST_16(HI, LO) \
+  _mm_set1_epi32((int)(((uint32_t)(HI) << 16) | ((LO) & 0xffff)))
+
 static void CollectColorBlueTransforms_SSE41(const uint32_t* argb, int stride,
                                              int tile_width, int tile_height,
                                              int green_to_blue, int red_to_blue,
                                              int histo[]) {
-  const __m128i mults_r = _mm_set1_epi16(CST_5b(red_to_blue));
-  const __m128i mults_g = _mm_set1_epi16(CST_5b(green_to_blue));
-  const __m128i mask_g = _mm_set1_epi16((short)0xff00);   // green mask
-  const __m128i mask_gb = _mm_set1_epi32(0xffff);         // green/blue mask
-  const __m128i mask_b = _mm_set1_epi16(0x00ff);          // blue mask
-  const __m128i shuffler_lo = _mm_setr_epi8(-1, 2, -1, 6, -1, 10, -1, 14, -1,
-                                            -1, -1, -1, -1, -1, -1, -1);
-  const __m128i shuffler_hi = _mm_setr_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1,
-                                            2, -1, 6, -1, 10, -1, 14);
-  int y;
-  for (y = 0; y < tile_height; ++y) {
-    const uint32_t* const src = argb + y * stride;
-    int i, x;
-    for (x = 0; x + SPAN <= tile_width; x += SPAN) {
-      uint16_t values[SPAN];
-      const __m128i in0 = _mm_loadu_si128((__m128i*)&src[x + 0]);
-      const __m128i in1 = _mm_loadu_si128((__m128i*)&src[x + SPAN / 2]);
-      const __m128i r0 = _mm_shuffle_epi8(in0, shuffler_lo);
-      const __m128i r1 = _mm_shuffle_epi8(in1, shuffler_hi);
-      const __m128i r = _mm_or_si128(r0, r1);         // r 0
-      const __m128i gb0 = _mm_and_si128(in0, mask_gb);
-      const __m128i gb1 = _mm_and_si128(in1, mask_gb);
-      const __m128i gb = _mm_packus_epi32(gb0, gb1);  // g b
-      const __m128i g = _mm_and_si128(gb, mask_g);    // g 0
-      const __m128i A = _mm_mulhi_epi16(r, mults_r);  // x dbr
-      const __m128i B = _mm_mulhi_epi16(g, mults_g);  // x dbg
-      const __m128i C = _mm_sub_epi8(gb, B);          // x b'
-      const __m128i D = _mm_sub_epi8(C, A);           // x b''
-      const __m128i E = _mm_and_si128(D, mask_b);     // 0 b''
-      _mm_storeu_si128((__m128i*)values, E);
-      for (i = 0; i < SPAN; ++i) ++histo[values[i]];
+  const __m128i mult =
+      MK_CST_16(CST_5b(red_to_blue) + 256,CST_5b(green_to_blue));
+  const __m128i perm =
+      _mm_setr_epi8(-1, 1, -1, 2, -1, 5, -1, 6, -1, 9, -1, 10, -1, 13, -1, 14);
+  if (tile_width >= 4) {
+    int y;
+    for (y = 0; y < tile_height; ++y) {
+      const uint32_t* const src = argb + y * stride;
+      const __m128i A1 = _mm_loadu_si128((const __m128i*)src);
+      const __m128i B1 = _mm_shuffle_epi8(A1, perm);
+      const __m128i C1 = _mm_mulhi_epi16(B1, mult);
+      const __m128i D1 = _mm_sub_epi16(A1, C1);
+      __m128i E = _mm_add_epi16(_mm_srli_epi32(D1, 16), D1);
+      int x;
+      for (x = 4; x + 4 <= tile_width; x += 4) {
+        const __m128i A2 = _mm_loadu_si128((const __m128i*)(src + x));
+        __m128i B2, C2, D2;
+        ++histo[_mm_extract_epi8(E,  0)];
+        B2 = _mm_shuffle_epi8(A2, perm);
+        ++histo[_mm_extract_epi8(E,  4)];
+        C2 = _mm_mulhi_epi16(B2, mult);
+        ++histo[_mm_extract_epi8(E,  8)];
+        D2 = _mm_sub_epi16(A2, C2);
+        ++histo[_mm_extract_epi8(E, 12)];
+        E = _mm_add_epi16(_mm_srli_epi32(D2, 16), D2);
+      }
+      ++histo[_mm_extract_epi8(E,  0)];
+      ++histo[_mm_extract_epi8(E,  4)];
+      ++histo[_mm_extract_epi8(E,  8)];
+      ++histo[_mm_extract_epi8(E, 12)];
     }
   }
   {
-    const int left_over = tile_width & (SPAN - 1);
+    const int left_over = tile_width & 3;
     if (left_over > 0) {
       VP8LCollectColorBlueTransforms_C(argb + tile_width - left_over, stride,
                                        left_over, tile_height,
@@ -95,33 +96,37 @@ static void CollectColorBlueTransforms_SSE41(const uint32_t* argb, int stride,
 static void CollectColorRedTransforms_SSE41(const uint32_t* argb, int stride,
                                             int tile_width, int tile_height,
                                             int green_to_red, int histo[]) {
-  const __m128i mults_g = _mm_set1_epi16(CST_5b(green_to_red));
-  const __m128i mask_g = _mm_set1_epi32(0x00ff00);  // green mask
-  const __m128i mask = _mm_set1_epi16(0xff);
-
-  int y;
-  for (y = 0; y < tile_height; ++y) {
-    const uint32_t* const src = argb + y * stride;
-    int i, x;
-    for (x = 0; x + SPAN <= tile_width; x += SPAN) {
-      uint16_t values[SPAN];
-      const __m128i in0 = _mm_loadu_si128((__m128i*)&src[x + 0]);
-      const __m128i in1 = _mm_loadu_si128((__m128i*)&src[x + SPAN / 2]);
-      const __m128i g0 = _mm_and_si128(in0, mask_g);  // 0 0  | g 0
-      const __m128i g1 = _mm_and_si128(in1, mask_g);
-      const __m128i g = _mm_packus_epi32(g0, g1);     // g 0
-      const __m128i A0 = _mm_srli_epi32(in0, 16);     // 0 0  | x r
-      const __m128i A1 = _mm_srli_epi32(in1, 16);
-      const __m128i A = _mm_packus_epi32(A0, A1);     // x r
-      const __m128i B = _mm_mulhi_epi16(g, mults_g);  // x dr
-      const __m128i C = _mm_sub_epi8(A, B);           // x r'
-      const __m128i D = _mm_and_si128(C, mask);       // 0 r'
-      _mm_storeu_si128((__m128i*)values, D);
-      for (i = 0; i < SPAN; ++i) ++histo[values[i]];
+
+  const __m128i mult = MK_CST_16(0, CST_5b(green_to_red));
+  const __m128i mask_g = _mm_set1_epi32(0x0000ff00);
+  if (tile_width >= 4) {
+    int y;
+    for (y = 0; y < tile_height; ++y) {
+      const uint32_t* const src = argb + y * stride;
+      const __m128i A1 = _mm_loadu_si128((const __m128i*)src);
+      const __m128i B1 = _mm_and_si128(A1, mask_g);
+      const __m128i C1 = _mm_madd_epi16(B1, mult);
+      __m128i D = _mm_sub_epi16(A1, C1);
+      int x;
+      for (x = 4; x + 4 <= tile_width; x += 4) {
+        const __m128i A2 = _mm_loadu_si128((const __m128i*)(src + x));
+        __m128i B2, C2;
+        ++histo[_mm_extract_epi8(D,  2)];
+        B2 = _mm_and_si128(A2, mask_g);
+        ++histo[_mm_extract_epi8(D,  6)];
+        C2 = _mm_madd_epi16(B2, mult);
+        ++histo[_mm_extract_epi8(D, 10)];
+        ++histo[_mm_extract_epi8(D, 14)];
+        D = _mm_sub_epi16(A2, C2);
+      }
+      ++histo[_mm_extract_epi8(D,  2)];
+      ++histo[_mm_extract_epi8(D,  6)];
+      ++histo[_mm_extract_epi8(D, 10)];
+      ++histo[_mm_extract_epi8(D, 14)];
     }
   }
   {
-    const int left_over = tile_width & (SPAN - 1);
+    const int left_over = tile_width & 3;
     if (left_over > 0) {
       VP8LCollectColorRedTransforms_C(argb + tile_width - left_over, stride,
                                       left_over, tile_height, green_to_red,
@@ -130,6 +135,8 @@ static void CollectColorRedTransforms_SSE41(const uint32_t* argb, int stride,
   }
 }
 
+#undef MK_CST_16
+
 //------------------------------------------------------------------------------
 // Entry point
 
diff --git a/src/3rdparty/libwebp/src/dsp/lossless_sse2.c b/src/3rdparty/libwebp/src/dsp/lossless_sse2.c
index aef0cee..3a0eb44 100644
--- a/src/3rdparty/libwebp/src/dsp/lossless_sse2.c
+++ b/src/3rdparty/libwebp/src/dsp/lossless_sse2.c
@@ -18,7 +18,6 @@
 #include "src/dsp/common_sse2.h"
 #include "src/dsp/lossless.h"
 #include "src/dsp/lossless_common.h"
-#include <assert.h>
 #include <emmintrin.h>
 
 //------------------------------------------------------------------------------
diff --git a/src/3rdparty/libwebp/src/dsp/lossless_sse41.c b/src/3rdparty/libwebp/src/dsp/lossless_sse41.c
new file mode 100644
index 0000000..b0d6daa
--- /dev/null
+++ b/src/3rdparty/libwebp/src/dsp/lossless_sse41.c
@@ -0,0 +1,132 @@
+// Copyright 2021 Google Inc. All Rights Reserved.
+//
+// Use of this source code is governed by a BSD-style license
+// that can be found in the COPYING file in the root of the source
+// tree. An additional intellectual property rights grant can be found
+// in the file PATENTS. All contributing project authors may
+// be found in the AUTHORS file in the root of the source tree.
+// -----------------------------------------------------------------------------
+//
+// SSE41 variant of methods for lossless decoder
+
+#include "src/dsp/dsp.h"
+
+#if defined(WEBP_USE_SSE41)
+
+#include "src/dsp/common_sse41.h"
+#include "src/dsp/lossless.h"
+#include "src/dsp/lossless_common.h"
+
+//------------------------------------------------------------------------------
+// Color-space conversion functions
+
+static void TransformColorInverse_SSE41(const VP8LMultipliers* const m,
+                                        const uint32_t* const src,
+                                        int num_pixels, uint32_t* dst) {
+// sign-extended multiplying constants, pre-shifted by 5.
+#define CST(X)  (((int16_t)(m->X << 8)) >> 5)   // sign-extend
+  const __m128i mults_rb = _mm_set1_epi32((uint32_t)CST(green_to_red_) << 16 |
+                                          (CST(green_to_blue_) & 0xffff));
+  const __m128i mults_b2 = _mm_set1_epi32(CST(red_to_blue_));
+#undef CST
+  const __m128i mask_ag = _mm_set1_epi32(0xff00ff00);
+  const __m128i perm1 = _mm_setr_epi8(-1, 1, -1, 1, -1, 5, -1, 5,
+                                      -1, 9, -1, 9, -1, 13, -1, 13);
+  const __m128i perm2 = _mm_setr_epi8(-1, 2, -1, -1, -1, 6, -1, -1,
+                                      -1, 10, -1, -1, -1, 14, -1, -1);
+  int i;
+  for (i = 0; i + 4 <= num_pixels; i += 4) {
+    const __m128i A = _mm_loadu_si128((const __m128i*)(src + i));
+    const __m128i B = _mm_shuffle_epi8(A, perm1); // argb -> g0g0
+    const __m128i C = _mm_mulhi_epi16(B, mults_rb);
+    const __m128i D = _mm_add_epi8(A, C);
+    const __m128i E = _mm_shuffle_epi8(D, perm2);
+    const __m128i F = _mm_mulhi_epi16(E, mults_b2);
+    const __m128i G = _mm_add_epi8(D, F);
+    const __m128i out = _mm_blendv_epi8(G, A, mask_ag);
+    _mm_storeu_si128((__m128i*)&dst[i], out);
+  }
+  // Fall-back to C-version for left-overs.
+  if (i != num_pixels) {
+    VP8LTransformColorInverse_C(m, src + i, num_pixels - i, dst + i);
+  }
+}
+
+//------------------------------------------------------------------------------
+
+#define ARGB_TO_RGB_SSE41 do {                        \
+  while (num_pixels >= 16) {                          \
+    const __m128i in0 = _mm_loadu_si128(in + 0);      \
+    const __m128i in1 = _mm_loadu_si128(in + 1);      \
+    const __m128i in2 = _mm_loadu_si128(in + 2);      \
+    const __m128i in3 = _mm_loadu_si128(in + 3);      \
+    const __m128i a0 = _mm_shuffle_epi8(in0, perm0);  \
+    const __m128i a1 = _mm_shuffle_epi8(in1, perm1);  \
+    const __m128i a2 = _mm_shuffle_epi8(in2, perm2);  \
+    const __m128i a3 = _mm_shuffle_epi8(in3, perm3);  \
+    const __m128i b0 = _mm_blend_epi16(a0, a1, 0xc0); \
+    const __m128i b1 = _mm_blend_epi16(a1, a2, 0xf0); \
+    const __m128i b2 = _mm_blend_epi16(a2, a3, 0xfc); \
+    _mm_storeu_si128(out + 0, b0);                    \
+    _mm_storeu_si128(out + 1, b1);                    \
+    _mm_storeu_si128(out + 2, b2);                    \
+    in += 4;                                          \
+    out += 3;                                         \
+    num_pixels -= 16;                                 \
+  }                                                   \
+} while (0)
+
+static void ConvertBGRAToRGB_SSE41(const uint32_t* src, int num_pixels,
+                                   uint8_t* dst) {
+  const __m128i* in = (const __m128i*)src;
+  __m128i* out = (__m128i*)dst;
+  const __m128i perm0 = _mm_setr_epi8(2, 1, 0, 6, 5, 4, 10, 9,
+                                      8, 14, 13, 12, -1, -1, -1, -1);
+  const __m128i perm1 = _mm_shuffle_epi32(perm0, 0x39);
+  const __m128i perm2 = _mm_shuffle_epi32(perm0, 0x4e);
+  const __m128i perm3 = _mm_shuffle_epi32(perm0, 0x93);
+
+  ARGB_TO_RGB_SSE41;
+
+  // left-overs
+  if (num_pixels > 0) {
+    VP8LConvertBGRAToRGB_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
+  }
+}
+
+static void ConvertBGRAToBGR_SSE41(const uint32_t* src,
+                                   int num_pixels, uint8_t* dst) {
+  const __m128i* in = (const __m128i*)src;
+  __m128i* out = (__m128i*)dst;
+  const __m128i perm0 = _mm_setr_epi8(0, 1, 2, 4, 5, 6, 8, 9, 10,
+                                      12, 13, 14, -1, -1, -1, -1);
+  const __m128i perm1 = _mm_shuffle_epi32(perm0, 0x39);
+  const __m128i perm2 = _mm_shuffle_epi32(perm0, 0x4e);
+  const __m128i perm3 = _mm_shuffle_epi32(perm0, 0x93);
+
+  ARGB_TO_RGB_SSE41;
+
+  // left-overs
+  if (num_pixels > 0) {
+    VP8LConvertBGRAToBGR_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
+  }
+}
+
+#undef ARGB_TO_RGB_SSE41
+
+//------------------------------------------------------------------------------
+// Entry point
+
+extern void VP8LDspInitSSE41(void);
+
+WEBP_TSAN_IGNORE_FUNCTION void VP8LDspInitSSE41(void) {
+  VP8LTransformColorInverse = TransformColorInverse_SSE41;
+  VP8LConvertBGRAToRGB = ConvertBGRAToRGB_SSE41;
+  VP8LConvertBGRAToBGR = ConvertBGRAToBGR_SSE41;
+}
+
+#else  // !WEBP_USE_SSE41
+
+WEBP_DSP_INIT_STUB(VP8LDspInitSSE41)
+
+#endif  // WEBP_USE_SSE41
diff --git a/src/3rdparty/libwebp/src/dsp/rescaler.c b/src/3rdparty/libwebp/src/dsp/rescaler.c
index c5a01e8..14620ce 100644
--- a/src/3rdparty/libwebp/src/dsp/rescaler.c
+++ b/src/3rdparty/libwebp/src/dsp/rescaler.c
@@ -38,8 +38,9 @@ void WebPRescalerImportRowExpand_C(WebPRescaler* const wrk,
     int x_out = channel;
     // simple bilinear interpolation
     int accum = wrk->x_add;
-    int left = src[x_in];
-    int right = (wrk->src_width > 1) ? src[x_in + x_stride] : left;
+    rescaler_t left = (rescaler_t)src[x_in];
+    rescaler_t right =
+        (wrk->src_width > 1) ? (rescaler_t)src[x_in + x_stride] : left;
     x_in += x_stride;
     while (1) {
       wrk->frow[x_out] = right * wrk->x_add + (left - right) * accum;
@@ -50,7 +51,7 @@ void WebPRescalerImportRowExpand_C(WebPRescaler* const wrk,
         left = right;
         x_in += x_stride;
         assert(x_in < wrk->src_width * x_stride);
-        right = src[x_in];
+        right = (rescaler_t)src[x_in];
         accum += wrk->x_add;
       }
     }
@@ -213,7 +214,7 @@ WEBP_DSP_INIT_FUNC(WebPRescalerDspInit) {
   WebPRescalerImportRowShrink = WebPRescalerImportRowShrink_C;
 
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       WebPRescalerDspInitSSE2();
     }
@@ -235,7 +236,7 @@ WEBP_DSP_INIT_FUNC(WebPRescalerDspInit) {
 #endif
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     WebPRescalerDspInitNEON();
diff --git a/src/3rdparty/libwebp/src/dsp/ssim.c b/src/3rdparty/libwebp/src/dsp/ssim.c
index 989ce82..f85c2e6 100644
--- a/src/3rdparty/libwebp/src/dsp/ssim.c
+++ b/src/3rdparty/libwebp/src/dsp/ssim.c
@@ -150,7 +150,7 @@ WEBP_DSP_INIT_FUNC(VP8SSIMDspInit) {
 #endif
 
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       VP8SSIMDspInitSSE2();
     }
diff --git a/src/3rdparty/libwebp/src/dsp/upsampling.c b/src/3rdparty/libwebp/src/dsp/upsampling.c
index 9b60da5..87f771f 100644
--- a/src/3rdparty/libwebp/src/dsp/upsampling.c
+++ b/src/3rdparty/libwebp/src/dsp/upsampling.c
@@ -233,12 +233,12 @@ WEBP_DSP_INIT_FUNC(WebPInitYUV444Converters) {
   WebPYUV444Converters[MODE_rgbA_4444] = WebPYuv444ToRgba4444_C;
 
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       WebPInitYUV444ConvertersSSE2();
     }
 #endif
-#if defined(WEBP_USE_SSE41)
+#if defined(WEBP_HAVE_SSE41)
     if (VP8GetCPUInfo(kSSE4_1)) {
       WebPInitYUV444ConvertersSSE41();
     }
@@ -278,12 +278,12 @@ WEBP_DSP_INIT_FUNC(WebPInitUpsamplers) {
 
   // If defined, use CPUInfo() to overwrite some pointers with faster versions.
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       WebPInitUpsamplersSSE2();
     }
 #endif
-#if defined(WEBP_USE_SSE41)
+#if defined(WEBP_HAVE_SSE41)
     if (VP8GetCPUInfo(kSSE4_1)) {
       WebPInitUpsamplersSSE41();
     }
@@ -300,7 +300,7 @@ WEBP_DSP_INIT_FUNC(WebPInitUpsamplers) {
 #endif
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     WebPInitUpsamplersNEON();
diff --git a/src/3rdparty/libwebp/src/dsp/yuv.c b/src/3rdparty/libwebp/src/dsp/yuv.c
index 14e67fc..48466f8 100644
--- a/src/3rdparty/libwebp/src/dsp/yuv.c
+++ b/src/3rdparty/libwebp/src/dsp/yuv.c
@@ -90,16 +90,16 @@ WEBP_DSP_INIT_FUNC(WebPInitSamplers) {
 
   // If defined, use CPUInfo() to overwrite some pointers with faster versions.
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       WebPInitSamplersSSE2();
     }
-#endif  // WEBP_USE_SSE2
-#if defined(WEBP_USE_SSE41)
+#endif  // WEBP_HAVE_SSE2
+#if defined(WEBP_HAVE_SSE41)
     if (VP8GetCPUInfo(kSSE4_1)) {
       WebPInitSamplersSSE41();
     }
-#endif  // WEBP_USE_SSE41
+#endif  // WEBP_HAVE_SSE41
 #if defined(WEBP_USE_MIPS32)
     if (VP8GetCPUInfo(kMIPS32)) {
       WebPInitSamplersMIPS32();
@@ -276,26 +276,26 @@ WEBP_DSP_INIT_FUNC(WebPInitConvertARGBToYUV) {
 #endif
 
   if (VP8GetCPUInfo != NULL) {
-#if defined(WEBP_USE_SSE2)
+#if defined(WEBP_HAVE_SSE2)
     if (VP8GetCPUInfo(kSSE2)) {
       WebPInitConvertARGBToYUVSSE2();
       WebPInitSharpYUVSSE2();
     }
-#endif  // WEBP_USE_SSE2
-#if defined(WEBP_USE_SSE41)
+#endif  // WEBP_HAVE_SSE2
+#if defined(WEBP_HAVE_SSE41)
     if (VP8GetCPUInfo(kSSE4_1)) {
       WebPInitConvertARGBToYUVSSE41();
     }
-#endif  // WEBP_USE_SSE41
+#endif  // WEBP_HAVE_SSE41
   }
 
-#if defined(WEBP_USE_NEON)
+#if defined(WEBP_HAVE_NEON)
   if (WEBP_NEON_OMIT_C_CODE ||
       (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
     WebPInitConvertARGBToYUVNEON();
     WebPInitSharpYUVNEON();
   }
-#endif  // WEBP_USE_NEON
+#endif  // WEBP_HAVE_NEON
 
   assert(WebPConvertARGBToY != NULL);
   assert(WebPConvertARGBToUV != NULL);
diff --git a/src/3rdparty/libwebp/src/enc/alpha_enc.c b/src/3rdparty/libwebp/src/enc/alpha_enc.c
index dce9ca9..0b54f3e 100644
--- a/src/3rdparty/libwebp/src/enc/alpha_enc.c
+++ b/src/3rdparty/libwebp/src/enc/alpha_enc.c
@@ -303,7 +303,7 @@ static int EncodeAlpha(VP8Encoder* const enc,
   int ok = 1;
   const int reduce_levels = (quality < 100);
 
-  // quick sanity checks
+  // quick correctness checks
   assert((uint64_t)data_size == (uint64_t)width * height);  // as per spec
   assert(enc != NULL && pic != NULL && pic->a != NULL);
   assert(output != NULL && output_size != NULL);
@@ -361,7 +361,7 @@ static int EncodeAlpha(VP8Encoder* const enc,
 //------------------------------------------------------------------------------
 // Main calls
 
-static int CompressAlphaJob(void* arg1, void* dummy) {
+static int CompressAlphaJob(void* arg1, void* unused) {
   VP8Encoder* const enc = (VP8Encoder*)arg1;
   const WebPConfig* config = enc->config_;
   uint8_t* alpha_data = NULL;
@@ -375,13 +375,13 @@ static int CompressAlphaJob(void* arg1, void* dummy) {
                    filter, effort_level, &alpha_data, &alpha_size)) {
     return 0;
   }
-  if (alpha_size != (uint32_t)alpha_size) {  // Sanity check.
+  if (alpha_size != (uint32_t)alpha_size) {  // Soundness check.
     WebPSafeFree(alpha_data);
     return 0;
   }
   enc->alpha_data_size_ = (uint32_t)alpha_size;
   enc->alpha_data_ = alpha_data;
-  (void)dummy;
+  (void)unused;
   return 1;
 }
 
diff --git a/src/3rdparty/libwebp/src/enc/analysis_enc.c b/src/3rdparty/libwebp/src/enc/analysis_enc.c
index 687757a..ebb7842 100644
--- a/src/3rdparty/libwebp/src/enc/analysis_enc.c
+++ b/src/3rdparty/libwebp/src/enc/analysis_enc.c
@@ -126,16 +126,6 @@ static void InitHistogram(VP8Histogram* const histo) {
   histo->last_non_zero = 1;
 }
 
-static void MergeHistograms(const VP8Histogram* const in,
-                            VP8Histogram* const out) {
-  if (in->max_value > out->max_value) {
-    out->max_value = in->max_value;
-  }
-  if (in->last_non_zero > out->last_non_zero) {
-    out->last_non_zero = in->last_non_zero;
-  }
-}
-
 //------------------------------------------------------------------------------
 // Simplified k-Means, to assign Nb segments based on alpha-histogram
 
@@ -285,49 +275,6 @@ static int FastMBAnalyze(VP8EncIterator* const it) {
   return 0;
 }
 
-static int MBAnalyzeBestIntra4Mode(VP8EncIterator* const it,
-                                   int best_alpha) {
-  uint8_t modes[16];
-  const int max_mode = MAX_INTRA4_MODE;
-  int i4_alpha;
-  VP8Histogram total_histo;
-  int cur_histo = 0;
-  InitHistogram(&total_histo);
-
-  VP8IteratorStartI4(it);
-  do {
-    int mode;
-    int best_mode_alpha = DEFAULT_ALPHA;
-    VP8Histogram histos[2];
-    const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC + VP8Scan[it->i4_];
-
-    VP8MakeIntra4Preds(it);
-    for (mode = 0; mode < max_mode; ++mode) {
-      int alpha;
-
-      InitHistogram(&histos[cur_histo]);
-      VP8CollectHistogram(src, it->yuv_p_ + VP8I4ModeOffsets[mode],
-                          0, 1, &histos[cur_histo]);
-      alpha = GetAlpha(&histos[cur_histo]);
-      if (IS_BETTER_ALPHA(alpha, best_mode_alpha)) {
-        best_mode_alpha = alpha;
-        modes[it->i4_] = mode;
-        cur_histo ^= 1;   // keep track of best histo so far.
-      }
-    }
-    // accumulate best histogram
-    MergeHistograms(&histos[cur_histo ^ 1], &total_histo);
-    // Note: we reuse the original samples for predictors
-  } while (VP8IteratorRotateI4(it, it->yuv_in_ + Y_OFF_ENC));
-
-  i4_alpha = GetAlpha(&total_histo);
-  if (IS_BETTER_ALPHA(i4_alpha, best_alpha)) {
-    VP8SetIntra4Mode(it, modes);
-    best_alpha = i4_alpha;
-  }
-  return best_alpha;
-}
-
 static int MBAnalyzeBestUVMode(VP8EncIterator* const it) {
   int best_alpha = DEFAULT_ALPHA;
   int smallest_alpha = 0;
@@ -371,13 +318,6 @@ static void MBAnalyze(VP8EncIterator* const it,
     best_alpha = FastMBAnalyze(it);
   } else {
     best_alpha = MBAnalyzeBestIntra16Mode(it);
-    if (enc->method_ >= 5) {
-      // We go and make a fast decision for intra4/intra16.
-      // It's usually not a good and definitive pick, but helps seeding the
-      // stats about level bit-cost.
-      // TODO(skal): improve criterion.
-      best_alpha = MBAnalyzeBestIntra4Mode(it, best_alpha);
-    }
   }
   best_uv_alpha = MBAnalyzeBestUVMode(it);
 
diff --git a/src/3rdparty/libwebp/src/enc/backward_references_enc.c b/src/3rdparty/libwebp/src/enc/backward_references_enc.c
index d445b40..519b36a 100644
--- a/src/3rdparty/libwebp/src/enc/backward_references_enc.c
+++ b/src/3rdparty/libwebp/src/enc/backward_references_enc.c
@@ -11,13 +11,14 @@
 //
 
 #include <assert.h>
+#include <float.h>
 #include <math.h>
 
-#include "src/enc/backward_references_enc.h"
-#include "src/enc/histogram_enc.h"
+#include "src/dsp/dsp.h"
 #include "src/dsp/lossless.h"
 #include "src/dsp/lossless_common.h"
-#include "src/dsp/dsp.h"
+#include "src/enc/backward_references_enc.h"
+#include "src/enc/histogram_enc.h"
 #include "src/utils/color_cache_utils.h"
 #include "src/utils/utils.h"
 
@@ -103,6 +104,20 @@ void VP8LBackwardRefsClear(VP8LBackwardRefs* const refs) {
   }
 }
 
+// Swaps the content of two VP8LBackwardRefs.
+static void BackwardRefsSwap(VP8LBackwardRefs* const refs1,
+                             VP8LBackwardRefs* const refs2) {
+  const int point_to_refs1 =
+      (refs1->tail_ != NULL && refs1->tail_ == &refs1->refs_);
+  const int point_to_refs2 =
+      (refs2->tail_ != NULL && refs2->tail_ == &refs2->refs_);
+  const VP8LBackwardRefs tmp = *refs1;
+  *refs1 = *refs2;
+  *refs2 = tmp;
+  if (point_to_refs2) refs1->tail_ = &refs1->refs_;
+  if (point_to_refs1) refs2->tail_ = &refs2->refs_;
+}
+
 void VP8LBackwardRefsInit(VP8LBackwardRefs* const refs, int block_size) {
   assert(refs != NULL);
   memset(refs, 0, sizeof(*refs));
@@ -154,6 +169,22 @@ static PixOrCopyBlock* BackwardRefsNewBlock(VP8LBackwardRefs* const refs) {
   return b;
 }
 
+// Return 1 on success, 0 on error.
+static int BackwardRefsClone(const VP8LBackwardRefs* const from,
+                             VP8LBackwardRefs* const to) {
+  const PixOrCopyBlock* block_from = from->refs_;
+  VP8LClearBackwardRefs(to);
+  while (block_from != NULL) {
+    PixOrCopyBlock* const block_to = BackwardRefsNewBlock(to);
+    if (block_to == NULL) return 0;
+    memcpy(block_to->start_, block_from->start_,
+           block_from->size_ * sizeof(PixOrCopy));
+    block_to->size_ = block_from->size_;
+    block_from = block_from->next_;
+  }
+  return 1;
+}
+
 extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
                                       const PixOrCopy v);
 void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
@@ -753,12 +784,18 @@ static int CalculateBestCacheSize(const uint32_t* argb, int quality,
         }
       }
     } else {
+      int code, extra_bits, extra_bits_value;
       // We should compute the contribution of the (distance,length)
       // histograms but those are the same independently from the cache size.
       // As those constant contributions are in the end added to the other
-      // histogram contributions, we can safely ignore them.
+      // histogram contributions, we can ignore them, except for the length
+      // prefix that is part of the literal_ histogram.
       int len = PixOrCopyLength(v);
       uint32_t argb_prev = *argb ^ 0xffffffffu;
+      VP8LPrefixEncode(len, &code, &extra_bits, &extra_bits_value);
+      for (i = 0; i <= cache_bits_max; ++i) {
+        ++histos[i]->literal_[NUM_LITERAL_CODES + code];
+      }
       // Update the color caches.
       do {
         if (*argb != argb_prev) {
@@ -842,16 +879,21 @@ extern int VP8LBackwardReferencesTraceBackwards(
     int xsize, int ysize, const uint32_t* const argb, int cache_bits,
     const VP8LHashChain* const hash_chain,
     const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
-static VP8LBackwardRefs* GetBackwardReferences(
-    int width, int height, const uint32_t* const argb, int quality,
-    int lz77_types_to_try, int* const cache_bits,
-    const VP8LHashChain* const hash_chain, VP8LBackwardRefs* best,
-    VP8LBackwardRefs* worst) {
-  const int cache_bits_initial = *cache_bits;
-  double bit_cost_best = -1;
+static int GetBackwardReferences(int width, int height,
+                                 const uint32_t* const argb, int quality,
+                                 int lz77_types_to_try, int cache_bits_max,
+                                 int do_no_cache,
+                                 const VP8LHashChain* const hash_chain,
+                                 VP8LBackwardRefs* const refs,
+                                 int* const cache_bits_best) {
   VP8LHistogram* histo = NULL;
-  int lz77_type, lz77_type_best = 0;
+  int i, lz77_type;
+  // Index 0 is for a color cache, index 1 for no cache (if needed).
+  int lz77_types_best[2] = {0, 0};
+  double bit_costs_best[2] = {DBL_MAX, DBL_MAX};
   VP8LHashChain hash_chain_box;
+  VP8LBackwardRefs* const refs_tmp = &refs[do_no_cache ? 2 : 1];
+  int status = 0;
   memset(&hash_chain_box, 0, sizeof(hash_chain_box));
 
   histo = VP8LAllocateHistogram(MAX_COLOR_CACHE_BITS);
@@ -860,86 +902,129 @@ static VP8LBackwardRefs* GetBackwardReferences(
   for (lz77_type = 1; lz77_types_to_try;
        lz77_types_to_try &= ~lz77_type, lz77_type <<= 1) {
     int res = 0;
-    double bit_cost;
-    int cache_bits_tmp = cache_bits_initial;
+    double bit_cost = 0.;
     if ((lz77_types_to_try & lz77_type) == 0) continue;
     switch (lz77_type) {
       case kLZ77RLE:
-        res = BackwardReferencesRle(width, height, argb, 0, worst);
+        res = BackwardReferencesRle(width, height, argb, 0, refs_tmp);
         break;
       case kLZ77Standard:
         // Compute LZ77 with no cache (0 bits), as the ideal LZ77 with a color
         // cache is not that different in practice.
-        res = BackwardReferencesLz77(width, height, argb, 0, hash_chain, worst);
+        res = BackwardReferencesLz77(width, height, argb, 0, hash_chain,
+                                     refs_tmp);
         break;
       case kLZ77Box:
         if (!VP8LHashChainInit(&hash_chain_box, width * height)) goto Error;
         res = BackwardReferencesLz77Box(width, height, argb, 0, hash_chain,
-                                        &hash_chain_box, worst);
+                                        &hash_chain_box, refs_tmp);
         break;
       default:
         assert(0);
     }
     if (!res) goto Error;
 
-    // Next, try with a color cache and update the references.
-    if (!CalculateBestCacheSize(argb, quality, worst, &cache_bits_tmp)) {
-      goto Error;
-    }
-    if (cache_bits_tmp > 0) {
-      if (!BackwardRefsWithLocalCache(argb, cache_bits_tmp, worst)) {
-        goto Error;
+    // Start with the no color cache case.
+    for (i = 1; i >= 0; --i) {
+      int cache_bits = (i == 1) ? 0 : cache_bits_max;
+
+      if (i == 1 && !do_no_cache) continue;
+
+      if (i == 0) {
+        // Try with a color cache.
+        if (!CalculateBestCacheSize(argb, quality, refs_tmp, &cache_bits)) {
+          goto Error;
+        }
+        if (cache_bits > 0) {
+          if (!BackwardRefsWithLocalCache(argb, cache_bits, refs_tmp)) {
+            goto Error;
+          }
+        }
       }
-    }
 
-    // Keep the best backward references.
-    VP8LHistogramCreate(histo, worst, cache_bits_tmp);
-    bit_cost = VP8LHistogramEstimateBits(histo);
-    if (lz77_type_best == 0 || bit_cost < bit_cost_best) {
-      VP8LBackwardRefs* const tmp = worst;
-      worst = best;
-      best = tmp;
-      bit_cost_best = bit_cost;
-      *cache_bits = cache_bits_tmp;
-      lz77_type_best = lz77_type;
+      if (i == 0 && do_no_cache && cache_bits == 0) {
+        // No need to re-compute bit_cost as it was computed at i == 1.
+      } else {
+        VP8LHistogramCreate(histo, refs_tmp, cache_bits);
+        bit_cost = VP8LHistogramEstimateBits(histo);
+      }
+
+      if (bit_cost < bit_costs_best[i]) {
+        if (i == 1) {
+          // Do not swap as the full cache analysis would have the wrong
+          // VP8LBackwardRefs to start with.
+          if (!BackwardRefsClone(refs_tmp, &refs[1])) goto Error;
+        } else {
+          BackwardRefsSwap(refs_tmp, &refs[0]);
+        }
+        bit_costs_best[i] = bit_cost;
+        lz77_types_best[i] = lz77_type;
+        if (i == 0) *cache_bits_best = cache_bits;
+      }
     }
   }
-  assert(lz77_type_best > 0);
+  assert(lz77_types_best[0] > 0);
+  assert(!do_no_cache || lz77_types_best[1] > 0);
 
   // Improve on simple LZ77 but only for high quality (TraceBackwards is
   // costly).
-  if ((lz77_type_best == kLZ77Standard || lz77_type_best == kLZ77Box) &&
-      quality >= 25) {
-    const VP8LHashChain* const hash_chain_tmp =
-        (lz77_type_best == kLZ77Standard) ? hash_chain : &hash_chain_box;
-    if (VP8LBackwardReferencesTraceBackwards(width, height, argb, *cache_bits,
-                                             hash_chain_tmp, best, worst)) {
-      double bit_cost_trace;
-      VP8LHistogramCreate(histo, worst, *cache_bits);
-      bit_cost_trace = VP8LHistogramEstimateBits(histo);
-      if (bit_cost_trace < bit_cost_best) best = worst;
+  for (i = 1; i >= 0; --i) {
+    if (i == 1 && !do_no_cache) continue;
+    if ((lz77_types_best[i] == kLZ77Standard ||
+         lz77_types_best[i] == kLZ77Box) &&
+        quality >= 25) {
+      const VP8LHashChain* const hash_chain_tmp =
+          (lz77_types_best[i] == kLZ77Standard) ? hash_chain : &hash_chain_box;
+      const int cache_bits = (i == 1) ? 0 : *cache_bits_best;
+      if (VP8LBackwardReferencesTraceBackwards(width, height, argb, cache_bits,
+                                               hash_chain_tmp, &refs[i],
+                                               refs_tmp)) {
+        double bit_cost_trace;
+        VP8LHistogramCreate(histo, refs_tmp, cache_bits);
+        bit_cost_trace = VP8LHistogramEstimateBits(histo);
+        if (bit_cost_trace < bit_costs_best[i]) {
+          BackwardRefsSwap(refs_tmp, &refs[i]);
+        }
+      }
     }
-  }
 
-  BackwardReferences2DLocality(width, best);
+    BackwardReferences2DLocality(width, &refs[i]);
+
+    if (i == 1 && lz77_types_best[0] == lz77_types_best[1] &&
+        *cache_bits_best == 0) {
+      // If the best cache size is 0 and we have the same best LZ77, just copy
+      // the data over and stop here.
+      if (!BackwardRefsClone(&refs[1], &refs[0])) goto Error;
+      break;
+    }
+  }
+  status = 1;
 
 Error:
   VP8LHashChainClear(&hash_chain_box);
   VP8LFreeHistogram(histo);
-  return best;
+  return status;
 }
 
-VP8LBackwardRefs* VP8LGetBackwardReferences(
+WebPEncodingError VP8LGetBackwardReferences(
     int width, int height, const uint32_t* const argb, int quality,
-    int low_effort, int lz77_types_to_try, int* const cache_bits,
-    const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs_tmp1,
-    VP8LBackwardRefs* const refs_tmp2) {
+    int low_effort, int lz77_types_to_try, int cache_bits_max, int do_no_cache,
+    const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs,
+    int* const cache_bits_best) {
   if (low_effort) {
-    return GetBackwardReferencesLowEffort(width, height, argb, cache_bits,
-                                          hash_chain, refs_tmp1);
+    VP8LBackwardRefs* refs_best;
+    *cache_bits_best = cache_bits_max;
+    refs_best = GetBackwardReferencesLowEffort(
+        width, height, argb, cache_bits_best, hash_chain, refs);
+    if (refs_best == NULL) return VP8_ENC_ERROR_OUT_OF_MEMORY;
+    // Set it in first position.
+    BackwardRefsSwap(refs_best, &refs[0]);
   } else {
-    return GetBackwardReferences(width, height, argb, quality,
-                                 lz77_types_to_try, cache_bits, hash_chain,
-                                 refs_tmp1, refs_tmp2);
+    if (!GetBackwardReferences(width, height, argb, quality, lz77_types_to_try,
+                               cache_bits_max, do_no_cache, hash_chain, refs,
+                               cache_bits_best)) {
+      return VP8_ENC_ERROR_OUT_OF_MEMORY;
+    }
   }
+  return VP8_ENC_OK;
 }
diff --git a/src/3rdparty/libwebp/src/enc/backward_references_enc.h b/src/3rdparty/libwebp/src/enc/backward_references_enc.h
index 103ddfd..4c0267b 100644
--- a/src/3rdparty/libwebp/src/enc/backward_references_enc.h
+++ b/src/3rdparty/libwebp/src/enc/backward_references_enc.h
@@ -16,6 +16,7 @@
 #include <assert.h>
 #include <stdlib.h>
 #include "src/webp/types.h"
+#include "src/webp/encode.h"
 #include "src/webp/format_constants.h"
 
 #ifdef __cplusplus
@@ -218,14 +219,19 @@ enum VP8LLZ77Type {
 // Evaluates best possible backward references for specified quality.
 // The input cache_bits to 'VP8LGetBackwardReferences' sets the maximum cache
 // bits to use (passing 0 implies disabling the local color cache).
-// The optimal cache bits is evaluated and set for the *cache_bits parameter.
-// The return value is the pointer to the best of the two backward refs viz,
-// refs[0] or refs[1].
-VP8LBackwardRefs* VP8LGetBackwardReferences(
+// The optimal cache bits is evaluated and set for the *cache_bits_best
+// parameter with the matching refs_best.
+// If do_no_cache == 0, refs is an array of 2 values and the best
+// VP8LBackwardRefs is put in the first element.
+// If do_no_cache != 0, refs is an array of 3 values and the best
+// VP8LBackwardRefs is put in the first element, the best value with no-cache in
+// the second element.
+// In both cases, the last element is used as temporary internally.
+WebPEncodingError VP8LGetBackwardReferences(
     int width, int height, const uint32_t* const argb, int quality,
-    int low_effort, int lz77_types_to_try, int* const cache_bits,
-    const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs_tmp1,
-    VP8LBackwardRefs* const refs_tmp2);
+    int low_effort, int lz77_types_to_try, int cache_bits_max, int do_no_cache,
+    const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs,
+    int* const cache_bits_best);
 
 #ifdef __cplusplus
 }
diff --git a/src/3rdparty/libwebp/src/enc/config_enc.c b/src/3rdparty/libwebp/src/enc/config_enc.c
index 9d48289..3518b41 100644
--- a/src/3rdparty/libwebp/src/enc/config_enc.c
+++ b/src/3rdparty/libwebp/src/enc/config_enc.c
@@ -39,6 +39,8 @@ int WebPConfigInitInternal(WebPConfig* config,
   config->partitions = 0;
   config->segments = 4;
   config->pass = 1;
+  config->qmin = 0;
+  config->qmax = 100;
   config->show_compressed = 0;
   config->preprocessing = 0;
   config->autofilter = 0;
@@ -106,6 +108,9 @@ int WebPValidateConfig(const WebPConfig* config) {
   if (config->filter_type < 0 || config->filter_type > 1) return 0;
   if (config->autofilter < 0 || config->autofilter > 1) return 0;
   if (config->pass < 1 || config->pass > 10) return 0;
+  if (config->qmin < 0 || config->qmax > 100 || config->qmin > config->qmax) {
+    return 0;
+  }
   if (config->show_compressed < 0 || config->show_compressed > 1) return 0;
   if (config->preprocessing < 0 || config->preprocessing > 7) return 0;
   if (config->partitions < 0 || config->partitions > 3) return 0;
diff --git a/src/3rdparty/libwebp/src/enc/frame_enc.c b/src/3rdparty/libwebp/src/enc/frame_enc.c
index 1aec376..af538d8 100644
--- a/src/3rdparty/libwebp/src/enc/frame_enc.c
+++ b/src/3rdparty/libwebp/src/enc/frame_enc.c
@@ -31,10 +31,15 @@
 // we allow 2k of extra head-room in PARTITION0 limit.
 #define PARTITION0_SIZE_LIMIT ((VP8_MAX_PARTITION0_SIZE - 2048ULL) << 11)
 
+static float Clamp(float v, float min, float max) {
+  return (v < min) ? min : (v > max) ? max : v;
+}
+
 typedef struct {  // struct for organizing convergence in either size or PSNR
   int is_first;
   float dq;
   float q, last_q;
+  float qmin, qmax;
   double value, last_value;   // PSNR or size
   double target;
   int do_size_search;
@@ -47,7 +52,9 @@ static int InitPassStats(const VP8Encoder* const enc, PassStats* const s) {
 
   s->is_first = 1;
   s->dq = 10.f;
-  s->q = s->last_q = enc->config_->quality;
+  s->qmin = 1.f * enc->config_->qmin;
+  s->qmax = 1.f * enc->config_->qmax;
+  s->q = s->last_q = Clamp(enc->config_->quality, s->qmin, s->qmax);
   s->target = do_size_search ? (double)target_size
             : (target_PSNR > 0.) ? target_PSNR
             : 40.;   // default, just in case
@@ -56,10 +63,6 @@ static int InitPassStats(const VP8Encoder* const enc, PassStats* const s) {
   return do_size_search;
 }
 
-static float Clamp(float v, float min, float max) {
-  return (v < min) ? min : (v > max) ? max : v;
-}
-
 static float ComputeNextQ(PassStats* const s) {
   float dq;
   if (s->is_first) {
@@ -75,7 +78,7 @@ static float ComputeNextQ(PassStats* const s) {
   s->dq = Clamp(dq, -30.f, 30.f);
   s->last_q = s->q;
   s->last_value = s->value;
-  s->q = Clamp(s->q + s->dq, 0.f, 100.f);
+  s->q = Clamp(s->q + s->dq, s->qmin, s->qmax);
   return s->q;
 }
 
@@ -848,9 +851,10 @@ int VP8EncTokenLoop(VP8Encoder* const enc) {
     }
 
 #if (DEBUG_SEARCH > 0)
-    printf("#%2d metric:%.1lf -> %.1lf   last_q=%.2lf q=%.2lf dq=%.2lf\n",
+    printf("#%2d metric:%.1lf -> %.1lf   last_q=%.2lf q=%.2lf dq=%.2lf "
+           " range:[%.1f, %.1f]\n",
            num_pass_left, stats.last_value, stats.value,
-           stats.last_q, stats.q, stats.dq);
+           stats.last_q, stats.q, stats.dq, stats.qmin, stats.qmax);
 #endif
     if (enc->max_i4_header_bits_ > 0 && size_p0 > PARTITION0_SIZE_LIMIT) {
       ++num_pass_left;
diff --git a/src/3rdparty/libwebp/src/enc/histogram_enc.c b/src/3rdparty/libwebp/src/enc/histogram_enc.c
index a4e6bf3..38a0ceb 100644
--- a/src/3rdparty/libwebp/src/enc/histogram_enc.c
+++ b/src/3rdparty/libwebp/src/enc/histogram_enc.c
@@ -208,6 +208,7 @@ void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram* const histo,
   } else if (PixOrCopyIsCacheIdx(v)) {
     const int literal_ix =
         NUM_LITERAL_CODES + NUM_LENGTH_CODES + PixOrCopyCacheIdx(v);
+    assert(histo->palette_code_bits_ != 0);
     ++histo->literal_[literal_ix];
   } else {
     int code, extra_bits;
@@ -1170,13 +1171,15 @@ static void RemoveEmptyHistograms(VP8LHistogramSet* const image_histo) {
 int VP8LGetHistoImageSymbols(int xsize, int ysize,
                              const VP8LBackwardRefs* const refs,
                              int quality, int low_effort,
-                             int histo_bits, int cache_bits,
+                             int histogram_bits, int cache_bits,
                              VP8LHistogramSet* const image_histo,
                              VP8LHistogram* const tmp_histo,
                              uint16_t* const histogram_symbols) {
   int ok = 0;
-  const int histo_xsize = histo_bits ? VP8LSubSampleSize(xsize, histo_bits) : 1;
-  const int histo_ysize = histo_bits ? VP8LSubSampleSize(ysize, histo_bits) : 1;
+  const int histo_xsize =
+      histogram_bits ? VP8LSubSampleSize(xsize, histogram_bits) : 1;
+  const int histo_ysize =
+      histogram_bits ? VP8LSubSampleSize(ysize, histogram_bits) : 1;
   const int image_histo_raw_size = histo_xsize * histo_ysize;
   VP8LHistogramSet* const orig_histo =
       VP8LAllocateHistogramSet(image_histo_raw_size, cache_bits);
@@ -1192,7 +1195,7 @@ int VP8LGetHistoImageSymbols(int xsize, int ysize,
   if (orig_histo == NULL || map_tmp == NULL) goto Error;
 
   // Construct the histograms from backward references.
-  HistogramBuild(xsize, histo_bits, refs, orig_histo);
+  HistogramBuild(xsize, histogram_bits, refs, orig_histo);
   // Copies the histograms and computes its bit_cost.
   // histogram_symbols is optimized
   HistogramCopyAndAnalyze(orig_histo, image_histo, &num_used,
diff --git a/src/3rdparty/libwebp/src/enc/histogram_enc.h b/src/3rdparty/libwebp/src/enc/histogram_enc.h
index 54c2d21..c3428b5 100644
--- a/src/3rdparty/libwebp/src/enc/histogram_enc.h
+++ b/src/3rdparty/libwebp/src/enc/histogram_enc.h
@@ -64,8 +64,8 @@ void VP8LHistogramCreate(VP8LHistogram* const p,
                          const VP8LBackwardRefs* const refs,
                          int palette_code_bits);
 
-// Return the size of the histogram for a given palette_code_bits.
-int VP8LGetHistogramSize(int palette_code_bits);
+// Return the size of the histogram for a given cache_bits.
+int VP8LGetHistogramSize(int cache_bits);
 
 // Set the palette_code_bits and reset the stats.
 // If init_arrays is true, the arrays are also filled with 0's.
@@ -110,7 +110,7 @@ int VP8LGetHistoImageSymbols(int xsize, int ysize,
                              const VP8LBackwardRefs* const refs,
                              int quality, int low_effort,
                              int histogram_bits, int cache_bits,
-                             VP8LHistogramSet* const image_in,
+                             VP8LHistogramSet* const image_histo,
                              VP8LHistogram* const tmp_histo,
                              uint16_t* const histogram_symbols);
 
diff --git a/src/3rdparty/libwebp/src/enc/picture_csp_enc.c b/src/3rdparty/libwebp/src/enc/picture_csp_enc.c
index 718e014..35eede9 100644
--- a/src/3rdparty/libwebp/src/enc/picture_csp_enc.c
+++ b/src/3rdparty/libwebp/src/enc/picture_csp_enc.c
@@ -61,16 +61,14 @@ static int CheckNonOpaque(const uint8_t* alpha, int width, int height,
 // Checking for the presence of non-opaque alpha.
 int WebPPictureHasTransparency(const WebPPicture* picture) {
   if (picture == NULL) return 0;
-  if (!picture->use_argb) {
-    return CheckNonOpaque(picture->a, picture->width, picture->height,
-                          1, picture->a_stride);
-  } else {
+  if (picture->use_argb) {
     const int alpha_offset = ALPHA_OFFSET;
     return CheckNonOpaque((const uint8_t*)picture->argb + alpha_offset,
                           picture->width, picture->height,
                           4, picture->argb_stride * sizeof(*picture->argb));
   }
-  return 0;
+  return CheckNonOpaque(picture->a, picture->width, picture->height,
+                        1, picture->a_stride);
 }
 
 //------------------------------------------------------------------------------
@@ -90,8 +88,9 @@ int WebPPictureHasTransparency(const WebPPicture* picture) {
 static int kLinearToGammaTab[kGammaTabSize + 1];
 static uint16_t kGammaToLinearTab[256];
 static volatile int kGammaTablesOk = 0;
+static void InitGammaTables(void);
 
-static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTables(void) {
+WEBP_DSP_INIT_FUNC(InitGammaTables) {
   if (!kGammaTablesOk) {
     int v;
     const double scale = (double)(1 << kGammaTabFix) / kGammaScale;
@@ -181,8 +180,9 @@ static uint32_t kLinearToGammaTabS[kGammaTabSize + 2];
 #define GAMMA_TO_LINEAR_BITS 14
 static uint32_t kGammaToLinearTabS[MAX_Y_T + 1];   // size scales with Y_FIX
 static volatile int kGammaTablesSOk = 0;
+static void InitGammaTablesS(void);
 
-static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTablesS(void) {
+WEBP_DSP_INIT_FUNC(InitGammaTablesS) {
   assert(2 * GAMMA_TO_LINEAR_BITS < 32);  // we use uint32_t intermediate values
   if (!kGammaTablesSOk) {
     int v;
diff --git a/src/3rdparty/libwebp/src/enc/picture_rescale_enc.c b/src/3rdparty/libwebp/src/enc/picture_rescale_enc.c
index 58a6ae7..a75f5d9 100644
--- a/src/3rdparty/libwebp/src/enc/picture_rescale_enc.c
+++ b/src/3rdparty/libwebp/src/enc/picture_rescale_enc.c
@@ -164,22 +164,25 @@ int WebPPictureCrop(WebPPicture* pic,
 //------------------------------------------------------------------------------
 // Simple picture rescaler
 
-static void RescalePlane(const uint8_t* src,
-                         int src_width, int src_height, int src_stride,
-                         uint8_t* dst,
-                         int dst_width, int dst_height, int dst_stride,
-                         rescaler_t* const work,
-                         int num_channels) {
+static int RescalePlane(const uint8_t* src,
+                        int src_width, int src_height, int src_stride,
+                        uint8_t* dst,
+                        int dst_width, int dst_height, int dst_stride,
+                        rescaler_t* const work,
+                        int num_channels) {
   WebPRescaler rescaler;
   int y = 0;
-  WebPRescalerInit(&rescaler, src_width, src_height,
-                   dst, dst_width, dst_height, dst_stride,
-                   num_channels, work);
+  if (!WebPRescalerInit(&rescaler, src_width, src_height,
+                        dst, dst_width, dst_height, dst_stride,
+                        num_channels, work)) {
+    return 0;
+  }
   while (y < src_height) {
     y += WebPRescalerImport(&rescaler, src_height - y,
                             src + y * src_stride, src_stride);
     WebPRescalerExport(&rescaler);
   }
+  return 1;
 }
 
 static void AlphaMultiplyARGB(WebPPicture* const pic, int inverse) {
@@ -222,25 +225,28 @@ int WebPPictureRescale(WebPPicture* pic, int width, int height) {
     // If present, we need to rescale alpha first (for AlphaMultiplyY).
     if (pic->a != NULL) {
       WebPInitAlphaProcessing();
-      RescalePlane(pic->a, prev_width, prev_height, pic->a_stride,
-                   tmp.a, width, height, tmp.a_stride, work, 1);
+      if (!RescalePlane(pic->a, prev_width, prev_height, pic->a_stride,
+                        tmp.a, width, height, tmp.a_stride, work, 1)) {
+        return 0;
+      }
     }
 
     // We take transparency into account on the luma plane only. That's not
     // totally exact blending, but still is a good approximation.
     AlphaMultiplyY(pic, 0);
-    RescalePlane(pic->y, prev_width, prev_height, pic->y_stride,
-                 tmp.y, width, height, tmp.y_stride, work, 1);
+    if (!RescalePlane(pic->y, prev_width, prev_height, pic->y_stride,
+                      tmp.y, width, height, tmp.y_stride, work, 1) ||
+        !RescalePlane(pic->u,
+                      HALVE(prev_width), HALVE(prev_height), pic->uv_stride,
+                      tmp.u,
+                      HALVE(width), HALVE(height), tmp.uv_stride, work, 1) ||
+        !RescalePlane(pic->v,
+                      HALVE(prev_width), HALVE(prev_height), pic->uv_stride,
+                      tmp.v,
+                      HALVE(width), HALVE(height), tmp.uv_stride, work, 1)) {
+      return 0;
+    }
     AlphaMultiplyY(&tmp, 1);
-
-    RescalePlane(pic->u,
-                 HALVE(prev_width), HALVE(prev_height), pic->uv_stride,
-                 tmp.u,
-                 HALVE(width), HALVE(height), tmp.uv_stride, work, 1);
-    RescalePlane(pic->v,
-                 HALVE(prev_width), HALVE(prev_height), pic->uv_stride,
-                 tmp.v,
-                 HALVE(width), HALVE(height), tmp.uv_stride, work, 1);
   } else {
     work = (rescaler_t*)WebPSafeMalloc(2ULL * width * 4, sizeof(*work));
     if (work == NULL) {
@@ -252,11 +258,12 @@ int WebPPictureRescale(WebPPicture* pic, int width, int height) {
     // the premultiplication afterward (while preserving the alpha channel).
     WebPInitAlphaProcessing();
     AlphaMultiplyARGB(pic, 0);
-    RescalePlane((const uint8_t*)pic->argb, prev_width, prev_height,
-                 pic->argb_stride * 4,
-                 (uint8_t*)tmp.argb, width, height,
-                 tmp.argb_stride * 4,
-                 work, 4);
+    if (!RescalePlane((const uint8_t*)pic->argb, prev_width, prev_height,
+                      pic->argb_stride * 4,
+                      (uint8_t*)tmp.argb, width, height,
+                      tmp.argb_stride * 4, work, 4)) {
+      return 0;
+    }
     AlphaMultiplyARGB(&tmp, 1);
   }
   WebPPictureFree(pic);
diff --git a/src/3rdparty/libwebp/src/enc/picture_tools_enc.c b/src/3rdparty/libwebp/src/enc/picture_tools_enc.c
index d0e8a49..38cb015 100644
--- a/src/3rdparty/libwebp/src/enc/picture_tools_enc.c
+++ b/src/3rdparty/libwebp/src/enc/picture_tools_enc.c
@@ -83,6 +83,19 @@ static int SmoothenBlock(const uint8_t* a_ptr, int a_stride, uint8_t* y_ptr,
   return (count == 0);
 }
 
+void WebPReplaceTransparentPixels(WebPPicture* const pic, uint32_t color) {
+  if (pic != NULL && pic->use_argb) {
+    int y = pic->height;
+    uint32_t* argb = pic->argb;
+    color &= 0xffffffu;   // force alpha=0
+    WebPInitAlphaProcessing();
+    while (y-- > 0) {
+      WebPAlphaReplace(argb, pic->width, color);
+      argb += pic->argb_stride;
+    }
+  }
+}
+
 void WebPCleanupTransparentArea(WebPPicture* pic) {
   int x, y, w, h;
   if (pic == NULL) return;
@@ -165,24 +178,6 @@ void WebPCleanupTransparentArea(WebPPicture* pic) {
 #undef SIZE
 #undef SIZE2
 
-void WebPCleanupTransparentAreaLossless(WebPPicture* const pic) {
-  int x, y, w, h;
-  uint32_t* argb;
-  assert(pic != NULL && pic->use_argb);
-  w = pic->width;
-  h = pic->height;
-  argb = pic->argb;
-
-  for (y = 0; y < h; ++y) {
-    for (x = 0; x < w; ++x) {
-      if ((argb[x] & 0xff000000) == 0) {
-        argb[x] = 0x00000000;
-      }
-    }
-    argb += pic->argb_stride;
-  }
-}
-
 //------------------------------------------------------------------------------
 // Blend color and remove transparency info
 
diff --git a/src/3rdparty/libwebp/src/enc/syntax_enc.c b/src/3rdparty/libwebp/src/enc/syntax_enc.c
index a9e5a6c..e18cf65 100644
--- a/src/3rdparty/libwebp/src/enc/syntax_enc.c
+++ b/src/3rdparty/libwebp/src/enc/syntax_enc.c
@@ -349,7 +349,7 @@ int VP8EncWrite(VP8Encoder* const enc) {
                                        (enc->alpha_data_size_ & 1);
     riff_size += CHUNK_HEADER_SIZE + padded_alpha_size;
   }
-  // Sanity check.
+  // RIFF size should fit in 32-bits.
   if (riff_size > 0xfffffffeU) {
     return WebPEncodingSetError(pic, VP8_ENC_ERROR_FILE_TOO_BIG);
   }
diff --git a/src/3rdparty/libwebp/src/enc/vp8i_enc.h b/src/3rdparty/libwebp/src/enc/vp8i_enc.h
index fedcaee..67e9509 100644
--- a/src/3rdparty/libwebp/src/enc/vp8i_enc.h
+++ b/src/3rdparty/libwebp/src/enc/vp8i_enc.h
@@ -31,8 +31,8 @@ extern "C" {
 
 // version numbers
 #define ENC_MAJ_VERSION 1
-#define ENC_MIN_VERSION 1
-#define ENC_REV_VERSION 0
+#define ENC_MIN_VERSION 2
+#define ENC_REV_VERSION 1
 
 enum { MAX_LF_LEVELS = 64,       // Maximum loop filter level
        MAX_VARIABLE_LEVEL = 67,  // last (inclusive) level with variable cost
@@ -286,8 +286,7 @@ int VP8IteratorNext(VP8EncIterator* const it);
 // save the yuv_out_ boundary values to top_/left_ arrays for next iterations.
 void VP8IteratorSaveBoundary(VP8EncIterator* const it);
 // Report progression based on macroblock rows. Return 0 for user-abort request.
-int VP8IteratorProgress(const VP8EncIterator* const it,
-                        int final_delta_percent);
+int VP8IteratorProgress(const VP8EncIterator* const it, int delta);
 // Intra4x4 iterations
 void VP8IteratorStartI4(VP8EncIterator* const it);
 // returns true if not done.
@@ -505,9 +504,9 @@ int WebPPictureAllocARGB(WebPPicture* const picture, int width, int height);
 // Returns false in case of error (invalid param, out-of-memory).
 int WebPPictureAllocYUVA(WebPPicture* const picture, int width, int height);
 
-// Clean-up the RGB samples under fully transparent area, to help lossless
-// compressibility (no guarantee, though). Assumes that pic->use_argb is true.
-void WebPCleanupTransparentAreaLossless(WebPPicture* const pic);
+// Replace samples that are fully transparent by 'color' to help compressibility
+// (no guarantee, though). Assumes pic->use_argb is true.
+void WebPReplaceTransparentPixels(WebPPicture* const pic, uint32_t color);
 
 //------------------------------------------------------------------------------
 
diff --git a/src/3rdparty/libwebp/src/enc/vp8l_enc.c b/src/3rdparty/libwebp/src/enc/vp8l_enc.c
index 2efd403..e330e71 100644
--- a/src/3rdparty/libwebp/src/enc/vp8l_enc.c
+++ b/src/3rdparty/libwebp/src/enc/vp8l_enc.c
@@ -65,25 +65,22 @@ static WEBP_INLINE void SwapColor(uint32_t* const col1, uint32_t* const col2) {
   *col2 = tmp;
 }
 
-static void GreedyMinimizeDeltas(uint32_t palette[], int num_colors) {
-  // Find greedily always the closest color of the predicted color to minimize
-  // deltas in the palette. This reduces storage needs since the
-  // palette is stored with delta encoding.
-  uint32_t predict = 0x00000000;
-  int i, k;
-  for (i = 0; i < num_colors; ++i) {
-    int best_ix = i;
-    uint32_t best_score = ~0U;
-    for (k = i; k < num_colors; ++k) {
-      const uint32_t cur_score = PaletteColorDistance(palette[k], predict);
-      if (best_score > cur_score) {
-        best_score = cur_score;
-        best_ix = k;
-      }
+static WEBP_INLINE int SearchColorNoIdx(const uint32_t sorted[], uint32_t color,
+                                        int num_colors) {
+  int low = 0, hi = num_colors;
+  if (sorted[low] == color) return low;  // loop invariant: sorted[low] != color
+  while (1) {
+    const int mid = (low + hi) >> 1;
+    if (sorted[mid] == color) {
+      return mid;
+    } else if (sorted[mid] < color) {
+      low = mid;
+    } else {
+      hi = mid;
     }
-    SwapColor(&palette[best_ix], &palette[i]);
-    predict = palette[i];
   }
+  assert(0);
+  return 0;
 }
 
 // The palette has been sorted by alpha. This function checks if the other
@@ -92,7 +89,8 @@ static void GreedyMinimizeDeltas(uint32_t palette[], int num_colors) {
 // no benefit to re-organize them greedily. A monotonic development
 // would be spotted in green-only situations (like lossy alpha) or gray-scale
 // images.
-static int PaletteHasNonMonotonousDeltas(uint32_t palette[], int num_colors) {
+static int PaletteHasNonMonotonousDeltas(const uint32_t* const palette,
+                                         int num_colors) {
   uint32_t predict = 0x000000;
   int i;
   uint8_t sign_found = 0x00;
@@ -115,28 +113,215 @@ static int PaletteHasNonMonotonousDeltas(uint32_t palette[], int num_colors) {
   return (sign_found & (sign_found << 1)) != 0;  // two consequent signs.
 }
 
+static void PaletteSortMinimizeDeltas(const uint32_t* const palette_sorted,
+                                      int num_colors, uint32_t* const palette) {
+  uint32_t predict = 0x00000000;
+  int i, k;
+  memcpy(palette, palette_sorted, num_colors * sizeof(*palette));
+  if (!PaletteHasNonMonotonousDeltas(palette_sorted, num_colors)) return;
+  // Find greedily always the closest color of the predicted color to minimize
+  // deltas in the palette. This reduces storage needs since the
+  // palette is stored with delta encoding.
+  for (i = 0; i < num_colors; ++i) {
+    int best_ix = i;
+    uint32_t best_score = ~0U;
+    for (k = i; k < num_colors; ++k) {
+      const uint32_t cur_score = PaletteColorDistance(palette[k], predict);
+      if (best_score > cur_score) {
+        best_score = cur_score;
+        best_ix = k;
+      }
+    }
+    SwapColor(&palette[best_ix], &palette[i]);
+    predict = palette[i];
+  }
+}
+
+// Sort palette in increasing order and prepare an inverse mapping array.
+static void PrepareMapToPalette(const uint32_t palette[], uint32_t num_colors,
+                                uint32_t sorted[], uint32_t idx_map[]) {
+  uint32_t i;
+  memcpy(sorted, palette, num_colors * sizeof(*sorted));
+  qsort(sorted, num_colors, sizeof(*sorted), PaletteCompareColorsForQsort);
+  for (i = 0; i < num_colors; ++i) {
+    idx_map[SearchColorNoIdx(sorted, palette[i], num_colors)] = i;
+  }
+}
+
 // -----------------------------------------------------------------------------
-// Palette
+// Modified Zeng method from "A Survey on Palette Reordering
+// Methods for Improving the Compression of Color-Indexed Images" by Armando J.
+// Pinho and Antonio J. R. Neves.
+
+// Finds the biggest cooccurrence in the matrix.
+static void CoOccurrenceFindMax(const uint32_t* const cooccurrence,
+                                uint32_t num_colors, uint8_t* const c1,
+                                uint8_t* const c2) {
+  // Find the index that is most frequently located adjacent to other
+  // (different) indexes.
+  uint32_t best_sum = 0u;
+  uint32_t i, j, best_cooccurrence;
+  *c1 = 0u;
+  for (i = 0; i < num_colors; ++i) {
+    uint32_t sum = 0;
+    for (j = 0; j < num_colors; ++j) sum += cooccurrence[i * num_colors + j];
+    if (sum > best_sum) {
+      best_sum = sum;
+      *c1 = i;
+    }
+  }
+  // Find the index that is most frequently found adjacent to *c1.
+  *c2 = 0u;
+  best_cooccurrence = 0u;
+  for (i = 0; i < num_colors; ++i) {
+    if (cooccurrence[*c1 * num_colors + i] > best_cooccurrence) {
+      best_cooccurrence = cooccurrence[*c1 * num_colors + i];
+      *c2 = i;
+    }
+  }
+  assert(*c1 != *c2);
+}
 
-// If number of colors in the image is less than or equal to MAX_PALETTE_SIZE,
-// creates a palette and returns true, else returns false.
-static int AnalyzeAndCreatePalette(const WebPPicture* const pic,
-                                   int low_effort,
-                                   uint32_t palette[MAX_PALETTE_SIZE],
-                                   int* const palette_size) {
-  const int num_colors = WebPGetColorPalette(pic, palette);
-  if (num_colors > MAX_PALETTE_SIZE) {
-    *palette_size = 0;
-    return 0;
+// Builds the cooccurrence matrix
+static WebPEncodingError CoOccurrenceBuild(const WebPPicture* const pic,
+                                           const uint32_t* const palette,
+                                           uint32_t num_colors,
+                                           uint32_t* cooccurrence) {
+  uint32_t *lines, *line_top, *line_current, *line_tmp;
+  int x, y;
+  const uint32_t* src = pic->argb;
+  uint32_t prev_pix = ~src[0];
+  uint32_t prev_idx = 0u;
+  uint32_t idx_map[MAX_PALETTE_SIZE] = {0};
+  uint32_t palette_sorted[MAX_PALETTE_SIZE];
+  lines = (uint32_t*)WebPSafeMalloc(2 * pic->width, sizeof(*lines));
+  if (lines == NULL) return VP8_ENC_ERROR_OUT_OF_MEMORY;
+  line_top = &lines[0];
+  line_current = &lines[pic->width];
+  PrepareMapToPalette(palette, num_colors, palette_sorted, idx_map);
+  for (y = 0; y < pic->height; ++y) {
+    for (x = 0; x < pic->width; ++x) {
+      const uint32_t pix = src[x];
+      if (pix != prev_pix) {
+        prev_idx = idx_map[SearchColorNoIdx(palette_sorted, pix, num_colors)];
+        prev_pix = pix;
+      }
+      line_current[x] = prev_idx;
+      // 4-connectivity is what works best as mentioned in "On the relation
+      // between Memon's and the modified Zeng's palette reordering methods".
+      if (x > 0 && prev_idx != line_current[x - 1]) {
+        const uint32_t left_idx = line_current[x - 1];
+        ++cooccurrence[prev_idx * num_colors + left_idx];
+        ++cooccurrence[left_idx * num_colors + prev_idx];
+      }
+      if (y > 0 && prev_idx != line_top[x]) {
+        const uint32_t top_idx = line_top[x];
+        ++cooccurrence[prev_idx * num_colors + top_idx];
+        ++cooccurrence[top_idx * num_colors + prev_idx];
+      }
+    }
+    line_tmp = line_top;
+    line_top = line_current;
+    line_current = line_tmp;
+    src += pic->argb_stride;
+  }
+  WebPSafeFree(lines);
+  return VP8_ENC_OK;
+}
+
+struct Sum {
+  uint8_t index;
+  uint32_t sum;
+};
+
+// Implements the modified Zeng method from "A Survey on Palette Reordering
+// Methods for Improving the Compression of Color-Indexed Images" by Armando J.
+// Pinho and Antonio J. R. Neves.
+static WebPEncodingError PaletteSortModifiedZeng(
+    const WebPPicture* const pic, const uint32_t* const palette_sorted,
+    uint32_t num_colors, uint32_t* const palette) {
+  uint32_t i, j, ind;
+  uint8_t remapping[MAX_PALETTE_SIZE];
+  uint32_t* cooccurrence;
+  struct Sum sums[MAX_PALETTE_SIZE];
+  uint32_t first, last;
+  uint32_t num_sums;
+  // TODO(vrabaud) check whether one color images should use palette or not.
+  if (num_colors <= 1) return VP8_ENC_OK;
+  // Build the co-occurrence matrix.
+  cooccurrence =
+      (uint32_t*)WebPSafeCalloc(num_colors * num_colors, sizeof(*cooccurrence));
+  if (cooccurrence == NULL) return VP8_ENC_ERROR_OUT_OF_MEMORY;
+  if (CoOccurrenceBuild(pic, palette_sorted, num_colors, cooccurrence) !=
+      VP8_ENC_OK) {
+    WebPSafeFree(cooccurrence);
+    return VP8_ENC_ERROR_OUT_OF_MEMORY;
+  }
+
+  // Initialize the mapping list with the two best indices.
+  CoOccurrenceFindMax(cooccurrence, num_colors, &remapping[0], &remapping[1]);
+
+  // We need to append and prepend to the list of remapping. To this end, we
+  // actually define the next start/end of the list as indices in a vector (with
+  // a wrap around when the end is reached).
+  first = 0;
+  last = 1;
+  num_sums = num_colors - 2;  // -2 because we know the first two values
+  if (num_sums > 0) {
+    // Initialize the sums with the first two remappings and find the best one
+    struct Sum* best_sum = &sums[0];
+    best_sum->index = 0u;
+    best_sum->sum = 0u;
+    for (i = 0, j = 0; i < num_colors; ++i) {
+      if (i == remapping[0] || i == remapping[1]) continue;
+      sums[j].index = i;
+      sums[j].sum = cooccurrence[i * num_colors + remapping[0]] +
+                    cooccurrence[i * num_colors + remapping[1]];
+      if (sums[j].sum > best_sum->sum) best_sum = &sums[j];
+      ++j;
+    }
+
+    while (num_sums > 0) {
+      const uint8_t best_index = best_sum->index;
+      // Compute delta to know if we need to prepend or append the best index.
+      int32_t delta = 0;
+      const int32_t n = num_colors - num_sums;
+      for (ind = first, j = 0; (ind + j) % num_colors != last + 1; ++j) {
+        const uint16_t l_j = remapping[(ind + j) % num_colors];
+        delta += (n - 1 - 2 * (int32_t)j) *
+                 (int32_t)cooccurrence[best_index * num_colors + l_j];
+      }
+      if (delta > 0) {
+        first = (first == 0) ? num_colors - 1 : first - 1;
+        remapping[first] = best_index;
+      } else {
+        ++last;
+        remapping[last] = best_index;
+      }
+      // Remove best_sum from sums.
+      *best_sum = sums[num_sums - 1];
+      --num_sums;
+      // Update all the sums and find the best one.
+      best_sum = &sums[0];
+      for (i = 0; i < num_sums; ++i) {
+        sums[i].sum += cooccurrence[best_index * num_colors + sums[i].index];
+        if (sums[i].sum > best_sum->sum) best_sum = &sums[i];
+      }
+    }
   }
-  *palette_size = num_colors;
-  qsort(palette, num_colors, sizeof(*palette), PaletteCompareColorsForQsort);
-  if (!low_effort && PaletteHasNonMonotonousDeltas(palette, num_colors)) {
-    GreedyMinimizeDeltas(palette, num_colors);
+  assert((last + 1) % num_colors == first);
+  WebPSafeFree(cooccurrence);
+
+  // Re-map the palette.
+  for (i = 0; i < num_colors; ++i) {
+    palette[i] = palette_sorted[remapping[(first + i) % num_colors]];
   }
-  return 1;
+  return VP8_ENC_OK;
 }
 
+// -----------------------------------------------------------------------------
+// Palette
+
 // These five modes are evaluated and their respective entropy is computed.
 typedef enum {
   kDirect = 0,
@@ -144,9 +329,17 @@ typedef enum {
   kSubGreen = 2,
   kSpatialSubGreen = 3,
   kPalette = 4,
-  kNumEntropyIx = 5
+  kPaletteAndSpatial = 5,
+  kNumEntropyIx = 6
 } EntropyIx;
 
+typedef enum {
+  kSortedDefault = 0,
+  kMinimizeDelta = 1,
+  kModifiedZeng = 2,
+  kUnusedPalette = 3,
+} PaletteSorting;
+
 typedef enum {
   kHistoAlpha = 0,
   kHistoAlphaPred,
@@ -354,14 +547,21 @@ static int GetTransformBits(int method, int histo_bits) {
 }
 
 // Set of parameters to be used in each iteration of the cruncher.
-#define CRUNCH_CONFIGS_LZ77_MAX 2
+#define CRUNCH_SUBCONFIGS_MAX 2
+typedef struct {
+  int lz77_;
+  int do_no_cache_;
+} CrunchSubConfig;
 typedef struct {
   int entropy_idx_;
-  int lz77s_types_to_try_[CRUNCH_CONFIGS_LZ77_MAX];
-  int lz77s_types_to_try_size_;
+  PaletteSorting palette_sorting_type_;
+  CrunchSubConfig sub_configs_[CRUNCH_SUBCONFIGS_MAX];
+  int sub_configs_size_;
 } CrunchConfig;
 
-#define CRUNCH_CONFIGS_MAX kNumEntropyIx
+// +2 because we add a palette sorting configuration for kPalette and
+// kPaletteAndSpatial.
+#define CRUNCH_CONFIGS_MAX (kNumEntropyIx + 2)
 
 static int EncoderAnalyze(VP8LEncoder* const enc,
                           CrunchConfig crunch_configs[CRUNCH_CONFIGS_MAX],
@@ -376,11 +576,20 @@ static int EncoderAnalyze(VP8LEncoder* const enc,
   int i;
   int use_palette;
   int n_lz77s;
+  // If set to 0, analyze the cache with the computed cache value. If 1, also
+  // analyze with no-cache.
+  int do_no_cache = 0;
   assert(pic != NULL && pic->argb != NULL);
 
-  use_palette =
-      AnalyzeAndCreatePalette(pic, low_effort,
-                              enc->palette_, &enc->palette_size_);
+  // Check whether a palette is possible.
+  enc->palette_size_ = WebPGetColorPalette(pic, enc->palette_sorted_);
+  use_palette = (enc->palette_size_ <= MAX_PALETTE_SIZE);
+  if (!use_palette) {
+    enc->palette_size_ = 0;
+  } else {
+    qsort(enc->palette_sorted_, enc->palette_size_,
+          sizeof(*enc->palette_sorted_), PaletteCompareColorsForQsort);
+  }
 
   // Empirical bit sizes.
   enc->histo_bits_ = GetHistoBits(method, use_palette,
@@ -390,6 +599,8 @@ static int EncoderAnalyze(VP8LEncoder* const enc,
   if (low_effort) {
     // AnalyzeEntropy is somewhat slow.
     crunch_configs[0].entropy_idx_ = use_palette ? kPalette : kSpatialSubGreen;
+    crunch_configs[0].palette_sorting_type_ =
+        use_palette ? kSortedDefault : kUnusedPalette;
     n_lz77s = 1;
     *crunch_configs_size = 1;
   } else {
@@ -402,29 +613,59 @@ static int EncoderAnalyze(VP8LEncoder* const enc,
       return 0;
     }
     if (method == 6 && config->quality == 100) {
+      do_no_cache = 1;
       // Go brute force on all transforms.
       *crunch_configs_size = 0;
       for (i = 0; i < kNumEntropyIx; ++i) {
-        if (i != kPalette || use_palette) {
+        // We can only apply kPalette or kPaletteAndSpatial if we can indeed use
+        // a palette.
+        if ((i != kPalette && i != kPaletteAndSpatial) || use_palette) {
           assert(*crunch_configs_size < CRUNCH_CONFIGS_MAX);
-          crunch_configs[(*crunch_configs_size)++].entropy_idx_ = i;
+          crunch_configs[(*crunch_configs_size)].entropy_idx_ = i;
+          if (use_palette && (i == kPalette || i == kPaletteAndSpatial)) {
+            crunch_configs[(*crunch_configs_size)].palette_sorting_type_ =
+                kMinimizeDelta;
+            ++*crunch_configs_size;
+            // Also add modified Zeng's method.
+            crunch_configs[(*crunch_configs_size)].entropy_idx_ = i;
+            crunch_configs[(*crunch_configs_size)].palette_sorting_type_ =
+                kModifiedZeng;
+          } else {
+            crunch_configs[(*crunch_configs_size)].palette_sorting_type_ =
+                kUnusedPalette;
+          }
+          ++*crunch_configs_size;
         }
       }
     } else {
       // Only choose the guessed best transform.
       *crunch_configs_size = 1;
       crunch_configs[0].entropy_idx_ = min_entropy_ix;
+      crunch_configs[0].palette_sorting_type_ =
+          use_palette ? kMinimizeDelta : kUnusedPalette;
+      if (config->quality >= 75 && method == 5) {
+        // Test with and without color cache.
+        do_no_cache = 1;
+        // If we have a palette, also check in combination with spatial.
+        if (min_entropy_ix == kPalette) {
+          *crunch_configs_size = 2;
+          crunch_configs[1].entropy_idx_ = kPaletteAndSpatial;
+          crunch_configs[1].palette_sorting_type_ = kMinimizeDelta;
+        }
+      }
     }
   }
   // Fill in the different LZ77s.
-  assert(n_lz77s <= CRUNCH_CONFIGS_LZ77_MAX);
+  assert(n_lz77s <= CRUNCH_SUBCONFIGS_MAX);
   for (i = 0; i < *crunch_configs_size; ++i) {
     int j;
     for (j = 0; j < n_lz77s; ++j) {
-      crunch_configs[i].lz77s_types_to_try_[j] =
+      assert(j < CRUNCH_SUBCONFIGS_MAX);
+      crunch_configs[i].sub_configs_[j].lz77_ =
           (j == 0) ? kLZ77Standard | kLZ77RLE : kLZ77Box;
+      crunch_configs[i].sub_configs_[j].do_no_cache_ = do_no_cache;
     }
-    crunch_configs[i].lz77s_types_to_try_size_ = n_lz77s;
+    crunch_configs[i].sub_configs_size_ = n_lz77s;
   }
   return 1;
 }
@@ -440,7 +681,7 @@ static int EncoderInit(VP8LEncoder* const enc) {
   int i;
   if (!VP8LHashChainInit(&enc->hash_chain_, pix_cnt)) return 0;
 
-  for (i = 0; i < 3; ++i) VP8LBackwardRefsInit(&enc->refs_[i], refs_block_size);
+  for (i = 0; i < 4; ++i) VP8LBackwardRefsInit(&enc->refs_[i], refs_block_size);
 
   return 1;
 }
@@ -769,13 +1010,10 @@ static WebPEncodingError StoreImageToBitMask(
 }
 
 // Special case of EncodeImageInternal() for cache-bits=0, histo_bits=31
-static WebPEncodingError EncodeImageNoHuffman(VP8LBitWriter* const bw,
-                                              const uint32_t* const argb,
-                                              VP8LHashChain* const hash_chain,
-                                              VP8LBackwardRefs* const refs_tmp1,
-                                              VP8LBackwardRefs* const refs_tmp2,
-                                              int width, int height,
-                                              int quality, int low_effort) {
+static WebPEncodingError EncodeImageNoHuffman(
+    VP8LBitWriter* const bw, const uint32_t* const argb,
+    VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs_array,
+    int width, int height, int quality, int low_effort) {
   int i;
   int max_tokens = 0;
   WebPEncodingError err = VP8_ENC_OK;
@@ -798,13 +1036,11 @@ static WebPEncodingError EncodeImageNoHuffman(VP8LBitWriter* const bw,
     err = VP8_ENC_ERROR_OUT_OF_MEMORY;
     goto Error;
   }
-  refs = VP8LGetBackwardReferences(width, height, argb, quality, 0,
-                                   kLZ77Standard | kLZ77RLE, &cache_bits,
-                                   hash_chain, refs_tmp1, refs_tmp2);
-  if (refs == NULL) {
-    err = VP8_ENC_ERROR_OUT_OF_MEMORY;
-    goto Error;
-  }
+  err = VP8LGetBackwardReferences(
+      width, height, argb, quality, /*low_effort=*/0, kLZ77Standard | kLZ77RLE,
+      cache_bits, /*do_no_cache=*/0, hash_chain, refs_array, &cache_bits);
+  if (err != VP8_ENC_OK) goto Error;
+  refs = &refs_array[0];
   histogram_image = VP8LAllocateHistogramSet(1, cache_bits);
   if (histogram_image == NULL) {
     err = VP8_ENC_ERROR_OUT_OF_MEMORY;
@@ -860,11 +1096,11 @@ static WebPEncodingError EncodeImageNoHuffman(VP8LBitWriter* const bw,
 
 static WebPEncodingError EncodeImageInternal(
     VP8LBitWriter* const bw, const uint32_t* const argb,
-    VP8LHashChain* const hash_chain, VP8LBackwardRefs refs_array[3], int width,
+    VP8LHashChain* const hash_chain, VP8LBackwardRefs refs_array[4], int width,
     int height, int quality, int low_effort, int use_cache,
     const CrunchConfig* const config, int* cache_bits, int histogram_bits,
     size_t init_byte_position, int* const hdr_size, int* const data_size) {
-  WebPEncodingError err = VP8_ENC_OK;
+  WebPEncodingError err = VP8_ENC_ERROR_OUT_OF_MEMORY;
   const uint32_t histogram_image_xysize =
       VP8LSubSampleSize(width, histogram_bits) *
       VP8LSubSampleSize(height, histogram_bits);
@@ -876,103 +1112,103 @@ static WebPEncodingError EncodeImageInternal(
       3ULL * CODE_LENGTH_CODES, sizeof(*huff_tree));
   HuffmanTreeToken* tokens = NULL;
   HuffmanTreeCode* huffman_codes = NULL;
-  VP8LBackwardRefs* refs_best;
-  VP8LBackwardRefs* refs_tmp;
   uint16_t* const histogram_symbols =
       (uint16_t*)WebPSafeMalloc(histogram_image_xysize,
                                 sizeof(*histogram_symbols));
-  int lz77s_idx;
+  int sub_configs_idx;
+  int cache_bits_init, write_histogram_image;
   VP8LBitWriter bw_init = *bw, bw_best;
   int hdr_size_tmp;
+  VP8LHashChain hash_chain_histogram;  // histogram image hash chain
+  size_t bw_size_best = ~(size_t)0;
   assert(histogram_bits >= MIN_HUFFMAN_BITS);
   assert(histogram_bits <= MAX_HUFFMAN_BITS);
   assert(hdr_size != NULL);
   assert(data_size != NULL);
 
-  if (histogram_symbols == NULL) {
-    err = VP8_ENC_ERROR_OUT_OF_MEMORY;
+  // Make sure we can allocate the different objects.
+  memset(&hash_chain_histogram, 0, sizeof(hash_chain_histogram));
+  if (huff_tree == NULL || histogram_symbols == NULL ||
+      !VP8LHashChainInit(&hash_chain_histogram, histogram_image_xysize) ||
+      !VP8LHashChainFill(hash_chain, quality, argb, width, height,
+                         low_effort)) {
     goto Error;
   }
-
   if (use_cache) {
     // If the value is different from zero, it has been set during the
     // palette analysis.
-    if (*cache_bits == 0) *cache_bits = MAX_COLOR_CACHE_BITS;
+    cache_bits_init = (*cache_bits == 0) ? MAX_COLOR_CACHE_BITS : *cache_bits;
   } else {
-    *cache_bits = 0;
+    cache_bits_init = 0;
   }
-  // 'best_refs' is the reference to the best backward refs and points to one
-  // of refs_array[0] or refs_array[1].
-  // Calculate backward references from ARGB image.
-  if (huff_tree == NULL ||
-      !VP8LHashChainFill(hash_chain, quality, argb, width, height,
-                         low_effort) ||
-      !VP8LBitWriterInit(&bw_best, 0) ||
-      (config->lz77s_types_to_try_size_ > 1 &&
+  // If several iterations will happen, clone into bw_best.
+  if (!VP8LBitWriterInit(&bw_best, 0) ||
+      ((config->sub_configs_size_ > 1 ||
+        config->sub_configs_[0].do_no_cache_) &&
        !VP8LBitWriterClone(bw, &bw_best))) {
-    err = VP8_ENC_ERROR_OUT_OF_MEMORY;
     goto Error;
   }
-  for (lz77s_idx = 0; lz77s_idx < config->lz77s_types_to_try_size_;
-       ++lz77s_idx) {
-    refs_best = VP8LGetBackwardReferences(
-        width, height, argb, quality, low_effort,
-        config->lz77s_types_to_try_[lz77s_idx], cache_bits, hash_chain,
-        &refs_array[0], &refs_array[1]);
-    if (refs_best == NULL) {
-      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
-      goto Error;
-    }
-    // Keep the best references aside and use the other element from the first
-    // two as a temporary for later usage.
-    refs_tmp = &refs_array[refs_best == &refs_array[0] ? 1 : 0];
-
-    histogram_image =
-        VP8LAllocateHistogramSet(histogram_image_xysize, *cache_bits);
-    tmp_histo = VP8LAllocateHistogram(*cache_bits);
-    if (histogram_image == NULL || tmp_histo == NULL) {
-      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
-      goto Error;
-    }
-
-    // Build histogram image and symbols from backward references.
-    if (!VP8LGetHistoImageSymbols(width, height, refs_best, quality, low_effort,
-                                  histogram_bits, *cache_bits, histogram_image,
-                                  tmp_histo, histogram_symbols)) {
-      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
-      goto Error;
-    }
-    // Create Huffman bit lengths and codes for each histogram image.
-    histogram_image_size = histogram_image->size;
-    bit_array_size = 5 * histogram_image_size;
-    huffman_codes = (HuffmanTreeCode*)WebPSafeCalloc(bit_array_size,
-                                                     sizeof(*huffman_codes));
-    // Note: some histogram_image entries may point to tmp_histos[], so the
-    // latter need to outlive the following call to GetHuffBitLengthsAndCodes().
-    if (huffman_codes == NULL ||
-        !GetHuffBitLengthsAndCodes(histogram_image, huffman_codes)) {
-      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
-      goto Error;
-    }
-    // Free combined histograms.
-    VP8LFreeHistogramSet(histogram_image);
-    histogram_image = NULL;
-
-    // Free scratch histograms.
-    VP8LFreeHistogram(tmp_histo);
-    tmp_histo = NULL;
+  for (sub_configs_idx = 0; sub_configs_idx < config->sub_configs_size_;
+       ++sub_configs_idx) {
+    const CrunchSubConfig* const sub_config =
+        &config->sub_configs_[sub_configs_idx];
+    int cache_bits_best, i_cache;
+    err = VP8LGetBackwardReferences(width, height, argb, quality, low_effort,
+                                    sub_config->lz77_, cache_bits_init,
+                                    sub_config->do_no_cache_, hash_chain,
+                                    &refs_array[0], &cache_bits_best);
+    if (err != VP8_ENC_OK) goto Error;
 
-    // Color Cache parameters.
-    if (*cache_bits > 0) {
-      VP8LPutBits(bw, 1, 1);
-      VP8LPutBits(bw, *cache_bits, 4);
-    } else {
-      VP8LPutBits(bw, 0, 1);
-    }
+    for (i_cache = 0; i_cache < (sub_config->do_no_cache_ ? 2 : 1); ++i_cache) {
+      const int cache_bits_tmp = (i_cache == 0) ? cache_bits_best : 0;
+      // Speed-up: no need to study the no-cache case if it was already studied
+      // in i_cache == 0.
+      if (i_cache == 1 && cache_bits_best == 0) break;
+
+      // Reset the bit writer for this iteration.
+      VP8LBitWriterReset(&bw_init, bw);
+
+      // Build histogram image and symbols from backward references.
+      histogram_image =
+          VP8LAllocateHistogramSet(histogram_image_xysize, cache_bits_tmp);
+      tmp_histo = VP8LAllocateHistogram(cache_bits_tmp);
+      if (histogram_image == NULL || tmp_histo == NULL ||
+          !VP8LGetHistoImageSymbols(width, height, &refs_array[i_cache],
+                                    quality, low_effort, histogram_bits,
+                                    cache_bits_tmp, histogram_image, tmp_histo,
+                                    histogram_symbols)) {
+        goto Error;
+      }
+      // Create Huffman bit lengths and codes for each histogram image.
+      histogram_image_size = histogram_image->size;
+      bit_array_size = 5 * histogram_image_size;
+      huffman_codes = (HuffmanTreeCode*)WebPSafeCalloc(bit_array_size,
+                                                       sizeof(*huffman_codes));
+      // Note: some histogram_image entries may point to tmp_histos[], so the
+      // latter need to outlive the following call to
+      // GetHuffBitLengthsAndCodes().
+      if (huffman_codes == NULL ||
+          !GetHuffBitLengthsAndCodes(histogram_image, huffman_codes)) {
+        goto Error;
+      }
+      // Free combined histograms.
+      VP8LFreeHistogramSet(histogram_image);
+      histogram_image = NULL;
+
+      // Free scratch histograms.
+      VP8LFreeHistogram(tmp_histo);
+      tmp_histo = NULL;
+
+      // Color Cache parameters.
+      if (cache_bits_tmp > 0) {
+        VP8LPutBits(bw, 1, 1);
+        VP8LPutBits(bw, cache_bits_tmp, 4);
+      } else {
+        VP8LPutBits(bw, 0, 1);
+      }
 
-    // Huffman image + meta huffman.
-    {
-      const int write_histogram_image = (histogram_image_size > 1);
+      // Huffman image + meta huffman.
+      write_histogram_image = (histogram_image_size > 1);
       VP8LPutBits(bw, write_histogram_image, 1);
       if (write_histogram_image) {
         uint32_t* const histogram_argb =
@@ -980,10 +1216,7 @@ static WebPEncodingError EncodeImageInternal(
                                       sizeof(*histogram_argb));
         int max_index = 0;
         uint32_t i;
-        if (histogram_argb == NULL) {
-          err = VP8_ENC_ERROR_OUT_OF_MEMORY;
-          goto Error;
-        }
+        if (histogram_argb == NULL) goto Error;
         for (i = 0; i < histogram_image_xysize; ++i) {
           const int symbol_index = histogram_symbols[i] & 0xffff;
           histogram_argb[i] = (symbol_index << 8);
@@ -995,65 +1228,64 @@ static WebPEncodingError EncodeImageInternal(
 
         VP8LPutBits(bw, histogram_bits - 2, 3);
         err = EncodeImageNoHuffman(
-            bw, histogram_argb, hash_chain, refs_tmp, &refs_array[2],
+            bw, histogram_argb, &hash_chain_histogram, &refs_array[2],
             VP8LSubSampleSize(width, histogram_bits),
             VP8LSubSampleSize(height, histogram_bits), quality, low_effort);
         WebPSafeFree(histogram_argb);
         if (err != VP8_ENC_OK) goto Error;
       }
-    }
 
-    // Store Huffman codes.
-    {
-      int i;
-      int max_tokens = 0;
-      // Find maximum number of symbols for the huffman tree-set.
-      for (i = 0; i < 5 * histogram_image_size; ++i) {
-        HuffmanTreeCode* const codes = &huffman_codes[i];
-        if (max_tokens < codes->num_symbols) {
-          max_tokens = codes->num_symbols;
+      // Store Huffman codes.
+      {
+        int i;
+        int max_tokens = 0;
+        // Find maximum number of symbols for the huffman tree-set.
+        for (i = 0; i < 5 * histogram_image_size; ++i) {
+          HuffmanTreeCode* const codes = &huffman_codes[i];
+          if (max_tokens < codes->num_symbols) {
+            max_tokens = codes->num_symbols;
+          }
+        }
+        tokens = (HuffmanTreeToken*)WebPSafeMalloc(max_tokens, sizeof(*tokens));
+        if (tokens == NULL) goto Error;
+        for (i = 0; i < 5 * histogram_image_size; ++i) {
+          HuffmanTreeCode* const codes = &huffman_codes[i];
+          StoreHuffmanCode(bw, huff_tree, tokens, codes);
+          ClearHuffmanTreeIfOnlyOneSymbol(codes);
         }
       }
-      tokens = (HuffmanTreeToken*)WebPSafeMalloc(max_tokens, sizeof(*tokens));
-      if (tokens == NULL) {
-        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
-        goto Error;
+      // Store actual literals.
+      hdr_size_tmp = (int)(VP8LBitWriterNumBytes(bw) - init_byte_position);
+      err = StoreImageToBitMask(bw, width, histogram_bits, &refs_array[i_cache],
+                                histogram_symbols, huffman_codes);
+      if (err != VP8_ENC_OK) goto Error;
+      // Keep track of the smallest image so far.
+      if (VP8LBitWriterNumBytes(bw) < bw_size_best) {
+        bw_size_best = VP8LBitWriterNumBytes(bw);
+        *cache_bits = cache_bits_tmp;
+        *hdr_size = hdr_size_tmp;
+        *data_size =
+            (int)(VP8LBitWriterNumBytes(bw) - init_byte_position - *hdr_size);
+        VP8LBitWriterSwap(bw, &bw_best);
       }
-      for (i = 0; i < 5 * histogram_image_size; ++i) {
-        HuffmanTreeCode* const codes = &huffman_codes[i];
-        StoreHuffmanCode(bw, huff_tree, tokens, codes);
-        ClearHuffmanTreeIfOnlyOneSymbol(codes);
+      WebPSafeFree(tokens);
+      tokens = NULL;
+      if (huffman_codes != NULL) {
+        WebPSafeFree(huffman_codes->codes);
+        WebPSafeFree(huffman_codes);
+        huffman_codes = NULL;
       }
     }
-    // Store actual literals.
-    hdr_size_tmp = (int)(VP8LBitWriterNumBytes(bw) - init_byte_position);
-    err = StoreImageToBitMask(bw, width, histogram_bits, refs_best,
-                              histogram_symbols, huffman_codes);
-    // Keep track of the smallest image so far.
-    if (lz77s_idx == 0 ||
-        VP8LBitWriterNumBytes(bw) < VP8LBitWriterNumBytes(&bw_best)) {
-      *hdr_size = hdr_size_tmp;
-      *data_size =
-          (int)(VP8LBitWriterNumBytes(bw) - init_byte_position - *hdr_size);
-      VP8LBitWriterSwap(bw, &bw_best);
-    }
-    // Reset the bit writer for the following iteration if any.
-    if (config->lz77s_types_to_try_size_ > 1) VP8LBitWriterReset(&bw_init, bw);
-    WebPSafeFree(tokens);
-    tokens = NULL;
-    if (huffman_codes != NULL) {
-      WebPSafeFree(huffman_codes->codes);
-      WebPSafeFree(huffman_codes);
-      huffman_codes = NULL;
-    }
   }
   VP8LBitWriterSwap(bw, &bw_best);
+  err = VP8_ENC_OK;
 
  Error:
   WebPSafeFree(tokens);
   WebPSafeFree(huff_tree);
   VP8LFreeHistogramSet(histogram_image);
   VP8LFreeHistogram(tmp_histo);
+  VP8LHashChainClear(&hash_chain_histogram);
   if (huffman_codes != NULL) {
     WebPSafeFree(huffman_codes->codes);
     WebPSafeFree(huffman_codes);
@@ -1095,8 +1327,7 @@ static WebPEncodingError ApplyPredictFilter(const VP8LEncoder* const enc,
   VP8LPutBits(bw, pred_bits - 2, 3);
   return EncodeImageNoHuffman(
       bw, enc->transform_data_, (VP8LHashChain*)&enc->hash_chain_,
-      (VP8LBackwardRefs*)&enc->refs_[0],  // cast const away
-      (VP8LBackwardRefs*)&enc->refs_[1], transform_width, transform_height,
+      (VP8LBackwardRefs*)&enc->refs_[0], transform_width, transform_height,
       quality, low_effort);
 }
 
@@ -1116,8 +1347,7 @@ static WebPEncodingError ApplyCrossColorFilter(const VP8LEncoder* const enc,
   VP8LPutBits(bw, ccolor_transform_bits - 2, 3);
   return EncodeImageNoHuffman(
       bw, enc->transform_data_, (VP8LHashChain*)&enc->hash_chain_,
-      (VP8LBackwardRefs*)&enc->refs_[0],  // cast const away
-      (VP8LBackwardRefs*)&enc->refs_[1], transform_width, transform_height,
+      (VP8LBackwardRefs*)&enc->refs_[0], transform_width, transform_height,
       quality, low_effort);
 }
 
@@ -1272,22 +1502,6 @@ static WebPEncodingError MakeInputImageCopy(VP8LEncoder* const enc) {
 
 // -----------------------------------------------------------------------------
 
-static WEBP_INLINE int SearchColorNoIdx(const uint32_t sorted[], uint32_t color,
-                                        int hi) {
-  int low = 0;
-  if (sorted[low] == color) return low;  // loop invariant: sorted[low] != color
-  while (1) {
-    const int mid = (low + hi) >> 1;
-    if (sorted[mid] == color) {
-      return mid;
-    } else if (sorted[mid] < color) {
-      low = mid;
-    } else {
-      hi = mid;
-    }
-  }
-}
-
 #define APPLY_PALETTE_GREEDY_MAX 4
 
 static WEBP_INLINE uint32_t SearchColorGreedy(const uint32_t palette[],
@@ -1322,17 +1536,6 @@ static WEBP_INLINE uint32_t ApplyPaletteHash2(uint32_t color) {
          (32 - PALETTE_INV_SIZE_BITS);
 }
 
-// Sort palette in increasing order and prepare an inverse mapping array.
-static void PrepareMapToPalette(const uint32_t palette[], int num_colors,
-                                uint32_t sorted[], uint32_t idx_map[]) {
-  int i;
-  memcpy(sorted, palette, num_colors * sizeof(*sorted));
-  qsort(sorted, num_colors, sizeof(*sorted), PaletteCompareColorsForQsort);
-  for (i = 0; i < num_colors; ++i) {
-    idx_map[SearchColorNoIdx(sorted, palette[i], num_colors)] = i;
-  }
-}
-
 // Use 1 pixel cache for ARGB pixels.
 #define APPLY_PALETTE_FOR(COLOR_INDEX) do {         \
   uint32_t prev_pix = palette[0];                   \
@@ -1464,8 +1667,8 @@ static WebPEncodingError EncodePalette(VP8LBitWriter* const bw, int low_effort,
   }
   tmp_palette[0] = palette[0];
   return EncodeImageNoHuffman(bw, tmp_palette, &enc->hash_chain_,
-                              &enc->refs_[0], &enc->refs_[1], palette_size, 1,
-                              20 /* quality */, low_effort);
+                              &enc->refs_[0], palette_size, 1, /*quality=*/20,
+                              low_effort);
 }
 
 // -----------------------------------------------------------------------------
@@ -1491,7 +1694,7 @@ static void VP8LEncoderDelete(VP8LEncoder* enc) {
   if (enc != NULL) {
     int i;
     VP8LHashChainClear(&enc->hash_chain_);
-    for (i = 0; i < 3; ++i) VP8LBackwardRefsClear(&enc->refs_[i]);
+    for (i = 0; i < 4; ++i) VP8LBackwardRefsClear(&enc->refs_[i]);
     ClearTransformBuffer(enc);
     WebPSafeFree(enc);
   }
@@ -1541,7 +1744,7 @@ static int EncodeStreamHook(void* input, void* data2) {
   int data_size = 0;
   int use_delta_palette = 0;
   int idx;
-  size_t best_size = 0;
+  size_t best_size = ~(size_t)0;
   VP8LBitWriter bw_init = *bw, bw_best;
   (void)data2;
 
@@ -1553,12 +1756,15 @@ static int EncodeStreamHook(void* input, void* data2) {
 
   for (idx = 0; idx < num_crunch_configs; ++idx) {
     const int entropy_idx = crunch_configs[idx].entropy_idx_;
-    enc->use_palette_ = (entropy_idx == kPalette);
+    enc->use_palette_ =
+        (entropy_idx == kPalette) || (entropy_idx == kPaletteAndSpatial);
     enc->use_subtract_green_ =
         (entropy_idx == kSubGreen) || (entropy_idx == kSpatialSubGreen);
-    enc->use_predict_ =
-        (entropy_idx == kSpatial) || (entropy_idx == kSpatialSubGreen);
-    if (low_effort) {
+    enc->use_predict_ = (entropy_idx == kSpatial) ||
+                        (entropy_idx == kSpatialSubGreen) ||
+                        (entropy_idx == kPaletteAndSpatial);
+    // When using a palette, R/B==0, hence no need to test for cross-color.
+    if (low_effort || enc->use_palette_) {
       enc->use_cross_color_ = 0;
     } else {
       enc->use_cross_color_ = red_and_blue_always_zero ? 0 : enc->use_predict_;
@@ -1590,6 +1796,19 @@ static int EncodeStreamHook(void* input, void* data2) {
 
     // Encode palette
     if (enc->use_palette_) {
+      if (crunch_configs[idx].palette_sorting_type_ == kSortedDefault) {
+        // Nothing to do, we have already sorted the palette.
+        memcpy(enc->palette_, enc->palette_sorted_,
+               enc->palette_size_ * sizeof(*enc->palette_));
+      } else if (crunch_configs[idx].palette_sorting_type_ == kMinimizeDelta) {
+        PaletteSortMinimizeDeltas(enc->palette_sorted_, enc->palette_size_,
+                                  enc->palette_);
+      } else {
+        assert(crunch_configs[idx].palette_sorting_type_ == kModifiedZeng);
+        err = PaletteSortModifiedZeng(enc->pic_, enc->palette_sorted_,
+                                      enc->palette_size_, enc->palette_);
+        if (err != VP8_ENC_OK) goto Error;
+      }
       err = EncodePalette(bw, low_effort, enc);
       if (err != VP8_ENC_OK) goto Error;
       err = MapImageFromPalette(enc, use_delta_palette);
@@ -1640,7 +1859,7 @@ static int EncodeStreamHook(void* input, void* data2) {
     if (err != VP8_ENC_OK) goto Error;
 
     // If we are better than what we already have.
-    if (idx == 0 || VP8LBitWriterNumBytes(bw) < best_size) {
+    if (VP8LBitWriterNumBytes(bw) < best_size) {
       best_size = VP8LBitWriterNumBytes(bw);
       // Store the BitWriter.
       VP8LBitWriterSwap(bw, &bw_best);
@@ -1754,6 +1973,8 @@ WebPEncodingError VP8LEncodeStream(const WebPConfig* const config,
         enc_side->palette_size_ = enc_main->palette_size_;
         memcpy(enc_side->palette_, enc_main->palette_,
                sizeof(enc_main->palette_));
+        memcpy(enc_side->palette_sorted_, enc_main->palette_sorted_,
+               sizeof(enc_main->palette_sorted_));
         param->enc_ = enc_side;
       }
       // Create the workers.
@@ -1816,7 +2037,7 @@ Error:
 }
 
 #undef CRUNCH_CONFIGS_MAX
-#undef CRUNCH_CONFIGS_LZ77_MAX
+#undef CRUNCH_SUBCONFIGS_MAX
 
 int VP8LEncodeImage(const WebPConfig* const config,
                     const WebPPicture* const picture) {
diff --git a/src/3rdparty/libwebp/src/enc/vp8li_enc.h b/src/3rdparty/libwebp/src/enc/vp8li_enc.h
index d2d0fc5..00de489 100644
--- a/src/3rdparty/libwebp/src/enc/vp8li_enc.h
+++ b/src/3rdparty/libwebp/src/enc/vp8li_enc.h
@@ -69,9 +69,11 @@ typedef struct {
   int use_palette_;
   int palette_size_;
   uint32_t palette_[MAX_PALETTE_SIZE];
+  // Sorted version of palette_ for cache purposes.
+  uint32_t palette_sorted_[MAX_PALETTE_SIZE];
 
   // Some 'scratch' (potentially large) objects.
-  struct VP8LBackwardRefs refs_[3];  // Backward Refs array for temporaries.
+  struct VP8LBackwardRefs refs_[4];  // Backward Refs array for temporaries.
   VP8LHashChain hash_chain_;         // HashChain data for constructing
                                      // backward references.
 } VP8LEncoder;
diff --git a/src/3rdparty/libwebp/src/enc/webp_enc.c b/src/3rdparty/libwebp/src/enc/webp_enc.c
index 9f4b10c..ce2db2e 100644
--- a/src/3rdparty/libwebp/src/enc/webp_enc.c
+++ b/src/3rdparty/libwebp/src/enc/webp_enc.c
@@ -400,7 +400,7 @@ int WebPEncode(const WebPConfig* config, WebPPicture* pic) {
     }
 
     if (!config->exact) {
-      WebPCleanupTransparentAreaLossless(pic);
+      WebPReplaceTransparentPixels(pic, 0x000000);
     }
 
     ok = VP8LEncodeImage(config, pic);  // Sets pic->error in case of problem.
diff --git a/src/3rdparty/libwebp/src/mux/anim_encode.c b/src/3rdparty/libwebp/src/mux/anim_encode.c
index 7be9906..7078d9a 100644
--- a/src/3rdparty/libwebp/src/mux/anim_encode.c
+++ b/src/3rdparty/libwebp/src/mux/anim_encode.c
@@ -248,9 +248,6 @@ WebPAnimEncoder* WebPAnimEncoderNewInternal(
 
   enc = (WebPAnimEncoder*)WebPSafeCalloc(1, sizeof(*enc));
   if (enc == NULL) return NULL;
-  // sanity inits, so we can call WebPAnimEncoderDelete():
-  enc->encoded_frames_ = NULL;
-  enc->mux_ = NULL;
   MarkNoError(enc);
 
   // Dimensions and options.
@@ -421,7 +418,7 @@ static void MinimizeChangeRectangle(const WebPPicture* const src,
   const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
   const int max_allowed_diff = is_lossless ? 0 : max_allowed_diff_lossy;
 
-  // Sanity checks.
+  // Assumption/correctness checks.
   assert(src->width == dst->width && src->height == dst->height);
   assert(rect->x_offset_ + rect->width_ <= dst->width);
   assert(rect->y_offset_ + rect->height_ <= dst->height);
@@ -949,7 +946,8 @@ static int IncreasePreviousDuration(WebPAnimEncoder* const enc, int duration) {
   int new_duration;
 
   assert(enc->count_ >= 1);
-  assert(prev_enc_frame->sub_frame_.duration ==
+  assert(!prev_enc_frame->is_key_frame_ ||
+         prev_enc_frame->sub_frame_.duration ==
          prev_enc_frame->key_frame_.duration);
   assert(prev_enc_frame->sub_frame_.duration ==
          (prev_enc_frame->sub_frame_.duration & (MAX_DURATION - 1)));
@@ -966,7 +964,7 @@ static int IncreasePreviousDuration(WebPAnimEncoder* const enc, int duration) {
       0x10, 0x88, 0x88, 0x08
     };
     const WebPData lossless_1x1 = {
-        lossless_1x1_bytes, sizeof(lossless_1x1_bytes)
+      lossless_1x1_bytes, sizeof(lossless_1x1_bytes)
     };
     const uint8_t lossy_1x1_bytes[] = {
       0x52, 0x49, 0x46, 0x46, 0x40, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
@@ -1358,6 +1356,12 @@ int WebPAnimEncoderAdd(WebPAnimEncoder* enc, WebPPicture* frame, int timestamp,
     if (!IncreasePreviousDuration(enc, (int)prev_frame_duration)) {
       return 0;
     }
+    // IncreasePreviousDuration() may add a frame to avoid exceeding
+    // MAX_DURATION which could cause CacheFrame() to over read encoded_frames_
+    // before the next flush.
+    if (enc->count_ == enc->size_ && !FlushFrames(enc)) {
+      return 0;
+    }
   } else {
     enc->first_timestamp_ = timestamp;
   }
diff --git a/src/3rdparty/libwebp/src/mux/muxedit.c b/src/3rdparty/libwebp/src/mux/muxedit.c
index ccf14b2..02c3ede 100644
--- a/src/3rdparty/libwebp/src/mux/muxedit.c
+++ b/src/3rdparty/libwebp/src/mux/muxedit.c
@@ -235,7 +235,6 @@ WebPMuxError WebPMuxSetImage(WebPMux* mux, const WebPData* bitstream,
   WebPMuxImage wpi;
   WebPMuxError err;
 
-  // Sanity checks.
   if (mux == NULL || bitstream == NULL || bitstream->bytes == NULL ||
       bitstream->size > MAX_CHUNK_PAYLOAD) {
     return WEBP_MUX_INVALID_ARGUMENT;
@@ -267,7 +266,6 @@ WebPMuxError WebPMuxPushFrame(WebPMux* mux, const WebPMuxFrameInfo* info,
   WebPMuxImage wpi;
   WebPMuxError err;
 
-  // Sanity checks.
   if (mux == NULL || info == NULL) return WEBP_MUX_INVALID_ARGUMENT;
 
   if (info->id != WEBP_CHUNK_ANMF) return WEBP_MUX_INVALID_ARGUMENT;
diff --git a/src/3rdparty/libwebp/src/mux/muxi.h b/src/3rdparty/libwebp/src/mux/muxi.h
index ad3e1bd..330da66 100644
--- a/src/3rdparty/libwebp/src/mux/muxi.h
+++ b/src/3rdparty/libwebp/src/mux/muxi.h
@@ -28,8 +28,8 @@ extern "C" {
 // Defines and constants.
 
 #define MUX_MAJ_VERSION 1
-#define MUX_MIN_VERSION 1
-#define MUX_REV_VERSION 0
+#define MUX_MIN_VERSION 2
+#define MUX_REV_VERSION 1
 
 // Chunk object.
 typedef struct WebPChunk WebPChunk;
diff --git a/src/3rdparty/libwebp/src/mux/muxread.c b/src/3rdparty/libwebp/src/mux/muxread.c
index ae3b876..8005039 100644
--- a/src/3rdparty/libwebp/src/mux/muxread.c
+++ b/src/3rdparty/libwebp/src/mux/muxread.c
@@ -56,7 +56,7 @@ static WebPMuxError ChunkVerifyAndAssign(WebPChunk* chunk,
   uint32_t chunk_size;
   WebPData chunk_data;
 
-  // Sanity checks.
+  // Correctness checks.
   if (data_size < CHUNK_HEADER_SIZE) return WEBP_MUX_NOT_ENOUGH_DATA;
   chunk_size = GetLE32(data + TAG_SIZE);
   if (chunk_size > MAX_CHUNK_PAYLOAD) return WEBP_MUX_BAD_DATA;
@@ -155,7 +155,6 @@ static int MuxImageParse(const WebPChunk* const chunk, int copy_data,
         break;
       default:
         goto Fail;
-        break;
     }
     subchunk_size = ChunkDiskSize(&subchunk);
     bytes += subchunk_size;
@@ -187,7 +186,6 @@ WebPMux* WebPMuxCreateInternal(const WebPData* bitstream, int copy_data,
   WebPChunk** chunk_list_ends[WEBP_CHUNK_NIL + 1] = { NULL };
   ChunkInit(&chunk);
 
-  // Sanity checks.
   if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_MUX_ABI_VERSION)) {
     return NULL;  // version mismatch
   }
@@ -264,7 +262,6 @@ WebPMux* WebPMuxCreateInternal(const WebPData* bitstream, int copy_data,
         if (!MuxImageParse(&chunk, copy_data, wpi)) goto Err;
         ChunkRelease(&chunk);
         goto PushImage;
-        break;
       default:  // A non-image chunk.
         if (wpi->is_partial_) goto Err;  // Encountered a non-image chunk before
                                          // getting all chunks of an image.
@@ -483,7 +480,6 @@ WebPMuxError WebPMuxGetFrame(
   WebPMuxError err;
   WebPMuxImage* wpi;
 
-  // Sanity checks.
   if (mux == NULL || frame == NULL) {
     return WEBP_MUX_INVALID_ARGUMENT;
   }
diff --git a/src/3rdparty/libwebp/src/utils/bit_reader_inl_utils.h b/src/3rdparty/libwebp/src/utils/bit_reader_inl_utils.h
index 46b3880..404b9a6 100644
--- a/src/3rdparty/libwebp/src/utils/bit_reader_inl_utils.h
+++ b/src/3rdparty/libwebp/src/utils/bit_reader_inl_utils.h
@@ -55,7 +55,7 @@ void VP8LoadFinalBytes(VP8BitReader* const br);
 
 // makes sure br->value_ has at least BITS bits worth of data
 static WEBP_UBSAN_IGNORE_UNDEF WEBP_INLINE
-void VP8LoadNewBytes(VP8BitReader* const br) {
+void VP8LoadNewBytes(VP8BitReader* WEBP_RESTRICT const br) {
   assert(br != NULL && br->buf_ != NULL);
   // Read 'BITS' bits at a time if possible.
   if (br->buf_ < br->buf_max_) {
@@ -104,7 +104,7 @@ void VP8LoadNewBytes(VP8BitReader* const br) {
 }
 
 // Read a bit with proba 'prob'. Speed-critical function!
-static WEBP_INLINE int VP8GetBit(VP8BitReader* const br,
+static WEBP_INLINE int VP8GetBit(VP8BitReader* WEBP_RESTRICT const br,
                                  int prob, const char label[]) {
   // Don't move this declaration! It makes a big speed difference to store
   // 'range' *before* calling VP8LoadNewBytes(), even if this function doesn't
@@ -137,7 +137,8 @@ static WEBP_INLINE int VP8GetBit(VP8BitReader* const br,
 
 // simplified version of VP8GetBit() for prob=0x80 (note shift is always 1 here)
 static WEBP_UBSAN_IGNORE_UNSIGNED_OVERFLOW WEBP_INLINE
-int VP8GetSigned(VP8BitReader* const br, int v, const char label[]) {
+int VP8GetSigned(VP8BitReader* WEBP_RESTRICT const br, int v,
+                 const char label[]) {
   if (br->bits_ < 0) {
     VP8LoadNewBytes(br);
   }
@@ -155,7 +156,7 @@ int VP8GetSigned(VP8BitReader* const br, int v, const char label[]) {
   }
 }
 
-static WEBP_INLINE int VP8GetBitAlt(VP8BitReader* const br,
+static WEBP_INLINE int VP8GetBitAlt(VP8BitReader* WEBP_RESTRICT const br,
                                     int prob, const char label[]) {
   // Don't move this declaration! It makes a big speed difference to store
   // 'range' *before* calling VP8LoadNewBytes(), even if this function doesn't
diff --git a/src/3rdparty/libwebp/src/utils/bit_writer_utils.c b/src/3rdparty/libwebp/src/utils/bit_writer_utils.c
index bef0e31..2f40850 100644
--- a/src/3rdparty/libwebp/src/utils/bit_writer_utils.c
+++ b/src/3rdparty/libwebp/src/utils/bit_writer_utils.c
@@ -278,7 +278,7 @@ void VP8LPutBitsFlushBits(VP8LBitWriter* const bw) {
   // If needed, make some room by flushing some bits out.
   if (bw->cur_ + VP8L_WRITER_BYTES > bw->end_) {
     const uint64_t extra_size = (bw->end_ - bw->buf_) + MIN_EXTRA_SIZE;
-    if (extra_size != (size_t)extra_size ||
+    if (!CheckSizeOverflow(extra_size) ||
         !VP8LBitWriterResize(bw, (size_t)extra_size)) {
       bw->cur_ = bw->buf_;
       bw->error_ = 1;
@@ -314,7 +314,7 @@ void VP8LPutBitsInternal(VP8LBitWriter* const bw, uint32_t bits, int n_bits) {
     while (used >= VP8L_WRITER_BITS) {
       if (bw->cur_ + VP8L_WRITER_BYTES > bw->end_) {
         const uint64_t extra_size = (bw->end_ - bw->buf_) + MIN_EXTRA_SIZE;
-        if (extra_size != (size_t)extra_size ||
+        if (!CheckSizeOverflow(extra_size) ||
             !VP8LBitWriterResize(bw, (size_t)extra_size)) {
           bw->cur_ = bw->buf_;
           bw->error_ = 1;
diff --git a/src/3rdparty/libwebp/src/utils/color_cache_utils.c b/src/3rdparty/libwebp/src/utils/color_cache_utils.c
index b09f538..7b5222b 100644
--- a/src/3rdparty/libwebp/src/utils/color_cache_utils.c
+++ b/src/3rdparty/libwebp/src/utils/color_cache_utils.c
@@ -20,22 +20,22 @@
 //------------------------------------------------------------------------------
 // VP8LColorCache.
 
-int VP8LColorCacheInit(VP8LColorCache* const cc, int hash_bits) {
+int VP8LColorCacheInit(VP8LColorCache* const color_cache, int hash_bits) {
   const int hash_size = 1 << hash_bits;
-  assert(cc != NULL);
+  assert(color_cache != NULL);
   assert(hash_bits > 0);
-  cc->colors_ = (uint32_t*)WebPSafeCalloc((uint64_t)hash_size,
-                                          sizeof(*cc->colors_));
-  if (cc->colors_ == NULL) return 0;
-  cc->hash_shift_ = 32 - hash_bits;
-  cc->hash_bits_ = hash_bits;
+  color_cache->colors_ = (uint32_t*)WebPSafeCalloc(
+      (uint64_t)hash_size, sizeof(*color_cache->colors_));
+  if (color_cache->colors_ == NULL) return 0;
+  color_cache->hash_shift_ = 32 - hash_bits;
+  color_cache->hash_bits_ = hash_bits;
   return 1;
 }
 
-void VP8LColorCacheClear(VP8LColorCache* const cc) {
-  if (cc != NULL) {
-    WebPSafeFree(cc->colors_);
-    cc->colors_ = NULL;
+void VP8LColorCacheClear(VP8LColorCache* const color_cache) {
+  if (color_cache != NULL) {
+    WebPSafeFree(color_cache->colors_);
+    color_cache->colors_ = NULL;
   }
 }
 
diff --git a/src/3rdparty/libwebp/src/utils/huffman_encode_utils.c b/src/3rdparty/libwebp/src/utils/huffman_encode_utils.c
index 6f3b1bb..fd7a47d 100644
--- a/src/3rdparty/libwebp/src/utils/huffman_encode_utils.c
+++ b/src/3rdparty/libwebp/src/utils/huffman_encode_utils.c
@@ -404,8 +404,7 @@ static void ConvertBitDepthsToSymbols(HuffmanTreeCode* const tree) {
 // Main entry point
 
 void VP8LCreateHuffmanTree(uint32_t* const histogram, int tree_depth_limit,
-                           uint8_t* const buf_rle,
-                           HuffmanTree* const huff_tree,
+                           uint8_t* const buf_rle, HuffmanTree* const huff_tree,
                            HuffmanTreeCode* const huff_code) {
   const int num_symbols = huff_code->num_symbols;
   memset(buf_rle, 0, num_symbols * sizeof(*buf_rle));
diff --git a/src/3rdparty/libwebp/src/utils/huffman_encode_utils.h b/src/3rdparty/libwebp/src/utils/huffman_encode_utils.h
index 3e6763c..3f7f1d8 100644
--- a/src/3rdparty/libwebp/src/utils/huffman_encode_utils.h
+++ b/src/3rdparty/libwebp/src/utils/huffman_encode_utils.h
@@ -51,7 +51,7 @@ int VP8LCreateCompressedHuffmanTree(const HuffmanTreeCode* const tree,
 // huffman code tree.
 void VP8LCreateHuffmanTree(uint32_t* const histogram, int tree_depth_limit,
                            uint8_t* const buf_rle, HuffmanTree* const huff_tree,
-                           HuffmanTreeCode* const tree);
+                           HuffmanTreeCode* const huff_code);
 
 #ifdef __cplusplus
 }
diff --git a/src/3rdparty/libwebp/src/utils/rescaler_utils.c b/src/3rdparty/libwebp/src/utils/rescaler_utils.c
index 4bcae24..a0581a1 100644
--- a/src/3rdparty/libwebp/src/utils/rescaler_utils.c
+++ b/src/3rdparty/libwebp/src/utils/rescaler_utils.c
@@ -12,66 +12,74 @@
 // Author: Skal (pascal.massimino@gmail.com)
 
 #include <assert.h>
+#include <limits.h>
 #include <stdlib.h>
 #include <string.h>
 #include "src/dsp/dsp.h"
 #include "src/utils/rescaler_utils.h"
+#include "src/utils/utils.h"
 
 //------------------------------------------------------------------------------
 
-void WebPRescalerInit(WebPRescaler* const wrk, int src_width, int src_height,
-                      uint8_t* const dst,
-                      int dst_width, int dst_height, int dst_stride,
-                      int num_channels, rescaler_t* const work) {
+int WebPRescalerInit(WebPRescaler* const rescaler,
+                     int src_width, int src_height,
+                     uint8_t* const dst,
+                     int dst_width, int dst_height, int dst_stride,
+                     int num_channels, rescaler_t* const work) {
   const int x_add = src_width, x_sub = dst_width;
   const int y_add = src_height, y_sub = dst_height;
-  wrk->x_expand = (src_width < dst_width);
-  wrk->y_expand = (src_height < dst_height);
-  wrk->src_width = src_width;
-  wrk->src_height = src_height;
-  wrk->dst_width = dst_width;
-  wrk->dst_height = dst_height;
-  wrk->src_y = 0;
-  wrk->dst_y = 0;
-  wrk->dst = dst;
-  wrk->dst_stride = dst_stride;
-  wrk->num_channels = num_channels;
+  const uint64_t total_size = 2ull * dst_width * num_channels * sizeof(*work);
+  if (!CheckSizeOverflow(total_size)) return 0;
+
+  rescaler->x_expand = (src_width < dst_width);
+  rescaler->y_expand = (src_height < dst_height);
+  rescaler->src_width = src_width;
+  rescaler->src_height = src_height;
+  rescaler->dst_width = dst_width;
+  rescaler->dst_height = dst_height;
+  rescaler->src_y = 0;
+  rescaler->dst_y = 0;
+  rescaler->dst = dst;
+  rescaler->dst_stride = dst_stride;
+  rescaler->num_channels = num_channels;
 
   // for 'x_expand', we use bilinear interpolation
-  wrk->x_add = wrk->x_expand ? (x_sub - 1) : x_add;
-  wrk->x_sub = wrk->x_expand ? (x_add - 1) : x_sub;
-  if (!wrk->x_expand) {  // fx_scale is not used otherwise
-    wrk->fx_scale = WEBP_RESCALER_FRAC(1, wrk->x_sub);
+  rescaler->x_add = rescaler->x_expand ? (x_sub - 1) : x_add;
+  rescaler->x_sub = rescaler->x_expand ? (x_add - 1) : x_sub;
+  if (!rescaler->x_expand) {  // fx_scale is not used otherwise
+    rescaler->fx_scale = WEBP_RESCALER_FRAC(1, rescaler->x_sub);
   }
   // vertical scaling parameters
-  wrk->y_add = wrk->y_expand ? y_add - 1 : y_add;
-  wrk->y_sub = wrk->y_expand ? y_sub - 1 : y_sub;
-  wrk->y_accum = wrk->y_expand ? wrk->y_sub : wrk->y_add;
-  if (!wrk->y_expand) {
+  rescaler->y_add = rescaler->y_expand ? y_add - 1 : y_add;
+  rescaler->y_sub = rescaler->y_expand ? y_sub - 1 : y_sub;
+  rescaler->y_accum = rescaler->y_expand ? rescaler->y_sub : rescaler->y_add;
+  if (!rescaler->y_expand) {
     // This is WEBP_RESCALER_FRAC(dst_height, x_add * y_add) without the cast.
-    // Its value is <= WEBP_RESCALER_ONE, because dst_height <= wrk->y_add, and
-    // wrk->x_add >= 1;
-    const uint64_t ratio =
-        (uint64_t)dst_height * WEBP_RESCALER_ONE / (wrk->x_add * wrk->y_add);
+    // Its value is <= WEBP_RESCALER_ONE, because dst_height <= rescaler->y_add
+    // and rescaler->x_add >= 1;
+    const uint64_t num = (uint64_t)dst_height * WEBP_RESCALER_ONE;
+    const uint64_t den = (uint64_t)rescaler->x_add * rescaler->y_add;
+    const uint64_t ratio = num / den;
     if (ratio != (uint32_t)ratio) {
       // When ratio == WEBP_RESCALER_ONE, we can't represent the ratio with the
       // current fixed-point precision. This happens when src_height ==
-      // wrk->y_add (which == src_height), and wrk->x_add == 1.
+      // rescaler->y_add (which == src_height), and rescaler->x_add == 1.
       // => We special-case fxy_scale = 0, in WebPRescalerExportRow().
-      wrk->fxy_scale = 0;
+      rescaler->fxy_scale = 0;
     } else {
-      wrk->fxy_scale = (uint32_t)ratio;
+      rescaler->fxy_scale = (uint32_t)ratio;
     }
-    wrk->fy_scale = WEBP_RESCALER_FRAC(1, wrk->y_sub);
+    rescaler->fy_scale = WEBP_RESCALER_FRAC(1, rescaler->y_sub);
   } else {
-    wrk->fy_scale = WEBP_RESCALER_FRAC(1, wrk->x_add);
-    // wrk->fxy_scale is unused here.
+    rescaler->fy_scale = WEBP_RESCALER_FRAC(1, rescaler->x_add);
+    // rescaler->fxy_scale is unused here.
   }
-  wrk->irow = work;
-  wrk->frow = work + num_channels * dst_width;
-  memset(work, 0, 2 * dst_width * num_channels * sizeof(*work));
+  rescaler->irow = work;
+  rescaler->frow = work + num_channels * dst_width;
+  memset(work, 0, (size_t)total_size);
 
   WebPRescalerDspInit();
+  return 1;
 }
 
 int WebPRescalerGetScaledDimensions(int src_width, int src_height,
@@ -82,6 +90,7 @@ int WebPRescalerGetScaledDimensions(int src_width, int src_height,
   {
     int width = *scaled_width;
     int height = *scaled_height;
+    const int max_size = INT_MAX / 2;
 
     // if width is unspecified, scale original proportionally to height ratio.
     if (width == 0 && src_height > 0) {
@@ -94,7 +103,7 @@ int WebPRescalerGetScaledDimensions(int src_width, int src_height,
           (int)(((uint64_t)src_height * width + src_width - 1) / src_width);
     }
     // Check if the overall dimensions still make sense.
-    if (width <= 0 || height <= 0) {
+    if (width <= 0 || height <= 0 || width > max_size || height > max_size) {
       return 0;
     }
 
@@ -107,31 +116,34 @@ int WebPRescalerGetScaledDimensions(int src_width, int src_height,
 //------------------------------------------------------------------------------
 // all-in-one calls
 
-int WebPRescaleNeededLines(const WebPRescaler* const wrk, int max_num_lines) {
-  const int num_lines = (wrk->y_accum + wrk->y_sub - 1) / wrk->y_sub;
+int WebPRescaleNeededLines(const WebPRescaler* const rescaler,
+                           int max_num_lines) {
+  const int num_lines =
+      (rescaler->y_accum + rescaler->y_sub - 1) / rescaler->y_sub;
   return (num_lines > max_num_lines) ? max_num_lines : num_lines;
 }
 
-int WebPRescalerImport(WebPRescaler* const wrk, int num_lines,
+int WebPRescalerImport(WebPRescaler* const rescaler, int num_lines,
                        const uint8_t* src, int src_stride) {
   int total_imported = 0;
-  while (total_imported < num_lines && !WebPRescalerHasPendingOutput(wrk)) {
-    if (wrk->y_expand) {
-      rescaler_t* const tmp = wrk->irow;
-      wrk->irow = wrk->frow;
-      wrk->frow = tmp;
+  while (total_imported < num_lines &&
+         !WebPRescalerHasPendingOutput(rescaler)) {
+    if (rescaler->y_expand) {
+      rescaler_t* const tmp = rescaler->irow;
+      rescaler->irow = rescaler->frow;
+      rescaler->frow = tmp;
     }
-    WebPRescalerImportRow(wrk, src);
-    if (!wrk->y_expand) {     // Accumulate the contribution of the new row.
+    WebPRescalerImportRow(rescaler, src);
+    if (!rescaler->y_expand) {    // Accumulate the contribution of the new row.
       int x;
-      for (x = 0; x < wrk->num_channels * wrk->dst_width; ++x) {
-        wrk->irow[x] += wrk->frow[x];
+      for (x = 0; x < rescaler->num_channels * rescaler->dst_width; ++x) {
+        rescaler->irow[x] += rescaler->frow[x];
       }
     }
-    ++wrk->src_y;
+    ++rescaler->src_y;
     src += src_stride;
     ++total_imported;
-    wrk->y_accum -= wrk->y_sub;
+    rescaler->y_accum -= rescaler->y_sub;
   }
   return total_imported;
 }
diff --git a/src/3rdparty/libwebp/src/utils/rescaler_utils.h b/src/3rdparty/libwebp/src/utils/rescaler_utils.h
index ca41e42..ef201ef 100644
--- a/src/3rdparty/libwebp/src/utils/rescaler_utils.h
+++ b/src/3rdparty/libwebp/src/utils/rescaler_utils.h
@@ -47,12 +47,13 @@ struct WebPRescaler {
 };
 
 // Initialize a rescaler given scratch area 'work' and dimensions of src & dst.
-void WebPRescalerInit(WebPRescaler* const rescaler,
-                      int src_width, int src_height,
-                      uint8_t* const dst,
-                      int dst_width, int dst_height, int dst_stride,
-                      int num_channels,
-                      rescaler_t* const work);
+// Returns false in case of error.
+int WebPRescalerInit(WebPRescaler* const rescaler,
+                     int src_width, int src_height,
+                     uint8_t* const dst,
+                     int dst_width, int dst_height, int dst_stride,
+                     int num_channels,
+                     rescaler_t* const work);
 
 // If either 'scaled_width' or 'scaled_height' (but not both) is 0 the value
 // will be calculated preserving the aspect ratio, otherwise the values are
diff --git a/src/3rdparty/libwebp/src/utils/utils.c b/src/3rdparty/libwebp/src/utils/utils.c
index 764f752..9e464c1 100644
--- a/src/3rdparty/libwebp/src/utils/utils.c
+++ b/src/3rdparty/libwebp/src/utils/utils.c
@@ -101,6 +101,9 @@ static void Increment(int* const v) {
 #if defined(MALLOC_LIMIT)
     {
       const char* const malloc_limit_str = getenv("MALLOC_LIMIT");
+#if MALLOC_LIMIT > 1
+      mem_limit = (size_t)MALLOC_LIMIT;
+#endif
       if (malloc_limit_str != NULL) {
         mem_limit = atoi(malloc_limit_str);
       }
@@ -169,16 +172,16 @@ static int CheckSizeArgumentsOverflow(uint64_t nmemb, size_t size) {
   const uint64_t total_size = nmemb * size;
   if (nmemb == 0) return 1;
   if ((uint64_t)size > WEBP_MAX_ALLOCABLE_MEMORY / nmemb) return 0;
-  if (total_size != (size_t)total_size) return 0;
+  if (!CheckSizeOverflow(total_size)) return 0;
 #if defined(PRINT_MEM_INFO) && defined(MALLOC_FAIL_AT)
   if (countdown_to_fail > 0 && --countdown_to_fail == 0) {
     return 0;    // fake fail!
   }
 #endif
-#if defined(MALLOC_LIMIT)
+#if defined(PRINT_MEM_INFO) && defined(MALLOC_LIMIT)
   if (mem_limit > 0) {
     const uint64_t new_total_mem = (uint64_t)total_mem + total_size;
-    if (new_total_mem != (size_t)new_total_mem ||
+    if (!CheckSizeOverflow(new_total_mem) ||
         new_total_mem > mem_limit) {
       return 0;   // fake fail!
     }
@@ -231,7 +234,7 @@ void WebPFree(void* ptr) {
 void WebPCopyPlane(const uint8_t* src, int src_stride,
                    uint8_t* dst, int dst_stride, int width, int height) {
   assert(src != NULL && dst != NULL);
-  assert(src_stride >= width && dst_stride >= width);
+  assert(abs(src_stride) >= width && abs(dst_stride) >= width);
   while (height-- > 0) {
     memcpy(dst, src, width);
     src += src_stride;
diff --git a/src/3rdparty/libwebp/src/utils/utils.h b/src/3rdparty/libwebp/src/utils/utils.h
index 2a3ec92..ef04f10 100644
--- a/src/3rdparty/libwebp/src/utils/utils.h
+++ b/src/3rdparty/libwebp/src/utils/utils.h
@@ -42,6 +42,10 @@ extern "C" {
 #endif
 #endif  // WEBP_MAX_ALLOCABLE_MEMORY
 
+static WEBP_INLINE int CheckSizeOverflow(uint64_t size) {
+  return size == (size_t)size;
+}
+
 // size-checking safe malloc/calloc: verify that the requested size is not too
 // large, or return NULL. You don't need to call these for constructs like
 // malloc(sizeof(foo)), but only if there's picture-dependent size involved
@@ -107,24 +111,33 @@ static WEBP_INLINE void PutLE32(uint8_t* const data, uint32_t val) {
   PutLE16(data + 2, (int)(val >> 16));
 }
 
-// Returns (int)floor(log2(n)). n must be > 0.
 // use GNU builtins where available.
 #if defined(__GNUC__) && \
     ((__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || __GNUC__ >= 4)
+// Returns (int)floor(log2(n)). n must be > 0.
 static WEBP_INLINE int BitsLog2Floor(uint32_t n) {
   return 31 ^ __builtin_clz(n);
 }
+// counts the number of trailing zero
+static WEBP_INLINE int BitsCtz(uint32_t n) { return __builtin_ctz(n); }
 #elif defined(_MSC_VER) && _MSC_VER > 1310 && \
       (defined(_M_X64) || defined(_M_IX86))
 #include <intrin.h>
 #pragma intrinsic(_BitScanReverse)
+#pragma intrinsic(_BitScanForward)
 
 static WEBP_INLINE int BitsLog2Floor(uint32_t n) {
-  unsigned long first_set_bit;
+  unsigned long first_set_bit;  // NOLINT (runtime/int)
   _BitScanReverse(&first_set_bit, n);
   return first_set_bit;
 }
-#else   // default: use the C-version.
+static WEBP_INLINE int BitsCtz(uint32_t n) {
+  unsigned long first_set_bit;  // NOLINT (runtime/int)
+  _BitScanForward(&first_set_bit, n);
+  return first_set_bit;
+}
+#else   // default: use the (slow) C-version.
+#define WEBP_HAVE_SLOW_CLZ_CTZ   // signal that the Clz/Ctz function are slow
 // Returns 31 ^ clz(n) = log2(n). This is the default C-implementation, either
 // based on table or not. Can be used as fallback if clz() is not available.
 #define WEBP_NEED_LOG_TABLE_8BIT
@@ -139,6 +152,15 @@ static WEBP_INLINE int WebPLog2FloorC(uint32_t n) {
 }
 
 static WEBP_INLINE int BitsLog2Floor(uint32_t n) { return WebPLog2FloorC(n); }
+
+static WEBP_INLINE int BitsCtz(uint32_t n) {
+  int i;
+  for (i = 0; i < 32; ++i, n >>= 1) {
+    if (n & 1) return i;
+  }
+  return 32;
+}
+
 #endif
 
 //------------------------------------------------------------------------------
diff --git a/src/3rdparty/libwebp/src/webp/config.h b/src/3rdparty/libwebp/src/webp/config.h
index 6f5d153..21e013a 100644
--- a/src/3rdparty/libwebp/src/webp/config.h
+++ b/src/3rdparty/libwebp/src/webp/config.h
@@ -81,7 +81,7 @@
 #define PACKAGE_NAME "libwebp"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "libwebp 1.1.0"
+#define PACKAGE_STRING "libwebp 1.2.1"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "libwebp"
@@ -90,7 +90,7 @@
 #define PACKAGE_URL "http://developers.google.com/speed/webp"
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "1.1.0"
+#define PACKAGE_VERSION "1.2.1"
 
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
@@ -100,7 +100,7 @@
 /* #undef STDC_HEADERS */
 
 /* Version number of package */
-#define VERSION "1.1.0"
+#define VERSION "1.2.1"
 
 /* Enable experimental code */
 /* #undef WEBP_EXPERIMENTAL_FEATURES */
diff --git a/src/3rdparty/libwebp/src/webp/decode.h b/src/3rdparty/libwebp/src/webp/decode.h
index 80dd0ef..44fcd64 100644
--- a/src/3rdparty/libwebp/src/webp/decode.h
+++ b/src/3rdparty/libwebp/src/webp/decode.h
@@ -453,7 +453,7 @@ struct WebPDecoderOptions {
   int scaled_width, scaled_height;    // final resolution
   int use_threads;                    // if true, use multi-threaded decoding
   int dithering_strength;             // dithering strength (0=Off, 100=full)
-  int flip;                           // flip output vertically
+  int flip;                           // if true, flip output vertically
   int alpha_dithering_strength;       // alpha dithering strength in [0..100]
 
   uint32_t pad[5];                    // padding for later use
diff --git a/src/3rdparty/libwebp/src/webp/encode.h b/src/3rdparty/libwebp/src/webp/encode.h
index 655166e..b4c599d 100644
--- a/src/3rdparty/libwebp/src/webp/encode.h
+++ b/src/3rdparty/libwebp/src/webp/encode.h
@@ -148,7 +148,8 @@ struct WebPConfig {
   int use_delta_palette;  // reserved for future lossless feature
   int use_sharp_yuv;      // if needed, use sharp (and slow) RGB->YUV conversion
 
-  uint32_t pad[2];        // padding for later use
+  int qmin;               // minimum permissible quality factor
+  int qmax;               // maximum permissible quality factor
 };
 
 // Enumerate some predefined settings for WebPConfig, depending on the type
@@ -291,6 +292,11 @@ typedef enum WebPEncodingError {
 #define WEBP_MAX_DIMENSION 16383
 
 // Main exchange structure (input samples, output bytes, statistics)
+//
+// Once WebPPictureInit() has been called, it's ok to make all the INPUT fields
+// (use_argb, y/u/v, argb, ...) point to user-owned data, even if
+// WebPPictureAlloc() has been called. Depending on the value use_argb,
+// it's guaranteed that either *argb or *y/*u/*v content will be kept untouched.
 struct WebPPicture {
   //   INPUT
   //////////////
diff --git a/src/plugins/imageformats/icns/qicnshandler.cpp b/src/plugins/imageformats/icns/qicnshandler.cpp
index dde783c..1bf9074 100644
--- a/src/plugins/imageformats/icns/qicnshandler.cpp
+++ b/src/plugins/imageformats/icns/qicnshandler.cpp
@@ -462,8 +462,12 @@ static bool parseIconEntryInfo(ICNSEntry &icon)
     if (isIconCompressed(icon))
         return true;
     // Icon depth:
-    if (!depth.isEmpty())
-        icon.depth = ICNSEntry::Depth(depth.toUInt());
+    if (!depth.isEmpty()) {
+        const uint depthUInt = depth.toUInt();
+        if (depthUInt > 32)
+            return false;
+        icon.depth = ICNSEntry::Depth(depthUInt);
+    }
     // Try mono if depth not found
     if (icon.depth == ICNSEntry::DepthUnknown)
         icon.depth = ICNSEntry::DepthMono;
@@ -515,6 +519,9 @@ static bool parseIconEntryInfo(ICNSEntry &icon)
         }
         icon.height = icon.width;
     }
+    // Sanity check
+    if (icon.width == 0 || icon.width > 4096)
+        return false;
     return true;
 }
 
@@ -685,7 +692,7 @@ bool QICNSHandler::canRead() const
 bool QICNSHandler::read(QImage *outImage)
 {
     QImage img;
-    if (!ensureScanned()) {
+    if (!ensureScanned() || m_currentIconIndex >= m_icons.size()) {
         qWarning("QICNSHandler::read(): The device wasn't parsed properly!");
         return false;
     }
@@ -892,7 +899,7 @@ bool QICNSHandler::scanDevice()
             return false;
 
         const qint64 blockDataOffset = device()->pos();
-        if (!isBlockHeaderValid(blockHeader)) {
+        if (!isBlockHeaderValid(blockHeader, ICNSBlockHeaderSize + filelength - blockDataOffset)) {
             qWarning("QICNSHandler::scanDevice(): Failed, bad header at pos %s. OSType \"%s\", length %u",
                      QByteArray::number(blockDataOffset).constData(),
                      nameFromOSType(blockHeader.ostype).constData(), blockHeader.length);
@@ -927,11 +934,14 @@ bool QICNSHandler::scanDevice()
         case ICNSBlockHeader::TypeOdrp:
             // Icns container seems to have an embedded icon variant container
             // Let's start a scan for entries
-            while (device()->pos() < nextBlockOffset) {
+            while (!stream.atEnd() && device()->pos() < nextBlockOffset) {
                 ICNSBlockHeader icon;
                 stream >> icon;
+                if (stream.status() != QDataStream::Ok)
+                    return false;
                 // Check for incorrect variant entry header and stop scan
-                if (!isBlockHeaderValid(icon, blockDataLength))
+                quint64 remaining = blockDataLength - (device()->pos() - blockDataOffset);
+                if (!isBlockHeaderValid(icon, ICNSBlockHeaderSize + remaining))
                     break;
                 if (!addEntry(icon, device()->pos(), blockHeader.ostype))
                     return false;
@@ -1003,7 +1013,7 @@ bool QICNSHandler::scanDevice()
             break;
         }
     }
-    return true;
+    return (m_icons.size() > 0);
 }
 
 const ICNSEntry &QICNSHandler::getIconMask(const ICNSEntry &icon) const
diff --git a/src/plugins/imageformats/jp2/qjp2handler.cpp b/src/plugins/imageformats/jp2/qjp2handler.cpp
index 5082023..cb34374 100644
--- a/src/plugins/imageformats/jp2/qjp2handler.cpp
+++ b/src/plugins/imageformats/jp2/qjp2handler.cpp
@@ -43,6 +43,7 @@
 #include "qimage.h"
 #include "qvariant.h"
 #include "qcolor.h"
+#include "qimagereader.h"
 
 #include <jasper/jasper.h>
 #include <math.h> // for pow
@@ -333,16 +334,46 @@ private:
 Jpeg2000JasperReader::Jpeg2000JasperReader(QIODevice *iod, SubFormat format)
     : jasperOk(true), ioDevice(iod), format(format), hasAlpha(false)
 {
+#if JAS_VERSION_MAJOR < 3
     if (jas_init()) {
         jasperOk = false;
         qDebug("Jasper Library initialization failed");
     }
+#else
+    jas_conf_clear();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
+    jas_conf_set_max_mem_usage(QImageReader::allocationLimit() * 1024 * 1024);
+#else
+    // 128MB seems to be enough.
+    jas_conf_set_max_mem_usage(128 * 1024 * 1024);
+#endif
+    if (jas_init_library()) {
+        jasperOk = false;
+        qDebug("Jasper library initialization failed");
+    }
+    if (jas_init_thread()) {
+        jas_cleanup_library();
+        jasperOk = false;
+        qDebug("Jasper thread initialization failed");
+    }
+#endif
 }
 
 Jpeg2000JasperReader::~Jpeg2000JasperReader()
 {
+#if JAS_VERSION_MAJOR < 3
     if (jasperOk)
         jas_cleanup();
+#else
+    if (jasperOk) {
+        if (jas_cleanup_thread()) {
+            qDebug("Jasper thread cleanup failed");
+        }
+        if (jas_cleanup_library()) {
+            qDebug("Jasper library cleanup failed");
+        }
+    }
+#endif
 }
 
 /*! \internal
@@ -857,7 +888,7 @@ bool Jpeg2000JasperReader::write(const QImage &image, int quality)
     }
 
     // Open an empty jasper stream that grows automatically
-    jas_stream_t * memory_stream = jas_stream_memopen(0, -1);
+    jas_stream_t * memory_stream = jas_stream_memopen(0, 0);
 
     // Jasper wants a non-const string.
     char *str = qstrdup(jasperFormatString.toLatin1().constData());
diff --git a/src/plugins/imageformats/tiff/qtiffhandler.cpp b/src/plugins/imageformats/tiff/qtiffhandler.cpp
index bf4bc36..ac8956c 100644
--- a/src/plugins/imageformats/tiff/qtiffhandler.cpp
+++ b/src/plugins/imageformats/tiff/qtiffhandler.cpp
@@ -116,7 +116,7 @@ public:
     QImageIOHandler::Transformations transformation;
     QImage::Format format;
     QSize size;
-    uint16 photometric;
+    uint16_t photometric;
     bool grayscale;
     bool headersRead;
     int currentDirectory;
@@ -250,8 +250,8 @@ bool QTiffHandlerPrivate::readHeaders(QIODevice *device)
 
     TIFFSetDirectory(tiff, currentDirectory);
 
-    uint32 width;
-    uint32 height;
+    uint32_t width;
+    uint32_t height;
     if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width)
         || !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)
         || !TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric)) {
@@ -260,15 +260,15 @@ bool QTiffHandlerPrivate::readHeaders(QIODevice *device)
     }
     size = QSize(width, height);
 
-    uint16 orientationTag;
+    uint16_t orientationTag;
     if (TIFFGetField(tiff, TIFFTAG_ORIENTATION, &orientationTag))
         transformation = exif2Qt(orientationTag);
 
     // BitsPerSample defaults to 1 according to the TIFF spec.
-    uint16 bitPerSample;
+    uint16_t bitPerSample;
     if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample))
         bitPerSample = 1;
-    uint16 samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel
+    uint16_t samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel
     if (!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel))
         samplesPerPixel = 1;
 
@@ -288,8 +288,8 @@ bool QTiffHandlerPrivate::readHeaders(QIODevice *device)
         else
             format = QImage::Format_RGB32;
     else {
-        uint16 count;
-        uint16 *extrasamples;
+        uint16_t count;
+        uint16_t *extrasamples;
         // If there is any definition of the alpha-channel, libtiff will return premultiplied
         // data to us. If there is none, libtiff will not touch it and  we assume it to be
         // non-premultiplied, matching behavior of tested image editors, and how older Qt
@@ -361,6 +361,8 @@ bool QTiffHandler::read(QImage *image)
     }
 
     TIFF *const tiff = d->tiff;
+    if (TIFFIsTiled(tiff) && TIFFTileSize64(tiff) > uint64_t(image->sizeInBytes())) // Corrupt image
+        return false;
     const quint32 width = d->size.width();
     const quint32 height = d->size.height();
 
@@ -377,7 +379,7 @@ bool QTiffHandler::read(QImage *image)
             }
             image->setColorTable(colortable);
         } else if (format == QImage::Format_Indexed8) {
-            const uint16 tableSize = 256;
+            const uint16_t tableSize = 256;
             QVector<QRgb> qtColorTable(tableSize);
             if (d->grayscale) {
                 for (int i = 0; i<tableSize; ++i) {
@@ -386,9 +388,9 @@ bool QTiffHandler::read(QImage *image)
                 }
             } else {
                 // create the color table
-                uint16 *redTable = 0;
-                uint16 *greenTable = 0;
-                uint16 *blueTable = 0;
+                uint16_t *redTable = 0;
+                uint16_t *greenTable = 0;
+                uint16_t *blueTable = 0;
                 if (!TIFFGetField(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable)) {
                     d->close();
                     return false;
@@ -423,14 +425,19 @@ bool QTiffHandler::read(QImage *image)
             quint32 tileWidth, tileLength;
             TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tileWidth);
             TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tileLength);
-            uchar *buf = (uchar *)_TIFFmalloc(TIFFTileSize(tiff));
-            if (!tileWidth || !tileLength || !buf) {
-                _TIFFfree(buf);
+            if (!tileWidth || !tileLength || tileWidth % 16 || tileLength % 16) {
                 d->close();
                 return false;
             }
             quint32 byteWidth = (format == QImage::Format_Mono) ? (width + 7)/8 : (width * bytesPerPixel);
             quint32 byteTileWidth = (format == QImage::Format_Mono) ? tileWidth/8 : (tileWidth * bytesPerPixel);
+            tmsize_t byteTileSize = TIFFTileSize(tiff);
+            uchar *buf = (uchar *)_TIFFmalloc(byteTileSize);
+            if (!buf || byteTileSize / tileLength < byteTileWidth) {
+                _TIFFfree(buf);
+                d->close();
+                return false;
+            }
             for (quint32 y = 0; y < height; y += tileLength) {
                 for (quint32 x = 0; x < width; x += tileWidth) {
                     if (TIFFReadTile(tiff, buf, x, y, 0, 0) < 0) {
@@ -448,7 +455,11 @@ bool QTiffHandler::read(QImage *image)
             }
             _TIFFfree(buf);
         } else {
-            for (uint32 y=0; y<height; ++y) {
+            if (image->bytesPerLine() < TIFFScanlineSize(tiff)) {
+                d->close();
+                return false;
+            }
+            for (uint32_t y=0; y<height; ++y) {
                 if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {
                     d->close();
                     return false;
@@ -459,8 +470,8 @@ bool QTiffHandler::read(QImage *image)
             rgb48fixup(image);
     } else {
         const int stopOnError = 1;
-        if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32 *>(image->bits()), qt2Exif(d->transformation), stopOnError)) {
-            for (uint32 y=0; y<height; ++y)
+        if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(image->bits()), qt2Exif(d->transformation), stopOnError)) {
+            for (uint32_t y=0; y<height; ++y)
                 convert32BitOrder(image->scanLine(y), width);
         } else {
             d->close();
@@ -471,7 +482,7 @@ bool QTiffHandler::read(QImage *image)
 
     float resX = 0;
     float resY = 0;
-    uint16 resUnit;
+    uint16_t resUnit;
     if (!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit))
         resUnit = RESUNIT_INCH;
 
@@ -494,7 +505,7 @@ bool QTiffHandler::read(QImage *image)
         }
     }
 
-    uint32 count;
+    uint32_t count;
     void *profile;
     if (TIFFGetField(tiff, TIFFTAG_ICCPROFILE, &count, &profile)) {
         QByteArray iccProfile(reinterpret_cast<const char *>(profile), count);
@@ -618,7 +629,7 @@ bool QTiffHandler::write(const QImage &image)
     // configure image depth
     const QImage::Format format = image.format();
     if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {
-        uint16 photometric = PHOTOMETRIC_MINISBLACK;
+        uint16_t photometric = PHOTOMETRIC_MINISBLACK;
         if (image.colorTable().at(0) == 0xffffffff)
             photometric = PHOTOMETRIC_MINISWHITE;
         if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)
@@ -640,7 +651,7 @@ bool QTiffHandler::write(const QImage &image)
             int chunkStart = y;
             int chunkEnd = y + chunk.height();
             while (y < chunkEnd) {
-                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {
+                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32_t *>(chunk.scanLine(y - chunkStart)), y) != 1) {
                     TIFFClose(tiff);
                     return false;
                 }
@@ -655,7 +666,7 @@ bool QTiffHandler::write(const QImage &image)
         QVector<QRgb> colorTable = effectiveColorTable(image);
         bool isGrayscale = checkGrayscale(colorTable);
         if (isGrayscale) {
-            uint16 photometric = PHOTOMETRIC_MINISBLACK;
+            uint16_t photometric = PHOTOMETRIC_MINISBLACK;
             if (colorTable.at(0) == 0xffffffff)
                 photometric = PHOTOMETRIC_MINISWHITE;
             if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)
@@ -677,9 +688,9 @@ bool QTiffHandler::write(const QImage &image)
             // allocate the color tables
             const int tableSize = colorTable.size();
             Q_ASSERT(tableSize <= 256);
-            QVarLengthArray<uint16> redTable(tableSize);
-            QVarLengthArray<uint16> greenTable(tableSize);
-            QVarLengthArray<uint16> blueTable(tableSize);
+            QVarLengthArray<uint16_t> redTable(tableSize);
+            QVarLengthArray<uint16_t> greenTable(tableSize);
+            QVarLengthArray<uint16_t> blueTable(tableSize);
 
             // set the color table
             for (int i = 0; i<tableSize; ++i) {
@@ -732,7 +743,7 @@ bool QTiffHandler::write(const QImage &image)
     } else if (format == QImage::Format_RGBA64
                || format == QImage::Format_RGBA64_Premultiplied) {
         const bool premultiplied = image.format() != QImage::Format_RGBA64;
-        const uint16 extrasamples = premultiplied ? EXTRASAMPLE_ASSOCALPHA : EXTRASAMPLE_UNASSALPHA;
+        const uint16_t extrasamples = premultiplied ? EXTRASAMPLE_ASSOCALPHA : EXTRASAMPLE_UNASSALPHA;
         if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)
             || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)
             || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)
@@ -780,7 +791,7 @@ bool QTiffHandler::write(const QImage &image)
     } else {
         const bool premultiplied = image.format() != QImage::Format_ARGB32
                                 && image.format() != QImage::Format_RGBA8888;
-        const uint16 extrasamples = premultiplied ? EXTRASAMPLE_ASSOCALPHA : EXTRASAMPLE_UNASSALPHA;
+        const uint16_t extrasamples = premultiplied ? EXTRASAMPLE_ASSOCALPHA : EXTRASAMPLE_UNASSALPHA;
         if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)
             || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)
             || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)
@@ -894,9 +905,9 @@ int QTiffHandler::currentImageNumber() const
 
 void QTiffHandler::convert32BitOrder(void *buffer, int width)
 {
-    uint32 *target = reinterpret_cast<uint32 *>(buffer);
-    for (int32 x=0; x<width; ++x) {
-        uint32 p = target[x];
+    uint32_t *target = reinterpret_cast<uint32_t *>(buffer);
+    for (int32_t x=0; x<width; ++x) {
+        uint32_t p = target[x];
         // convert between ARGB and ABGR
         target[x] = (p & 0xff000000)
                     | ((p & 0x00ff0000) >> 16)
@@ -913,7 +924,7 @@ void QTiffHandler::rgb48fixup(QImage *image)
     uchar *scanline = image->bits();
     const qsizetype bpl = image->bytesPerLine();
     for (int y = 0; y < h; ++y) {
-        quint16 *dst = reinterpret_cast<uint16 *>(scanline);
+        quint16 *dst = reinterpret_cast<uint16_t *>(scanline);
         for (int x = w - 1; x >= 0; --x) {
             dst[x * 4 + 3] = 0xffff;
             dst[x * 4 + 2] = dst[x * 3 + 2];
diff --git a/src/plugins/imageformats/webp/CMakeLists.txt b/src/plugins/imageformats/webp/CMakeLists.txt
new file mode 100644
index 0000000..ceef4b0
--- /dev/null
+++ b/src/plugins/imageformats/webp/CMakeLists.txt
@@ -0,0 +1,200 @@
+# Generated from webp.pro.
+
+#####################################################################
+## QWebpPlugin Plugin:
+#####################################################################
+
+qt_internal_add_plugin(QWebpPlugin
+    OUTPUT_NAME qwebp
+    PLUGIN_TYPE imageformats
+    SOURCES
+        main.cpp
+        qwebphandler.cpp qwebphandler_p.h
+    LIBRARIES
+        Qt::Core
+        Qt::Gui
+)
+
+#### Keys ignored in scope 1:.:.:webp.pro:<TRUE>:
+# OTHER_FILES = "webp.json"
+# QT_FOR_CONFIG = "imageformats-private"
+
+## Scopes:
+#####################################################################
+
+qt_internal_extend_target(QWebpPlugin CONDITION QT_FEATURE_system_webp
+    LIBRARIES
+        WrapWebP::WrapWebP
+)
+
+qt_internal_extend_target(QWebpPlugin CONDITION NOT QT_FEATURE_system_webp
+    SOURCES
+        ../../../3rdparty/libwebp/src/dec/alpha_dec.c
+        ../../../3rdparty/libwebp/src/dec/buffer_dec.c
+        ../../../3rdparty/libwebp/src/dec/frame_dec.c
+        ../../../3rdparty/libwebp/src/dec/idec_dec.c
+        ../../../3rdparty/libwebp/src/dec/io_dec.c
+        ../../../3rdparty/libwebp/src/dec/quant_dec.c
+        ../../../3rdparty/libwebp/src/dec/tree_dec.c
+        ../../../3rdparty/libwebp/src/dec/vp8_dec.c
+        ../../../3rdparty/libwebp/src/dec/vp8l_dec.c
+        ../../../3rdparty/libwebp/src/dec/webp_dec.c
+        ../../../3rdparty/libwebp/src/demux/anim_decode.c
+        ../../../3rdparty/libwebp/src/demux/demux.c
+        ../../../3rdparty/libwebp/src/dsp/alpha_processing.c
+        ../../../3rdparty/libwebp/src/dsp/alpha_processing_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/alpha_processing_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/alpha_processing_sse41.c
+        ../../../3rdparty/libwebp/src/dsp/cost.c
+        ../../../3rdparty/libwebp/src/dsp/cost_mips32.c
+        ../../../3rdparty/libwebp/src/dsp/cost_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/cost_neon.c
+        ../../../3rdparty/libwebp/src/dsp/cost_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/cpu.c
+        ../../../3rdparty/libwebp/src/dsp/dec.c
+        ../../../3rdparty/libwebp/src/dsp/dec_clip_tables.c
+        ../../../3rdparty/libwebp/src/dsp/dec_mips32.c
+        ../../../3rdparty/libwebp/src/dsp/dec_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/dec_msa.c
+        ../../../3rdparty/libwebp/src/dsp/dec_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/dec_sse41.c
+        ../../../3rdparty/libwebp/src/dsp/enc.c
+        ../../../3rdparty/libwebp/src/dsp/enc_mips32.c
+        ../../../3rdparty/libwebp/src/dsp/enc_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/enc_msa.c
+        ../../../3rdparty/libwebp/src/dsp/enc_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/enc_sse41.c
+        ../../../3rdparty/libwebp/src/dsp/filters.c
+        ../../../3rdparty/libwebp/src/dsp/filters_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/filters_msa.c
+        ../../../3rdparty/libwebp/src/dsp/filters_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/lossless.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_enc.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_enc_mips32.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_enc_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_enc_msa.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_enc_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_enc_sse41.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_sse41.c
+        ../../../3rdparty/libwebp/src/dsp/rescaler.c
+        ../../../3rdparty/libwebp/src/dsp/rescaler_mips32.c
+        ../../../3rdparty/libwebp/src/dsp/rescaler_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/rescaler_msa.c
+        ../../../3rdparty/libwebp/src/dsp/rescaler_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/ssim.c
+        ../../../3rdparty/libwebp/src/dsp/ssim_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/upsampling.c
+        ../../../3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/upsampling_msa.c
+        ../../../3rdparty/libwebp/src/dsp/upsampling_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/upsampling_sse41.c
+        ../../../3rdparty/libwebp/src/dsp/yuv.c
+        ../../../3rdparty/libwebp/src/dsp/yuv_mips32.c
+        ../../../3rdparty/libwebp/src/dsp/yuv_mips_dsp_r2.c
+        ../../../3rdparty/libwebp/src/dsp/yuv_sse2.c
+        ../../../3rdparty/libwebp/src/dsp/yuv_sse41.c
+        ../../../3rdparty/libwebp/src/enc/alpha_enc.c
+        ../../../3rdparty/libwebp/src/enc/analysis_enc.c
+        ../../../3rdparty/libwebp/src/enc/backward_references_cost_enc.c
+        ../../../3rdparty/libwebp/src/enc/backward_references_enc.c
+        ../../../3rdparty/libwebp/src/enc/config_enc.c
+        ../../../3rdparty/libwebp/src/enc/cost_enc.c
+        ../../../3rdparty/libwebp/src/enc/filter_enc.c
+        ../../../3rdparty/libwebp/src/enc/frame_enc.c
+        ../../../3rdparty/libwebp/src/enc/histogram_enc.c
+        ../../../3rdparty/libwebp/src/enc/iterator_enc.c
+        ../../../3rdparty/libwebp/src/enc/near_lossless_enc.c
+        ../../../3rdparty/libwebp/src/enc/picture_csp_enc.c
+        ../../../3rdparty/libwebp/src/enc/picture_enc.c
+        ../../../3rdparty/libwebp/src/enc/picture_psnr_enc.c
+        ../../../3rdparty/libwebp/src/enc/picture_rescale_enc.c
+        ../../../3rdparty/libwebp/src/enc/picture_tools_enc.c
+        ../../../3rdparty/libwebp/src/enc/predictor_enc.c
+        ../../../3rdparty/libwebp/src/enc/quant_enc.c
+        ../../../3rdparty/libwebp/src/enc/syntax_enc.c
+        ../../../3rdparty/libwebp/src/enc/token_enc.c
+        ../../../3rdparty/libwebp/src/enc/tree_enc.c
+        ../../../3rdparty/libwebp/src/enc/vp8l_enc.c
+        ../../../3rdparty/libwebp/src/enc/webp_enc.c
+        ../../../3rdparty/libwebp/src/mux/anim_encode.c
+        ../../../3rdparty/libwebp/src/mux/muxedit.c
+        ../../../3rdparty/libwebp/src/mux/muxinternal.c
+        ../../../3rdparty/libwebp/src/mux/muxread.c
+        ../../../3rdparty/libwebp/src/utils/bit_reader_utils.c
+        ../../../3rdparty/libwebp/src/utils/bit_writer_utils.c
+        ../../../3rdparty/libwebp/src/utils/color_cache_utils.c
+        ../../../3rdparty/libwebp/src/utils/filters_utils.c
+        ../../../3rdparty/libwebp/src/utils/huffman_encode_utils.c
+        ../../../3rdparty/libwebp/src/utils/huffman_utils.c
+        ../../../3rdparty/libwebp/src/utils/quant_levels_dec_utils.c
+        ../../../3rdparty/libwebp/src/utils/quant_levels_utils.c
+        ../../../3rdparty/libwebp/src/utils/random_utils.c
+        ../../../3rdparty/libwebp/src/utils/rescaler_utils.c
+        ../../../3rdparty/libwebp/src/utils/thread_utils.c
+        ../../../3rdparty/libwebp/src/utils/utils.c
+    INCLUDE_DIRECTORIES
+        ../../../3rdparty/libwebp
+        ../../../3rdparty/libwebp/src
+        ../../../3rdparty/libwebp/src/dec
+        ../../../3rdparty/libwebp/src/dsp
+        ../../../3rdparty/libwebp/src/enc
+        ../../../3rdparty/libwebp/src/mux
+        ../../../3rdparty/libwebp/src/utils
+        ../../../3rdparty/libwebp/src/webp
+)
+
+qt_internal_extend_target(QWebpPlugin CONDITION ANDROID AND NOT ANDROID_EMBEDDED AND NOT QT_FEATURE_system_webp
+    SOURCES
+        ${CMAKE_ANDROID_NDK}/sources/android/cpufeatures/cpu-features.c   # special case
+    INCLUDE_DIRECTORIES
+        ${CMAKE_ANDROID_NDK}/sources/android/cpufeatures                  # special case
+)
+
+# special case begin
+set(neon_sources
+        ../../../3rdparty/libwebp/src/dsp/alpha_processing_neon.c
+        ../../../3rdparty/libwebp/src/dsp/dec_neon.c
+        ../../../3rdparty/libwebp/src/dsp/enc_neon.c
+        ../../../3rdparty/libwebp/src/dsp/filters_neon.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_enc_neon.c
+        ../../../3rdparty/libwebp/src/dsp/lossless_neon.c
+        ../../../3rdparty/libwebp/src/dsp/rescaler_neon.c
+        ../../../3rdparty/libwebp/src/dsp/upsampling_neon.c
+        ../../../3rdparty/libwebp/src/dsp/yuv_neon.c
+)
+
+if(NOT QT_FEATURE_system_webp)
+    if(ANDROID)
+        qt_internal_extend_target(QWebpPlugin
+            CONDITION (CMAKE_ANDROID_ARM_NEON OR CMAKE_ANDROID_ARCH_ABI STREQUAL "arm64-v8a")
+            SOURCES ${neon_sources}
+        )
+    else()
+        # For universal macOS and iOS, and other platforms that support neon
+        qt_internal_add_simd_part(QWebpPlugin SIMD neon SOURCES ${neon_sources})
+    endif()
+endif()
+# special case end
+
+#### Keys ignored in scope 6:.:../../../3rdparty:../../../3rdparty/libwebp.pri:INTEGRITY:
+# QMAKE_CFLAGS = "-c99"
+
+#### Keys ignored in scope 12:.:../../../3rdparty:../../../3rdparty/libwebp.pri:else:
+# QMAKE_EXTRA_COMPILERS = "neon_comp"
+# neon_comp.commands = "$$QMAKE_CC" "-c" "$(CFLAGS)" "$$QMAKE_CFLAGS_NEON" "$(INCPATH)" "${QMAKE_FILE_IN}"
+# neon_comp.dependency_type = "TYPE_C"
+# neon_comp.input = "SOURCES_FOR_NEON"
+# neon_comp.name = "compiling[neon]" "${QMAKE_FILE_IN}"
+# neon_comp.output = "${QMAKE_VAR_OBJECTS_DIR}${QMAKE_FILE_BASE}$${firstQMAKE_EXT_OBJ}"
+# neon_comp.variable_out = "OBJECTS"
+
+#### Keys ignored in scope 13:.:../../../3rdparty:../../../3rdparty/libwebp.pri:MSVC:
+# neon_comp.commands = "-Fo${QMAKE_FILE_OUT}"
+
+#### Keys ignored in scope 14:.:../../../3rdparty:../../../3rdparty/libwebp.pri:else:
+# neon_comp.commands = "-o" "${QMAKE_FILE_OUT}"
+
+#### Keys ignored in scope 15:.:../../../3rdparty:../../../3rdparty/libwebp.pri:silent:
+# neon_comp.commands = "@echo" "compiling[neon]" "${QMAKE_FILE_IN}" "&&"
diff --git a/src/plugins/imageformats/webp/qwebphandler.cpp b/src/plugins/imageformats/webp/qwebphandler.cpp
index 82d38cb..d02eb05 100644
--- a/src/plugins/imageformats/webp/qwebphandler.cpp
+++ b/src/plugins/imageformats/webp/qwebphandler.cpp
@@ -45,6 +45,7 @@
 #include <qdebug.h>
 #include <qpainter.h>
 #include <qvariant.h>
+#include <QtEndian>
 
 static const int riffHeaderSize = 12; // RIFF_HEADER_SIZE from webp/format_constants.h
 
@@ -102,21 +103,23 @@ bool QWebpHandler::ensureScanned() const
 
     m_scanState = ScanError;
 
-    if (device()->isSequential()) {
-        qWarning() << "Sequential devices are not supported";
+    QWebpHandler *that = const_cast<QWebpHandler *>(this);
+    const int headerBytesNeeded = sizeof(WebPBitstreamFeatures);
+    QByteArray header = device()->peek(headerBytesNeeded);
+    if (header.size() < headerBytesNeeded)
         return false;
-    }
 
-    qint64 oldPos = device()->pos();
-    device()->seek(0);
-
-    QWebpHandler *that = const_cast<QWebpHandler *>(this);
-    QByteArray header = device()->peek(sizeof(WebPBitstreamFeatures));
+    // We do no random access during decoding, just a readAll() of the whole image file. So if
+    // if it is all available already, we can accept a sequential device. The riff header contains
+    // the file size minus 8 bytes header
+    qint64 byteSize = qFromLittleEndian<quint32>(header.constData() + 4);
+    if (device()->isSequential() && device()->bytesAvailable() < byteSize + 8) {
+        qWarning() << "QWebpHandler: Insufficient data available in sequential device";
+        return false;
+    }
     if (WebPGetFeatures((const uint8_t*)header.constData(), header.size(), &(that->m_features)) == VP8_STATUS_OK) {
         if (m_features.has_animation) {
             // For animation, we have to read and scan whole file to determine loop count and images count
-            device()->seek(oldPos);
-
             if (that->ensureDemuxer()) {
                 that->m_loop = WebPDemuxGetI(m_demuxer, WEBP_FF_LOOP_COUNT);
                 that->m_frameCount = WebPDemuxGetI(m_demuxer, WEBP_FF_FRAME_COUNT);
@@ -126,17 +129,13 @@ bool QWebpHandler::ensureScanned() const
                 if (that->m_features.has_alpha)
                     that->m_composited->fill(Qt::transparent);
 
-                // We do not reset device position since we have read in all data
                 m_scanState = ScanSuccess;
-                return true;
             }
         } else {
             m_scanState = ScanSuccess;
         }
     }
 
-    device()->seek(oldPos);
-
     return m_scanState == ScanSuccess;
 }
 
@@ -159,7 +158,7 @@ bool QWebpHandler::ensureDemuxer()
 
 bool QWebpHandler::read(QImage *image)
 {
-    if (!ensureScanned() || device()->isSequential() || !ensureDemuxer())
+    if (!ensureScanned() || !ensureDemuxer())
         return false;
 
     QRect prevFrameRect;
